<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySql | 陌上花开缓缓归</title><meta name="description" content="大佬笔记入口同上 mysql的逻辑架构数据库两个操作系统文件每个 SQL Server 2005 数据库至少具有两个操作系统文件：一个数据文件和一个日志文件。  数据文件包含数据和对象，例容如表、索引、存储过程和视图。 日志文件包含恢复数据库中的所有事务所需的信息。为了便于分配和管理，可以将数据文件集合起来，放到文件组中。主要数据文件包含数据库的启动信息，并指向数据库中的其他文件。用户数据和对象可"><meta name="keywords" content="数据库"><meta name="author" content="lys-studys"><meta name="copyright" content="lys-studys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/timg.jpeg"><link rel="canonical" href="http://example.com/posts/16097/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="MySql"><meta property="og:url" content="http://example.com/posts/16097/"><meta property="og:site_name" content="陌上花开缓缓归"><meta property="og:description" content="大佬笔记入口同上 mysql的逻辑架构数据库两个操作系统文件每个 SQL Server 2005 数据库至少具有两个操作系统文件：一个数据文件和一个日志文件。  数据文件包含数据和对象，例容如表、索引、存储过程和视图。 日志文件包含恢复数据库中的所有事务所需的信息。为了便于分配和管理，可以将数据文件集合起来，放到文件组中。主要数据文件包含数据库的启动信息，并指向数据库中的其他文件。用户数据和对象可"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-10-27T05:25:31.000Z"><meta property="article:modified_time" content="2020-11-01T08:16:54.317Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: 'days',
  date_suffix: {"one_hour":"Just","hours":"hours ago","day":"days ago"},
  copyright: {"limitCount":50,"languages":{"author":"Author: lys-studys","link":"Link: ","source":"Source: 陌上花开缓缓归","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: {"text":"I,LOVE,YOU","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-11-01 16:16:54'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'true'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="./source/css/background.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="陌上花开缓缓归" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%9A%84%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">mysql的逻辑架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%A4%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">数据库两个操作系统文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">1.事务四大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">隔离操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%BA%8B%E7%89%A9%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">并行事物的四大问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">对应隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AD%E9%9A%94%E7%A6%BB%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">四中隔离原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B6%89%E5%8F%8A%E7%9A%84%E9%94%81"><span class="toc-number">4.4.</span> <span class="toc-text">数据库涉及的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">4.4.1.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%BC%95%E6%93%8E%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.4.2.</span> <span class="toc-text">各个索引引擎的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%94%81%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">为什么需要锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">什么是悲观锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">什么是乐观锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">悲观锁与乐观锁区别与联系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">悲观锁与乐观锁的使用场景？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodbe-%E5%92%8C-myisim%E6%8E%8C%E6%8F%A1"><span class="toc-number">6.</span> <span class="toc-text">innodbe 和 myisim掌握</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7-%E5%8F%8C%E6%AC%A1%E5%86%99%EF%BC%8C%E6%8F%92%E5%85%A5%E7%BC%93%E5%AD%98%EF%BC%8C%E8%87%AA%E9%80%82%E5%BA%94"><span class="toc-number">7.</span> <span class="toc-text">三个特性(双次写，插入缓存，自适应)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mvcc-%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">8.1.</span> <span class="toc-text">mvcc(乐观锁，悲观锁)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81-%E8%A1%8C%E9%94%81%EF%BC%8C%E9%9B%B6%E4%BB%B6%E9%94%81%EF%BC%8C%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">8.3.</span> <span class="toc-text">行锁(行锁，零件锁，间隙锁)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">8.4.</span> <span class="toc-text">表锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">9.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88B-%E6%A0%91%EF%BC%8CB%E6%A0%91%EF%BC%8CHash%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%85%A8%E6%96%87%E6%9C%AC%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">数据结构（B+树，B树，Hash索引，全文本索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E7%B4%A2%E5%BC%95"><span class="toc-number">9.2.</span> <span class="toc-text">hash索引　</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%B4%A2%E5%BC%95-%E4%B8%BB%E9%94%AE%EF%BC%8C%E5%94%AF%E4%B8%80%EF%BC%8C%E5%89%8D%E7%BC%80%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E8%81%94%E5%90%88%EF%BC%8C%E6%99%AE%E9%80%9A"><span class="toc-number">9.3.</span> <span class="toc-text">逻辑索引(主键，唯一，前缀，覆盖，联合，普通)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-innodbe-%E6%8E%92%E5%BA%8F%E7%B4%A2%E5%BC%95-myisim"><span class="toc-number">9.4.</span> <span class="toc-text">存储结构(聚集索引(innodbe),排序索引(myisim))</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MyISAM%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.4.1.</span> <span class="toc-text">MyISAM存储索引实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-%E8%81%9A%E9%9B%86"><span class="toc-number">9.4.2.</span> <span class="toc-text">InnoDB索引实现(聚集)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">9.4.3.</span> <span class="toc-text">聚集索引　</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%8E%A8%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">9.4.4.</span> <span class="toc-text">类推非聚集索引(稀疏索引)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">9.4.5.</span> <span class="toc-text">联合索引　</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E7%90%86"><span class="toc-number">9.4.5.1.</span> <span class="toc-text">索引最左前缀原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%9B%9E%E8%A1%A8%EF%BC%8E"><span class="toc-number">9.5.</span> <span class="toc-text">索引失效，索引优化，索引下推，索引回表．</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">10.</span> <span class="toc-text">最左匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%8E"><span class="toc-number">12.</span> <span class="toc-text">分区分库分表，主从复制．</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">12.1.</span> <span class="toc-text">分区分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%EF%BC%9A"><span class="toc-number">12.1.1.</span> <span class="toc-text">分表：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%EF%BC%9A"><span class="toc-number">12.1.2.</span> <span class="toc-text">分区：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%BA%93%EF%BC%9A"><span class="toc-number">12.1.3.</span> <span class="toc-text">分库：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">12.2.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">12.3.</span> <span class="toc-text">什么是主从复制?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E5%A5%BD%E5%A4%84%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%B8%BB%E4%BB%8E%EF%BC%89%E9%87%8D%E7%82%B9%EF%BC%9F"><span class="toc-number">12.3.1.</span> <span class="toc-text">主从复制的作用（好处，或者说为什么要做主从）重点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">12.3.2.</span> <span class="toc-text">主从复制的原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">12.3.3.</span> <span class="toc-text">主从复制的好处？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">12.3.4.</span> <span class="toc-text">从数据库的读的延迟问题了解吗？如何解决？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.3.5.</span> <span class="toc-text">主从复制和主主复制区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">2.数据库隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MYSQL%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81%E7%BA%A7%E5%88%AB%E7%AD%89%E7%AD%89%EF%BC%89%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.</span> <span class="toc-text">3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E6%9C%89B-%E7%B4%A2%E5%BC%95%E5%92%8Chash%E7%B4%A2%E5%BC%95"><span class="toc-number">15.</span> <span class="toc-text">4.索引有B+索引和hash索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">16.</span> <span class="toc-text">5.聚集索引和非聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">17.</span> <span class="toc-text">6.索引的优缺点，什么时候使用索引，什么时候不能使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-InnoDB%E7%B4%A2%E5%BC%95%E5%92%8CMyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">7.InnoDB索引和MyISAM索引的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88B-%E6%A0%91%EF%BC%8C%E4%B8%BA%E4%BD%95%E4%B8%8D%E9%87%87%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8CB%E6%A0%91%EF%BC%89%E9%87%8D%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text">8.索引的底层实现（B+树，为何不采用红黑树，B树）重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-B-%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">20.</span> <span class="toc-text">9.B+树的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-Tree"><span class="toc-number">21.</span> <span class="toc-text">10.为什么使用B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Sql%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">22.</span> <span class="toc-text">11.Sql的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98"><span class="toc-number">23.</span> <span class="toc-text">12.索引最左前缀问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.</span> <span class="toc-text">13.索引分类，索引失效条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">25.</span> <span class="toc-text">14.数据库的主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-long-query%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">26.</span> <span class="toc-text">15.long_query怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-varchar%E5%92%8Cchar%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">27.</span> <span class="toc-text">16.varchar和char的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">28.</span> <span class="toc-text">17.数据库连接池的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">29.</span> <span class="toc-text">19.分库分表，主从复制，读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">30.</span> <span class="toc-text">20.数据库三范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB"><span class="toc-number">31.</span> <span class="toc-text">21.关系型数据库和非关系型数据库区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADjoin%E7%9A%84left-join-inner-join-cross-join"><span class="toc-number">32.</span> <span class="toc-text">22.数据库中join的left join , inner join, cross join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81-select%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%A0%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">33.</span> <span class="toc-text">23.有哪些锁,select时怎么加排它锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">34.</span> <span class="toc-text">24.死锁怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">35.</span> <span class="toc-text">25.最左匹配原则</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陌上花开缓缓归</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">MySql</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-10-27T05:25:31.000Z" title="Created 2020-10-27 13:25:31">2020-10-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-11-01T08:16:54.317Z" title="Updated 2020-11-01 16:16:54">2020-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BC%98%E5%8C%96/">优化</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/203622688">大佬笔记入口</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/389444">同上</a></p>
<h3 id="mysql的逻辑架构"><a href="#mysql的逻辑架构" class="headerlink" title="mysql的逻辑架构"></a>mysql的逻辑架构</h3><h3 id="数据库两个操作系统文件"><a href="#数据库两个操作系统文件" class="headerlink" title="数据库两个操作系统文件"></a>数据库两个操作系统文件</h3><p>每个 SQL Server 2005 数据库至少具有两个操作系统文件：<br>一个数据文件和一个日志文件。</p>
<ol>
<li>数据文件包含数据和对象，例容如表、索引、存储过程和视图。</li>
<li>日志文件包含恢复数据库中的所有事务所需的信息。为了便于分配和管理，可以将数据文件集合起来，放到文件组中。<br>主要数据文件包含数据库的启动信息，并指向数据库中的其他文件。用户数据和对象可存储在此文件中，也可以存储在次要数据文件中。每个数据库有一个主要数据文件。主要数据文件的建议文件扩展名是 .mdf。<br>事务日志文件保存用于恢复数据库的日志信息。每个数据库必须至少有一个日志文件。事务日志的建议文件扩展名是 .ldf。</li>
</ol>
<h3 id="1-事务四大特性"><a href="#1-事务四大特性" class="headerlink" title="1.事务四大特性"></a>1.事务四大特性</h3><p>事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</p>
<ol>
<li><p>原子性:<br>最小的执行单元： 要么全执行，要么全不执行</p>
</li>
<li><p>隔离性：<br>所有操作全部执行完以前其它会话不能看到过程</p>
</li>
<li><p>一致性：<br>事务前后，数据总额一致</p>
</li>
<li><p>持久性:<br> 一旦事务提交，对数据的改变就是永久的</p>
</li>
</ol>
<h3 id="隔离操作"><a href="#隔离操作" class="headerlink" title="隔离操作"></a>隔离操作</h3><h4 id="并行事物的四大问题"><a href="#并行事物的四大问题" class="headerlink" title="并行事物的四大问题"></a>并行事物的四大问题</h4><ol>
<li><p>更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）</p>
</li>
<li><p>脏读：读到别的事务未提交的数据。（万一回滚，数据就是脏的无效的了）</p>
</li>
<li><p>不可重复读：两次读之间有别的事务修改。</p>
</li>
<li><p>幻读：两次读之间有别的事务增删。</p>
<h4 id="对应隔离级别"><a href="#对应隔离级别" class="headerlink" title="对应隔离级别"></a>对应隔离级别</h4></li>
<li><p>READ UNCOMMITTED：读未提交，不处理。</p>
</li>
<li><p>READ COMMITTED：读已提交，只读提交的数据，无脏读；</p>
</li>
<li><p>REPEATABLE READ：可重复读，加行锁，两次读之间不会有修改，无脏读无重复读；</p>
</li>
<li><p>SERIALIZABLE: 串行化，加表锁，全部串行，无所有问题。<br>详细解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. READ UNCIMMITTED（未提交读）</span><br><span class="line">　　      事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读。</span><br><span class="line"></span><br><span class="line">2. READ COMMITTED（提交读）</span><br><span class="line">　　      首先大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象</span><br><span class="line"></span><br><span class="line">3. REPEATABLE READ（可重复读）</span><br><span class="line"> 　　     REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻行，顾名思义就是突然蹦出来的行数据。</span><br><span class="line">          指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。</span><br><span class="line"></span><br><span class="line">4. SERIALIZABLE（可串行化）</span><br><span class="line">          　　      SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，</span><br><span class="line">                   因此性能会比较低下，在需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="四中隔离原理"><a href="#四中隔离原理" class="headerlink" title="四中隔离原理"></a>四中隔离原理</h4></li>
<li><p>READ_UNCOMMITED 的原理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据不加锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。</span><br><span class="line">下面分别对应上面1，2产生的表现：</span><br><span class="line"></span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>READ_COMMITED 的原理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>REPEATABLE READ 的原理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1，事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>SERIALIZABLE 的原理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</span><br><span class="line">2，事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line">2，事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="数据库涉及的锁"><a href="#数据库涉及的锁" class="headerlink" title="数据库涉及的锁"></a>数据库涉及的锁</h4><p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，<br>MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）。<br>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。<br>所有的锁都是绑定在数据库的索引机制上的！！！</p>
<p>首先锁可以分为： </p>
<ol>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ol>
<p>而除了粒度，锁根据模式分为：</p>
<ol>
<li><p>共享锁(S)：发生在数据查找之前，多个事务的共享锁之间可以共存</p>
</li>
<li><p>排他锁(X)：发生在数据更新之前，排他锁是一个独占锁，与其他锁都不兼容</p>
</li>
<li><p>更新锁(U)：发生在更新语句中，更新锁用来查找数据，当查找的数据不是要更新的数据时转化为S锁，当是要更新的数据时转化为X锁</p>
</li>
<li><p>意向锁：发生在较低粒度级别的资源获取之前，表示对该资源下低粒度的资源添加对应的锁，意向锁有分为：<br>　　　　意向共享锁(IS) ，意向排他锁(IX)，意向更新锁(IU)，共享意向排他锁(SIX)，共享意向更新锁(SIU)，更新意向排他锁(UIX)</p>
</li>
</ol>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><ol>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ol>
<p>共享锁／排他锁／更新锁一般作用在较低级别上，例如数据行或数据页，意向锁一般作用在较高的级别上，例如数据表或数据。锁是有层级结构的，若在数据行上持有排他锁的时候，则会在所在的数据页上持有意向排他锁. 在一个事务中，可能由于锁持有的时间太长或个数太多，出于节约资源的考虑，会造成锁升级；</p>
<p>我理解的就以最后一个SERIALIZABLE来说，开始时是设置的表级共享锁，分为表级别的而且是共享锁，表级别就是作用于整个表，不是行级别！而共享锁，则说明了其他事务也是共享锁的情况下可以共享这个表！虽然仅限于读，但这样也可能存在脏读等情况的存在，而如果换成表级排它锁，那么第一个事务在使用了这个锁之后，那其他事务连这个表的读的权限也没有，从根本上避免了各种可能的问题。</p>
<h5 id="各个索引引擎的情况"><a href="#各个索引引擎的情况" class="headerlink" title="各个索引引擎的情况"></a>各个索引引擎的情况</h5><ol>
<li><p>InnoDB（MySQL默认存储引擎 从版本5.5.5开始）<br>支持事务，行级锁，以及外键，拥有高并发处理能力。但是在创建索引和加载数据时，比MyISAM慢。默认的隔离级别是Repeatable Read（可重复读）</p>
</li>
<li><p>MyISAM<br>不支持事务和行级锁。所以速度很快，性能优秀。可以对整张表加锁，支持并发插入，支持全文索引。</p>
</li>
<li><p>MEMORY<br>支持Hash索引，内存表，Memory引擎将数据存储在内存中，表结构不是存储在内存中的，查询时不需要执行磁盘I/O操作，所以要比MyISAM和InnoDB快很多倍，<br>但是数据库断电或是重启后，表中的数据将会丢失，表结构不会丢失。</p>
</li>
</ol>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h4><p>在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，乐观锁和悲观锁，可以在一定程度上解决并发访问。</p>
<h4 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h4><p>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>其他知识点</p>
<p>悲观锁主要是共享锁或排他锁<br>共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p>
<h4 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h4><p>是应用系统层面和数据的业务逻辑层次上的（实际上并没有加锁，只是一种锁思想），利用程序处理并发， 它假定当某一个用户去读取某一个数据的时候，其他的用户不会来访问修改这个数据，但是在最后进行事务的提交的时候会进行数据的检查，以判断在该用户的操作过程中，没有其他用户修改了这个数据。乐观锁的实现大部分都是基于版本控制实现的， 除此之外，还有CAS操作实现</p>
<p>其他知识点</p>
<p>实现乐观锁一般来说有以下2种方式：</p>
<p>使用版本号<br>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
<p>使用时间戳<br>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p>
<h4 id="悲观锁与乐观锁区别与联系？"><a href="#悲观锁与乐观锁区别与联系？" class="headerlink" title="悲观锁与乐观锁区别与联系？"></a>悲观锁与乐观锁区别与联系？</h4><h4 id="悲观锁与乐观锁的使用场景？"><a href="#悲观锁与乐观锁的使用场景？" class="headerlink" title="悲观锁与乐观锁的使用场景？"></a>悲观锁与乐观锁的使用场景？</h4><p>悲观锁</p>
<p>比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p>
<p>乐观锁</p>
<p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<h3 id="innodbe-和-myisim掌握"><a href="#innodbe-和-myisim掌握" class="headerlink" title="innodbe 和 myisim掌握"></a>innodbe 和 myisim掌握</h3><h3 id="三个特性-双次写，插入缓存，自适应"><a href="#三个特性-双次写，插入缓存，自适应" class="headerlink" title="三个特性(双次写，插入缓存，自适应)"></a>三个特性(双次写，插入缓存，自适应)</h3><p>InnoDB存储引擎的关键特性包括插入缓冲、两次写（double write）、自适应哈希索引（adaptive hash index）。这些特性为InnoDB存储引擎带来了更好的性能和更高的可靠性。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ilovemilk/article/details/80024789">详细解释跳转</a></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程并发访问某一资源的机制。</p>
<h4 id="mvcc-乐观锁，悲观锁"><a href="#mvcc-乐观锁，悲观锁" class="headerlink" title="mvcc(乐观锁，悲观锁)"></a>mvcc(乐观锁，悲观锁)</h4><p>mvcc主要是为了提高并发读写性能，不用枷锁就能让多个事务并发读写．</p>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol>
<li>从对数据操作的类型（读/写）分<br>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li>
<li>从对数据操作的粒度分<br>表锁<br>行锁<h4 id="行锁-行锁，零件锁，间隙锁"><a href="#行锁-行锁，零件锁，间隙锁" class="headerlink" title="行锁(行锁，零件锁，间隙锁)"></a>行锁(行锁，零件锁，间隙锁)</h4></li>
</ol>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<ol>
<li>手动增加表锁:</li>
</ol>
<p>lock table 表名字 read(write), 表名字2 read(write), 其他;<br>2. 查看表上加过的锁<br>show open tables;<br>3. 释放表锁</p>
<p>unlock tables;<br>4. 加读锁（我们为mylock表加read锁（读阻塞写例子））</p>
<ol start="5">
<li>加写锁（我们为mylock表加write锁（MyISAM存储引擎的写阻塞读例子））</li>
</ol>
<p>案例结论</p>
<p>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是帮助MySQl高效获取数据的排好序的数据结构.</p>
<h4 id="数据结构（B-树，B树，Hash索引，全文本索引）"><a href="#数据结构（B-树，B树，Hash索引，全文本索引）" class="headerlink" title="数据结构（B+树，B树，Hash索引，全文本索引）"></a>数据结构（B+树，B树，Hash索引，全文本索引）</h4><p>二叉树索引的弊端：如果是序列有序(索引key 值)，就变成线性查找了．比如1,2,3,4,5,6,要查找6则需要搜索六次.</p>
<p>红黑树索引的弊端: 数据量过大索引次数过多(过多的磁盘io不能被接受)，虽然是一种平衡状态，比二叉树更优越，但是不能够被广泛使用.</p>
<p>由于树的高度限制了查询的效率</p>
<p>进而想到的解决办法：纵向不能伸长，就横向扩张．</p>
<p>进而B-tree就产生了：</p>
<p>B-tree很难进行范围查找，没有小箭头，而且值的分布不是都在叶子节点，需要每次查找等操作．<br>还有一个就是</p>
<p>然而数据库的底层用的是我们曾经写过的B+Tree<br>细节讲解：</p>
<p>为什么每个节点的成员个数有限?<br>因为在查询的到节点，进行磁盘IO,会把该节点的数据写入ARM中,在磁盘中的查找速度非常快，跟磁盘IO时间比较可以忽略不计，但是ARM存储空间毕竟是有限的，MySql中设置的16kb<br>数据库中存储值为bigint为8b后边的指针为6b, 16kb/(8+6)b 大概是1170个索引.<br>叶子节点data是地址，假设比加大给1kb的存储空间.一个叶子节点大概16个元素.<br>那么高度为三的树能容纳 1170 * 1170 * 16 大概2100多万．<br>而且在数据库中根节点是长驻内存的，时间更快了.时间可忽略不计.</p>
<p>千万级数据表如何用索引快速查找？（上边即为答案）<br>b+Tree的树高可以的得到很好的控制，即使数据量很大，也能把树高维持在一个很小的数值．</p>
<p>b+tree:<br>    下边的小箭头就是为了支持范围查找的，是一个双向指针．解决了范围查找问题，</p>
<p>非叶子节点都不存data,只存储索引(冗余).可以放更多的索引，实现了等高的b-tree和<br>b+tree ,b+tree存储量非常可观．<br>就是都是三层b+tree 能存2100多万数据，b+tree就能存16<em>16</em>16 =4096个而已．</p>
<h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引　"></a>hash索引　</h4><p>select * from t where t.col = 2;</p>
<ol>
<li>先通过hash(2) =定位哈西散列值就是对应值的存储地址　MD5或crc16/32就是hash散列算法.</li>
</ol>
<p>hash 是不是就是说比B+tree的查找速率高呢？</p>
<p>单个值的查找是很快的，但是范围查找就崩了，必须遍历查找．<br>2.<br>3. </p>
<h4 id="逻辑索引-主键，唯一，前缀，覆盖，联合，普通"><a href="#逻辑索引-主键，唯一，前缀，覆盖，联合，普通" class="headerlink" title="逻辑索引(主键，唯一，前缀，覆盖，联合，普通)"></a>逻辑索引(主键，唯一，前缀，覆盖，联合，普通)</h4><h4 id="存储结构-聚集索引-innodbe-排序索引-myisim"><a href="#存储结构-聚集索引-innodbe-排序索引-myisim" class="headerlink" title="存储结构(聚集索引(innodbe),排序索引(myisim))"></a>存储结构(聚集索引(innodbe),排序索引(myisim))</h4><h5 id="MyISAM存储索引实现"><a href="#MyISAM存储索引实现" class="headerlink" title="MyISAM存储索引实现"></a>MyISAM存储索引实现</h5><p>注意: 存储引擎是形容数据库表的不是形容数据库的．</p>
<p>数据中的表的数据存储位置：根目录的DATA目录.</p>
<ol>
<li>.frm文件:表的定义和结构信息.</li>
<li>.MYD文件:MyISAM-date 存储的数据</li>
<li>.MYI文件:MyISAM-index 表的索引信息.<br>举例子：<br>select * from T  where coll = 30 ;<br>先判断数据coll有无索引，如果有索引，就去myi文件中检索，快速定位节点，由于MySql中b+Tree的叶子节点的data域存的是数据表中索引所在行的磁盘地址,就是查出地址后根据该地址在MYD文件中查找所对应的数据．</li>
</ol>
<h5 id="InnoDB索引实现-聚集"><a href="#InnoDB索引实现-聚集" class="headerlink" title="InnoDB索引实现(聚集)"></a>InnoDB索引实现(聚集)</h5><p>表结构:</p>
<ol>
<li><p>frm表: 表的定义和结构信息</p>
</li>
<li><p>ibd表: 按照B-tree组织的一个索引结构文件.</p>
</li>
<li><p>InnoDB表的主键索引　<br>是聚集的</p>
</li>
<li><p>InnoDB表的非主键索引<br>是非聚集的<br>别的位置是一样的，主要是叶子节点，存储的是主键，首先查找到主键信息，然后再从主键索引树里边找到该索引对应的信息．</p>
</li>
</ol>
<p>为什么InnoDB表必须要有主键，并且推荐使用整型的自增主键呢?</p>
<p>如果自己没有在InnoDB表中规定主键信息，系统会在数据表中找到一列没有重复信息的列，把他确定为主键，并根据该信息维护一个b+tree的主键索引信息表.<br>如果都是有重复的列，系统就会生成一个隐藏的主键列，作为主键维护信息表.<br>所以说在使用的时候定义了主键，系统会减少很多麻烦效率更高.</p>
<p>整型:</p>
<p>反义的是UUID不推荐使用既不是整形也不是自增的.</p>
<p>整型在比较过程中比较快（类比字符串比较）</p>
<p>bigint 占8个字节如果是字符串字节较多<br>数据库存储环境是高速的SSD(硬盘),价格昂贵.</p>
<p>主键自增问题:</p>
<pre><code>涉及到hash索引
b+Tree 叶子节点的小箭头</code></pre>
<p>如果b+Tree插入的顺序不是自增的，就会存在[1,2,4,5,] 这个节点满了，在插入3的情况是就会出现，节点分裂还需要做平衡，中间节点上移的问题，树会说＂我TM裂了＂！<br>正常自增的话就不会频繁出现这样的情况，减少了平衡的操作.<br>先维护索引，再运行insert语句比较快，</p>
<h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引　"></a>聚集索引　</h5><p>叶子节点包含了完整的数据记录<br>说白了索引和数据放在一起的.</p>
<h5 id="类推非聚集索引-稀疏索引"><a href="#类推非聚集索引-稀疏索引" class="headerlink" title="类推非聚集索引(稀疏索引)"></a>类推非聚集索引(稀疏索引)</h5><p>同样的MyISM 索引文件和数据文件是分离的就是非聚集的.一部分放在了MYZ一部分放在了MYD文件中.</p>
<p>比较:<br>单纯从聚集和非聚集索引分析，聚集索引更快.直接找到值．</p>
<h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引　"></a>联合索引　</h5><p>就比如(a,b,c)三个联合起来构成一个索引，底层结构什么样子.</p>
<p>底层采用的b+tree </p>
<p>如何排序呢：索引最左前缀原理</p>
<h6 id="索引最左前缀原理"><a href="#索引最左前缀原理" class="headerlink" title="索引最左前缀原理"></a>索引最左前缀原理</h6><p>先比较第一个字段，第一个能比较大小就排序(字典序比较)，若比较不了，比较第二个．<br>注意：不可跨字段，必须按照顺序应用，才能用到联合索引.<br>原因：b+tree 的排序规则，先按照第一个字段，在比较第二个字段．．．．．如果去掉第一个字段，剩下的第二个字段绝大多数可能是无序的，如果不是一个排好序的序列，就不能作为一个索引来用.还得所有值进行一次比较操作．</p>
<h4 id="索引失效，索引优化，索引下推，索引回表．"><a href="#索引失效，索引优化，索引下推，索引回表．" class="headerlink" title="索引失效，索引优化，索引下推，索引回表．"></a>索引失效，索引优化，索引下推，索引回表．</h4><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h3 id="分区分库分表，主从复制．"><a href="#分区分库分表，主从复制．" class="headerlink" title="分区分库分表，主从复制．"></a>分区分库分表，主从复制．</h3><h4 id="分区分库分表"><a href="#分区分库分表" class="headerlink" title="分区分库分表"></a>分区分库分表</h4><h5 id="分表："><a href="#分表：" class="headerlink" title="分表："></a>分表：</h5><p>分表就是为了减少单个数据库表的压力，当单表数据量达到百万级别时候，无论是插入和查询对将面临瓶颈，访问变慢，引入分表也是为了减轻单表的压力，常见的分表策略</p>
<p>对于业务表或者用户表，可以根据业务ID或者用户ID 对表数取模、范围a~b等，以取模为例%n,将表分为n个，如tb_uesr0,tb_user1,tb_user2,tb_user3….</p>
<p>对于用作分析或者统计时候，例如日志表，可以根据日期分表，如tb_log20180101,tb_log20180102….</p>
<h5 id="分区："><a href="#分区：" class="headerlink" title="分区："></a>分区：</h5><p>分区和分表大致相同，只是将单个数据表的数据分段存放在磁盘的不同区域，对外读写还是现实一张表，由DB去西东组织数据。</p>
<h5 id="分库："><a href="#分库：" class="headerlink" title="分库："></a>分库：</h5><p>分表减轻的是单个数据表的数据量压力，而分库则是应对并发请求下面数据库服务器的访问压力。分库也可以选择对关键字取模的方式选择访问的数据库</p>
<p>存放DB= 关键字段%DB数</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>基本原理 slave会从master读取binlog来进行数据同步</p>
<p>MySql复制过程分为三步:<br>    1. master将改变记录到二进制日志(binary log).这些记录过程叫二进制日志事件，binary log events;<br>    2. slave 将master的binary log events拷贝到他的中继日志(relay log).<br>    3. slave重做中继日志中的时间，将改变应用到自己的数据库中，MySql复制是异步的且串行化的．</p>
<p>复制的基本原则:<br>    1. 每个slave只有一个master<br>    2. 每个slave只能有一个唯一的服务器ID<br>    3. 每个master可以有多个slave</p>
<h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制?"></a>什么是主从复制?</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43879074/article/details/88525006#commentBox">主从复制牛逼博主跳转和图片来源</a><br>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库，主数据库一般是准实时的业务数据库。您看，像在mysql数据库中，支持单项、异步赋值。在赋值过程中，一个服务器充当主服务器，而另外一台服务器充当从服务器。此时主服务器会将更新信息写入到一个特定的二进制文件中。并会维护文件的一个索引用来跟踪日志循环。这个日志可以记录并发送到从服务器的更新中去。当一台从服务器连接到主服务器时，从服务器会通知主服务器从服务器的日志文件中读取最后一次成功更新的位置。然后从服务器会接收从哪个时刻起发生的任何更新，然后锁住并等到主服务器通知新的更新</p>
<h5 id="主从复制的作用（好处，或者说为什么要做主从）重点？"><a href="#主从复制的作用（好处，或者说为什么要做主从）重点？" class="headerlink" title="主从复制的作用（好处，或者说为什么要做主从）重点？"></a>主从复制的作用（好处，或者说为什么要做主从）重点？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p>
<p> 1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）<br>  2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）<br>   3–当主服务器出现问题时，可以切换到从服务器。（提升性能）</p>
<h5 id="主从复制的原理？"><a href="#主从复制的原理？" class="headerlink" title="主从复制的原理？"></a>主从复制的原理？</h5><p>一步能让你清晰理解操作的目的</p>
<p>   1.数据库有个bin-log二进制文件，记录了所有sql语句。</p>
<p>   2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。</p>
<p>   3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。</p>
<p>   4.下面的主从配置就是围绕这个原理配置</p>
<p>   5.具体需要三个线程来操作：</p>
<p>   1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：<br>   2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p>
<p>   3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p>
<pre><code>可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。</code></pre>
<h5 id="主从复制的好处？"><a href="#主从复制的好处？" class="headerlink" title="主从复制的好处？"></a>主从复制的好处？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p>
<p> 好处一:实现服务器负载均衡</p>
<p> 通过服务器复制功能，可以在主服务器和从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好地客户相应时间。通常情况下，数据库管理员会有两种思路。</p>
<p> 一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询。将数据更新与查询分别放在不同的服务器 上进行，即可以提高数据的安全性，同时也缩短应用程序的响应时间、提高系统的性能。</p>
<p> 二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作 业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。当然，像修改数据、插入数 据、删除数据等语句仍然会发送到主服务器中，以便主服务器和从服务器数据的同步。</p>
<p>  好处二：通过复制实现数据的异地备份</p>
<p>  可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。</p>
<p>  而如果使用复制来实现对数据的备份，就可以在从服务器上对数据进行备份。此时不仅不会干扰主服务气的正常运行，而且在备份过程中主服务器可以继 续处理相关的更新作业。同时在数据复制的同时，也实现了对数据的异地备份。除非主服务器和从服务器的两块硬盘同时损坏了，否则的话数据库管理员就可以在最 短时间内恢复数据，减少企业的由此带来的损失。</p>
<p>   好处三：提高数据库系统的可用性</p>
<p>   数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。</p>
<p>   一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道理。</p>
<p>   二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患。</p>
<h5 id="从数据库的读的延迟问题了解吗？如何解决？"><a href="#从数据库的读的延迟问题了解吗？如何解决？" class="headerlink" title="从数据库的读的延迟问题了解吗？如何解决？"></a>从数据库的读的延迟问题了解吗？如何解决？</h5><p>主库宕机后，数据可能丢失<br>从库只有一个sql Thread，主库写压力大，复制很可能延时<br>解决方法：</p>
<ol>
<li>半同步复制—解决数据丢失的问题</li>
</ol>
<p>半同步复制:　<br>就是在master 端放了wait_ack, 在slave端放了ack发送功能，在文件relay_log中写完数据后，发送一个确认ack,等收到ack在进行客户端的反馈．</p>
<ol start="2">
<li><p>并行复制—-解决从库复制延迟的问题<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/caicz/p/11009528.html">参考博客</a></p>
</li>
<li><p>那么如何并行化，并行IO线程，还是并行SQL线程？<br>其实两方面都可以并行，但是并行SQL线程的收益更大，因为SQL线程做的事情更多(解析，执行)。并行IO线程，可以将从Master拉取和写Relay lomZ分为两个线程；并行SQL线程则可以根据需要做到库级并行，表级并行，事务级并行。库级并行在mysql官方版本5.6已经实现。并行复制框架实际包含了一个协调线程和若干个工作线程，协调线程负责分发和解决冲突，工作线程只负责执行。</p>
</li>
<li><p>并行复制如何处理冲突？</p>
</li>
</ol>
<p>并发的世界是美好的，但不能乱并发，否则数据就乱了。Master上面通过锁机制来保证并发的事务有序进行，那么并行复制呢？Slave必需保证回放的顺序与Master上事务执行顺序一致，因此只要做到顺序读取binlog，将不冲突的事务并发执行即可。对于库级并发而言，协调线程要保证执行同一个库的事务放在一个工作线程串行执行；对于表级并发而言，协调线程要保证同一个表的事务串行执行；对于事务级而言，则是保证操作同一行的事务串行执行。</p>
<ol start="3">
<li>是否粒度越细，性能越好？</li>
</ol>
<p>这个并不是一定的。相对于串行复制而言，并行复制多了一个协调线程。协调线程一个重要作用是解决冲突，粒度越细的并发，可能会有更多的冲突，最终可能也是串行执行的，但消耗了大量的冲突检测代价。</p>
<p>并行复制:<br>    在relay_log库信息读取操作转换为数据的过程中，采用多线程，执行效率增加．</p>
<h5 id="主从复制和主主复制区别？"><a href="#主从复制和主主复制区别？" class="headerlink" title="主从复制和主主复制区别？"></a>主从复制和主主复制区别？</h5><p>最大区别是<br>主从是对主操作数据，从会实时同步数据。反之对从操作，主不会同步数据，还有可能造成数据紊乱，导致主从失效。 主主则是无论对那一台操作，另一个都会同步数据。一般用作高容灾方案 </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22222499/article/details/79060495">以下部分参考网站</a></p>
<h3 id="2-数据库隔离级别"><a href="#2-数据库隔离级别" class="headerlink" title="2.数据库隔离级别"></a>2.数据库隔离级别</h3><p>多个事务读可能会道理以下问题<br>脏读：事务B读取事务A还没有提交的数据<br>不可重复读：，一行被检索两次，并且该行中的值在不同的读取之间不同时<br>幻读:当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时<br>这两个区别在于，不可重复读重点在一行，幻读的重点 ，返回 的集合不一样</p>
<h3 id="3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"><a href="#3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景" class="headerlink" title="3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"></a>3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</h3><p>引擎　　　　　　　　　　特性<br>MYISAM<br>　　　　　　　　　　　　不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描<br>INNODB<br>　　　　　　　　　　　　支持外键，行锁，查表总行数时，全表扫描</p>
<h3 id="4-索引有B-索引和hash索引"><a href="#4-索引有B-索引和hash索引" class="headerlink" title="4.索引有B+索引和hash索引"></a>4.索引有B+索引和hash索引</h3><p>索引　　　　　　　　　　区别<br>Hash<br>　　　　　　　　　　　　hash索引，等值查询效率高，不能排序,不能进行范围查询<br>B+<br>　　　　　　　　　　　　数据有序,范围查询</p>
<h3 id="5-聚集索引和非聚集索引"><a href="#5-聚集索引和非聚集索引" class="headerlink" title="5.聚集索引和非聚集索引"></a>5.聚集索引和非聚集索引</h3><p>索引　　　　　　　　　　区别<br>聚集索引<br>　　　　　　　　　　　　数据按索引顺序存储，中子结点存储真实的物理数据<br>非聚集索引<br>　　　　　　　　　　　　存储指向真正数据行的指针</p>
<h3 id="6-索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#6-索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="6.索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>6.索引的优缺点，什么时候使用索引，什么时候不能使用索引</h3><ol>
<li>索引最大的好处是提高查询速度，</li>
<li>缺点是更新数据时效率低，因为要同时更新索引</li>
<li>对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。</li>
</ol>
<h3 id="7-InnoDB索引和MyISAM索引的区别"><a href="#7-InnoDB索引和MyISAM索引的区别" class="headerlink" title="7.InnoDB索引和MyISAM索引的区别"></a>7.InnoDB索引和MyISAM索引的区别</h3><p>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主</p>
<h3 id="8-索引的底层实现（B-树，为何不采用红黑树，B树）重点"><a href="#8-索引的底层实现（B-树，为何不采用红黑树，B树）重点" class="headerlink" title="8.索引的底层实现（B+树，为何不采用红黑树，B树）重点"></a>8.索引的底层实现（B+树，为何不采用红黑树，B树）重点</h3><p>树                                 区别<br>红黑树<br>                                   增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间</p>
<p>B树也就是B-树<br>                                   B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。</p>
<p>B+树<br>                                   B+树相比较于另外两种树,显得更矮更宽，查询层次更浅</p>
<h3 id="9-B-树的实现"><a href="#9-B-树的实现" class="headerlink" title="9.B+树的实现"></a>9.B+树的实现</h3><p>一个m阶的B+树具有如下几个特征：</p>
<ol>
<li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li>
<li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li>
</ol>
<h3 id="10-为什么使用B-Tree"><a href="#10-为什么使用B-Tree" class="headerlink" title="10.为什么使用B+Tree"></a>10.为什么使用B+Tree</h3><ol>
<li>索引查找过程中就要产生磁盘I/O消耗,主要看IO次数，和磁盘存取原理有关。</li>
<li>根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，</li>
<li>将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入<br>局部性原理与磁盘预读</li>
</ol>
<h3 id="11-Sql的优化"><a href="#11-Sql的优化" class="headerlink" title="11.Sql的优化"></a>11.Sql的优化</h3><p>1.sql尽量使用索引,而且查询要走索引</p>
<p>2.对sql语句优化</p>
<ol>
<li>子查询变成left join</li>
<li>limit 分布优化，先利用ID定位，再分页</li>
<li>or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）</li>
<li>不必要的排序</li>
<li>where代替having,having 检索完所有记录，才进行过滤</li>
<li>避免嵌套查询</li>
<li>对多个字段进行等值查询时，联合索引</li>
</ol>
<h3 id="12-索引最左前缀问题"><a href="#12-索引最左前缀问题" class="headerlink" title="12.索引最左前缀问题"></a>12.索引最左前缀问题</h3><p>如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了</p>
<h3 id="13-索引分类，索引失效条件"><a href="#13-索引分类，索引失效条件" class="headerlink" title="13.索引分类，索引失效条件"></a>13.索引分类，索引失效条件</h3><p>索引类型　　　　　　　　　　　　　　　　　　概念<br>普通索引　　　　　　　　　　　　　最基本的索引，没有任何限制<br>唯一索引　　　　mZZ<br>失效条件:</p>
<p>条件是or,如果还想让or条件生效，给or每个字段加个索引<br>like查询，以%开发<br>内部函数<br>对索引列进行计算<br>is null不会用，is not null 会用</p>
<h3 id="14-数据库的主从复制"><a href="#14-数据库的主从复制" class="headerlink" title="14.数据库的主从复制"></a>14.数据库的主从复制</h3><p>复制方式：操作.</p>
<ol>
<li>异步复制：<br>默认异步复制，容易造成主库数据和从库不一致,一个数据库为Master,一个数据库为slave,通过Binlog日志,slave两个线程，一个线程去读master binlog日志，写到自己的中继日志一个线程解析日志，执行sql,master启动一个线程,给slave传递binlog日志</li>
<li>半同步复制: 只有把master发送的binlog日志写到slave的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低</li>
<li>并行操作:slave 多个线程去请求binlog日志</li>
</ol>
<h3 id="15-long-query怎么解决"><a href="#15-long-query怎么解决" class="headerlink" title="15.long_query怎么解决"></a>15.long_query怎么解决</h3><p>设置参数，开启慢日志功能，得到耗时超过一定时间的sql</p>
<h3 id="16-varchar和char的使用场景"><a href="#16-varchar和char的使用场景" class="headerlink" title="16.varchar和char的使用场景"></a>16.varchar和char的使用场景</h3><p>类型           使用场景<br>varchar        字符长度经常变的<br>char           用字符长度固定的</p>
<h3 id="17-数据库连接池的作用"><a href="#17-数据库连接池的作用" class="headerlink" title="17.数据库连接池的作用"></a>17.数据库连接池的作用</h3><p>维护一定数量的连接，减少创建连接的时间<br>更快的响应时间<br>统一的管理</p>
<h3 id="19-分库分表，主从复制，读写分离"><a href="#19-分库分表，主从复制，读写分离" class="headerlink" title="19.分库分表，主从复制，读写分离"></a>19.分库分表，主从复制，读写分离</h3><p>读写分离，读从库，写主库<br>spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。</p>
<h3 id="20-数据库三范式"><a href="#20-数据库三范式" class="headerlink" title="20.数据库三范式"></a>20.数据库三范式</h3><p>级别　　　　　　　　　　　　概念<br>1NF　　　　　　　　　　　　属性不可分<br>2NF　　　　　　　　　　　　非主键属性，完全依赖于主键属性<br>3NF　　　　　　　　　　　　非主键属性无传递依赖</p>
<h3 id="21-关系型数据库和非关系型数据库区别"><a href="#21-关系型数据库和非关系型数据库区别" class="headerlink" title="21.关系型数据库和非关系型数据库区别"></a>21.关系型数据库和非关系型数据库区别</h3><p>关系型数据库</p>
<p>优点：</p>
<p>1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</p>
<p>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。<br>5.支持事务</p>
<p>缺点<br>1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、不支持高并发读写需求；<br>4、不支持海量数据的高效率读写</p>
<p>非关系型数据库</p>
<p>1、使用键值对存储数据；<br>2、分布式；<br>优点<br>无需经过sql层的解析，读写性能很高<br>基于键值对，数据没有耦合性，容易扩展<br>存储数据的格式：nosql的存储格式是key,value形式<br>缺点<br>不提供sql支持</p>
<h3 id="22-数据库中join的left-join-inner-join-cross-join"><a href="#22-数据库中join的left-join-inner-join-cross-join" class="headerlink" title="22.数据库中join的left join , inner join, cross join"></a>22.数据库中join的left join , inner join, cross join</h3><ol>
<li><p>以A，B两张表为例<br>A left join B<br>选出A的所有记录，B表中没有的以null 代替<br>right join 同理</p>
</li>
<li><p>inner join<br>A,B有交集的记录</p>
</li>
<li><p>cross join (笛卡尔积)<br>A中的每一条记录和B中的每一条记录生成一条记录<br>例如A中有4条，B中有4条，cross join 就有16条记录</p>
</li>
</ol>
<h3 id="23-有哪些锁-select时怎么加排它锁"><a href="#23-有哪些锁-select时怎么加排它锁" class="headerlink" title="23.有哪些锁,select时怎么加排它锁"></a>23.有哪些锁,select时怎么加排它锁</h3><p>锁　　　　　　　　　　　　　　　　　　　概念<br>乐观锁　　　　　　　　　　　　　　　　　自己实现，通过版本号<br>悲观锁　　　　　　　　　　　　　　　　　共享锁，多个事务，只能读不能写，加 lock in share mode<br>排它锁　　　　　　　　　　　　　　　　　一个事务，只能写，for update<br>行锁　　　　　　　　　　　　　　　　　　作用于数据行<br>表锁　　　　　　　　　　　　　　　　　　作于用表</p>
<h3 id="24-死锁怎么解决"><a href="#24-死锁怎么解决" class="headerlink" title="24.死锁怎么解决"></a>24.死锁怎么解决</h3><p>找到进程号，kill 进程</p>
<h3 id="25-最左匹配原则"><a href="#25-最左匹配原则" class="headerlink" title="25.最左匹配原则"></a>25.最左匹配原则</h3><p>最左匹配原则是针对索引的<br>举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的，<br>这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了，<br>查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗，<br>按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了</p>
<hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">lys-studys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/posts/16097/">http://example.com/posts/16097/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/15731/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">mysql2</div></div></a></div><div class="next-post pull-right"><a href="/posts/226/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">cloud</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/15411/" title="mysql1"><img class="cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-13</div><div class="title">mysql1</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By lys-studys</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我们相遇不是意外~ <a target="_blank" rel="noopener" href="https://lys-studys.github.io//">blog</a>!</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png"/><span>粵ICP備xxxx</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'K6YAjTUpfqvIIJRgat2mpicY-gzGzoHsz',
      appKey: 'TiK1kxcHhW26MWKdEgTtxWlm',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = '';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
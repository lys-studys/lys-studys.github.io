<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>docker | 陌上花开缓缓归</title><meta name="description" content="docker计算机虚拟化概述计算机虚拟化起始于上世纪60年代的IBM公司。 虚拟化：将底层的计算机资源抽象（虚拟）为多组彼此之间互相隔离的计算平台，每个计算平台都应该具有五大基本部件中的所有设备  CPU 内存（Memory） IO（keyboard键盘，monitor显示器）  1.1 CPU的虚拟化所有的内核在开发时都以为自己可以操作所有的硬件设备，也就是运行在环0上  1.1.1 模拟：em"><meta name="author" content="lys-studys"><meta name="copyright" content="lys-studys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/timg.jpeg"><link rel="canonical" href="http://example.com/posts/49176/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="docker"><meta property="og:url" content="http://example.com/posts/49176/"><meta property="og:site_name" content="陌上花开缓缓归"><meta property="og:description" content="docker计算机虚拟化概述计算机虚拟化起始于上世纪60年代的IBM公司。 虚拟化：将底层的计算机资源抽象（虚拟）为多组彼此之间互相隔离的计算平台，每个计算平台都应该具有五大基本部件中的所有设备  CPU 内存（Memory） IO（keyboard键盘，monitor显示器）  1.1 CPU的虚拟化所有的内核在开发时都以为自己可以操作所有的硬件设备，也就是运行在环0上  1.1.1 模拟：em"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2021-07-25T11:25:35.000Z"><meta property="article:modified_time" content="2021-07-25T11:26:26.784Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: 'days',
  date_suffix: {"one_hour":"Just","hours":"hours ago","day":"days ago"},
  copyright: {"limitCount":50,"languages":{"author":"Author: lys-studys","link":"Link: ","source":"Source: 陌上花开缓缓归","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: {"text":"I,LOVE,YOU","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2021-07-25 19:26:26'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'true'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="./source/css/background.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="陌上花开缓缓归" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">76</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">26</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker"><span class="toc-number">1.</span> <span class="toc-text">docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%99%9A%E6%8B%9F%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">计算机虚拟化概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-CPU%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 CPU的虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E6%A8%A1%E6%8B%9F%EF%BC%9Aemulation"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1.1 模拟：emulation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E8%99%9A%E6%8B%9F%EF%BC%9Avirtulization"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.1.2 虚拟：virtulization</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Memory%E5%8F%8AI-O%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 Memory及I&#x2F;O的虚拟化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">1.3 虚拟化的实现及分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E6%A1%A5"><span class="toc-number">1.5.</span> <span class="toc-text">1.4 创建和配置桥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A1%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text">网桥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE%E6%A1%A5"><span class="toc-number">1.6.</span> <span class="toc-text">创建和配置桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%89%8D%E4%B8%96LXC"><span class="toc-number">1.7.</span> <span class="toc-text">Docker前世LXC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.</span> <span class="toc-text">Docker的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AE%B9%E5%99%A8%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9A%842%E7%A7%8D%E9%87%8D%E8%A6%81%E6%8A%80%E6%9C%AF"><span class="toc-number">1.9.</span> <span class="toc-text">2.3 容器在内核中支持的2种重要技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%95%9C%E5%83%8F-amp-%E5%AE%B9%E5%99%A8-amp-%E4%BB%93%E5%BA%93"><span class="toc-number">1.10.</span> <span class="toc-text">2.4 镜像&amp;容器&amp;仓库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Docker%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">3. Docker架构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-docker-client"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 docker client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-docker-daemon"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 docker daemon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-docker-server"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 docker server</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">4. Docker的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 Docker的安装和配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 docker的基本使用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%9F%BA%E4%BA%8E%E5%AE%B9%E5%99%A8%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 基于容器制作镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%95%9C%E5%83%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 镜像的导入和导出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E7%BD%91%E7%BB%9C"><span class="toc-number">4.</span> <span class="toc-text">5. 容器虚拟化网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-docker%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">5.1 docker中的网络模式概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Bridge%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.2.</span> <span class="toc-text">5.2 Bridge模式详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">4.3.</span> <span class="toc-text">5.3 自定义网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Docker%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C"><span class="toc-number">4.4.</span> <span class="toc-text">5.4 Docker中设置网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E8%81%94%E7%9B%9F%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">5.5 联盟式容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A1%A5"><span class="toc-number">4.6.</span> <span class="toc-text">5.6 自定义网桥</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-docker%E5%AD%98%E5%82%A8%E5%8D%B7"><span class="toc-number">5.</span> <span class="toc-text">6. docker存储卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%AD%98%E5%82%A8%E5%8D%B7%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">6.1 存储卷概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%8D%B7%E7%9A%84%E7%B1%BB%E5%9E%8BVolume-Type"><span class="toc-number">5.2.</span> <span class="toc-text">6.2 卷的类型Volume Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%9C%A8docker%E4%B8%AD%E4%BD%BF%E7%94%A8volumes"><span class="toc-number">5.3.</span> <span class="toc-text">6.3 在docker中使用volumes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-dockerfile%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">7. dockerfile文件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Dockerfile%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">7.1 Dockerfile简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Dockerfile%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">7.2 Dockerfile中的环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-Dockerfile%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E4%BB%A4%E5%8F%8A%E8%AF%AD%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">7.3 Dockerfile文件编写指令及语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%9E%84%E5%BB%BA%E7%A7%81%E6%9C%89Registry"><span class="toc-number">7.</span> <span class="toc-text">8. 构建私有Registry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E7%A7%81%E6%9C%89Registry%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.</span> <span class="toc-text">8.1 私有Registry概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E9%80%9A%E8%BF%87docker-registry%E6%9D%A5%E9%85%8D%E7%BD%AE%E7%A7%81%E5%BA%93"><span class="toc-number">7.2.</span> <span class="toc-text">8.2 通过docker-registry来配置私库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E9%80%9A%E8%BF%87harbor-registry%E6%9D%A5%E9%85%8D%E7%BD%AE%E7%A7%81%E5%BA%93"><span class="toc-number">7.3.</span> <span class="toc-text">8.3 通过harbor-registry来配置私库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Docker%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">9. Docker资源限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">8.1.</span> <span class="toc-text">9.1 内存资源限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-CPU%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">8.2.</span> <span class="toc-text">9.2 CPU资源限制</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陌上花开缓缓归</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">docker</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-25T11:25:35.000Z" title="Created 2021-07-25 19:25:35">2021-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-07-25T11:26:26.784Z" title="Updated 2021-07-25 19:26:26">2021-07-25</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="计算机虚拟化概述"><a href="#计算机虚拟化概述" class="headerlink" title="计算机虚拟化概述"></a>计算机虚拟化概述</h3><p>计算机虚拟化起始于上世纪60年代的IBM公司。</p>
<p>虚拟化：将底层的计算机资源抽象（虚拟）为多组彼此之间互相隔离的计算平台，每个计算平台都应该具有五大基本部件中的所有设备</p>
<ul>
<li>CPU</li>
<li>内存（Memory）</li>
<li>IO（keyboard键盘，monitor显示器）</li>
</ul>
<h3 id="1-1-CPU的虚拟化"><a href="#1-1-CPU的虚拟化" class="headerlink" title="1.1 CPU的虚拟化"></a>1.1 CPU的虚拟化</h3><p>所有的内核在开发时都以为自己可以操作所有的硬件设备，也就是运行在环0上</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202010/1278240-20201021143127275-3141383.png" alt="img"></p>
<h4 id="1-1-1-模拟：emulation"><a href="#1-1-1-模拟：emulation" class="headerlink" title="1.1.1 模拟：emulation"></a>1.1.1 模拟：emulation</h4><ul>
<li>虚拟是直接在每个虚拟机上用软件虚拟化一个CPU，用纯软件的方式实现，性能很差</li>
<li>底层和上层的架构可以不一致</li>
<li>要模拟CPU的环0、1、2、3 //环这里表示运行权限等级。</li>
</ul>
<h4 id="1-1-2-虚拟：virtulization"><a href="#1-1-2-虚拟：virtulization" class="headerlink" title="1.1.2 虚拟：virtulization"></a>1.1.2 虚拟：virtulization</h4><ul>
<li>上层架构和底层架构要保持一致</li>
<li>虚拟只需要模拟环0</li>
<li>因为上层架构和底层架构一致，所以Guest上用户空间的指令直接可以放到Host上来运行</li>
<li>注：<strong>Host</strong> OS (主人操作系统）就是安装在你硬件设备上的系统，而<strong>Guest</strong> OS (客人操作系统）则是安装在虚拟机（VM）上面的系统。</li>
</ul>
<p><strong>1）完全虚拟化（full-virtulization）</strong></p>
<p>所谓完全虚拟化，即虚拟机都不知道自己是运行在虚拟环境中的</p>
<p>完全虚拟化一定会导致中间有个转换的过程</p>
<ul>
<li>BT：（二进制翻译软件）<ul>
<li>能让客户机对特权指令的调用按需直接翻译成宿主机对特权指令的调用</li>
<li>Guest的用户空间在环3上，Guest的内核空间在环1上，Host的内核空间在环0上，BT就监控在环1上，随时将Guest的内核的调用转换成特权指令的调用</li>
</ul>
</li>
<li>HVM：（硬件辅助的虚拟机，硬件虚拟化）<ul>
<li>多增一个指令环，有5个级别的环</li>
<li>宿主机的内核空间在环-1上，Guest直接运行在环0上，但是环0上没有指令，但它能自动捕获后放到环-1上运行</li>
</ul>
</li>
</ul>
<p><strong>2）半虚拟化（para-virtulization）</strong></p>
<ul>
<li>宿主机系统是明确知道自己在虚拟环境中的（特制的内核）</li>
<li>对hypervisor（宿主机）的调用被称为hyper call</li>
</ul>
<h3 id="1-2-Memory及I-O的虚拟化"><a href="#1-2-Memory及I-O的虚拟化" class="headerlink" title="1.2 Memory及I/O的虚拟化"></a>1.2 Memory及I/O的虚拟化</h3><p><strong>1）内存的虚拟化</strong></p>
<ul>
<li>进程：线性地址空间</li>
<li>内核：物理地址空间</li>
<li>shadow page table</li>
<li>MMU的虚拟化<ul>
<li>Interl：EPT，Extend Page Table</li>
<li>AMD：NTP，Nested Page Table</li>
</ul>
</li>
<li>TLB的虚拟化<ul>
<li>tagged TLB</li>
</ul>
</li>
</ul>
<p><strong>2）I/O的虚拟化</strong></p>
<ul>
<li>模拟：完全用软件来模拟真实硬件（键盘鼠标通常都是完全模拟实现的）</li>
<li>半虚拟化（这种虚拟通常只适用于硬盘和网卡）<ul>
<li>IO frontend 前端驱动</li>
<li>IO backend 后端驱动</li>
</ul>
</li>
<li>IO-through：IO透传<ul>
<li>让虚拟机直接去操作硬件，但依然需要hypervisor来协调</li>
</ul>
</li>
<li>Intel：VT-d<ul>
<li>要完成中断映射</li>
<li>基于北桥的硬件辅助的虚拟化技术</li>
</ul>
</li>
</ul>
<h3 id="1-3-虚拟化的实现及分类"><a href="#1-3-虚拟化的实现及分类" class="headerlink" title="1.3 虚拟化的实现及分类"></a>1.3 虚拟化的实现及分类</h3><p><strong>1）虚拟化的两种实现方式</strong></p>
<ul>
<li>Type-I<ul>
<li>直接在硬件上运行hypervisor，所有运行在当前机器上的都是虚拟机</li>
<li>如 xen，vmware ESX/ESXi</li>
</ul>
</li>
<li>Type-II<ul>
<li>宿主机运行在硬件上，在宿主机上运行客户机</li>
<li>kvm，vmware workstation，virtualbox</li>
</ul>
</li>
</ul>
<p><strong>2）虚拟化技术的分类</strong></p>
<ul>
<li>模拟：著名的模拟器：PearPC，Bochs，<strong>QEMU</strong></li>
<li>完全虚拟化（native virtulization）<ul>
<li>两种加速方式<ul>
<li>BT 二进制翻译</li>
<li>HVM 硬件辅助虚拟化</li>
</ul>
</li>
<li>产品：VMware Workstation，VMware Server，KVM，Xen（HVM）</li>
</ul>
</li>
<li>半虚拟化（para-virtulization）<ul>
<li>xen，uml（user-mod linux）</li>
</ul>
</li>
<li>OS级别的虚拟化<ul>
<li>OpenVZ</li>
<li>LXC</li>
<li>Solaris Containers</li>
<li>FreeBSD jails</li>
</ul>
</li>
<li>库虚拟化：wine</li>
<li>应用程序虚拟化：jvm</li>
</ul>
<h3 id="1-4-创建和配置桥"><a href="#1-4-创建和配置桥" class="headerlink" title="1.4 创建和配置桥"></a>1.4 创建和配置桥</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>1.虚拟网桥与NAT网桥区别<br>    1）bridged networking（桥接模式）<br>    在这种模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。在桥接模式下，需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，配置好网关和DNS的地址后，以实现通过局域网的网关或路由器访问互联网。<br>    2）network address translation(NAT模式)<br>    NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，只需要宿主机器能访问互联网，你不需要配置IP地址，子网掩码，网关，但是DNS地址还是要根据实际情况填的。添加DNS地址除了在网卡属性中填写，还可以在虚拟机中的“虚拟网络编辑器”中的NAT选项卡中点击“编辑”按钮中来添加。<br>    总结：<br>    桥接：虚拟出来的一个独立主机;需要手动配和宿主机同一个网段的ip地址和子网掩码，可实现与宿主机之间的通信。<br>如果配置好网关和DNS后，可实现局域网的网管或路由访问互联网。总之，桥接可实现虚机与网络内部和外部通信之间的<br>互相通信。<br>    NAT模式：通过NAT功能，需要依赖宿主机与外界互联网通信，不能实现与宿主机通信；只需要配DNS；联网简单，只<br>要宿主机能访问网络，虚拟系统就能接入网络。 从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下（也可<br>通过相关配置实现互相通信），外部网络终端也无法访问到虚拟机。</p>
<h3 id="创建和配置桥"><a href="#创建和配置桥" class="headerlink" title="创建和配置桥"></a>创建和配置桥</h3><ul>
<li>桥设备不支持使用NetworkManager来管理服务，必须确保NetworkManager处于关闭状态</li>
<li>要先安装一个桥设备管理程序包：<strong>yum install bridge-utils</strong></li>
<li><strong>桥0也就是br0是被当做了一台交换机来使用（它其实就是宿主机的物理网卡），而原本宿主机的IP地址被配置在了一块虚拟出来的网卡上，且这块网卡被桥接到了br0上</strong></li>
</ul>
<p><strong>1）使用brctl的配置过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brctl add br0              # 创建br0桥</span><br><span class="line">brctl stp br0 on           # 开启生成树</span><br><span class="line">ifconfig eth0 0 up         # 要将eth0的地址删除</span><br><span class="line">brctl addif br0 eth0       # 向br0上添加eth0</span><br><span class="line">ifconfig br0 IP&#x2F;NETMASK up # 在br0上添加IP地址</span><br><span class="line">route add default gw GW    # 添加默认网关</span><br></pre></td></tr></table></figure>

<p><strong>2）全手动配置</strong></p>
<p>看起来ens33更像是桥，但实际上是把ens33做成交br0的桥了，引用的时候要引用br0</p>
<ul>
<li><p>ifcfg-ens33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">NM_CONTROLLED&#x3D;no</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">IPV6INIT&#x3D;no</span><br><span class="line">NAME&#x3D;ens33</span><br><span class="line">DEVICE&#x3D;ens33</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BRIDGE&#x3D;br0   # 这块网卡桥接到br0上</span><br><span class="line">USERCTL&#x3D;no</span><br></pre></td></tr></table></figure>
</li>
<li><p>ifcfg-dr0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Bridge</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">NM_CONTROLLED&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;no</span><br><span class="line">NAME&#x3D;br0</span><br><span class="line">DEVICE&#x3D;br0</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;10.0.0.201</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;10.0.0.2</span><br><span class="line">DNS1&#x3D;10.0.0.2</span><br><span class="line">USERCTL&#x3D;no</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>3）查看桥设备特征</strong></p>
<p>copy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示当前的桥设备及桥设备的特征</span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure>

<h3 id="Docker前世LXC"><a href="#Docker前世LXC" class="headerlink" title="Docker前世LXC"></a>Docker前世LXC</h3><p>LXC（Linux Container）是一种轻量级的虚拟化手段，LXC提供了在单一可控主节点上支持多个相互隔离的server container通知执行的机制。</p>
<p>LXC有点像chroot，提供了一个拥有自己进程的网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。</p>
<p>容器将单个操作系统管理的资源划分到孤立的组中，可以更好的平衡孤立的组之间资源使用的冲突。</p>
<p>docker底层使用了LXC来实现，LXC将linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。在LXC的基础之上，docker提供了一系列更强大的功能。</p>
<p><strong>沙盒化</strong>：就是把一个整体虚拟化为若干部分，每一部分有特定的权限职能。</p>
<h3 id="Docker的概述"><a href="#Docker的概述" class="headerlink" title="Docker的概述"></a>Docker的概述</h3><p><strong>1）Docker简介</strong></p>
<p>docker只是LXC的前端工具，Docker的底层就是通过LXC来实现，LXC将Linux进程沙盒化，使进程之间相互孤立，并且能够控制各进程的资源分配。</p>
<p>docker是一个开源的应用容器引擎，基于go语言开发。</p>
<p>docker可以让开发者打包到他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux服务器，也可以实现虚拟化。容器是完全适用沙盒机制，相互之间不会有任何接口，并且容器开销及其低。</p>
<p><strong>2）docker的版本</strong></p>
<ul>
<li>CE：Community Edition 社区版</li>
<li>EE：Enterprise Edition 商业版</li>
</ul>
<p><strong>3）虚拟机、容器、镜像</strong></p>
<ul>
<li>虚拟机：<ul>
<li>虚拟机运行的是一个完整的操作系统，通过虚拟机管理程序对主机资源进行访问</li>
</ul>
</li>
<li>容器：<ul>
<li>容器共享主机的内核，它运行的是一个独立的进程，且不占用其他任何可执行文件的内存</li>
</ul>
</li>
<li>镜像：<ul>
<li>通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的内容如代码、运行时间、库、环境变量、配置文件等</li>
<li>容器是镜像的运行实例</li>
</ul>
</li>
</ul>
<p><strong>4）docker的运行方式</strong></p>
<p>docker的运行方式：“分层构建 联合挂载”</p>
<p>一个docker启动一个进程，它就是一个普通的进程，非常方便，再挂载外部目录进行存储</p>
<p>大规模使用docker时必须由编排工具，因为如果有很多台服务器，为了使得资源不滥用或者过度空闲，需要将需求（业务端）和资源端（服务器）对接起来，将这个需求放到最合适的服务器上并开始构建，人是不知道哪台服务器闲置的（或者需要提前检查），编排工具就可以。一些服务启动或关闭有依赖关系（dependent），这些docker本身也无法解决，也需要编排工具来解决。如lnmp搭载的系统。</p>
<h3 id="2-3-容器在内核中支持的2种重要技术"><a href="#2-3-容器在内核中支持的2种重要技术" class="headerlink" title="2.3 容器在内核中支持的2种重要技术"></a>2.3 容器在内核中支持的2种重要技术</h3><p>docker本质就是宿主机中的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制机制（copy-on-write）实现高效的文件操作（类似虚拟机的磁盘分配500G并不是占用物理磁盘500G）</p>
<p><strong>1）namespace名称空间</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103133659161-76177737.png" alt="img"></p>
<p><strong>2）Control Group控制组</strong></p>
<ul>
<li>cgroup的特点：<ul>
<li>cgroup的api以一个伪文件系统的实现方式，用户的程序可以通过文件系统实现cgroup的组件管理</li>
<li>cgroup的组件管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源再分配和再利用</li>
<li>所有资源管理的功能都以子系统的方式实现，接口同一子任务创建之初与其父任务处于同一个cgroup的控制组</li>
</ul>
</li>
<li>四大功能：<ul>
<li>资源限制：可以对任务使用的资源总额进行限制</li>
<li>优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级</li>
<li>资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等</li>
<li>任务控制：cgroup可以对任务执行挂起、恢复等操作</li>
</ul>
</li>
</ul>
<h3 id="2-4-镜像-amp-容器-amp-仓库"><a href="#2-4-镜像-amp-容器-amp-仓库" class="headerlink" title="2.4 镜像&amp;容器&amp;仓库"></a>2.4 镜像&amp;容器&amp;仓库</h3><p><strong>1）image镜像</strong></p>
<p>docker镜像含有启动容器所需要的文件系统及其内容，因此其用于创建并启动docker容器</p>
<ul>
<li>docker镜像就是一个只读模板；比如，一个镜像可以包含一个完整的centos，里面仅安装apache或用户的其他应用，镜像可以用来创建docker容器</li>
<li>docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用</li>
</ul>
<p>采用分层构建机制，最底层为bootfs，其上为rootfs：</p>
<ul>
<li>bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约内存资源</li>
<li>rootfs：位于bootfs之上，表现为docker容器的根文件系统<ul>
<li>传统模式中，系统启动之时，内核挂载rootfs时会首先将其挂载为“只读”模式，完整性自检完成后将其重新挂载为读写模式</li>
<li>docker中，rootfs由内核挂载为“只读”模式，而后通过 “联合挂载” 技术额外挂载一个 “可写” 层</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103135810133-1696172476.png" alt="img"></p>
<p>镜像的层次：</p>
<ul>
<li>位于下层的镜像称为父镜像（parent image），最底层的称为基础镜像（base image）</li>
<li>最上层的为 “可读写” 层，其下的均为 “只读” 层</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103140115071-1457873933.png" alt="img"></p>
<p>关于Aufs（advanced multi-layered unification filesystem）高级多层同一文件系统：</p>
<ul>
<li><p>aufs用于为Linux系统实现 “联合挂载”</p>
</li>
<li><p>aufs是之前的UnionFS的重新实现，docker最初使用aufs作为容器文件系统层，它目前仍然作为存储后端之一来支持</p>
</li>
<li><p>aufs的竞争产品是<strong>overlayfs</strong>，overlayfs从3.18版本开始被合并到Linux内核</p>
</li>
<li><p>docker的分层镜像，除了aufs，docker还支持btrfs，devicemaapper和vfs等</p>
<ul>
<li>在Ubuntu系统下，docker默认Ubuntu的aufs，而在CentOS7上，用的是devicemapper</li>
</ul>
<p><strong>挂载</strong>：linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</p>
</li>
</ul>
<p><strong>2）container容器</strong></p>
<p>docker利用容器来运行应用，容器是从镜像创建的运行实例，它可以被启动、开始、停止、删除。</p>
<p>每个容器都是互相隔离的，保证安全的平台，可以把容器看做是个简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p><strong>3）repository仓库</strong></p>
<ul>
<li>由某特定的docker镜像的所有迭代版本组成的镜像仓库</li>
<li>一个Registry中可以存在多个Repository<ul>
<li>Repository可分为 “顶层仓库” 和 “用户仓库” </li>
<li>用户仓库名称格式为 “用户名/仓库名”</li>
</ul>
</li>
<li>Index<ul>
<li>维护用户账号、镜像的校验以及公共命名空间的信息</li>
<li>相当于为Registry提供了一个完成用户认证等功能的检索接口</li>
</ul>
</li>
</ul>
<p><strong>4）图示</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103141355858-1248166948.png" alt="img"></p>
<ul>
<li>标识一个镜像：<ul>
<li>仓库名+标签，如  nginx:1.10</li>
<li>nginx是仓库名，1.10是标签</li>
<li>如果只给仓库名而没有给标签，则默认是最新版，nginx:latest</li>
</ul>
</li>
<li>镜像：<ul>
<li>静态的</li>
<li>镜像文件是只读的</li>
</ul>
</li>
<li>容器：<ul>
<li>动态的，有生命周期</li>
<li><strong>因为一个容器只运行单个应用程序，所以这个应用程序必须运行在前台，否则容器会直接停止</strong></li>
</ul>
</li>
</ul>
<h2 id="3-Docker架构概述"><a href="#3-Docker架构概述" class="headerlink" title="3. Docker架构概述"></a>3. Docker架构概述</h2><h3 id="3-1-docker-client"><a href="#3-1-docker-client" class="headerlink" title="3.1 docker client"></a>3.1 docker client</h3><ul>
<li>docker client是docker架构中用户用来和docker daemon建立通信的客户端<ul>
<li>用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。</li>
</ul>
</li>
<li>docker client可以通过三种方式和docker daemon建立通信：<ul>
<li>tcp://host:port</li>
<li>unix:path_to_socker</li>
<li>fd://sockerfd</li>
</ul>
</li>
<li>docker可以通过设置命令行flag参数的形式设置安全传输层（TLS）的有关参数，保证传输的安全性</li>
<li>docker client发送容器管理请求后，由docker daemon接受并处理请求，当docker client接收到返回的请求响应并简单处理后，docker client一次完整的生命周期就结束了<ul>
<li>当需要继续发送容器管理请求后，用户必须再次通过docker可执行文件创建docker client</li>
</ul>
</li>
</ul>
<h3 id="3-2-docker-daemon"><a href="#3-2-docker-daemon" class="headerlink" title="3.2 docker daemon"></a>3.2 docker daemon</h3><ul>
<li>docker daemon是docker架构中一个常驻在后台的系统进程，它负责接收处理docker client发送的请求<ul>
<li>该守护进程在后台启动一个server，server负责接受docker client发送的请求</li>
<li>接受请求后，server通过路由与分发调度，找到相应的handler来执行请求</li>
</ul>
</li>
<li>docker daemon启动所使用的可执行文件也为docker，与docker client启动所使用的可执行文件docker相同，在docker命令执行时，通过传入的参数来判别docker daemon与docker client</li>
</ul>
<h3 id="3-3-docker-server"><a href="#3-3-docker-server" class="headerlink" title="3.3 docker server"></a>3.3 docker server</h3><ul>
<li> docker server在docker架构中专门服务于docker client的server，该server的功能是接受并调度分发docker client发送的请求</li>
</ul>
<p><strong>架构图示：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201108155340149-20535033.png![img](https://img2018.cnblogs.com/blog/1464965/201907/1464965-20190725202426969-1450304880.jpg" alt="img"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangxingeng/p/11236968.html#auto_id_15">更为详细的docker软件架构分析</a></li>
</ul>
<h2 id="4-Docker的安装和使用"><a href="#4-Docker的安装和使用" class="headerlink" title="4. Docker的安装和使用"></a>4. Docker的安装和使用</h2><h3 id="4-1-Docker的安装和配置"><a href="#4-1-Docker的安装和配置" class="headerlink" title="4.1 Docker的安装和配置"></a>4.1 Docker的安装和配置</h3><p><strong>1）安装docker</strong></p>
<p>配置清华大学镜像源，然后直接yum安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce  -y</span><br></pre></td></tr></table></figure>

<p>注意：如果直接下载repo文件的话，需要手动修改其中的源信息，因为这个文件中是直接指向了docker官方的地址的，需要改成国内的源</p>
<p><strong>2）配置镜像加速</strong></p>
<p>要在 /etc/docker/daemon.json 文件中定义一个镜像加速器（这是一个json格式的数组，这个文件需要自己创建）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    &quot;registry-mirrors&quot;:  [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;,&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）启动docker服务</strong></p>
<p>因为docker是运行方式是C/S架构模式的，需要启动docker守护进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl  start  docker</span><br></pre></td></tr></table></figure>

<h3 id="4-2-docker的基本使用命令"><a href="#4-2-docker的基本使用命令" class="headerlink" title="4.2 docker的基本使用命令"></a>4.2 docker的基本使用命令</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103143308182-1700569082.png" alt="img"></p>
<p><strong>1）基本信息查看</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看docker版本及其他信息</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"># 镜像查看</span><br><span class="line">docker image ls</span><br><span class="line"># 查看容器信息</span><br><span class="line">docker container ls</span><br><span class="line">docker container ls -a</span><br><span class="line"># 状态查看</span><br><span class="line">docker ps </span><br><span class="line">docker ps -a  # 可以查看处于停止状态的容器</span><br><span class="line"># 查看网络状态</span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p><strong>2）镜像的搜索和拉取</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 镜像搜索</span><br><span class="line">docker search nginx:latest</span><br><span class="line">docker search nginx:1.16</span><br><span class="line"></span><br><span class="line">### 镜像的拉取和删除</span><br><span class="line"># 镜像拉取</span><br><span class="line">docker image pull busybox</span><br><span class="line"># 镜像删除</span><br><span class="line">docker image rm busybox  # 删除镜像</span><br><span class="line">docker rmi busybox     # 删除镜像</span><br><span class="line">docker rm busybox      # 删除容器</span><br></pre></td></tr></table></figure>

<p><strong>3）镜像的启动和停止</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker start -i -a b1</span><br><span class="line">    # -i 交互式</span><br><span class="line">    # -a 依附于终端</span><br><span class="line"></span><br><span class="line"># 创建并启动容器 </span><br><span class="line"># docker run可以创建并启动容器，如果没有镜像会自动去下载镜像</span><br><span class="line">docker run --name b1 -i -t busybox:latest</span><br><span class="line">docker run --name web1 -d nginx:1.16</span><br><span class="line">    # -d 剥离终端</span><br><span class="line">    # -t 启用终端</span><br><span class="line"></span><br><span class="line"># 停止容器</span><br><span class="line">docker stop b1</span><br><span class="line"># 杀死容器</span><br><span class="line">docker kill b1</span><br><span class="line"># 删除容器</span><br><span class="line">docker rm b1</span><br><span class="line"></span><br><span class="line"># 查看指定容器的日志</span><br><span class="line">docker logs web1</span><br><span class="line"></span><br><span class="line"># 查看容器的信息</span><br><span class="line">docker inspect b1</span><br><span class="line"></span><br><span class="line"># 在指定的容器中执行指定的命令</span><br><span class="line">docker container exec -i -t web1 &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line"># 依附于一个启动的容器</span><br><span class="line">docker attach b1 </span><br><span class="line"></span><br><span class="line"># 如果不想运行容器中给定的命令，只需在docker run后面给定命令即可</span><br><span class="line">docker run --name tinyweb -it --rm -P tinyhttpd:v0.2-5 ls &#x2F;data&#x2F;web&#x2F;html</span><br></pre></td></tr></table></figure>

<p><strong>4）从别的地址来拉取镜像</strong></p>
<ul>
<li><p>拉取镜像的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull &lt;registry&gt;[:&lt;port&gt;]&#x2F;[&lt;namespace&gt;&#x2F;]&lt;name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认是从docker hub来拉取镜像，如果要从别的地址拉取镜像，如 quay.io这个地址来拉取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull quay.io&#x2F;coreos&#x2F;flannel</span><br><span class="line"># 默认是443端口</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-3-基于容器制作镜像"><a href="#4-3-基于容器制作镜像" class="headerlink" title="4.3 基于容器制作镜像"></a>4.3 基于容器制作镜像</h3><ul>
<li>镜像的生成途径<ul>
<li>Dockerfile：通过build命令来制作</li>
<li>基于容器制作</li>
<li>Docker Hub automated builds</li>
</ul>
</li>
</ul>
<p><strong>1）运行一个busybox并做些改动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 运行一个busybox</span><br><span class="line">docker run --name b1 -it busybox</span><br><span class="line"></span><br><span class="line"># 创建一个html文件并写入一些内容</span><br><span class="line">vi  &#x2F;data&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure>

<p><strong>2）创建镜像并打上标签</strong></p>
<ul>
<li>注意：要新开一个会话</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新开一个ssh会话，创建镜像</span><br><span class="line">docker commit -p b1</span><br><span class="line">    # -p 表示在commit的时候暂停容器</span><br><span class="line">    # 也可以在创建镜像的时候就打上标签</span><br><span class="line">        docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line"># 为镜像打上标签，语法：docker tag 镜像的ID号  标签</span><br><span class="line">docker tag  镜像ID  dockerhgzero&#x2F;httpd:v0.1</span><br><span class="line"># 还可以再打个标签</span><br><span class="line">docker tag hgzero&#x2F;httpd:v0.1 dockerhgzero&#x2F;httpd:latest</span><br></pre></td></tr></table></figure>

<p><strong>3）修改镜像启动时要运行的命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker inspect 中有个Cmd的项，此项就是容器启动时要执行的命令</span><br><span class="line">docker inspect dockerhgzero&#x2F;httpd:latest</span><br><span class="line"></span><br><span class="line"># 修改原有基础镜像启动时要运行的命令，改Cmd就行了</span><br><span class="line">docker commit -a &quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; -c &#39;CMD [&quot;&#x2F;bin&#x2F;httpd&quot;,&quot;-f&quot;,&quot;-h&quot;,&quot;&#x2F;data&#x2F;html&quot;]&#39; -p b1 dockerhgzerowzh&#x2F;httpd:v1.1</span><br><span class="line">    # docker commit 的选项：</span><br><span class="line">         # -a 指明作者名</span><br><span class="line">         # -c 改动列表</span><br><span class="line">         # -p 制作时让其处于暂停状态</span><br><span class="line">    # httpd的选项：</span><br><span class="line">         # -f 运行在前台</span><br><span class="line">         # -h 指明网页文件的目录</span><br></pre></td></tr></table></figure>

<p><strong>4）将镜像推送到Docker Hub</strong></p>
<ul>
<li>要先在Docekr Hub上建立个仓库，并且本地的名称和仓库的名称要保持一致</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在推送之前要登录</span><br><span class="line"># 也可以指定服务器，默认是登录Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"># 推送到dockerhub</span><br><span class="line">docker image push dockerhgzerowzh&#x2F;httpd</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要推送到其他从库，在打标时必须带上仓库地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 推送到阿里云</span><br><span class="line">docker tag hgzerowzh&#x2F;httpd:v0.1 registry.cn-qingdao.aliyuncs.com&#x2F;hgzerowzh&#x2F;httpd:v0.2</span><br></pre></td></tr></table></figure>

<h3 id="4-4-镜像的导入和导出"><a href="#4-4-镜像的导入和导出" class="headerlink" title="4.4 镜像的导入和导出"></a>4.4 镜像的导入和导出</h3><p><strong>1）镜像的导出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o myimage.gz dockerhgzerowzh&#x2F;httpd:v0.1 dockerhgzerowzh&#x2F;httpd:v1.1</span><br><span class="line"># -o 指明保存为一个文件</span><br><span class="line"># 会自动压缩</span><br></pre></td></tr></table></figure>

<p><strong>2）镜像的导入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i myimage.gz</span><br><span class="line"># 使用这种方式要事先准备好本地镜像，否则执行docker run的时候它还是会到docker hub上去下载</span><br></pre></td></tr></table></figure>

<h2 id="5-容器虚拟化网络"><a href="#5-容器虚拟化网络" class="headerlink" title="5. 容器虚拟化网络"></a>5. 容器虚拟化网络</h2><h3 id="5-1-docker中的网络模式概述"><a href="#5-1-docker中的网络模式概述" class="headerlink" title="5.1 docker中的网络模式概述"></a>5.1 docker中的网络模式概述</h3><ul>
<li>默认docker会自动创建3个网络：host、none、bridge</li>
</ul>
<p><strong>1）Host</strong></p>
<p>相当于VMware中的桥接模式，与宿主机在同一个网络中，但是没有独立的IP地址。</p>
<p>Docker使用了Linux的Namespace技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、iptables规则等都与其他的Network Namespace隔离。</p>
<p>一个Docker容器一般会分配一个独立的Network Namespace，但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机公用一个Network Namespace，容器将不会虚拟出自己动网卡、配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p>外界访问容器中的应用，不用任何NAT转换，就如同直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<p><strong>2）None</strong></p>
<p>该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。</p>
<p>实际上，该模式关闭了容器的网络功能，在如下情况中是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）</p>
<p><strong>3）Bridge</strong></p>
<p> 相当于VMware中的NAT模式，容器使用独立的Network Namespace，并连接到docker0的虚拟网卡（默认模式）。通过docker0网桥以及iptables nat表配置与宿主机通信。</p>
<p>bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</p>
<p><strong>4）Container</strong></p>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。</p>
<p>新创建的容器不会创建自己的网卡、配置自己的IP，而是和一个指定的容器共享IP地址、端口范围等。</p>
<p>两个容器除了网络方面，其他的如文件系统、进程列表还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>
<h3 id="5-2-Bridge模式详解"><a href="#5-2-Bridge模式详解" class="headerlink" title="5.2 Bridge模式详解"></a>5.2 Bridge模式详解</h3><p><strong>1）Bridge模式的拓扑详解</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201104120921949-1802562682.png" alt="img"></p>
<p>当Docker Server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>
<p>接下来会为容器分配IP，Docker会从私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如一般Docker会使用172.17.0.0/16这个网段，并将172.17.0.1/16分配给docker0网桥（在主机上使用ficonfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p>
<p><strong>2）Docker网络模式详解</strong></p>
<p>Docker完成以上网络配置的过程大致是这样：</p>
<ol>
<li><p>在主机上创建一堆虚拟网卡veth pair设备。veth设备总是成对出现，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p>
</li>
<li><p>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以eth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令来查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.02425f21c208       no</span><br></pre></td></tr></table></figure>
</li>
<li><p>从docker0子网中分配一个IP给容器使用，并设备docker0的IP地址为容器的默认网关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看容器网络</span><br><span class="line">docker inspect 9582dbec7981</span><br><span class="line"></span><br><span class="line"># 查看桥设备信息</span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>3）bridge模式下容器的通信</strong></p>
<p>在bridge模式下，连在同一网桥上的容器可以相互通信；出于安全考虑，也可以禁止它们之间通信：在DOCKER_OPTS变量中设置 –icc=false，这样只有使用–link才能使两个容器通信。</p>
<p>Docker可以开启容器间通信（意味着默认配置 –icc=true），也就是说，宿主机上的所有容器可以不受任何限制的相互通信，这可能导致拒绝服务攻击；Docker可以通过–ip_forward和–iptables两个选项控制容器间、容器和外部世界的通信。</p>
<p>容器也可以和外部通信，主机上定义了如下iptables规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A POSTROUTING -s 172.17.0.0&#x2F;16 ! -o docker0 -j MASQUERADE</span><br><span class="line"># 这条规则会将源地址为172.17.0.0&#x2F;16的包（也就是从Docker容器产生的包）</span><br><span class="line"># 　　并且不是从docker0网卡发出的包，进行源地址转换，转换成主机网卡的地址</span><br><span class="line">#　　 这样在外界看来，这个包是从主机网卡上发出来的，Docker容器对外是不可见的</span><br></pre></td></tr></table></figure>

<h3 id="5-3-自定义网络"><a href="#5-3-自定义网络" class="headerlink" title="5.3 自定义网络"></a>5.3 自定义网络</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zuxing/articles/8780661.html">https://www.cnblogs.com/zuxing/articles/8780661.html</a></li>
</ul>
<h3 id="5-4-Docker中设置网络"><a href="#5-4-Docker中设置网络" class="headerlink" title="5.4 Docker中设置网络"></a>5.4 Docker中设置网络</h3><ul>
<li>默认创建容器时如果没有特别指定，则都使用的是桥接网络（bridge），是NAT桥</li>
<li>指定容器的网络模式：docker container run <strong>–network</strong> xxx</li>
</ul>
<p><strong>1）查看网络的相关内容</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看网络模式</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"># 查看网络的现骨干内容</span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure>

<p><strong>2）docker中设置网络</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name t1 -it --network bridge --rm busybox:latest</span><br><span class="line">    --rm </span><br><span class="line">　　　　　# 表示容器退出自动删除</span><br><span class="line">    --network  # 指定网络类型</span><br><span class="line">        # none</span><br><span class="line">        # bridge 默认</span><br><span class="line">    --hostname www.hgzerowzh.com  </span><br><span class="line">　　　　　# 设置主机名，注入到容器中</span><br><span class="line">    --dns 114.114.114.114 </span><br><span class="line">　　　　　# 注入设置DNS</span><br><span class="line">    --dns-search hgzerowzh.com  </span><br><span class="line">　　　　　# 向容器中注入搜索域</span><br><span class="line">    --add-host www.hgzerowzh.com:10.0.0.201 </span><br><span class="line">　　　　　# 向容器中注入hosts文件解析记录</span><br></pre></td></tr></table></figure>

<p><strong>3）设置端口映射</strong></p>
<ul>
<li>查看指定容器上的端口映射：docker port myweb</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将myweb容器上的80端口暴露到宿主机的随机端口（一般是3万之后）</span><br><span class="line">docker run --name myweb --rm -p 80 hgzerowzh&#x2F;httpd:v0.2</span><br><span class="line">    # 可以在iptables生成的规则中查看这个随机端口</span><br><span class="line">    # iptables -t nat -vnl</span><br><span class="line">    # 这条iptables规则会随着容器的删除而自动删除</span><br><span class="line"></span><br><span class="line"># 端口映射的规则，-p选项可以使用多次</span><br><span class="line">    -p 80 </span><br><span class="line">        # 将容器的80端口expose至宿主机的随机端口（一般是3万之后）</span><br><span class="line">　　　　　# 会暴露到宿主机上所有的IP上</span><br><span class="line">    -p 宿主机IP::容器端口</span><br><span class="line">        # 将指定的容器端口映射到主机指定IP的动态端口</span><br><span class="line">　　　　　# 只是指定宿主机的IP地址，宿主机的端口还是随机的</span><br><span class="line">    -p 80:80</span><br><span class="line">        # 将宿主机的80端口映射到容器的80端口（前面的80表示宿主机）</span><br><span class="line">    -p 宿主机IP:宿主机端口:容器端口</span><br><span class="line">    　 　# 将宿主机指定IP的指定端口映射到容器的端口</span><br><span class="line">    -P  # 大P表示直接暴露容器中暴露的端口</span><br><span class="line">　　　　 # 表示只要容器中暴露了端口，则将其直接暴露到宿主机中</span><br></pre></td></tr></table></figure>

<h3 id="5-5-联盟式容器"><a href="#5-5-联盟式容器" class="headerlink" title="5.5 联盟式容器"></a>5.5 联盟式容器</h3><p><strong>1）概述</strong></p>
<p>联盟式容器指用某个已经存在的网络接口的容器，接口被联盟内的各容器共享使用，因此，联盟式容器彼此间完全无隔离。</p>
<p>联盟式容器彼此之间虽然共享一个网络名称空间，但其他名称空间如User、Mount等还是隔离的。</p>
<p>联盟式容器彼此间存在端口冲突的可能性，因此，通常只会在多个容器上的程序需要程序loopback接口互相通信、或对某已存的容器的网络属性进行监控时才使用此种模式的网络模型。</p>
<p><strong>2）容器之间共享网络名称空间</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个监听于2222端口的http服务容器</span><br><span class="line">docker run --name b1 -d -it --rm -p 2222 busybox:latest &#x2F;bin&#x2F;httpd -p 2222 -f </span><br><span class="line"></span><br><span class="line"># 创建一个联盟式容器，并查看其监听的端口</span><br><span class="line">docker run --name b2 -it --rm --network container:b1 buxybox:latest netstat -tan</span><br><span class="line">    # --network container:b1 表示这个b2容器共享b1容器的网络名称空间</span><br></pre></td></tr></table></figure>

<h3 id="5-6-自定义网桥"><a href="#5-6-自定义网桥" class="headerlink" title="5.6 自定义网桥"></a>5.6 自定义网桥</h3><p><strong>1）自定义docker0桥网络属性信息</strong></p>
<ul>
<li>编辑 <strong>/etc/docker/daemon.json</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bip&quot;: &quot;192.168.1.5&#x2F;24&quot;,</span><br><span class="line">  &quot;fixed-cidr&quot;: &quot;10.20.0.0&#x2F;16&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1500,</span><br><span class="line">  &quot;default-gateway&quot;: &quot;10.20.1.1&quot;,</span><br><span class="line">  &quot;default-gateway-v6&quot;: &quot;2001:db8:abcd::89&quot;,</span><br><span class="line">  &quot;dns&quot;: [&quot;10.20.1.2&quot;,&quot;10.20.1.3&quot;]              </span><br><span class="line">&#125;</span><br><span class="line"># 核心选项为bip，即bridge ip之意，用于指定docker0桥自身的IP地址# 配置文件中最后一个key后面不能有逗号，否则语法错误# 一般指定bip就可以了，其他选项会自动计算得知，如果希望容器的dns不使用系统的dns，也可以指定dns</span><br></pre></td></tr></table></figure>

<p><strong>2）自己创建桥</strong></p>
<ul>
<li>可以自己手动再创建一个网桥</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 再创建一个网桥mybr0，地址是172.26.0.0&#x2F;16，网关是172.26.0.1</span><br><span class="line">docker network create -d bridge --subnet &quot;172.26.0.0&#x2F;16&quot; --gateway &quot;172.26.0.1&quot; mybr0</span><br><span class="line"># mybr0只是网络叫mybr0，网络接口的名字是 自动生成的，可以改成其他名字</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个容器，加入刚刚的网络</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name t1 -it --network mybr0 busybox:latest</span><br><span class="line"></span><br><span class="line"># 在宿主机上打开核心转发，就可以让两个网段的容器通信</span><br><span class="line"># 如果ping不通，是跟iptables规则有关，被iptables阻断了而已</span><br></pre></td></tr></table></figure>

<p><strong>3）允许docker从外部连入</strong></p>
<ul>
<li>默认docker是监听在本机的Unix Sock套接字上</li>
<li>docker的守护进程的C/S，其默认仅监听Unix Socker格式的地址，/var/run/docker.sock</li>
<li>如果要使用TCP套接字，需要修改配置文件 /etc/docker/daemon.json</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hosts&quot;: [&quot;tcp:&#x2F;&#x2F;0.0.0.0:2375&quot;, &quot;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>远程连入docker：<ul>
<li>docker -H 10.0.0.204:2375 ps</li>
<li>docker -H 10.0.0.204:2374 image ls</li>
</ul>
</li>
</ul>
<p><strong>4）docker配置允许从外部tcp连接时报错</strong></p>
<ul>
<li><p>报错信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dockerd[2144]: unable to configure the Docker daemon with file &#x2F;etc&#x2F;docker&#x2F;daemon.json: the following directives are specified both as a flag and in the configuratio</span><br><span class="line">n file: hosts: (from flag: [fd:&#x2F;&#x2F;], from file: [unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock])</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service中将ExecStart项中docker启动的 -H fd:&#x2F;&#x2F; 删掉即可</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="6-docker存储卷"><a href="#6-docker存储卷" class="headerlink" title="6. docker存储卷"></a>6. docker存储卷</h2><h3 id="6-1-存储卷概述"><a href="#6-1-存储卷概述" class="headerlink" title="6.1 存储卷概述"></a>6.1 存储卷概述</h3><p><strong>1）文件的写时复制</strong></p>
<p>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层。</p>
<p>如果运行中的容器修改了现有的一个已经存在的文件，那该文件会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，此即“写时复制（COW）”机制。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103231616546-553686731.png" alt="img"></p>
<p><strong>2）数据持久化问题</strong></p>
<p>当关闭并重启容器时，其数据不受影响，但是如果删除Docker容器，则其更改将会全部丢失。</p>
<ul>
<li>容器存储数据会存在如下问题：<ul>
<li>容器中的数据存储于联合文件系统中，不易于宿主机访问</li>
<li>容器间数据共享不便</li>
<li>删除容器其数据会丢失</li>
</ul>
</li>
<li>解决方案：卷（volume）<ul>
<li>“卷” 是容器上的一个或多个 “目录”，此类目录可以绕过联合文件系统，与宿主机上的某目录“绑定（关联）”</li>
</ul>
</li>
</ul>
<p>Volume与容器初始化之时就会创建，由base image提供的卷中的数据会于此期间完成复制。</p>
<p>Volume的初衷是独立于容器的生命周期实现数据持久化，因此删除容器的时候既不会删除卷，也不会对未被引用的卷做垃圾回收操作。</p>
<p><strong>3）独立于容器的数据管理机制</strong></p>
<p>可以把“镜像”想成静态文件，例如“程序”，把卷类比为动态内容，例如“数据”，于是，镜像可以重用，而卷可以共享</p>
<p>卷实现了“程序（镜像）”和“数据（卷）”分离，以及“程序（镜像）”和“制作镜像的主机”分离，用户制作镜像时无须再考虑镜像运行的容器所在的主机的环境。</p>
<p><strong>3）常见的服务可以分为有状态的服务和无状态的服务两种</strong></p>
<ul>
<li>有状态的服务：mysql、redis、tomcat，需要持久存储</li>
<li>无状态的服务：nginx、httpd等</li>
</ul>
<h3 id="6-2-卷的类型Volume-Type"><a href="#6-2-卷的类型Volume-Type" class="headerlink" title="6.2 卷的类型Volume Type"></a>6.2 卷的类型Volume Type</h3><ul>
<li>Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同。</li>
</ul>
<p><strong>1）Bind mount volume （绑定挂载卷）</strong></p>
<ul>
<li>明确指定容器和宿主机上的对应位置</li>
<li>即需要手工指定宿主机和容器内目录的绑定关系</li>
<li><strong>注意：bind方式创建的目录在容器删除后依旧可以实现持久化存储，不会删除或消失</strong></li>
</ul>
<p><strong>2）Docker-managed volume （Docker管理的卷）</strong></p>
<ul>
<li>在容器中指定位置，但它在宿主机中对应的位置由docker来自行管控</li>
<li>不需要特别指定绑定关系，而由docker管理，一般绑定的目录为/var/lib/docker/volumes/container id 目录下</li>
<li><strong>注意：这种方式创建的文件会在容器删除后自动删除，不能实现真正的持久化</strong></li>
</ul>
<h3 id="6-3-在docker中使用volumes"><a href="#6-3-在docker中使用volumes" class="headerlink" title="6.3 在docker中使用volumes"></a><strong>6.3 在docker中使用volumes</strong></h3><ul>
<li>为docker run命令使用-v选项即可使用Volumes</li>
</ul>
<p><strong>1）Docker管理的卷</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将容器的&#x2F;data目录映射到宿主机的docker管理的目录中</span><br><span class="line">docker run -it --name bbox1 -v &#x2F;data busybox</span><br><span class="line"></span><br><span class="line"># 可以使用docker inspect bbox1来查看&#x2F;data在宿主机上所对应的目录位置</span><br><span class="line"># 在docker inspect的Mounts建所对应的值中查看</span><br></pre></td></tr></table></figure>

<ul>
<li>过滤docker inspect中的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 过滤显示根下的Mounts中的内容</span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; b2</span><br><span class="line"></span><br><span class="line"># 过滤显示根下的NetworkSettings中的内容</span><br><span class="line">docker inspect -f &#123;&#123;.NetworkSettings&#125;&#125; b2</span><br><span class="line"></span><br><span class="line"># 过滤显示根下的NetworkSettings下的IPAddress中的内容</span><br><span class="line">docker inspect -f &#123;&#123;.NetworkSettings.IPAddress&#125;&#125; b2</span><br><span class="line"></span><br><span class="line"># 以上的 . 点 表示docker inspect显示内容的根</span><br></pre></td></tr></table></figure>

<p><strong>2）绑定挂载卷</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 语法：docker run -it -v HOSTDIR:VOLUMEDIR --name bbox2 busybox</span><br><span class="line"></span><br><span class="line"># 将宿主机中的&#x2F;data&#x2F;volumes&#x2F;b2目录和容器中的&#x2F;data目录做映射</span><br><span class="line">docker run -it -v &#x2F;data&#x2F;volumes&#x2F;b2:&#x2F;data busybox</span><br><span class="line"></span><br><span class="line"># 默认会在宿主机上自动创建目录</span><br></pre></td></tr></table></figure>

<p><strong>3）复制使用其他容器的卷</strong></p>
<ul>
<li>为docker run命令使用 –volumes-from 选项即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建bbox2时直接复制使用bbox1的卷</span><br><span class="line">docker run -it --name bbox2 --volumes-from bbox1 busybox</span><br></pre></td></tr></table></figure>

<h2 id="7-dockerfile文件详解"><a href="#7-dockerfile文件详解" class="headerlink" title="7. dockerfile文件详解"></a>7. dockerfile文件详解</h2><h3 id="7-1-Dockerfile简介"><a href="#7-1-Dockerfile简介" class="headerlink" title="7.1 Dockerfile简介"></a>7.1 Dockerfile简介</h3><p><strong>1）Dockerfile</strong></p>
<ul>
<li>将用来全自动构建镜像文件，命名为Dockerfile</li>
<li>注释行用 # 号开头</li>
<li>用docker build做镜像时，docker build主机还要隐藏式的启用一个容器，以提供容器制作环境</li>
</ul>
<p><strong>2）打包时过滤文件</strong></p>
<p>可以做一个单独的隐藏文件： <strong>.dockerignore</strong></p>
<p>在这个文件可以写文件路径，一行一个，可以使用通配符；在打包时，凡是在此文件中的内容，在打包时都不包含进来，包括dockerignore本身和dockerignore中定义的文件，都不会被打包进来</p>
<h3 id="7-2-Dockerfile中的环境变量"><a href="#7-2-Dockerfile中的环境变量" class="headerlink" title="7.2 Dockerfile中的环境变量"></a><strong>7.2 Dockerfile中的环境变量</strong></h3><p><strong>1）变量的定义</strong></p>
<ul>
<li>可以用ENV指令来定义环境变量</li>
</ul>
<p><strong>2）变量的引用</strong>（以下两种写法等价）</p>
<ul>
<li>$variable_name</li>
<li>${variable_name}</li>
</ul>
<p><strong>3）其他用法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;variable:-word&#125;</span><br><span class="line">    # 如果该变量没有值或者值为空，则将word赋值给该变量</span><br><span class="line">    # 如果变量有值，就用变量自身的值</span><br><span class="line">$&#123;variable:+word&#125;</span><br><span class="line">    # 如果变量有值，则将word赋值给该变量</span><br><span class="line">    # 如果该变量没有值，则不设置该变量的值</span><br></pre></td></tr></table></figure>

<p><strong>4）在docker run时，向变量传值</strong></p>
<ul>
<li>在docker run时，使用-e参数即可向变量传值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name web1 --rm -P -e WEB_SERVER_PACKAGE&#x3D;&quot;nginx-1.15.1&quot; tinyhttpd:v0.1-7 printenv </span><br></pre></td></tr></table></figure>

<h3 id="7-3-Dockerfile文件编写指令及语法"><a href="#7-3-Dockerfile文件编写指令及语法" class="headerlink" title="7.3 Dockerfile文件编写指令及语法"></a><strong>7.3 Dockerfile文件编写指令及语法</strong></h3><ul>
<li>在Dockerfile文件中是不区分字符大小写的</li>
<li>在Dockerfile中，每一条指令都会生成一个新的镜像层，因此，如果能把两条指令写成一条，就一定要写成一条</li>
</ul>
<p><strong>1）FROM</strong></p>
<ul>
<li><p>FROM指定必须为Dockerfile文件开篇的第一个非注释行，用于为构建过程指定基准镜像，后续的指令运行于此基准镜像所提供的运行环境。</p>
</li>
<li><p>基准镜像可以是任何可用镜像文件，默认情况下，docker build会在docker主机上查找指定的镜像文件，在其不存在时，则会从Docker Hub Registry上拉取所需的镜像文件。如果找不到指定的镜像文件，docker build会返回一个错误信息。</p>
</li>
<li><p>两种使用语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一种，直接指定仓库和标签</span><br><span class="line">FROM &lt;repository&gt;[:&lt;tag&gt;]</span><br><span class="line"># 如 FROM busybox:latest</span><br><span class="line"># 如果不指定tag，则默认就为latest</span><br><span class="line"></span><br><span class="line"># 第二种，指定镜像的哈希码，以防止镜像被别人冒名顶替</span><br><span class="line">FROM &lt;repository&gt;@&lt;digest&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>2）LABEL</strong></p>
<ul>
<li><p>用于让Dockefile制作者提供本人的详细信息，定义为key=value的形式</p>
</li>
<li><p>一个镜像可以有多个LABEL，并且可以将多个LABEL定义在一行</p>
</li>
<li><p>两种语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下两种方式等价</span><br><span class="line">LABEL  &quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line">LABEL  maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; </span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>3）COPY</strong></p>
<ul>
<li><p>用于从Docker主机复制文件至创建的新印象文件</p>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY  &lt;src&gt;  ...  &lt;dest&gt;</span><br><span class="line"># &lt;src&gt; 表示要复制的源文件或目录，支持使用通配符</span><br><span class="line"># &lt;dest&gt;  表示目标路径，即真在创建的image的文件系统路径，</span><br><span class="line">    # 建议dest使用绝对路径，否则COPY指定则以WORKDIR为其起始路径</span><br><span class="line"></span><br><span class="line"># 如果路径中有空白字符时，可以使用如下格式</span><br><span class="line">COPY  [&quot;&lt;src&gt;&quot; ... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ul>
<li><src> 必须是build上下文中的路径，不能是其父目录中的文件</li>
<li>如果<src>是目录，则其内部文件或子目录会被递归复制，但<src>目录自身不会被复制（如果源是目录，那么只会复制该目录下的所有文件）</li>
<li>如果指定了多个<src>，或在<src>中使用了通配符，则<dest>必须是一个目录，且必须以 / 结尾</li>
</ul>
</li>
</ul>
<p><strong>4）ADD</strong></p>
<ul>
<li><p>ADD指令类似于COPY指令，ADD支持使用tar文件和URL路径</p>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD  &lt;src&gt; ... &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"># 或者使用如下形式</span><br><span class="line">ADD  [&quot;&lt;src&gt;&quot; ... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项:</p>
<ul>
<li>如果<src>为URL，且<dest>不以 / 结尾，则<src>指定的文件将被下载并创建为<dest>；如果<dest>以 / 结尾，则文件名URL指定的文件将被下载并保存为<dest>/<filename></li>
<li>如果<src>是一个本地系统上压缩格式的tar文件，它将被展开为一个目录，其行为类似于“tar -x”命令；但是通过URL获取到的tar文件将不会自动展开</li>
<li>如果<src>有多个，或其使用了通配符，则<dest>必须是一个以 / 结尾的目录路径；如果<dest>不以 / 结尾，则其被视作一个普通文件，<src>的内容将被直接写入到<dest></li>
</ul>
</li>
</ul>
<p><strong>5）WORKDIR</strong></p>
<ul>
<li><p>用于为Dockerfile中所有的RUN、CMD、ENTRYPOINT、COPY和ADD设定工作目录</p>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用格式</span><br><span class="line">WORKDIR  &lt;dir_path&gt;</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">WORKDIR &#x2F;var&#x2F;log</span><br><span class="line">WORKDIR $STATEPATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ul>
<li>在Dockerfile文件中，WORKDIR指令可出现多次，其路径也可以为相对路径，但它是相对于此前一个WORKDIR指令指定的路径</li>
<li>WORKDIR也可以调用有ENV指定定义的变量</li>
</ul>
</li>
</ul>
<p><strong>6）VOLUME</strong></p>
<ul>
<li><p>用于在image中创建一个挂载点目录，以挂载Docker host上的卷或其他容器上的卷</p>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME   &lt;mountpoint&gt;</span><br><span class="line"></span><br><span class="line"># 或者使用如下语法</span><br><span class="line">VOLUME  [&quot;&lt;mountpoint&gt;&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ul>
<li>如果挂载点目录路径下存在文件，docker run命令会在卷挂载完成后将此前的所有文件复制到新挂载的卷中</li>
</ul>
</li>
</ul>
<p><strong>7）EXPOSE</strong></p>
<ul>
<li><p>用于为容器打开指定要监听的端口以实现与外部通信</p>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE  &lt;port&gt;[&#x2F;&lt;protocol&gt;][&lt;port&gt;[&#x2F;&lt;protocol&gt;] ... ]</span><br><span class="line"># &lt;protocol&gt;用于指定传输层协议，可为tcp或udp二者之一，默认为TCP协议</span><br><span class="line"></span><br><span class="line"># EXPOSE指令可一次指定多个端口</span><br><span class="line">EXPOSE  11211&#x2F;udp  11211&#x2F;tcp</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>8）ENV</strong></p>
<ul>
<li><p>用于为镜像定义所需要的环境变量，并可被Dockerfile文件中位于其后的其他指令（如ENV、ADD、COPY等）所调用</p>
</li>
<li><p>调用格式为 $variable_name 或 ${variable_name}</p>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &lt;key&gt;之后的所有内容均会被视作其&lt;value&gt;的组成部分，因此，一次只能设置一个变量</span><br><span class="line">ENV  &lt;key&gt;  &lt;value&gt;</span><br><span class="line"></span><br><span class="line"># 可用一次设置多个变量，每个变量为一个&quot;&lt;key&gt;&#x3D;&lt;value&gt;&quot;的键值对</span><br><span class="line"># 如果&lt;value&gt;中包含空格，可以以反斜线 \ 进行转义，也可以通过对&lt;value&gt;加引号进行标识</span><br><span class="line"># 反斜线也可以用于续行ENV  &lt;key&gt;&#x3D;&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ul>
<li>定义多个变量时，建议使用第二种方式，以便在同一层中完成所有功能</li>
</ul>
</li>
</ul>
<p><strong>9）RUN</strong></p>
<ul>
<li><p>用于指定docker build过程中运行的程序，其可以是任何命令</p>
<ul>
<li>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础</li>
<li>镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的 版本控制</li>
</ul>
</li>
<li><p>exec会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号</p>
</li>
<li><p>exec方式不会调用一个命令shell，所以也不会继承相应的变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 第一种使用语法</span><br><span class="line">RUN &lt;command&gt;</span><br><span class="line"># 在这种格式中，&lt;command&gt;通常是一个shell命令，且以&quot;&#x2F;bin&#x2F;sh -c&quot;来运行</span><br><span class="line"># 这意味着此进程在容器中的PID不为1，不能接收到Unix信号，因此，当使用docker stop命令停止容器时，此进程接收不到SIGTERM信号</span><br><span class="line"></span><br><span class="line">### 第二种使用语法</span><br><span class="line">RUN　&lt;&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;&gt;</span><br><span class="line"># 在这种格式中的参数是一个JSON格式的数组，&lt;executable&gt;为要运行的命令，后面的&lt;param&gt;为传递给命令的选项或参数</span><br><span class="line"># 但是这种格式指令的命令不会以&quot;&#x2F;bin&#x2F;sh -c&quot;来发起，因此常见的shell操作如变量替换以及通配符(?,*等)替换将不会进行</span><br><span class="line"># 如要要运行的命令依赖于此shell特性的时，可以将其替换为如下格式：</span><br><span class="line">RUN [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;]</span><br><span class="line">RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot; ]</span><br><span class="line"># RUN产生的缓存在下一次构建的时候是不会失效的，会被重用</span><br><span class="line"># 可以使用--no-cache选项，即docker build-no-cache，这样便不会缓存</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>基本使用示例 ：</p>
<ul>
<li><p>mkdir test &amp;&amp; cd test</p>
</li>
<li><p>vim Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Description： test image</span><br><span class="line">FROM busybox:latest</span><br><span class="line">#FROM busybox@哈希码</span><br><span class="line"># MAINTAINER &quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line">ENV DOC_ROOT&#x3D;&#x2F;data&#x2F;web&#x2F;html \</span><br><span class="line">    WEB_SERVER_PACKAGE&#x3D;&quot;nginx-1.15.2&quot;</span><br><span class="line">COPY index.html $&#123;DOC_ROOT:-&#x2F;data&#x2F;web&#x2F;html&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">ADD http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.15.2.tar.gz &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line"></span><br><span class="line"># WORKDIR &#x2F;usr&#x2F;local</span><br><span class="line"></span><br><span class="line">COPY yum.repos.d &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"># ADD $&#123;WEB_SERVER_PACKAGE&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line"></span><br><span class="line">VOLUME &#x2F;data&#x2F;mysql&#x2F;</span><br><span class="line"></span><br><span class="line">EXPOSE 80&#x2F;tcp</span><br><span class="line"></span><br><span class="line">RUN cd &#x2F;usr&#x2F;local&#x2F;src &amp;&amp; \</span><br><span class="line">    tar -x nginx-1.15.2.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker build -t tinyhttpd:v0.1-1 ./</p>
<ul>
<li>-t  表示打上标签</li>
</ul>
</li>
</ul>
<p><strong>10）CMD</strong></p>
<p><strong><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201104203633080-994909625.png" alt="img"></strong></p>
<ul>
<li><p>类似于RUN指令，CMD指令也可用于运行任何命令或应用程序，但是二者的运行时间点不同</p>
<ul>
<li>RUN指令运行于印象文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新映像文件启动一个容器时</li>
<li>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；但CMD指定的命令可以为docker run 的命令行选项所覆盖</li>
<li>在Dockerfile中可以存在多个CMD指令，但仅最后一个会生效</li>
</ul>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下面这两种语法格式的意义同RUNCMD  &lt;command&gt;  # 这种CMD运行命令的方式pid不为1</span><br><span class="line">CMD  [&quot;&lt;executable&gt;&quot;, &quot;&lt;param1&gt;&quot;, &quot;&lt;param2&gt;&quot;]</span><br><span class="line"></span><br><span class="line"># 这种语法格式用于为ENTRYPOINT指令提供默认参数CMD  [&quot;&lt;param1&gt;&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; app&#x3D;&quot;httpd&quot;</span><br><span class="line"></span><br><span class="line">ENV WEB_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&quot;</span><br><span class="line"></span><br><span class="line">RUN mkdir -p $WEB_DOC_ROOT &amp;&amp; \</span><br><span class="line">    echo &quot;&lt;h1&gt;Busybox httpd server.&lt;&#x2F;h1&gt;&quot; &gt; $&#123;WEB_DOC_ROOT&#125;&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># CMD &#x2F;bin&#x2F;httpd -f -h $&#123;WEB_DOC_ROOT&#125;</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;&#x2F;bin&#x2F;httpd&quot;,&quot;-f&quot;,&quot;-h $&#123;WEB_DOC_ROOT&#125;&quot;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>11）ENTRYPOINT</strong></p>
<ul>
<li><p>类似CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一个单独的可执行程序</p>
</li>
<li><p>由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序</p>
<ul>
<li>docker run命令的–entrypoint选项的参数可以覆盖ENTRYPOINT指令指定的程序</li>
</ul>
</li>
<li><p>如果dockerfile文件中同时存在CMD和ENTRYPOINT，则CMD的参数将被作为可选项传递给ENTRYPOINT</p>
<ul>
<li>如果docker run中指定有命令行参数选项，则这些命令行参数将会覆盖掉CMD，并附加到ENTRYPOINT命令行作为其参数使用，否则才会将CMD作为参数传递给ENTRYPOINT</li>
<li>dockerfile文件中也可以存在多个ENTRYPOINT，但只有最后一个有效</li>
</ul>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 跟RUN类似，在这种格式中，command通常为一个shell命令，且以&quot;&#x2F;bin&#x2F;sh -c&quot;来运行</span><br><span class="line"># 此进程在容器中的PID不为1</span><br><span class="line">ENTRYPOINT &lt;command&gt;</span><br><span class="line"></span><br><span class="line"># 跟RUN类似，这种格式指定的命令不会以&quot;&#x2F;bin&#x2F;sh -c&quot;发起，无法使用shell通配符等特性</span><br><span class="line">ENTRYPOINT [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; app&#x3D;&quot;httpd&quot;</span><br><span class="line"></span><br><span class="line">ENV WEB_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">RUN mkdir -p $WEB_DOC_ROOT &amp;&amp; \</span><br><span class="line">    echo &quot;&lt;h1&gt;Busybox httpd server.&lt;h1&gt;&quot; &gt; $&#123;WEB_DOC_ROOT&#125;&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># CMD &#x2F;bin&#x2F;httpd -f -h $&#123;WEB_DOC_ROOT&#125;</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;httpd&quot;,&quot;-f&quot;,&quot;-h $&#123;WEB_DOC_ROOT&#125;&quot;]</span><br><span class="line">ENTRYPOINT &#x2F;bin&#x2F;sh -c</span><br><span class="line"># 这样运行时会用&#x2F;bin&#x2F;sh -c 来运行ENTRYPOINT中的&#x2F;bin&#x2F;sh -c ，并且CMD中的命令将会作为参数传递给ENTRYPOINT中的指令</span><br><span class="line"># 如果不想重复启用&#x2F;bin&#x2F;sh -c ，可以写成如下格式：</span><br><span class="line"># ENTRYPOINT [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>实际使用示例：</p>
<ul>
<li><p>dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.14-alpine</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">ENV NGX_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&quot;</span><br><span class="line"></span><br><span class="line">ADD index.html $&#123;NGX_DOC_ROOT&#125;</span><br><span class="line">ADD entrypoint.sh &#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>被调用的shell脚本文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">#</span><br><span class="line">cat &gt; &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;www.conf &lt;&lt; EOF</span><br><span class="line">server &#123;</span><br><span class="line">  server_name $&#123;HOSTNAME&#125;;</span><br><span class="line">  listen $&#123;IP:-0.0.0.0&#125;:$&#123;PORT:-80&#125;;</span><br><span class="line">  root $&#123;NGX_DOC_ROOT:-&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#125;;  </span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br><span class="line"># 因为CMD指令中的内容将会作为参数传递给ENTRYPOINT，# 所以当ENTRYPOINT调用此脚本文件执行完毕后，可以用exec来调用CMD指令内容中的nginx来覆盖当前进程# 这样保证了nginx进程的PID号依然为1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>12）USER</strong></p>
<ul>
<li><p>用于指定运行image时的用户名或UID</p>
</li>
<li><p>或者指定运行Dockerfile中任何RUN、CMD、ENTRYPOINT指令指定的程序时的用户名或UID</p>
</li>
<li><p>默认情况下，容器的运行身份为root用户</p>
</li>
<li><p>使用语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER &lt;UID&gt; | &lt;UserName&gt;</span><br><span class="line"># &lt;UID&gt;可以为任意数字，但实践中必须为&#x2F;etc&#x2F;passwd中某用户的有效UID，否则docker run命令将运行失败</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>13）HEALTHCHECK</strong></p>
<ul>
<li><p>监控检查，可以根据主进程所提供的服务正常与否来进行判定健康与否</p>
</li>
<li><p>使用语法及参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 两种语法形式HEALTHCHECK  [OPTIONS]  CMD  command # CMD关键词后也可以跟执行shell脚本的命令或者exec数组</span><br><span class="line">HEALTHCHECK NONE  # 意思是禁止从父镜像继承的HEALTHCHECK生效</span><br><span class="line"></span><br><span class="line"># OPTIONS可设定的参数（下面选项中的值都是默认值）</span><br><span class="line">　　--interval&#x3D;30s    # 每隔多长时间进行一次健康检查（从容器运行起来开始计时），单位s、m、h</span><br><span class="line">　　--timeout&#x3D;30s     # 执行command的超时时间</span><br><span class="line">　　--start-period&#x3D;0s # 启动时间，也就是在这里指定的时候之后再进行健康检查</span><br><span class="line">　　--retries&#x3D;3       # 重试次数，连续检查次数</span><br><span class="line"></span><br><span class="line"># CMD执行完成可能的返回值</span><br><span class="line">　　0  health状态</span><br><span class="line">　　1  unhealth状态</span><br><span class="line">　　2  reserved状态</span><br><span class="line"></span><br><span class="line"># 注意：在Dockerfile中只能有一个HEALTHCHECK指令，如果列出多个，则只有最后一个生效</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK --interval&#x3D;5m --timeout&#x3D;3s \</span><br><span class="line">    CMD curl -f http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.14-alpine</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">ENV NGX_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&quot;</span><br><span class="line"></span><br><span class="line">ADD index.html $&#123;NGX_DOC_ROOT&#125;</span><br><span class="line">ADD entrypoint.sh &#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">HEALTHCHECK --start-period&#x3D;3s CMD wget -O - -q http:&#x2F;&#x2F;$&#123;IP:-0.0.0.0&#125;:$&#123;PORT:-80&#125;&#x2F;</span><br><span class="line"></span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>14）SHELL</strong></p>
<ul>
<li><p>SHELL指令允许覆盖用于shell形式命令的默认shell</p>
<ul>
<li>Linux上默认的shell是 [“/bin/sh”, “-c”]</li>
<li>Windows上是 [“cmd”, “/S”, “/C”]</li>
</ul>
</li>
<li><p>SHELL指令必须以JSON格式写入Dockerfile，且SHELL指令可以出现多次，每个SHELL指令都会覆盖所有先前的SHELL指令，并影响所有后续指令</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;&#x2F;S&quot;, &quot;&#x2F;C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>15）STOPSIGNAL</strong></p>
<ul>
<li><p>STOPSIGNAL指令设置将发送到容器的系统调用信号以退出</p>
<ul>
<li>此信号可以是与内核的系统调用表中的位置匹配的有效无符号数，如9，或SIGNAME格式的信号名，如SIGKILL</li>
<li>停止进程的信号，默认是发15的信号，也可以改成9</li>
</ul>
</li>
<li><p>默认的stop-signal是SIGTERM，在docker stop的时候会给容器内PID为1的进程发送这个signal，主要的目的是为了让容器内的应用程序在接收到signal之后可以先做一些事情，实现容器的平滑退出，如果不做任何处理，容器将在一段时间之后强制退出，会造成业务的强制中断，这个时间默认是10s</p>
</li>
<li><p>使用语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>16）ARG</strong></p>
<ul>
<li><p>可以在dockerfile文件中用ARG指令定义一些变量，然后在docker build的时候将这些变量传递进去</p>
<ul>
<li>ARG所定义的参数，在docker build命令中以 –build-arg NAME=VALUE的形式进行赋值</li>
<li>如果docker build命令传递的参数在Dockerfile中没有对应的参数，则会抛出警告</li>
</ul>
</li>
<li><p>使用示例：</p>
<ul>
<li><p>先在dockerfile文件中定义ARG</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG author&#x3D;“hgzerowzh”</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在dockerbuild的时候通过 –build-arg 将对应的值传进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build --build-arg author&#x3D;“wzh” -t myweb:v0.3-10 .&#x2F;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>17）ONBUILD</strong></p>
<ul>
<li><p>ONBUILD用于在dockerfile中定义一个触发器</p>
<ul>
<li>这个触发器不是在自己被build的时候执行，而是此镜像被别人拿去做基础镜像时触发执行，也就是被别人FROM的时候触发执行</li>
<li>一般ONBUILD都是执行RUN或者ADD</li>
</ul>
</li>
<li><p>ONBUILD不能自我嵌套，且不会触发FROM和MAINTAINER指令</p>
</li>
<li><p>使用包含ONBUILD指令的Dockerfile构建的镜像应该使用特殊的标签，如ruby:2.0-onbuild</p>
</li>
<li><p>在ONBUILD指令中使用ADD或COPY指令时应该要特别注意，因为新构建过程的上下文在缺少指定的源文件时会失败</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD ADD . &#x2F;app&#x2F;src</span><br><span class="line">ONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build --dri &#x2F;app&#x2F;src</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="8-构建私有Registry"><a href="#8-构建私有Registry" class="headerlink" title="8. 构建私有Registry"></a>8. 构建私有Registry</h2><h3 id="8-1-私有Registry概述"><a href="#8-1-私有Registry概述" class="headerlink" title="8.1 私有Registry概述"></a>8.1 私有Registry概述</h3><p><strong>1）私有仓库搭建的好处</strong></p>
<ul>
<li>节约带宽</li>
<li>可以自己定制系统</li>
<li>更加安全</li>
</ul>
<p><strong>2）构建私有Registry的方式</strong></p>
<ol>
<li>利用官方提供的工具docker-registry来配置私库<ul>
<li>这个工具是一个镜像，直接下载并使用registry镜像启动docker实例就可以了</li>
</ul>
</li>
<li>利用Harbor-Registry来搭建私库<ul>
<li>Harbor是一个用于存储Docker镜像的企业级Registry服务</li>
</ul>
</li>
</ol>
<h3 id="8-2-通过docker-registry来配置私库"><a href="#8-2-通过docker-registry来配置私库" class="headerlink" title="8.2 通过docker-registry来配置私库"></a>8.2 通过docker-registry来配置私库</h3><p><strong>1）安装docker私有仓库</strong></p>
<ul>
<li>要在私库上安装好docker，然后直接yum安装docker-registry</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-registry</span><br><span class="line"></span><br><span class="line"># 安装完成后即可直接启动服务,要注意这里的是docker-distribution</span><br><span class="line">systemctl start docker-distribution</span><br><span class="line"></span><br><span class="line"># 安装完成后可以查看一下生成的文件</span><br><span class="line">rpm -ql docker-distribution</span><br></pre></td></tr></table></figure>

<p><strong>2）配置文件</strong></p>
<ul>
<li>vim <strong>/etc/docker-distribution/registry/config.yml</strong> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry        # 定义启动的服务</span><br><span class="line">storage:</span><br><span class="line">    cache:</span><br><span class="line">        layerinfo: inmemory  # 定义缓存在内存中</span><br><span class="line">    filesystem:</span><br><span class="line">        rootdirectory: &#x2F;var&#x2F;lib&#x2F;registry  # 定义数据存放的位置</span><br><span class="line">http:  </span><br><span class="line">    addr: :5000              # 定义监听的端口，冒号后面没写地址表示监听本机的所有地址</span><br></pre></td></tr></table></figure>

<p><strong>3）把镜像推送到刚刚建好的私有仓库</strong></p>
<ul>
<li><p>先要对镜像打标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dcoekr tag myweb:v0.3-11  node1.hgzerowzh.com:5000&#x2F;myweb:v0.3-11</span><br><span class="line"># myweb前面没有加其他的用户名，这里表示这是一个顶层仓库</span><br><span class="line"># node1.hgzerowzh.com:5000是仓库的地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后将镜像推送上去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果不给标签，会推送整个仓库</span><br><span class="line">docker push node1.hgzerowzh.com:5000&#x2F;myweb</span><br><span class="line"></span><br><span class="line"># 推送时，因为客户端使用的是https的连接，而服务端是http的响应，所以推送时会出错</span><br><span class="line">docker push node1.hgzerowzh.com:5000&#x2F;myweb:v0.3-11</span><br><span class="line"></span><br><span class="line"># 仓库必须做成https的</span><br><span class="line"># 如果是在内网使用，确实不想使用https，就可以在客户端添加配置，明确说明要使用非安全的docker registry</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>4）明确指定要使用非安全的docker-registry</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 特别注意，如下配置是要在客户端配置的，谁要连接docker-registry就在谁上配置</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">        &quot;insecure-registries&quot;:[&quot;node1.hgzerowzh.com:5000&quot;]  # 在这里指定非安全的docker-registry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-通过harbor-registry来配置私库"><a href="#8-3-通过harbor-registry来配置私库" class="headerlink" title="8.3 通过harbor-registry来配置私库"></a>8.3 通过harbor-registry来配置私库</h3><p><strong>1）harbor概述</strong></p>
<p>harbor是VMwar公司基于docker registry开发的一个用于存储和分发docker镜像的企业级registry服务器。</p>
<p>harbor通过添加需要的功能如安全性、身份认证、管理来扩展了源Docker Distribution，提升了镜像的传输效率；harbor支持registry之间复制镜像，还提供了更高级的安全功能，比如：漏洞分析、用户管理、访问控制、活动审计等。</p>
<p><strong>2）harbor的安装</strong></p>
<p>harbor有两种安装方式：online installer / offline installer</p>
<p>online installer：从docker hub下载安装</p>
<p>offline installer：没有网络时，下载离线安装包安装</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangxingeng/p/11598708.html#auto_id_11">详细安装步骤</a></li>
</ul>
<h2 id="9-Docker资源限制"><a href="#9-Docker资源限制" class="headerlink" title="9. Docker资源限制"></a>9. Docker资源限制</h2><h3 id="9-1-内存资源限制"><a href="#9-1-内存资源限制" class="headerlink" title="9.1 内存资源限制"></a>9.1 内存资源限制</h3><h3 id="9-2-CPU资源限制"><a href="#9-2-CPU资源限制" class="headerlink" title="9.2 CPU资源限制"></a>9.2 CPU资源限制</h3><p> 参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoshancun/p/12352981.html">https://www.cnblogs.com/xiaoshancun/p/12352981.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zuxing/articles/8780661.html">https://www.cnblogs.com/zuxing/articles/8780661.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangxingeng/p/11236968.html">https://www.cnblogs.com/zhangxingeng/p/11236968.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangxingeng/p/11558782.html">https://www.cnblogs.com/zhangxingeng/p/11558782.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangxingeng/p/11598708.html">https://www.cnblogs.com/zhangxingeng/p/11598708.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hgzero/p/13852259.html">Docker详解 - Praywu - 博客园 (cnblogs.com)</a></li>
</ul>
<hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">lys-studys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/posts/49176/">http://example.com/posts/49176/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/62516/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">dp专栏</div></div></a></div><div class="next-post pull-right"><a href="/posts/56673/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Python微服务框架nameko</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By lys-studys</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我们相遇不是意外~ <a target="_blank" rel="noopener" href="https://lys-studys.github.io//">blog</a>!</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png"/><span>粵ICP備xxxx</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'K6YAjTUpfqvIIJRgat2mpicY-gzGzoHsz',
      appKey: 'TiK1kxcHhW26MWKdEgTtxWlm',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = '';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
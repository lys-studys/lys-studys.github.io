<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>c-2 | 陌上花开缓缓归</title><meta name="description" content="人不可有傲气，但不可无傲骨！ c++基本思想从面向过程转变为面向对象，由操作局部改变为操作整体，c语言就好像指挥单兵作战，每个人员分配都得事必躬亲，c++就是指挥兵团作战，整体布局，指挥的是一个个团体, 类和对象基础类和对象含义类是用户定义类型 (C++ 的核心特性，通常被称为用户定义的类型)。类用于指定对象 (指定对象的形式，它包含了数据表示法和用于处理数据的方法)。类中的数据和方法称为类的成员"><meta name="keywords" content="c++"><meta name="author" content="lys-studys"><meta name="copyright" content="lys-studys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/timg.jpeg"><link rel="canonical" href="http://example.com/posts/39788/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="c-2"><meta property="og:url" content="http://example.com/posts/39788/"><meta property="og:site_name" content="陌上花开缓缓归"><meta property="og:description" content="人不可有傲气，但不可无傲骨！ c++基本思想从面向过程转变为面向对象，由操作局部改变为操作整体，c语言就好像指挥单兵作战，每个人员分配都得事必躬亲，c++就是指挥兵团作战，整体布局，指挥的是一个个团体, 类和对象基础类和对象含义类是用户定义类型 (C++ 的核心特性，通常被称为用户定义的类型)。类用于指定对象 (指定对象的形式，它包含了数据表示法和用于处理数据的方法)。类中的数据和方法称为类的成员"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-10-10T08:34:46.000Z"><meta property="article:modified_time" content="2020-10-13T02:40:50.832Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: 'days',
  date_suffix: {"one_hour":"Just","hours":"hours ago","day":"days ago"},
  copyright: {"limitCount":50,"languages":{"author":"Author: lys-studys","link":"Link: ","source":"Source: 陌上花开缓缓归","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: {"text":"I,LOVE,YOU","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-13 10:40:50'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'true'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="./source/css/background.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="陌上花开缓缓归" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">45</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.</span> <span class="toc-text">c++基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">类和对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%90%AB%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">类和对象含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE-%E5%AE%9A%E4%B9%89c-%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">来直接访问.定义c++对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">2.4.</span> <span class="toc-text">访问数据成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">!成员属性与成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.6.</span> <span class="toc-text">!访问权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">2.7.</span> <span class="toc-text">!this指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">!构造和析构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">默认构造函数:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">构造函数:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">析构函数:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">拷贝构造函数:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%EF%BC%88%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">类型转换构造函数:（有参构造函数中一个参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.6.</span> <span class="toc-text">各个函数的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#default%E4%B8%8Edelete"><span class="toc-number">3.7.</span> <span class="toc-text">default与delete</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#default"><span class="toc-number">3.7.1.</span> <span class="toc-text">default:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete"><span class="toc-number">3.7.2.</span> <span class="toc-text">delete:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-number">3.8.</span> <span class="toc-text">构造和析构的三五法则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">!类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">!类属性和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">成员属性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.1.2.</span> <span class="toc-text">成员方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.1.3.</span> <span class="toc-text">类属型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.1.4.</span> <span class="toc-text">类方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.5.</span> <span class="toc-text">const类型的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E7%B1%BB%E5%B1%9E%E5%9E%8B"><span class="toc-number">4.1.6.</span> <span class="toc-text">类和类属型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.</span> <span class="toc-text">浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">返回值优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">7.1.</span> <span class="toc-text">继承下的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">7.2.</span> <span class="toc-text">菱形继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%9A"><span class="toc-number">7.3.</span> <span class="toc-text">继承下的拷贝构造：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">8.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%A4%96%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">8.1.</span> <span class="toc-text">类外运算符重载:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">9.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">多态和虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.1.</span> <span class="toc-text">纯虚函数:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9A"><span class="toc-number">9.1.2.</span> <span class="toc-text">抽象类：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E5%95%A5%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.3.</span> <span class="toc-text">父类的析构函数为啥设置为虚函数?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8Cthis%E6%8C%87%E9%92%88"><span class="toc-number">10.</span> <span class="toc-text">虚函数和this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">虚函数表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88-1"><span class="toc-number">12.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">13.</span> <span class="toc-text">虚继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">15.</span> <span class="toc-text">模板</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陌上花开缓缓归</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">c-2</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-10-10T08:34:46.000Z" title="Created 2020-10-10 16:34:46">2020-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-13T02:40:50.832Z" title="Updated 2020-10-13 10:40:50">2020-10-13</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>人不可有傲气，但不可无傲骨！</p>
<h3 id="c-基本思想"><a href="#c-基本思想" class="headerlink" title="c++基本思想"></a>c++基本思想</h3><p>从面向过程转变为面向对象，由操作局部改变为操作整体，c语言就好像指挥单兵作战，每个人员分配都得事必躬亲，c++就是指挥兵团作战，整体布局，指挥的是一个个团体,</p>
<h3 id="类和对象基础"><a href="#类和对象基础" class="headerlink" title="类和对象基础"></a>类和对象基础</h3><h4 id="类和对象含义"><a href="#类和对象含义" class="headerlink" title="类和对象含义"></a>类和对象含义</h4><p>类是用户定义类型 (C++ 的核心特性，通常被称为用户定义的类型)。<br>类用于指定对象 (指定对象的形式，它包含了数据表示法和用于处理数据的方法)。<br>类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>定义一个类，本质上是定义一个自己想要的数据类型．可以类比结构体，而对象类比结构体变量.<br>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">       public:</span><br><span class="line">          double length;   &#x2F;&#x2F; 盒子的长度</span><br><span class="line">          double breadth;  &#x2F;&#x2F; 盒子的宽度</span><br><span class="line">          double height;   &#x2F;&#x2F; 盒子的高度</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="来直接访问-定义c-对象"><a href="#来直接访问-定义c-对象" class="headerlink" title="来直接访问.定义c++对象"></a>来直接访问.定义c++对象</h4><p>对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box Box1;          &#x2F;&#x2F; 声明 Box1，类型为 Box</span><br><span class="line">Box Box2;          &#x2F;&#x2F; 声明 Box2，类型为 Box</span><br><span class="line">注：对象 Box1 和 Box2 都有它们各自的数据成员。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="访问数据成员"><a href="#访问数据成员" class="headerlink" title="访问数据成员"></a>访问数据成员</h4><p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。<br>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问.</p>
<h4 id="成员属性与成员方法"><a href="#成员属性与成员方法" class="headerlink" title="!成员属性与成员方法"></a>!成员属性与成员方法</h4><p>类把成员属性和成员方法打包到了一起．<br>成员属性: 类中的各种类型的变量(存储的数据).<br>成员方法:  所定义的这个类所具备的功能，比如狗的类，成员方法可以说叫，跑，啃骨头．</p>
<p>类方法:　</p>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="!访问权限"></a>!访问权限</h4><p>c++中class和struct等价，不声明权限的默认为公有权限．<br>class中不声明就是private的.<br>public: 公共访问权限<br>private:　私有访问权限:’只有’本类型的方法可以访问.(该类内部的方法可以访问)<br>protected: 受保护访问权限</p>
<h4 id="this指针"><a href="#this指针" class="headerlink" title="!this指针"></a>!this指针</h4><p>this指针指的是调用该方法的对象(不是类，对象有地址，类没有地址)，所以在构造函数中对成员属性赋值操作不能直接用参数赋值，而是this指针指向的该对象的属性.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void set_xy(int x, int y)&#123;</span><br><span class="line">    this-&gt;x &#x3D; x; b的属性 &#x3D; 传入参数</span><br><span class="line">    this-&gt;y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="!构造和析构"></a>!构造和析构</h3><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数:"></a>默认构造函数:</h4><pre><code>也称为无参构造函数,
如果没有自己的构造函数，在定义对象的时候会自动调用默认构造函数.</code></pre>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h4><pre><code>　构造函数用来初始化对象的，我们自己想初始化对象，可以把构造函数写再构造函数里．</code></pre>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数:"></a>析构函数:</h4><pre><code>通常给系统调用的，不是我们自己调用的．~Car(); 没有返回值.</code></pre>
<h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数:"></a>拷贝构造函数:</h4><pre><code>同类型对象的赋值行为，</code></pre>
<p>系统的默认实现：调用了每个成员属性的赋值方法．</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">A b &#x3D; a;</span><br><span class="line">这里调用了拷贝构造函数.拷贝构造函数参数传的是引用.(const &amp;).</span><br><span class="line">一般加上const</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么拷贝构造函数一定要传引用？不传引用为什么通不过编译?<br>因为拷贝构造函数的参数也是该类的对象，调用该函数会首先给参数进行赋值（调用拷贝构造函数）这里他调用了他自己，会形成一个无限递归，格式不对所以编译不过.是不可行代码.<br>反过来说，如果改成了引用，也就是说当前参数就代表了传入的参数，相当于就是执行参数本身，消除了参数的构造过程．<br>引用（＆）：只是相关变量的别名.</p>
<h4 id="类型转换构造函数-（有参构造函数中一个参数）"><a href="#类型转换构造函数-（有参构造函数中一个参数）" class="headerlink" title="类型转换构造函数:（有参构造函数中一个参数）"></a>类型转换构造函数:（有参构造函数中一个参数）</h4><p>构造函数只有一个参数．<br>＇在对象定义时＇，可以直接定义对象是传参，也可以用等号赋值.系统根据类型匹配构造函数(跟普通的＝不同的功能).<br>不是在定义时：等于号调用的是赋值运算函数.如果没写赋值运算函数就还是调用的赋值构造函数.<br>有了这个函数就可以在初始化时不用传参传入类，如传入整形就会自动去匹配相关构造函数．</p>
<h4 id="各个函数的执行顺序"><a href="#各个函数的执行顺序" class="headerlink" title="各个函数的执行顺序"></a>各个函数的执行顺序</h4><p>构造函数1,2,3,析构函数3,2,1<br>原因：栈空间，(无论是全局变量还是局部变量)(按照书写先后顺序)数据/对象压栈的过程，就是构造函数执行的过程，弹出栈的时候，系统会调用相关的析构函数．单数一般的变量没有看不到相关操作但是存在相关过程.<br>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car a;</span><br><span class="line">Car b(a)</span><br><span class="line">Car C(b),</span><br><span class="line">若果顺序析构，机会出现如果ｂ需要ａ的信息，就会出现非法访问问题.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="default与delete"><a href="#default与delete" class="headerlink" title="default与delete"></a>default与delete</h4><p>在初始化对象时，先初始化对象相关成员，先调用成员的构造函数，若果成员构造函数为delete,那么该对象构造函数也不能为default,只能为delete.</p>
<h5 id="default"><a href="#default" class="headerlink" title="default:"></a>default:</h5><pre><code>Car() = default;
使用相关构造函数对默认行为,就是什么都不做的初始化.
Car(const Car &amp;) = default;
是代码更为严禁，更能发现错误．　</code></pre>
<h5 id="delete"><a href="#delete" class="headerlink" title="delete:"></a>delete:</h5><p>　　相关方法去除操作．如果不想被别人调用，可以变为delete，别人调用就会报错.禁止了一个类的对象产生拷贝行为.<br>　　Car() = delete.<br>　　表示Car()的默认构造函数不存在.</p>
<h4 id="构造和析构的三五法则"><a href="#构造和析构的三五法则" class="headerlink" title="构造和析构的三五法则"></a>构造和析构的三五法则</h4><p>１．需要析构函数的类也需要拷贝构造函数和拷贝赋值函数。<br>需要析构函数：一般在相关构造函数中开辟了新的存储空间，需要析构函数进行内存空间的释放.(开辟了额外的存储空间)</p>
<p>需要拷贝构造函数：开辟了新的存储空间的类，需要的＇深拷贝＇<br>所以得到上述结论!</p>
<p>２．需要拷贝操作的类也需要赋值操作，反之亦然。</p>
<p>３．析构函数不能是私有的（删除的）<br>析构函数被删除了我们就没办法定义局部变量.(就是在主函数中创建一个类对象，因为系统在用完变量后会调用相应的析构函数，析构函数不存在，便会在编译阶段报错). 自主函数中　Car a;</p>
<p>但是可以Car *p = new Car();这样动态申请空间．<br>不能调用delete　ｐ因为delete也调用了相关的析构函数.</p>
<p>４．如果一个类有私有的(删除的)或不可访问的析构函数，那么其默认和拷贝构造函数会被定义为私有的。<br>既然不能删除，那么不能被重复利用的空间，这个类也变得没有什么意义.<br>５．如果一个类有const或引用成员，则不能使用默认（合成的赋值操作）的拷贝赋值操作。<br>合成的赋值操作：就是把赋值构造函数参数设定为一个类，然后进行类与类之间各个属性的赋值操作．<br>赋值操作不能作用在const修饰的变量上，常量不可修改.<br>若何操作const的成员属性，可以使用构造函数的初始化列表修改其值，他调用相关成员的构造函数，而相关的拷贝构造是进行赋值操作.<br>&amp;(引用)是在定义的时候立即绑定对象.&amp;引用的初始化操作也得放在构造函数初始化列表中.</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="!类和对象"></a>!类和对象</h3><h4 id="类属性和类方法"><a href="#类属性和类方法" class="headerlink" title="!类属性和类方法"></a>!类属性和类方法</h4><h5 id="成员属性："><a href="#成员属性：" class="headerlink" title="成员属性："></a>成员属性：</h5><p>类中每一个成员都决定着该类的一个属性.比如人的体重.而且呢每个对象都有有个特定值值.</p>
<p>注！只有在成员方法中能访问到this指针.</p>
<h5 id="成员方法："><a href="#成员方法：" class="headerlink" title="成员方法："></a>成员方法：</h5><p>就是类的行为动作．</p>
<p>类属型类方法，就是在对应的属性和方法前加上static关键字.</p>
<h5 id="类属型："><a href="#类属型：" class="headerlink" title="类属型："></a>类属型：</h5><p>类中的变量可以说是声明.<br>类属型的定义:写到类外边．</p>
<p>所有对象访问的时候访问的是一个值，成员属性是每个对象都有一个.<br>１．可以通过 对象访问（不同对象访问的类属型值是一样的）<br>２．可以通过命名空间去访问.[std::] 类名也是命名空间.</p>
<h5 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h5><p>全局只有一个方法，访问不到this指针的.<br>访问方式同类属型.</p>
<h5 id="const类型的方法"><a href="#const类型的方法" class="headerlink" title="const类型的方法"></a>const类型的方法</h5><p>这个方法不去修改任何属性的值.</p>
<p>对象与引用<br>等同于变量和变量的引用.<br>也可以在main也可以定义cosnt Car().<br>常量的对象，非常量方法无法访问．所以说const类型的对象只能调用const类型的方法.<br>在const方法中修改成员属性，需要在类中的对应属性前加上mutable关键字.</p>
<h5 id="类和类属型"><a href="#类和类属型" class="headerlink" title="类和类属型"></a>类和类属型</h5><p>构造顺序：先构造成员在构造类<br>析构顺序：先析构类后析构类成员</p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>浅拷贝：每一个成员属性依次的进行赋值操作.(主要就是数组的拷贝（传入的是首地址）)浅拷贝中改变拷贝后得值会影响拷贝原版的值．深拷贝解决这次问题．<br>系统自带的拷贝就是浅拷贝<br>深拷贝：比浅拷贝多了一个申请内存空间的过程，解决了浅拷贝中所出现的（更改连带问题）．</p>
<h3 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h3><p>对象初始化顺序：　开辟存储区-&gt;匹配(拷贝)构造函数-&gt;完成构造.<br>函数返回时存在匿名变量，再由匿名变量拷贝给对象，所以说匿名变量的消除是第一个优化.<br>就只剩下一次默认构造一次拷贝构造.<br>第二步优化消除拷贝构造(可以理解为引用的操作)<br>最后剩下一次默认构造.<br>编译过程：加上　-fno-elide-constructors 参数即可关闭返回值优化.<br>注意：关闭优化前在函数返回的时候存在一个匿名变量<br>通过匿名变量给a拷贝<br>A a(func);<br>相关优化一般基于相关的编译系统，比如微软的就进行了一次优化.</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>继承语法:</p>
<p>class Cat : public Animal{//公有继承</p>
<p>};<br>相关继承权限:<br>１．对于子类的权限<br>使用public 和 protected和 private均能访问到父类中的public,protected相关属性和方法．</p>
<p>２．子类继承过来的属性和方法这些继承完对外的权限<br>公有继承　public-&gt;public | protected-&gt;protected<br>保护继承  public-&gt;protected | protected-&gt;protected<br>私有继承　public-&gt;private | protected-&gt;private<br>不能存在私有继承<br>不让外界访问让子类访问设置成受保护的<br>都不让访问设置成私有的</p>
<h4 id="继承下的构造"><a href="#继承下的构造" class="headerlink" title="继承下的构造"></a>继承下的构造</h4><p>子类在进行构造之前先让父类进行构造再进行子类的构造．<br>那么先调用子类的析构再调用父类的析构函数<br>构造：Cat():Animal(“cat”){} 可以显性调用构造函数否者调用默认构造函数．</p>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>比如Ｂ和Ｃ同时继承于Ａ而Ｄ同时继承于Ｂ和Ｃ那么这种继承就是菱形继承.</p>
<h4 id="继承下的拷贝构造："><a href="#继承下的拷贝构造：" class="headerlink" title="继承下的拷贝构造："></a>继承下的拷贝构造：</h4><p>子类的对象绑定到父类的引用上(显时的调用父类的拷贝构造函数)，隐式的类型转换.<br>显式的调用父类的赋值运算符函数.<br>即使有些子类的成员属性无法访问但是父类的成员属性在子类中依然是存在的.(sizeof(类)大小会改变).</p>
<p>子类的存储方式:<br>    子类中先存储父类的相关信息，然后在存储子类的信息.<br>子类对象的首地址也就是父类对象的首地址.所以说子类的地址可以赋值给他父类的相关指针变量的.也可以绑定到相关的父类的应用上.</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>１．在类内部式运算符重载成为他的成员方法.相当于调用了ａ对象的　＋＝　方法，传入对象为３．<br>２．在类外边直接实现运算符重载.bool operator += (a, 3);</p>
<p>友元函数实现类内部的声明，函数实现在类外，可以通过此改变进行使得函数可以访问类的私有成员</p>
<h4 id="类外运算符重载"><a href="#类外运算符重载" class="headerlink" title="类外运算符重载:"></a>类外运算符重载:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##### 类内部：</span><br><span class="line"> friend Point operator+(const Point &amp;, const Point &amp;);</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line">int operator()(int num) &#123;</span><br><span class="line">            return this-&gt;x + this-&gt;y + num;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">int operator[](string str) &#123;</span><br><span class="line">            if (str &#x3D;&#x3D; &quot;x&quot;) return this-&gt;x;</span><br><span class="line">            if (str &#x3D;&#x3D; &quot;y&quot;) return this-&gt;y;</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">Point operator-(const Point &amp;a) &#123;</span><br><span class="line">            Point ret;</span><br><span class="line">            ret.x &#x3D; this-&gt;x - a.x;</span><br><span class="line">            ret.y &#x3D; this-&gt;y - a.y;</span><br><span class="line">            return ret;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回值为＆应为支持连续&lt;&lt;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;out, const Point &amp;a) &#123;</span><br><span class="line">        out &lt;&lt; &quot;&lt;class Point&gt; (&quot; &lt;&lt; a.x &lt;&lt; &quot;, &quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;;</span><br><span class="line">        return out; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类外部</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line"></span><br><span class="line">const 来确定左值右值问题，后边讲</span><br><span class="line">Point operator+(const Point &amp;a, const Point &amp;b) &#123;</span><br><span class="line">        Point ret;</span><br><span class="line">        ret.x &#x3D; a.x + b.y;</span><br><span class="line">        ret.y &#x3D; a.y + b.y;</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h4><p>virtual 关键字不能修饰　static,因为static只跟着类走.<br>virtual　void run(){};<br>指针和引用调用该方法时，虚函数是跟着对象走，谁调用跟谁走.（可以通过等于进行函数传递）<br>普通函数跟着类走的.跟着普通调用者的类型走的.(定义类的类型中的函数是啥输出哈)</p>
<p>父类的相关方法是虚函数，子类继承的方法也是虚函数有无关键字都可.</p>
<h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数:"></a>纯虚函数:</h5><pre><code>virtual void run() = 0;
若果父类中被声明为纯虚函数，子类中必须实现相关方法.相当于接口的作用.</code></pre>
<h5 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h5><p>拥有纯虚函数的类叫抽象类(接口类)</p>
<h5 id="父类的析构函数为啥设置为虚函数"><a href="#父类的析构函数为啥设置为虚函数" class="headerlink" title="父类的析构函数为啥设置为虚函数?"></a>父类的析构函数为啥设置为虚函数?</h5><p>如果父类析构函数在被子类继承后，并且子类定义了相关的类，在析构的时候，这时父类的析构函数为普通成员函数，跟这类走的，所以说只会销毁父类的类，不会销毁相关派生类所产生的类或者说相关内存的开销无法收回.造成内存泄露的问题.</p>
<h3 id="虚函数和this指针"><a href="#虚函数和this指针" class="headerlink" title="虚函数和this指针"></a>虚函数和this指针</h3><p>虚函数：子类可以不用实现，子类在用到该函数会依次往上找.调用父类的实现,<br>纯虚函数; 则必须要实现的.(接口)．一般在子类实现需要加overide,告诉编译器我在覆盖一个父类的虚函数,若果不存在父类的虚函数该关键字可以报错.<br>不加也可以,但是不严谨，出错难找.</p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>成员方法不占用数据存储空间,sizeof表示的是数据空间的占用.<br>一个类对应一个虚函数表，每个对象都指向同一个虚函数表,<br>每个对象的存储区头部会存在一个地址（八个字节）对应着相对应类的虚函数表首地址，虚函数表存在该类相关的虚函数，所以说虚函数跟着类走.</p>
<h3 id="this指针-1"><a href="#this指针-1" class="headerlink" title="this指针"></a>this指针</h3><p>this指针是一个隐藏参数.<br>比如 void buy(int x) -&gt; void buy(void *this, int x);</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> </span><br><span class="line"> class A  &#x2F;&#x2F;大小为4</span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">        int a;</span><br><span class="line">        double b;</span><br><span class="line">         </span><br><span class="line">   &#125;;</span><br><span class="line">   &#x2F;&#x2F;在32位环境下,大小为12，变量a,b共8字节，虚基类表指针4;</span><br><span class="line">   &#x2F;&#x2F;在64位环境下，变量a 4个字节，b 4个字节，虚基类表指针8个字节，为了对齐，大小总共24</span><br><span class="line">    class B :virtual public A  </span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">            int b;</span><br><span class="line">        </span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;与B一样</span><br><span class="line">    class C :virtual public A </span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">            int c;</span><br><span class="line">        </span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;在32位环境下,大小为24,变量a,b,c,d共16，B的虚基类指针4，C的虚基类指针</span><br><span class="line">    class D :public B, public C </span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">            int d;</span><br><span class="line">        </span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">            cout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(C) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(D) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(void *) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">            system(&quot;pause&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>+11提供了一种防止继承发生的方法，即在类名后面跟一个关键字final。</p>
<p>另外，我们也可以在成员函数的后面加final。</p>
<p>如果我们把某个函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">struct A&#123;</span><br><span class="line">        virtual void f1(int) const;</span><br><span class="line">        virtual void f2();</span><br><span class="line">        void f3;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> struct B1 : A &#123;</span><br><span class="line">         void f1(int) const final;    &#x2F;&#x2F;不允许后续的其他类覆盖f1(int)</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line">  </span><br><span class="line">  struct B2 : B1 &#123;</span><br><span class="line">          void f1(int) const;        &#x2F;&#x2F;错误，B1已经将f1()声明成final</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>泛型编程 + 面向过程编程　= 用模板实现函数过程.<br>泛型编程 + 面向对象编程  = 用模板实现类.<br>模板函数<br>template <typename T> 一个抽象出来的类型　为T<br>T Sa(T a, T b){ //相关一样的类型换成T即可.<br>    return  a * b;<br>}<br>模板类<br>类似模板函数</p>
<p>模板的变特化：<br>类似于模板函数：就是比如当Ｔ为int类型需要执行　a * b *c的操作<br>就需要写成<br>template&lt;&gt;<br>int Sa(int a,int b){<br>    return a * b * c;<br>}<br>模板类的特化：</p>
<p>模板的偏特化:<br>就是兼容多种传入类型<br>template <typename T><br>void Sa(T *a, T *b){<br>    cout &lt;&lt; (*a) * (*b);<br>}</p>
<hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">lys-studys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/posts/39788/">http://example.com/posts/39788/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/23469/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">c-3</div></div></a></div><div class="next-post pull-right"><a href="/posts/35949/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">network-of-computer2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/14192/" title="c++(1)"><img class="cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-30</div><div class="title">c++(1)</div></div></a></div><div><a href="/posts/23469/" title="c-3"><img class="cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-11</div><div class="title">c-3</div></div></a></div><div><a href="/posts/39404/" title="c-4"><img class="cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-11</div><div class="title">c-4</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By lys-studys</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我们相遇不是意外~ <a target="_blank" rel="noopener" href="https://lys-studys.github.io//">blog</a>!</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png"/><span>粵ICP備xxxx</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'K6YAjTUpfqvIIJRgat2mpicY-gzGzoHsz',
      appKey: 'TiK1kxcHhW26MWKdEgTtxWlm',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = '';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
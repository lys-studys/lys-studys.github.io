<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>mysql1 | 陌上花开缓缓归</title><meta name="description" content="如果你想拥有你从未有过的东西，那么你必须去做你从未做过的事情。－－－向羽． 数据库底层请看B+树 首先引荐一个挺全的数据库基础知识书写顺序:    select (distinct])    from    join（如left join）    on    where    group by    having    union    order by    limit执行顺序:    from"><meta name="keywords" content="数据库"><meta name="author" content="lys-studys"><meta name="copyright" content="lys-studys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/timg.jpeg"><link rel="canonical" href="http://example.com/posts/15411/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="mysql1"><meta property="og:url" content="http://example.com/posts/15411/"><meta property="og:site_name" content="陌上花开缓缓归"><meta property="og:description" content="如果你想拥有你从未有过的东西，那么你必须去做你从未做过的事情。－－－向羽． 数据库底层请看B+树 首先引荐一个挺全的数据库基础知识书写顺序:    select (distinct])    from    join（如left join）    on    where    group by    having    union    order by    limit执行顺序:    from"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-10-13T02:46:27.000Z"><meta property="article:modified_time" content="2020-10-31T01:04:46.321Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime: 'days',
  date_suffix: {"one_hour":"Just","hours":"hours ago","day":"days ago"},
  copyright: {"limitCount":50,"languages":{"author":"Author: lys-studys","link":"Link: ","source":"Source: 陌上花开缓缓归","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: {"text":"I,LOVE,YOU","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-31 09:04:46'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'true'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="./source/css/background.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="陌上花开缓缓归" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">68</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">26</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.</span> <span class="toc-text">数据库的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">数据库的相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%92%8C%E7%8E%AF%E5%A2%83%E6%9A%82%E6%97%B6%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">数据库相关配置和环境暂时略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">MySQL的常见命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83"><span class="toc-number">5.</span> <span class="toc-text">MySQL的语法规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.</span> <span class="toc-text">MySQL基础表的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.</span> <span class="toc-text">基础查询介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.</span> <span class="toc-text">预操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="toc-number">7.2.</span> <span class="toc-text">查询单个字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5"><span class="toc-number">7.3.</span> <span class="toc-text">查询表中的所有字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%B8%B8%E9%87%8F%E5%80%BC"><span class="toc-number">7.4.</span> <span class="toc-text">查询常量值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.5.</span> <span class="toc-text">查询表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">查询函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B7%E5%88%AB%E5%90%8D"><span class="toc-number">7.7.</span> <span class="toc-text">起别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D"><span class="toc-number">7.8.</span> <span class="toc-text">去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">7.9.</span> <span class="toc-text">+的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">7.10.</span> <span class="toc-text">案例分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.</span> <span class="toc-text">条件查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AD%9B%E9%80%89"><span class="toc-number">8.1.</span> <span class="toc-text">按条件表达式筛选</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AD%9B%E9%80%89"><span class="toc-number">8.2.</span> <span class="toc-text">按逻辑表达式筛选</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.3.</span> <span class="toc-text">模糊查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#like%E4%B8%80%E8%88%AC%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BD%BF%E7%94%A8"><span class="toc-number">8.3.1.</span> <span class="toc-text">like一般和通配符使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#between-and"><span class="toc-number">8.3.2.</span> <span class="toc-text">between and</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#in"><span class="toc-number">8.3.3.</span> <span class="toc-text">in</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#is-NULL"><span class="toc-number">8.3.4.</span> <span class="toc-text">is NULL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.4.</span> <span class="toc-text">排序查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text">常见函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.1.</span> <span class="toc-text">字符函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">8.7.</span> <span class="toc-text">日期函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">8.8.</span> <span class="toc-text">其他函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.9.</span> <span class="toc-text">分组函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">8.9.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#count%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E7%8B%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.9.2.</span> <span class="toc-text">count函数的单独介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.10.</span> <span class="toc-text">分组查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.11.</span> <span class="toc-text">连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sql92%E6%A0%87%E5%87%86"><span class="toc-number">8.11.1.</span> <span class="toc-text">sql92标准</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.11.1.1.</span> <span class="toc-text">等值连接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.11.1.2.</span> <span class="toc-text">非等值连接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.11.1.3.</span> <span class="toc-text">外连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.12.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.13.</span> <span class="toc-text">分页查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.14.</span> <span class="toc-text">联合查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%80%BB%E7%BB%93"><span class="toc-number">8.15.</span> <span class="toc-text">查询总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML%EF%BC%88Data-Manipulation-Language%EF%BC%89%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80"><span class="toc-number">9.</span> <span class="toc-text">DML（Data Manipulation Language）数据操作语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.1.</span> <span class="toc-text">插入语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">表的管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">常见的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%A6%E6%9D%9F"><span class="toc-number">9.4.</span> <span class="toc-text">常见约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E7%BA%A7%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">9.5.</span> <span class="toc-text">列级约束的写法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">表级约束的写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E7%BA%A7%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%86%99%E6%B3%95-1"><span class="toc-number">9.5.2.</span> <span class="toc-text">列级约束的写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%86%99%E6%B3%95-1"><span class="toc-number">9.5.3.</span> <span class="toc-text">表级约束的写法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E5%88%97"><span class="toc-number">9.6.</span> <span class="toc-text">标识列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCL%EF%BC%88Transaction-Control-Language%EF%BC%89%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80"><span class="toc-number">10.</span> <span class="toc-text">TCL（Transaction Control Language）事务控制语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">10.1.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA%E9%83%A8%E9%97%A8%E7%9A%84%E5%B9%B3%E5%9D%87%E5%B7%A5%E8%B5%84"><span class="toc-number">10.1.1.</span> <span class="toc-text">创建视图查看每个部门的平均工资</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">10.1.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%B9%A0%E9%A2%982%E7%9A%84%E8%A7%86%E5%9B%BEmyv2"><span class="toc-number">10.1.3.</span> <span class="toc-text">用习题2的视图myv2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mZ%E6%8F%92%E5%85%A5"><span class="toc-number">10.1.4.</span> <span class="toc-text">mZ插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">10.1.5.</span> <span class="toc-text">修改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">10.1.6.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">10.2.</span> <span class="toc-text">变量</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E9%94%99"><span class="toc-number"></span> <span class="toc-text">报错</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">0.1.</span> <span class="toc-text">存储过程和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">0.1.1.</span> <span class="toc-text">存储过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">0.1.2.</span> <span class="toc-text">函数</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陌上花开缓缓归</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> message</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">mysql1</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-10-13T02:46:27.000Z" title="Created 2020-10-13 10:46:27">2020-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-31T01:04:46.321Z" title="Updated 2020-10-31 09:04:46">2020-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>如果你想拥有你从未有过的东西，那么你必须去做你从未做过的事情。－－－向羽．</p>
<p>数据库底层请看B+树</p>
<p>首先引荐一个挺全的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cainiao-chuanqi/p/11191647.html">数据库基础知识</a><br>书写顺序:<br>    select (distinct])<br>    from<br>    join（如left join）<br>    on<br>    where<br>    group by<br>    having<br>    union<br>    order by<br>    limit<br>执行顺序:<br>    from<br>    on<br>    join<br>    where<br>    group by<br>    having<br>    select<br>    distinct<br>    union<br>    order by </p>
<h3 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h3><ol>
<li>持久化数据库到本地</li>
<li>可以实现结构化查询，方便管理.</li>
</ol>
<h3 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h3><p>DB:</p>
<p>数据库(database); 存储数据的”仓库”，它保存了一系列有组织的数据的容器.</p>
<p>DBMS:</p>
<p>数据库管理系统(database Management System),数据库通过DBMS创建和操作的容器．管理DB中的数据.</p>
<p>SQL:</p>
<p>结构化查询语言(Structure Query Language):专门用于数据库通信的语言.</p>
<p>SQL的优点:<br>    1. 不是某个特定数据库供应商专有的语言，几乎所有的DBMS都支持SQL.<br>    2. 简单<br>    3. 可以进行非常复杂和高级的数据库操作．</p>
<p>数据库存储数据的特点:<br>    1. 将数据放到表中，表再放到库中．<br>    2. 一个数据库有多个表，每个表都有一个名字，用来标识自己，表名具有唯一性．<br>    3. 表具有一些特征，这些特性定义了数据在表中如何存储，类似类的设计．<br>    4. 表由列组成，我们也称为字段，所有表都是由一个或多个列组成，每一列相当于java中的属性.<br>    5. 表中的数据是按行存储的，每一行类似于java中的”对象”．</p>
<h3 id="数据库相关配置和环境暂时略"><a href="#数据库相关配置和环境暂时略" class="headerlink" title="数据库相关配置和环境暂时略"></a>数据库相关配置和环境暂时略</h3><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><ol>
<li><p>查看当前所有的数据库<br>show database;</p>
</li>
<li><p>打开指定的库<br>use 库名</p>
</li>
<li><p>查看当前库的所有表<br>show tables;</p>
</li>
<li><p>查看其库的所有表<br>show tables from 库名;</p>
</li>
<li><p>创建表<br>create table 表名{<br>　　列名　列类型;<br>　　列名　列类型;<br>};</p>
</li>
<li><p>查看表结构<br>desc 表名;</p>
</li>
<li><p>查看服务器的版本</p>
</li>
</ol>
<p>方式一: 登录到mysql服务器<br>select version();<br>方式二:没有登录到mysql服务器</p>
<p>mysql –version/ –V</p>
<h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><ol>
<li>不区分大小写,建议关键字大写表，表名列名小写．</li>
<li>每条命令最好用分号结尾．</li>
<li>每条命令根据需要，可以进行缩进或换行．</li>
<li>注释　<br>单行注释：＃注释文字或者－－空格注释文字．<br>多行注释：/<em>注释文字</em>/</li>
</ol>
<h3 id="MySQL基础表的介绍"><a href="#MySQL基础表的介绍" class="headerlink" title="MySQL基础表的介绍"></a>MySQL基础表的介绍</h3><h3 id="基础查询介绍"><a href="#基础查询介绍" class="headerlink" title="基础查询介绍"></a>基础查询介绍</h3><p>select 查询列表　from 表明;<br>类似java中: System.out.println(打印东西);<br>特点：</p>
<ol>
<li>查询列表可以使：表中的字段，常量值，表达式，函数.</li>
<li>查询的结果是一个虚拟的表格.<h4 id="预操作"><a href="#预操作" class="headerlink" title="预操作"></a>预操作</h4>建议在查询操作之前添加所操作的库．<br>use myemployess;<br>类似C++的作用域;</li>
</ol>
<p>#``(着重号)<br>用来区分是关键字和字段,不添加也可以.</p>
<h4 id="查询单个字段"><a href="#查询单个字段" class="headerlink" title="查询单个字段"></a>查询单个字段</h4><p>select lastname from employess;</p>
<p>查询表中的多个字段<br>注意：最后没有逗号，顺序跟原来的表格可以不同.<br>select lastname,salary,email from employess;</p>
<h4 id="查询表中的所有字段"><a href="#查询表中的所有字段" class="headerlink" title="查询表中的所有字段"></a>查询表中的所有字段</h4><p>方式一．<br>select 可以双击点击表中的字段 from employess;</p>
<p>或者</p>
<p>方式二<br>#select (*) from employess;</p>
<h4 id="查询常量值"><a href="#查询常量值" class="headerlink" title="查询常量值"></a>查询常量值</h4><p>select 100;</p>
<p>查询字符字符串一个形式．<br>select ‘john’;</p>
<h4 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h4><p>直接返回的是结果.<br>select 100*99;</p>
<h4 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h4><p>调用该函数，显示返回值．<br>select version();</p>
<h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><ol>
<li>起别名容易读取，易读．</li>
<li>如果要查询的字段有重名的情况，可用别名可以区分开来．</li>
</ol>
<p>方式一：<br>select 100 * 98 as 结果；</p>
<p>罗列出来的表，列属性的名字直接替换为姓．<br>select lastname as 姓，firstname as 名 from employess;</p>
<p>方式二：</p>
<p>直接把as省略掉.<br>select lastname 姓，firstname 名 from employess;</p>
<p>例如：查询salary,显示结果为out put</p>
<p>取别名的时候，如果有特殊字符如空格，就加上双引号或者单引号．<br>select salary as “out put” from employess;</p>
<h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>案例：查询员工表中涉及到的所有的部门编号．</p>
<p>去重关键字: distinct.</p>
<p>select distinct departmentid from employess;</p>
<h4 id="的作用域"><a href="#的作用域" class="headerlink" title="+的作用域"></a>+的作用域</h4><p>java 中:</p>
<ol>
<li>运算符，表示操作数都是数值型．</li>
<li>连接符，只要有一个操作数为字符串．</li>
</ol>
<p>MySQL中的加号:<br>    只有一个功能：运算符，</p>
<ol>
<li> 两个操作室都是数值型，就做加法运算．</li>
<li> 其中一方为字符型，就将字符型转换为数值型，如果转换成功就做加法运算．转换失败就将字符型转换为0;接着拿0和后边数进行加法运算.</li>
<li>其中一方为NULL,则结果就为NULL;</li>
</ol>
<p>案例：查询员工名和姓连接成一个字段，并显示为姓名．</p>
<p>这个样子是不对的．<br>select lastname + firstname as 姓名<br>from  employess; </p>
<p>改正样子:<br>    concat表示字符串链接功能，相当于一列和另一列结合．然后属性取了别名．<br>　　select concat(‘lastname’,’firstname’) as 姓名<br>　　from employess;</p>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>案例：显示表departments的结构，并查询其中的全部数据.<br>关键字　desc;<br>desc departments;<br>select * from departments;</p>
<p>显示出表employess中的全部job_id(不重复)<br>select distinct job_id from employess;</p>
<p>显示出表employess的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</p>
<p>第一部分表示如果lastname 如果为NULL，就显示成0,改名为奖金率<br>所以选出了两列，一个是更名的，一个是没有更名的．</p>
<p>select IFNILL(lastname, 0) as 奖金率,<br>       lastname<br>from<br>       employess;</p>
<p>select<br>       concat(firstname,’,’,lastname) as OUT_PUT<br>from<br>       employess;</p>
<p>改正后　：</p>
<p>select<br>       concat(firstname,’,’,IFNILL(lastname,0))<br>from<br>       employess;</p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>where 相当于 if.</p>
<p>语法：<br>select<br>　　　　查询列表<br>from<br>　　　　表名<br>where<br>　　　　筛选条件;</p>
<p>语法执行顺序:</p>
<ol>
<li>表名．</li>
<li>筛选条件．</li>
<li>查询列表．</li>
</ol>
<p>分类：</p>
<ol>
<li><p>按条件表达式筛选<br>条件运算符:&gt;,&lt;,=(类似==),&lt;&gt;(类似!=),&gt;=,&lt;=.</p>
</li>
<li><p>按逻辑表达式筛选</p>
</li>
</ol>
<p>java中：逻辑运算符: &amp;&amp;, \,!(与,或,非)<br>MySQL: and, or, not.</p>
<p>3.模糊查询</p>
<ol>
<li>like </li>
<li>between</li>
<li>in</li>
<li>is null</li>
</ol>
<h4 id="按条件表达式筛选"><a href="#按条件表达式筛选" class="headerlink" title="按条件表达式筛选"></a>按条件表达式筛选</h4><p>案例一: 查询工资&gt;12000的员工信息．<br>select  *<br>from employess<br>where salary &gt; 12000;</p>
<p>案例二: 查询部门编号不等于90号的员工名和部门编号.<br>的后边是谁select后边就是谁.</p>
<p>select lastname, departmentid<br>from employess<br>where departmentid ＜＞90;<br>或者　前者建议使用<br>where departmentid != 90;</p>
<h4 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h4><p>案例一：查询工资在10000到20000之间的员工名，工资以及奖金.</p>
<p>select lastname,salary,commissionpct<br>from employess<br>where salary&gt;=10000<br>and salary＜＝20000</p>
<p>案例二:查询部门编号不是在90到110间,或者工资高于15000的员工信息</p>
<p>select *<br>from employess</p>
<p>where not(departmentid＞＝90 and departmentid＜＝110) or salary&gt;15000;<br>或者<br>where departmentid&lt;90 or departmentid&gt;110 or salary&gt;15000;</p>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><h5 id="like一般和通配符使用"><a href="#like一般和通配符使用" class="headerlink" title="like一般和通配符使用"></a>like一般和通配符使用</h5><p>通配符:<br>    %表示任意多个字符包含零个字符<br>    _表示任意单个字符<br>    表示通配符的时候用\进行转义.</p>
<p>案例一: 查询员工名中包含字符的员工信息<br>like前字符型的值必须加单引号.<br>%表示通配符，若干个．<br>select * from employess where lastname like ‘%a% ‘</p>
<p>案例二:查询员工名中第三个字符为e,第五个字符为a的员工名和工资．<br>select lastname,salary from employess where lastname like ‘__e_a%’;</p>
<p>案例三：查询员工名中第二个字符为（下划线）的员工名．注释：没办法打出来．<br>用转义<br>select lastname from employess where lastname like ‘<em>\</em>%’;<br>_<br>定义转义符号<br>重新弄个符号定义为转义符，关键字　escape.<br>select lastname from employess where lastname like ‘<em>$</em>%’ escape ‘$’;</p>
<h5 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h5><ol>
<li>使用between and 可以提高语句的简洁度．</li>
<li>包含临界值</li>
<li>两个值不可以交换顺序．</li>
</ol>
<p>案例一: 查询员工编号在100到120之间的所有员工信息．</p>
<p>select * from employess </p>
<p>where employessid &gt;= 100 and employess_id &lt;= 120;<br>或者<br>where employessid between 100 and 120;<br>完全等价以　&gt;= 和　&lt;= </p>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>判断某字段的值是否属于in列表中的某一项</p>
<ol>
<li>使用in提高语句的简洁渡.</li>
<li>in列表中的类型必须一致或者兼容．(‘123’) 和123 ，’123’可以转换成123.</li>
<li>in的列表不能是省略的形式，比如%12%这样的.</li>
</ol>
<p>案例:查询员工的工种编号 IT_PROG,AD_VP,AD_PRES中的一个员工和工种编号．<br>select<br>      lastname,<br>      job_id<br>from </p>
<p>job_id = ‘IT_PROG’ or job_id = ‘AD_VP’ or job_id = ‘AD_PRES’;<br>或者<br>job_id in(‘IT_PROG’,’AD_VP’,’AD_PRES’);</p>
<h5 id="is-NULL"><a href="#is-NULL" class="headerlink" title="is NULL"></a>is NULL</h5><ol>
<li>=或&lt;&gt;不能用于判断NULL值<br>is null 或　is not null 可以判断NULL值.</li>
</ol>
<p>实例: 查询没有奖金的员工名和奖金率．<br>select lastname,<br>       commissionpct<br>from   employess</p>
<p>where commissionpct = NULL; 注意＝不能判断NULL;<br>改正<br>where commissionpct is NULL;<br>如果是有奖金<br>where commissionpct is not NULL;</p>
<p>安全等于 &lt;=&gt; 即可判断NULL 也可判断普通值.</p>
<p>面试题:<br>访问select * from employess 和<br>select * from employess where commissionpct like ‘%%’ and lastname like ‘%%’;<br>有什么不同，说明原因.<br>答案：<br>是不一样，<br>如果判断的字段有null值的化，第二种情况就不对了，第二种%表示有不表示空．</p>
<p>改正，前提如果两个属性对应的位置不存在全为NULL 的情况就可以下边方式更改．<br>select * from employess where commissionpct like ‘%%’ 或 lastname like ‘%%’;</p>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法:</p>
<ol>
<li>select 查询列表</li>
<li>from 表</li>
<li>[where 筛选条件]</li>
<li>order by 排序列表　asc\desc (升序或降序)</li>
</ol>
<p>执行顺序2,3,1,4</p>
<ol>
<li>asc代表是升序，desc 代表降序，若果不写默认是升序．</li>
<li>order by 子句中可以支持单个字段，多个字段，表达式，函数别名．</li>
<li>order by 子句一般放在查询语句的最后．limit子句更为靠后,</li>
</ol>
<p>案例一:查询员工信息，要求工资从高到低排序<br>select * from employess order by salary desc;<br>select * from employess order by salary ;　//升序</p>
<p>案例二:查询部门编号&gt;= 90的员工信息，按入职时间的先后进行．(添加筛选条件)<br>select * from employess where dapartment_id &gt;= 90 order by hiredata asc;</p>
<p>案例三: 按年薪的高低显示员工的信息和年薪［按表达式排序］<br>select *,salary * 12 *(1 + IFNILL(commissionpct, 0)) 年薪<br>from employess<br>order by salary * 12 *(1 + IFNILL(commissionpct, 0)) desc；</p>
<p>案例四: 按年薪的高低显示员工的信息和年薪［按别名排序］</p>
<p>select *, salary * 12 * (1 + IFNILL(commissionpct, 0)) 年薪<br>from employess<br>order by 年薪　desc;</p>
<p>案例四：　按姓名的长度来显示员工的姓名和工资［按函数排序］<br>select LENGTH(“john”);  //LENGTH 表示输出长度的函数　</p>
<p>答案:</p>
<p>select LENGTH (lastname) 字节长度，lastname,salary<br>from employess<br>order by LENGTH(lastname) desc;</p>
<p>案例六：查询员工信息，要求按工资升序排序，再按员工编号降序排序[按多个字段排序]</p>
<p>select * from employess order by salary asc, employess_id desc;</p>
<p>解释: 就是先按照工资排序，工资一样按员工编号排序．</p>
<h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><p>概念: 类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名<br>好处: </p>
<ol>
<li>隐藏了实现细节．</li>
<li>提高了代码的重用性．</li>
</ol>
<p>调用: select 函数名（实参列表）［from 表］；　［中若有from表就写若没有就不写］</p>
<p>特点:<br>    1. 函数名字<br>    2. 函数功能</p>
<p>分类:<br>    1. 单行函数<br>    如: concat, length, IFNILL等<br>    2. 分组函数<br>    功能:做统计使用.又称为统计函数，聚合函数，组函数．</p>
<h5 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h5><p>额外的知识:<br>    utf8 字符占用一个字节<br>    汉字三个字节<br>    ｊｄｋ汉字是两个字节．</p>
<ol>
<li><p>length函数获取参数的字节个数．<br>select LENGTH(‘john’); 返回4<br>select LENGTH(‘哈哈哈’)；　utf8为9.</p>
</li>
<li><p>concat拼接字符</p>
</li>
</ol>
<p>select concat(lastname,’__’,firstname) from employess;<br>_为中间字符进行了拼接.<br>3. upper,lower<br>大小写变换<br>select upper(‘john’);<br>select lower(‘john’);</p>
<p>示例: 将姓变大写，名变小写，然后拼接．<br>select concat(upper(lastname),lower(firstname)) 名字　from employess;</p>
<ol start="4">
<li>substr,substring .<br>注意；索引从１开始<br>返回陆展元<br>select substr(‘李莫愁爱上陆展元’,7) OUT_PUT;截取从⑦开始的所有字符</li>
</ol>
<p>返回李莫愁；</p>
<p>select substr(‘李莫愁爱上陆展元’,1, 3) OUT_PUT;截取开始位置及长度．</p>
<p>案例:姓名中的首字符大写，然后用下划线进行链接．<br>select concat(upper(substr(lastname, 1, 1)),’_ ‘,lower(substr(lastname, 2))) from employess;<br>_</p>
<ol start="5">
<li>instr</li>
</ol>
<p>instr(‘杨不悔爱上了殷六侠’，＇殷六侠＇) as OUT_PUT ；//返回子串在父串中首次出现的的下标索引值．如果没有即为０．</p>
<ol start="6">
<li>trim</li>
</ol>
<p>select LENGTH(trim(‘    张翠山　　　‘)) as OUT_PUT;</p>
<p>去掉前后空格，不去中间．</p>
<p>select trim(‘a’ from ‘aaaa蛋蛋aaaa蛋蛋aaaa’) as OUT_PUT;</p>
<p>输出蛋蛋aaaa蛋蛋．</p>
<ol start="7">
<li>lpad 用指定的字符实现左填充指定长度．超了就截取．</li>
</ol>
<p>select lpad (‘殷素素’,10,’*’) as OUT_PUT;</p>
<p>不够十个左边用*填充;</p>
<p>8.rpad 用指定的字符实现右填充指定长度</p>
<ol start="9">
<li>replace(‘张无忌爱上周芷若’，’周芷若’，’赵敏’)　as OUT_PUT;<br>周芷若替换成赵敏.全部替换</li>
</ol>
<h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><ol>
<li>round 四舍五入<br>select round(-1.55); //绝对值进行四舍五入然后加上符号．<br>select round(1.567,2); 小数点后两位．</li>
</ol>
<ol start="2">
<li>ceil 向上取整向上返回&gt;=该参数的最小整数</li>
</ol>
<p>select ceil (1,00);</p>
<ol start="3">
<li><p>floar向下取整,返回&lt;= 该参数的最大整数.<br>select floar(-9.99); -9</p>
</li>
<li><p>truncate 截断<br>select truncate (1.6999999,1);<br>小数点后一位.</p>
</li>
</ol>
<ol start="5">
<li>mod取余<br>mod (a, b) : a - a/b * b;<br>正负数带入就好.<br>select mod (10 ,-3)</li>
</ol>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>now：返回当前系统日期+时间</p>
<p>curdate：返回当前系统日期，不包含时间</p>
<p>curtime：返回当前时间，不包含日期</p>
<p>可以获取指定的部分，年、月、日、小时、分钟、秒</p>
<p>SELECT<br>  YEAR(hiredate) 年<br>FROM<br>    employees ;</p>
<p>str_to_date：将日期格式的字符转换成指定格式的日期</p>
<p>  SELECT<br>    STR_TO_DATE(‘1998-3-2’, ‘%Y-%c-%d’) AS output ;</p>
<p>  查询入职日期为1992-4-3的员工信息</p>
<p>  SELECT<br>    *<br>    FROM<br>      employees<br>      WHERE hiredate = STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’) ;</p>
<p>date_format：将日期转换成字符串</p>
<p>SELECT<br>  DATE_FORMAT(NOW(), ‘%y年%m月%d日)’) AS output ;<br>  查询有奖金的员工名和入职日期（xx月/xx日 xx年）</p>
<p>  SELECT<br>    last_name,<br>      DATE_FORMAT(hiredate, ‘%m月/%d日 %y年’) AS 入职日期<br>      FROM<br>        employees<br>        WHERE commission_pct IS NOT NULL ;<br>        datediff：返回两个日期相差的天数</p>
<pre><code>    monthname：以英文形式返回月</code></pre>
<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>SELECT VERSION();<br>当前数据库服务器的版本<br>SELECT DATABASE();<br>当前打开的数据库<br>SELECT USER();</p>
<p>当前用户<br>password(‘字符’);<br>流程控制函数</p>
<p>if函数：if else的效果</p>
<p>SELECT<br>  last_name,<br>  commission_pct,<br>  IF(<br>    commission_pct IS NULL,<br>    ‘没奖金，呵呵’,<br>    ‘有奖金，嘻嘻’<br>  ) 备注<br>FROM<br>  employees ;</p>
<p>case函数的使用1：switch case的效果</p>
<p>语法：</p>
<p>case 要判断的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量2 then 要显示的值2或语句2;<br>…<br>else 要显示的值n或语句n;<br>end</p>
<p>查询员工的工资，要求：</p>
<p>部门号=30，显示的工资为1.1倍</p>
<p>部门号=40，显示的工资为1.2倍</p>
<p>部门号=50，显示的工资为1.3倍</p>
<p>其他部门，显示的工资为原工资</p>
<p>SELECT<br>  salary AS 原始工资,<br>  department_id,<br>  CASE<br>    department_id<br>    WHEN 30<br>    THEN salary * 1.1<br>    WHEN 40<br>    THEN salary * 1.2<br>    WHEN 50<br>    THEN salary * 1.3<br>    ELSE salary<br>  END AS 新工资<br>FROM<br>  employees ;</p>
<p>case函数的使用2：类似于多重if</p>
<p>case<br>when 条件1 then 要显示的值1或语句1<br>when 条件2 then 要显示的值2或语句2<br>…<br>else 要显示的值n或语句n<br>end</p>
<p>查询员工的工资情况</p>
<p>如果工资&gt;20000，显示A级别</p>
<p>如果工资&gt;15000，显示B级别</p>
<p>如果工资&gt;10000，显示C级别</p>
<p>否则，显示D级别</p>
<p>SELECT<br>  salary,<br>  CASE<br>    WHEN salary &gt; 20000<br>    THEN ‘A’<br>    WHEN salary &gt; 15000<br>    THEN ‘B’<br>    WHEN salary &gt; 10000<br>    THEN ‘C’<br>    ELSE ‘D’<br>  END AS 工资级别<br>FROM<br>  employees ;</p>
<p>测试题</p>
<p>显示系统时间（日期+时间）</p>
<p>SELECT NOW();<br>1<br>查询员工号，姓名，工资，以及工资提高20%后的结果（new salary）</p>
<p>SELECT<br>  employee_id,<br>  last_name,<br>  salary,<br>  salary * 1.2 AS “new salary”<br>FROM<br>  employees ;</p>
<p>将员工的姓名按首字母排序，并写出姓名的长度（length）</p>
<p>SELECT<br>  last_name,<br>  LENGTH(last_name)<br>FROM<br>  employees<br>ORDER BY SUBSTR(last_name, 1, 1) ;</p>
<p>做一个查询</p>
<p>SELECT<br>  CONCAT(<br>    last_name,<br>    ‘ earns ‘,<br>    salary,<br>    ‘ monthly but wants ‘,<br>    salary * 3<br>  ) AS “Dream Salary”<br>FROM<br>  employees ;</p>
<p>case-when训练</p>
<p>SELECT<br>  last_name,<br>  job_id AS job,<br>  CASE<br>    job_id<br>    WHEN ‘AD_PRES’<br>    THEN ‘A’<br>    WHEN ‘ST_MAN’<br>    THEN ‘B’<br>    WHEN ‘IT_PROG’<br>    THEN ‘C’<br>    WHEN ‘SA_PRE’<br>    THEN ‘D’<br>    WHEN ‘ST_CLERK’<br>    THEN ‘E’<br>  END AS Grade<br>FROM<br>  employees<br>WHERE job_id = ‘AD_PRES’ ;</p>
<h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><p>功能：用作统计使用，又称为聚合函数或统计函数或组函数</p>
<p>分类：sum 求和、avg 平均值、max 最大值、min 最小值、count 计数（非空）</p>
<p>SELECT SUM(salary) FROM employees;</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>sum、avg一般用于处理数值型数据</li>
<li>max、min、count可以处理任何类型数据</li>
<li>以上分组函数都忽略null值</li>
<li>可以和distinct搭配实现去重的运算</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39729527/article/details/82377925">count</a><br>_<br>SELECT<br>  SUM(DISTINCT salary),<br>  SUM(salary)<br>FROM<br>  employees ;</p>
<p>SELECT<br>  COUNT(DISTINCT salary),<br>  COUNT(salary)<br>FROM<br>  employees ;</p>
<h5 id="count函数的单独介绍"><a href="#count函数的单独介绍" class="headerlink" title="count函数的单独介绍"></a>count函数的单独介绍</h5><p>效率</p>
<p>MYISAM存储引擎下，count(<em>)的效率高<br>INNODB存储引擎下，count(</em>)和count(1)效率差不多，比count(字段)要高一些<br>使用count(*) 统计一共有多少行</p>
<p>SELECT COUNT(salary) FROM employees;<br>SELECT COUNT(*) FROM employees;//对行数进行统计<br>SELECT COUNT(1) FROM employees;//  对表中第一列的值的函数进行计算，忽略countNULL列.</p>
<p>count(列名字)对表中特定的列的值的行数进行计算，不包括null;</p>
<ol start="5">
<li>和分组函数一同查询的字段有限制，要求是group by后的字段</li>
</ol>
<p>训练题</p>
<p>查询公司员工工资的最大值，最小值，平均值，总和</p>
<p>SELECT<br>  MAX(salary),<br>  MIN(salary),<br>  AVG(salary),<br>  SUM(salary)<br>FROM<br>  employees ;</p>
<p>查询员工表中的最大入职时间和最小入职时间的相差天数（difference）</p>
<p>SELECT<br>  DATEDIFF(MAX(hiredate), MIN(hiredate)) DIFFERENCE<br>FROM<br>  employees ;</p>
<p>查询部门编号为90的员工个数</p>
<p>SELECT<br>  COUNT(*)<br>FROM<br>  employees<br>WHERE department_id = 90 ;</p>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>select 分组函数，列（要求出现在group by的后面）</p>
<p>from 表</p>
<p>【where 筛选条件】</p>
<p>group by 分组的列表</p>
<p>【having 分组后的筛选】</p>
<p>【order by 子句】</p>
<p>注意：查询列表比较特殊，要求是分组函数和group by后出现的字段</p>
<p>特点：</p>
<p>分组查询中的筛选条件分为两类：<br>　　　　　　数据源 　　　　位置 　　　　　　　　关键字</p>
<p>分组前筛选 原始表 　　group by子句的前面 　　　　where</p>
<p>分组后筛选 分组后的结果集 group by子句的后面 　　having</p>
<p>分组函数做条件肯定是放在having子句中</p>
<p>能用分组前筛选的，就优先考虑使用分组前筛选</p>
<p>group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开没有顺序要求），表达式或函数（用得较少）</p>
<p>也可以添加排序（排序放在整个分组查询最后位置）</p>
<p>查询每个工种的最高工资</p>
<p>SELECT<br>  MAX(salary),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id ;</p>
<p>查询每个位置上的部门个数</p>
<p>SELECT<br>  COUNT(*),<br>  location_id<br>FROM<br>  departments<br>GROUP BY location_id ;</p>
<p>查询邮箱中包含a字符的，每个部门的平均工资</p>
<p>SELECT<br>  AVG(salary),<br>  department_id<br>FROM<br>  employees<br>WHERE email LIKE ‘%a%’<br>GROUP BY department_id ;</p>
<p>查询有奖金的每个领导手下员工的最高工资</p>
<p>SELECT<br>  MAX(salary),<br>  manager_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY manager_id ;</p>
<p>查询那个部门的员工个数&gt;2</p>
<p>查询每个部门的员工个数</p>
<p>SELECT<br>  COUNT(*) AS 员工个数,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id ;</p>
<p>根据上面的结果进行筛选，查询哪个部门的员工个数＞2</p>
<p>SELECT<br>  COUNT(*) AS 员工个数,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING 员工个数 &gt; 2 ;</p>
<p>添加分组后的筛选用having，分组前的用where</p>
<p>查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p>
<ol>
<li>查询每个工种有奖金的员工的最高工资</li>
</ol>
<p>SELECT<br>  MAX(salary),<br>  job_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id ;</p>
<ol start="2">
<li>根据上面的结果继续筛选，最高工资&gt;12000</li>
</ol>
<p>SELECT<br>  MAX(salary) AS 最高工资,<br>  job_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING 最高工资 &gt; 12000 ;</p>
<p>查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及其最低工资</p>
<p>SELECT<br>  MIN(salary) AS 最低工资,<br>  manager_id<br>FROM<br>  employees<br>WHERE manager_id &gt; 102<br>GROUP BY manager_id<br>HAVING 最低工资 &gt; 5000 ;</p>
<p>按表达式或函数分组</p>
<p>按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些</p>
<ol>
<li>查询每个长度的员工个数</li>
</ol>
<p>SELECT<br>  COUNT(*) 员工个数,<br>  LENGTH(last_name) 姓名长度<br>FROM<br>  employees<br>GROUP BY 姓名长度 ;</p>
<ol start="2">
<li>添加筛选条件</li>
</ol>
<p>SELECT<br>  COUNT(*) 员工个数,<br>  LENGTH(last_name) 姓名长度<br>FROM<br>  employees<br>GROUP BY 姓名长度<br>HAVING 员工个数 &gt; 5 ;</p>
<ol start="3">
<li>按多个字段分组</li>
</ol>
<p>查询每个部门每个工种的员工的平均工资</p>
<p>SELECT<br>  AVG(salary),<br>  department_id,<br>  job_id<br>FROM<br>  employees<br>GROUP BY department_id,<br>  job_id ;//这两个一样才能划分为一组.</p>
<p>添加排序</p>
<p>查询每个部门每个工种的员工的平均工资，并按平均工资的高低显示</p>
<p>SELECT<br>  AVG(salary) AS 平均工资,<br>  department_id,<br>  job_id<br>FROM<br>  employees<br>GROUP BY department_id,<br>  job_id<br>ORDER BY 平均工资 DESC ;</p>
<p>练习题</p>
<p>查询各job_id的员工工资的最大值、最小值、平均值，总和，并按job_id升序</p>
<p>SELECT<br>  MAX(salary),<br>  MIN(salary),<br>  AVG(salary),<br>  SUM(salary),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id<br>ORDER BY job_id ;</p>
<p>查询员工最高工资和最低工资的差距（DIFFERENCE）</p>
<p>SELECT<br>  MAX(salary) - MIN(salary) AS DIFFERENCE<br>FROM<br>  employees ;</p>
<p>查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</p>
<p>SELECT<br>  MIN(salary) AS 最低工资<br>FROM<br>  employees<br>WHERE manager_id IS NOT NULL<br>GROUP BY manager_id<br>HAVING 最低工资 &gt;= 6000 ;</p>
<p>查询所有部门的编号，员工数量和工资平均值，并按平均工资降序</p>
<p>SELECT<br>  department_id,<br>  COUNT(*) AS 员工数量,<br>  AVG(salary) AS 工资平均值<br>FROM<br>  employees<br>GROUP BY department_id<br>ORDER BY 工资平均值 DESC ;</p>
<p>查询具有各个job_id的员工人数</p>
<p>SELECT<br>  COUNT(*),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id ;</p>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p>
<p>笛卡尔乘积现象：表1有m行，表2有n行，结果=m*n</p>
<p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件<br>分类：</p>
<p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接<br>按功能分类：<br>内连接:<br>  等值连接<br>  非等值连接<br>  自连接<br>外连接:<br>  左外连接<br>  右外连接<br>  全外连接（mysql不支持）<br>交叉连接:</p>
<h5 id="sql92标准"><a href="#sql92标准" class="headerlink" title="sql92标准"></a>sql92标准</h5><h6 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h6><p>多表等值连接的结果为多表的交集部分</p>
<p>n表连接，至少需要n-1个连接条件</p>
<p>多表的顺序没有要求</p>
<p>一般需要为表起别名</p>
<p>可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p>
<p>查询女神名和对应的男神名：</p>
<p>SELECT<br>  NAME,<br>  boyname<br>FROM<br>  boys,<br>  beauty<br>WHERE beauty.boyfriend_id = boys.id ;</p>
<p>查询员工名和对应的部门名</p>
<p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees,<br>  departments<br>WHERE employees.<code>department_id</code> = departments.<code>department_id</code> ;</p>
<p>为表起别名</p>
<p>提高语句的简洁度</p>
<p>区分多个重名的字段</p>
<p>注意：如果为表起了别名，则查询 的字段就不能使用原始的表明去限定</p>
<p>查询员工名、工种号、工种名</p>
<p>SELECT<br>  last_name,<br>  e.<code>job_id</code>,<br>  job_title<br>FROM<br>  employees e,<br>  jobs j<br>WHERE e.<code>job_id</code> = j.<code>job_id</code> ;</p>
<p>两个表的顺序是否可以调换</p>
<p>查询员工名、工种号、工种名</p>
<p>SELECT<br>  last_name,<br>  e.<code>job_id</code>,<br>  job_title<br>FROM<br>  jobs j ,<br>  employees e<br>WHERE e.<code>job_id</code> = j.<code>job_id</code> ;</p>
<p>可以加筛选</p>
<p>查询有奖金的员工名、部门名</p>
<p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees AS e,<br>  departments AS d<br>WHERE e.<code>department_id</code> = d.<code>department_id</code><br>  AND e.<code>commission_pct</code> IS NOT NULL ;</p>
<p>查询城市名中第二个字符为o的部门名和城市名</p>
<p>SELECT<br>  department_name,<br>  city<br>FROM<br>  departments d,<br>  locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>  AND city LIKE ‘_o%’ ;</p>
<p>可以加分组</p>
<p>查询每个城市的部门个数</p>
<p>SELECT<br>  COUNT(*) 个数,<br>  city<br>FROM<br>  departments d,<br>  locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>GROUP BY city ;</p>
<p>查询有将近的每个部门的部门名和部门的领导编号和该部门的最低工资</p>
<p>SELECT<br>  department_name,<br>  d.manager_id,<br>  MIN(salary)<br>FROM<br>  departments d,<br>  employees e<br>WHERE d.<code>department_id</code> = e.<code>department_id</code><br>  AND commission_pct IS NOT NULL<br>GROUP BY department_name,<br>  d.manager_id ;</p>
<p>可以加排序</p>
<p>查询每个工种的工种名和员工的个数，并且按员工个数降序</p>
<p>SELECT<br>  job_title,<br>  COUNT(*) AS 个数<br>FROM<br>  employees e,<br>  jobs j<br>WHERE e.<code>job_id</code> = j.<code>job_id</code><br>GROUP BY job_title<br>ORDER BY 个数 DESC ;</p>
<p>可是实现三表连接：</p>
<p>查询员工名、部门名和所在的城市</p>
<p>SELECT<br>  last_name,<br>  department_name,<br>  city<br>FROM<br>  employees e,<br>  departments d,<br>  locations l<br>WHERE e.<code>department_id</code> = d.<code>department_id</code><br>  AND d.<code>location_id</code> = l.<code>location_id</code> ;</p>
<h6 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h6><p>查询员工的工资和工资级别</p>
<p>SELECT<br>  salary,<br>  grade_level<br>FROM<br>  employees e,<br>  job_grades g<br>WHERE salary BETWEEN g.lowest_sal<br>  AND g.highest_sal ;</p>
<p>自连接</p>
<p>查询 员工名和上级的名称</p>
<p>SELECT<br>  e.employee_id,<br>  e.last_name,<br>  m.employee_id,<br>  m.last_name<br>FROM<br>  employees e,<br>  employees m<br>WHERE e.<code>manager_id</code> = m.<code>employee_id</code> ;</p>
<p>测试题：</p>
<p>显示员工表的最大工资，工资平均值</p>
<p>SELECT<br>  MAX(salary),<br>  AVG(salary)<br>FROM<br>  employees ;</p>
<p>查询员工表的employee_id，job_id，last_name，按department_id降序，salary升序</p>
<p>SELECT<br>  employee_id,<br>  job_id,<br>  last_name<br>FROM<br>  employees<br>ORDER BY department_id DESC,<br>  salary ASC ;</p>
<p>查询员工表的job_id中包含a和e的，并且a在e的前面</p>
<p>SELECT<br>  job_id<br>FROM<br>  employees<br>WHERE job_id LIKE ‘%a%e%’ ;</p>
<p>显示当前日期，以及去前后空格，截取子字符串的函数</p>
<p>select now();<br>select trim();<br>select substr(str, startIndex, [length])</p>
<p>sql99语法</p>
<p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名 【连接类型】</p>
<p>join 表2 别名</p>
<p>on 连接条件</p>
<p>【where 筛选条件】</p>
<p>【group by 分组】</p>
<p>【having 筛选条件】</p>
<p>【order by 排序列表】</p>
<p>内连接（同上）：连接类型是inner</p>
<h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><p>左外：left 【outer】<br>右外：right【outer】<br>全外：full 【outer】<br>交叉连接：cross</p>
<p>内连接：</p>
<p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名</p>
<p>inner join 表2 别名</p>
<p>on 连接条件</p>
<p>…</p>
<p>分类：</p>
<p>等值连接</p>
<p>非等值连接</p>
<p>自连接</p>
<p>特点：</p>
<p>添加排序、分组、筛选<br>inner可以省略<br>筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p>
<ol>
<li>等值连接：</li>
</ol>
<p>查询员工名、部门名</p>
<p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees e<br>  INNER JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code> ;</p>
<p>查询名字中包含e的给员工名和工种名</p>
<p>SELECT<br>  last_name,<br>  job_title<br>FROM<br>  employees e<br>  INNER JOIN jobs j<br>    ON e.<code>job_id</code> = j.<code>job_id</code><br>WHERE last_name LIKE “%e%” ;</p>
<p>查询部门个数&gt;3的城市名和部门个数</p>
<p>SELECT<br>  city,<br>  COUNT(*) 部门个数<br>FROM<br>  departments d<br>  INNER JOIN locations l<br>    ON d.<code>location_id</code> = l.<code>location_id</code><br>GROUP BY city<br>HAVING 部门个数 &gt; 3 ;</p>
<p>查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按个数降序排序</p>
<p>SELECT<br>  department_name,<br>  COUNT(*) 员工个数<br>FROM<br>  departments d<br>  INNER JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>GROUP BY d.<code>department_id</code><br>HAVING 员工个数 &gt; 3<br>ORDER BY 员工个数 DESC ;</p>
<p>查询员工名、部门名、工种名，并按部门名降序.三表连接（有连接条件能连就可以）<br>SELECT<br>  last_name,<br>  department_name,<br>  job_title<br>FROM<br>  employees e<br>  INNER JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code><br>  INNER JOIN jobs j<br>    ON e.<code>job_id</code> = j.<code>job_id</code><br>ORDER BY d.<code>department_id</code> DESC ;</p>
<p>2, 非等值连接</p>
<p>查询员工的工资级别</p>
<p>SELECT<br>  salary,<br>  grade_level<br>FROM<br>  employees e<br>  INNER JOIN job_grades g<br>    ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p>
<p>查询每个工资级别&gt;20的个数，并且按工资级别降序</p>
<p>SELECT<br>  COUNT(<em>),<br>  grade_level<br>FROM<br>  employees e<br>  INNER JOIN job_grades g<br>    ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code><br>GROUP BY grade_level<br>HAVING COUNT(</em>) &gt; 20<br>ORDER BY grade_level DESC ;</p>
<ol start="3">
<li>自连接</li>
</ol>
<p>把一张表当成两张表使用.</p>
<p>查询员工的名字、上级的名字</p>
<p>SELECT<br>  e.last_name,<br>  m.last_name<br>FROM<br>  employees e<br>  INNER JOIN employees m<br>    ON e.<code>manager_id</code> = m.<code>employee_id</code> ;</p>
<p>查询姓名中包含字符k的员工的名字、上级的名字</p>
<p>SELECT<br>  e.last_name,<br>  m.last_name<br>FROM<br>  employees e<br>  INNER JOIN employees m<br>    ON e.<code>manager_id</code> = m.<code>employee_id</code><br>WHERE e.<code>last_name</code> LIKE “%k%” ;</p>
<p>外连接</p>
<p>应用场景：用于查询一个表中有，另一个表没有的记录</p>
<p>特点：</p>
<p>外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的，则显示匹配的值，如果从表中没有和它匹配的，则显示null<br>外连接查询结果=内连接结果+主表中有而从表中没有的记录<br>左外连接：left join左边的是主表<br>右外连接：right join右边的是主表<br>左外和右外交换两个表的顺序，可以实现同样的效果<br>圈外链接=内连接的结果+表1中有但表2中没有的+表2中有但表1中没有的</p>
<p>查询没有男朋友的女神名</p>
<p>SELECT<br>  b.name,<br>  bo.*<br>FROM<br>  beauty b<br>  LEFT JOIN boys bo<br>    ON b.boyfriend_id = bo.id<br>WHERE bo.<code>id</code> IS NULL ;</p>
<p>查询哪个部门没有员工</p>
<p>左外：</p>
<p>SELECT<br>  d.*,<br>  e.employee_id<br>FROM<br>  departments d<br>  LEFT OUTER JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE e.<code>employee_id</code> IS NULL ;</p>
<p>右外：</p>
<p>SELECT<br>  d.*,<br>  e.employee_id<br>FROM<br>  employees e<br>  RIGHT OUTER JOIN departments d<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE e.<code>employee_id</code> IS NULL ;</p>
<p>全外连接</p>
<p>mysql不支持</p>
<p>案例：</p>
<p>SELECT<br>  b.<em>,<br>  bo.</em><br>FROM<br>  beauty b FULL<br>  OUTER JOIN boys bo<br>    ON b.<code>boyfriend_id</code> = bo.id ;</p>
<p>交叉连接（也就是笛卡尔乘积）</p>
<p>案例：</p>
<p>SELECT<br>  b.<em>,<br>  bo.</em><br>FROM<br>  beauty b<br>  CROSS JOIN boys bo ;</p>
<p>sql92 和 sql99 pk</p>
<p>功能：sql99支持的较多<br>可读性：sql99实现连接条件和筛选条件的分离，可读性较高<br>练习：</p>
<p>查询编号&gt;3的女神的男朋友信息，如果有则列出详细信息，如果没有，则用null填充</p>
<p>SELECT<br>  a.id,<br>  a.name,<br>  b.*<br>FROM<br>  beauty a<br>  LEFT JOIN boys b<br>    ON a.<code>boyfriend_id</code> = b.<code>id</code><br>WHERE a.<code>id</code> &gt; 3 ;</p>
<p>查询哪个城市没有部门</p>
<p>SELECT<br>  city,<br>  d.*<br>FROM<br>  departments d<br>  RIGHT JOIN locations l<br>    ON d.location_id = l.location_id<br>WHERE d.department_id IS NULL ;</p>
<p>查询部门名为SAL或IT的员工信息</p>
<p>SELECT<br>  d.<code>department_name</code>,<br>  e.*<br>FROM<br>  departments d<br>  LEFT JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE d.<code>department_name</code> = ‘SAL’<br>  OR d.<code>department_name</code> = ‘IT’ ;</p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>含义：出现在其他语句中的select语句，称为子查询或内查询；外部的查询语句，称为主查询或外查询</p>
<p>嵌套在其他语句内部的select语句成为子查询或内查询</p>
<p>外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多</p>
<p>外面如果为select语句，则此语句称为外查询或主查询</p>
<p>分类：</p>
<p>按子查询出现的位置：<br>select后面：仅仅支持标量子查询<br>from后面：支持表子查询<br>where或having后面：支持标量子查询，列子查询，行子查询（较少）<br>exists后面（相关子查询）：支持表子查询<br>按功能、结果集的行列数不同：<br>标量子查询（结果集只有一行一列）<br>列子查询（结果集只有一列多行）<br>行子查询（结果集有一行多列）<br>表子查询（结果集一般为多行多列）</p>
<p>where或having后面</p>
<ol>
<li><p>标量子查询（单行子查询）</p>
</li>
<li><p>列子查询（多行子查询）</p>
</li>
<li><p>行子查询（多列多行）</p>
</li>
</ol>
<p>特点：</p>
<p>子查询放在小括号内<br>子查询一般放在条件的右侧，where，having<br>标量子查询，一般搭配着单行操作符使用（&gt; &lt; &gt;= &lt;= = &lt;&gt;）<br>列子查询，一般搭配着多行操作符使用（IN、ANY/SOME、ALL）<br>子查询的执行优选与主查询执行，主查询的条件用到了子查询的结果<br>标量子查询<br>案例1：谁的工资比Abel高？</p>
<p>SELECT<br>  salary<br>FROM<br>  employees<br>WHERE last_name = ‘Abel’ ;</p>
<p>案例2：返回job_id与141号员工相同，salary比143员工多的员工，姓名，job_id，工资</p>
<p>SELECT<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE job_id =<br>  (  SELECT<br>      job_id<br>     FROM<br>      employees<br>      WHERE employee_id = 141)<br>  AND salary &gt;<br>  (   SELECT<br>       salary<br>      FROM<br>       employees<br>       WHERE employee_id = 143) ;</p>
<p>案例3：返回公司工资最少的员工的last_name, job_id和salary</p>
<p>SELECT<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary =<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees) ;</p>
<p>案例4：查询最低工资大于50号部门的最低工资的部门id和其最低工资</p>
<p>SELECT<br>  MIN(salary),<br>  e.<code>department_id</code><br>FROM<br>  employees e<br>GROUP BY e.<code>department_id</code><br>HAVING MIN(salary) &gt;<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees<br>  WHERE department_id = 50) ;</p>
<p>列子查询<br>（多行子查询）</p>
<p>多行比较操作符：</p>
<p>IN/NOT IN：等于列表中的任意一个</p>
<p>ANY|SOME：和子查询返回的某一个值比较，用的较少</p>
<p>ALL：和子查询返回的所有值比较</p>
<p>案例1：返回location_id是1400或1700的部门中的所有员工姓名</p>
<p>SELECT<br>  last_name<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    departments<br>  WHERE location_id IN (1400, 1700)) ;</p>
<p>案例2：返回其他工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id以及salary</p>
<p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt; ANY<br>  (SELECT DISTINCT<br>    salary<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p>
<p>或者用max代替any</p>
<p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt;<br>  (SELECT<br>    MAX(salary)<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p>
<p>案例3：返回其他工种中比job_id为‘IT_PROG’工种所有工资都低的员工的员工号、姓名、job_id以及salary</p>
<p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt; ALL<br>  (SELECT DISTINCT<br>    salary<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p>
<p>或者用min代替all</p>
<p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt;<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p>
<p>行子查询<br>结果集一行多列或多行多列</p>
<p>案例1：查询员工编号最少并且工资最高的员工信息<br>把两个合在一起一起查询.<br>SELECT </p>
<ul>
<li>FROM<br>employees<br>WHERE (employee_id, salary) =<br>(SELECT<br>MIN(employee_id),<br>MAX(salary)<br>FROM<br>employees) ;</li>
</ul>
<p>select后面<br>仅仅支持标量子查询</p>
<p>案例1：查询每个部门的员工个数</p>
<p>SELECT<br>  d.<em>,<br>  (SELECT<br>    COUNT(</em>)<br>  FROM<br>    employees e<br>  WHERE e.department_id = d.department_Id) 个数<br>FROM<br>  departments d ;</p>
<p>案例2：查询员工号=102的部门名</p>
<p>SELECT<br>  (SELECT<br>    department_name<br>  FROM<br>    departments d<br>    INNER JOIN employees e<br>      ON d.department_id = e.department_id<br>  WHERE e.employee_id = 102) 部门名 ;</p>
<p>from后面<br>将子查询结果充当一张表，要求必须起别名</p>
<p>案例1：查询每个部门的平均工资的工资等级</p>
<p>SELECT<br>  ag_dep.*,<br>  g.<code>grade_level</code><br>FROM<br>  (SELECT<br>    AVG(salary) ag,<br>    department_id<br>  FROM<br>    employees<br>  GROUP BY department_id) ag_dep<br>  INNER JOIN job_grades g<br>    ON ag_dep.ag BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p>
<p>exists后面<br>相关子查询</p>
<p>语法：exists（完整的查询语句）</p>
<p>结果：1或0</p>
<p>案例1：查询有员工的部门名</p>
<p>SELECT<br>  department_name<br>FROM<br>  departments d<br>WHERE EXISTS<br>  (SELECT<br>    *<br>  FROM<br>    employees e<br>  WHERE d.<code>department_id</code> = e.<code>department_id</code>) ;</p>
<p>用in更简单</p>
<p>SELECT<br>  department_name<br>FROM<br>  departments d<br>WHERE d.<code>department_id</code> IN<br>  (SELECT<br>    department_id<br>  FROM<br>    employees e) ;</p>
<p>习题集</p>
<p>查询和zlotkey相同部门的员工姓名和工资</p>
<p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE department_id =<br>  (SELECT<br>    department_id<br>  FROM<br>    employees e<br>  WHERE e.<code>last_name</code> = ‘Zlotkey’) ;</p>
<p>查询工资比公司平均工资高的员工的员工号，姓名和工资</p>
<p>SELECT<br>  employee_id,<br>  last_name,<br>  salary<br>FROM<br>  employees e<br>WHERE e.<code>salary</code> &gt;<br>  (SELECT<br>    AVG(salary)<br>  FROM<br>    employees) ;</p>
<p>查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资</p>
<p>SELECT<br>  employee_id,<br>  last_name,<br>  salary<br>FROM<br>  employees e<br>  INNER JOIN<br>    (SELECT<br>      AVG(salary) ag,<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id) nt<br>    ON nt.department_id = e.department_id<br>WHERE salary &gt; ag ;</p>
<p>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</p>
<p>SELECT<br>  employee_id,<br>  last_name<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    employees<br>  WHERE last_name LIKE ‘%u%’) ;</p>
<p>查询在部门的location_id为1700的部门工作的员工的员工号</p>
<p>SELECT<br>  employee_id<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    departments<br>  WHERE location_id = 1700) ;</p>
<p>查询管理者是King的员工姓名和工资</p>
<p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE manager_id IN<br>  (SELECT<br>    employee_id<br>  FROM<br>    employees<br>  WHERE last_name = ‘K_ing’) ;</p>
<p>查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</p>
<p>SELECT<br>  CONCAT(nt.first_name, nt.last_name) “姓.名”<br>FROM<br>  (SELECT<br>    first_name,<br>    last_name<br>  FROM<br>    employees<br>  WHERE salary =<br>    (SELECT<br>      MAX(salary)<br>    FROM<br>      employees)) nt ;</p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
<p>语法：</p>
<p>select 查询列表</p>
<p>from 表</p>
<p>【join type】 join 表2</p>
<p>on 连接条件</p>
<p>where 筛选条件</p>
<p>group by 分组字段</p>
<p>having 分组后的筛选</p>
<p>order by 排序的字段】</p>
<p>limit offset，size；</p>
<p>offset：要显示条目的起始索引（从0开始）</p>
<p>size：要显示的条目个数</p>
<p>特点：</p>
<p>limit语句放在查询语句的最后</p>
<p>公式：</p>
<p>要显示的页数page，每页的条目数size</p>
<p>select 查询列表</p>
<p>from 表</p>
<p>limit （page - 1）* size， size；</p>
<p>案例1：查询前5条员工信息</p>
<p>SELECT * FROM employees LIMIT 0, 5;<br>或者<br>SELECT * FROM employees LIMIT 5;</p>
<p>案例2：查询第11条-第25条</p>
<p>SELECT * FROM employees LIMIT 10, 15;<br>1<br>案例3：有奖金的员工信息，并且工资较高的前10名显示出来</p>
<p>SELECT </p>
<ul>
<li>FROM<br>employees<br>WHERE commission_pct IS NOT NULL<br>ORDER BY salary DESC<br>LIMIT 10 ;</li>
</ul>
<p>经典案例1：</p>
<p>查询工资最低的员工信息：last_name, salary</p>
<p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE salary =<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees) ;</p>
<p>查询平均工资最低的部门信息</p>
<p>SELECT </p>
<ul>
<li>FROM<br>departments<br>WHERE department_id =<br>(SELECT<br>department_id<br>FROM<br>employees<br>GROUP BY department_id<br>ORDER BY AVG(salary) ASC<br>LIMIT 1) ;</li>
</ul>
<p>查询平均工资最低的部门信息和该部门的平均工资</p>
<p>SELECT<br>  d.*,<br>  dd.ag<br>FROM<br>  departments d<br>  INNER JOIN<br>    (SELECT<br>      AVG(salary) ag,<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id<br>    ORDER BY ag<br>    LIMIT 1) dd<br>    ON d.<code>department_id</code> = dd.department_id ;</p>
<p>查询平均工资最高的job信息</p>
<p>SELECT </p>
<ul>
<li>FROM<br>jobs j<br>WHERE j.<code>job_id</code> =<br>(SELECT<br>job_id<br>FROM<br>employees<br>GROUP BY job_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1) ;</li>
</ul>
<p>查询平均工资高于公司平均工资的部门有哪些</p>
<p>SELECT<br>  AVG(salary) ag,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING ag &gt;<br>  (SELECT<br>    AVG(salary)<br>  FROM<br>    employees) ;</p>
<p>查询出公司中所有manager的详细信息</p>
<p>SELECT </p>
<ul>
<li>FROM<br>employees<br>WHERE employee_id IN<br>(SELECT DISTINCT<br>manager_id<br>FROM<br>employees<br>WHERE manager_id IS NOT NULL) ;</li>
</ul>
<p>各个部门中，最高工资中，最低的那个部门的最低工资是多少</p>
<p>SELECT<br>  MIN(salary)<br>FROM<br>  employees<br>WHERE department_id =<br>  (SELECT<br>    department_id<br>  FROM<br>    employees<br>  GROUP BY department_id<br>  ORDER BY MAX(salary) ASC<br>  LIMIT 1) ;</p>
<p>查询平均工资最高的部门的manager的详细信息</p>
<p>SELECT<br>  last_name,<br>  department_id,<br>  email,<br>  salary<br>FROM<br>  employees<br>WHERE employee_id =<br>  (SELECT DISTINCT<br>    manager_id<br>  FROM<br>    employees<br>  WHERE department_id =<br>    (SELECT<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary) DESC<br>    LIMIT 1)<br>    AND manager_id IS NOT NULL) ;</p>
<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>union：联合，合并，将多条查询语句的结果合并成一个结果</p>
<p>引入案例：查询部门编号&gt;90或邮箱包含a的员工信息</p>
<p>SELECT </p>
<ul>
<li>FROM<br>employees<br>WHERE email LIKE “%a%”<br>OR department_id &gt; 90 ;</li>
</ul>
<p>用联合查询为：</p>
<p>SELECT </p>
<ul>
<li>FROM<br>employees<br>WHERE email LIKE “%a%”<br>UNION<br>SELECT </li>
<li>FROM<br>employees<br>WHERE department_id &gt; 90;</li>
</ul>
<p>语法：</p>
<p>查询语句1</p>
<p>union 【ALL】</p>
<p>查询语句2</p>
<p>union 【ALL】</p>
<p>…</p>
<p>应用场景：要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致</p>
<p>特点：</p>
<p>要求多条查询语句的查询列数是一致的<br>要求多条查询语句的查询的每一列的类型和顺序最好是一致的<br>union关键字默认去重，如果使用union all可以包含重复项</p>
<h4 id="查询总结"><a href="#查询总结" class="headerlink" title="查询总结"></a>查询总结</h4><p>语法：</p>
<p>select 查询列表 7</p>
<p>from 表1 别名 1</p>
<p>连接类型 join 表2 2</p>
<p>on 连接条件 3</p>
<p>where 筛选 4</p>
<p>group by 分组列表 5</p>
<p>having 筛选 6</p>
<p>order by 排序列表 8</p>
<p>limit 排序列表 9</p>
<h3 id="DML（Data-Manipulation-Language）数据操作语言"><a href="#DML（Data-Manipulation-Language）数据操作语言" class="headerlink" title="DML（Data Manipulation Language）数据操作语言"></a>DML（Data Manipulation Language）数据操作语言</h3><p>涉mZ到数据的<br>插入：insert<br>修改：update<br>删除：delete</p>
<h4 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h4><p>方式1：</p>
<p>语法：insert into 表名（列名，…） values（值1，…）</p>
<p>示例1：插入的值的类型要与列的类型一致或兼容</p>
<p>INSERT INTO beauty (<br>  id,<br>  NAME,<br>  sex,<br>  borndate,<br>  phone,<br>  photo,<br>  boyfriend_id<br>)<br>VALUES<br>  (<br>    13,<br>    ‘唐艺昕’,<br>    ‘女’,<br>    ‘1990-4-23’,<br>    ‘18934531234’,<br>    NULL,<br>    2<br>  );</p>
<p>示例2：不可以为null的列必须插入值。可以为null的列如何插入值？</p>
<p>方式1：字段的值写null<br>方式2：不写该字段</p>
<p>示例3：列的顺序是否可以调换</p>
<p>INSERT INTO beauty(NAME, sex, id, phone)<br>VALUES(‘蒋欣’, ‘女’, 16, ‘110’);</p>
<p>示例4：列数和值的个数必须一致</p>
<p>示例5：可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</p>
<p>INSERT INTO beauty<br>VALUES(18, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL);<br>1<br>2<br>方式2：</p>
<p>语法：insert into 表名 set 列名=值，列名=值，…</p>
<p>INSERT INTO beauty SET id = 19,<br>NAME = ‘刘涛’,<br>phone = ‘999’ ;</p>
<p>两种方式大pk</p>
<p>方式1支持插入多行，但是方式2不支持</p>
<p>INSERT INTO beauty<br>VALUES<br>(20, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL),<br>(21, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL),<br>(22, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL);</p>
<p>方式1支持子查询，方式2不支持</p>
<p>INSERT INTO beauty(id, NAME, phone)<br>SELECT 26, ‘送钱’, ‘12341234’;</p>
<ol start="2">
<li>修改语句<br>语法：</li>
</ol>
<p>修改单表的记录</p>
<p>update 表名</p>
<p>set 列=新值，列=新值…</p>
<p>where 筛选条件；</p>
<p>修改多表的记录</p>
<p>sql92语法</p>
<p>update 表1 别名，表2 别名</p>
<p>set 列=值…</p>
<p>where 筛选条件</p>
<p>and 筛选条件；</p>
<p>sql99语法：</p>
<p>update 表1 别名</p>
<p>inner | left | right join 表2 别名</p>
<p>on 连接条件</p>
<p>set 列=值，…</p>
<p>where 筛选条件；</p>
<p>修改单表的记录<br>案例1：修改beauty表中姓唐的女神电话为109090909</p>
<p>UPDATE<br>  beauty<br>SET<br>  phone = ‘109090909’<br>WHERE NAME LIKE ‘唐%’ ;</p>
<p>案例2：修改boys表中id号位2的名称为张飞，魅力值为10</p>
<p>UPDATE<br>  boys<br>SET<br>  boyname = ‘张飞’,<br>  usercp = 10<br>WHERE id = 2 ;</p>
<p>修改多表的记录<br>案例1：修改张无忌的女朋友的手机号为114</p>
<p>UPDATE<br>  boys b<br>  INNER JOIN beauty be<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code> SET be.<code>phone</code> = ‘114’<br>WHERE b.<code>boyName</code> = ‘张无忌’ ;</p>
<p>案例2：修改没有男朋友的女神的男朋友编号都为 2号</p>
<p>UPDATE<br>  boys b<br>  RIGHT JOIN beauty be<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code> SET be.<code>boyfriend_id</code> = 2<br>WHERE be.<code>boyfriend_id</code> IS NULL ;</p>
<ol start="3">
<li>删除语句<br>方式1：delete</li>
</ol>
<p>语法</p>
<p>单表的删除</p>
<p>delete from 表名 where 筛选条件</p>
<p>多表的删除</p>
<p>sql92语法</p>
<p>delete 别名（要删哪个表就写哪个表的别名，都删就都写）</p>
<p>from 表1 别名，表2 别名</p>
<p>where 连接条件</p>
<p>and 筛选条件</p>
<p>limit 条目数；</p>
<p>sql99语法</p>
<p>delete 别名（要删哪个表就写哪个表的别名，都删就都写）</p>
<p>from 表1 别名</p>
<p>inner | left | right join 表2 别名 on 连接条件</p>
<p>where 筛选条件</p>
<p>limit 条目数；</p>
<p>案例1：删除手机号以9结尾的女神信息</p>
<p>DELETE<br>FROM<br>  beauty<br>WHERE phone LIKE ‘%9’ ;</p>
<p>案例2：删除张无忌的女朋友的信息</p>
<p>DELETE<br>  be<br>FROM<br>  beauty be<br>  INNER JOIN boys b<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code><br>WHERE b.<code>boyName</code> = ‘张无忌’ ;</p>
<p>案例3：删除黄晓明的信息以及他女朋友的信息</p>
<p>DELETE<br>  b,<br>  be<br>FROM<br>  beauty be<br>  INNER JOIN boys b<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code><br>WHERE b.<code>boyName</code> = ‘黄晓明’ ;</p>
<p>方式2：truncate</p>
<p>语法</p>
<p>truncate table 表名；</p>
<p>truncate语句中不许加where</p>
<p>一删全删</p>
<p>TRUNCATE TABLE boyes ;<br>1<br>delete pk truncate</p>
<p>delete可以加where条件，truncate不可以<br>truncate删除效率高一些<br>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。<br>truncate删除没有返回值，delete删除有返回值<br>truncate删除不能回滚，delete删除可以回滚<br>DDL（Data Definition Language）数据定义语言<br>库和表的管理<br>库的管理：创建、修改、删除<br>标的管理：创建、修改、删除<br>创建：create<br>修改：alter<br>删除：frop</p>
<ol>
<li>库的管理<br>库的创建</li>
</ol>
<p>语法：create database [if not exists] 库名 [character set 字符集名]；</p>
<p>案例：创建库book</p>
<p>CREATE DATABASE IF NOT EXISTS books;<br>1<br>库的修改</p>
<p>修改库名的语句【已停用】</p>
<p>RENAME DATABASE books TO new_books;<br>1<br>更改库的字符集</p>
<p>ALTER DATABASE books CHARACTER SET gbk;<br>1<br>库的删除</p>
<p>DROP DATABASE IF EXISTS books;<br>1</p>
<h4 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h4><p>表的创建</p>
<p>语法：<br>create table 【if not exists】 表名(</p>
<p>​ 列名 列的类型【（长度） 约束】，</p>
<p>​ 列名 列的类型【（长度） 约束】，</p>
<p>​ …</p>
<p>)</p>
<p>案例1：创建表 book</p>
<p>CREATE TABLE book (<br>  id INT,<br>  bname VARCHAR (20),<br>  price DOUBLE,<br>  authorid INT,<br>  publishdate DATETIME<br>) ;</p>
<p>案例2：创建表author</p>
<p>CREATE TABLE author (<br>  id INT,<br>  au_name VARCHAR (20),<br>  nation VARCHAR (10)<br>) ;</p>
<p>案例3：查看创建的表</p>
<p>DESC author;<br>1<br>表的修改</p>
<p>语法：alter table 表名 add | drop | modify | change column 列名 【列类型 约束】；</p>
<p>添加列：alter table 表名 add column 列名 类型 【first | after 字段名】；</p>
<p>修改列的类型或约束：alter table 表名 modify column 列名 新类型 【新约束】；</p>
<p>修改列名：alter table 表名 change column 旧列名 新列名 类型；</p>
<p>删除列：alter table 表名 drop column 列名；</p>
<p>修改表名：alter table 表名 rename 【to】 新表名；</p>
<p>修改列名</p>
<p>ALTER TABLE book<br>  CHANGE COLUMN publishdate pubdate DATETIME ;</p>
<p>修改列的类型或约束</p>
<p>ALTER TABLE book<br>  MODIFY COLUMN pubdate TIMESTAMP ;</p>
<p>添加新列</p>
<p>ALTER TABLE author<br>  ADD COLUMN annual DOUBLE ;</p>
<p>删除列</p>
<p>ALTER TABLE author<br>  DROP COLUMN annual ;</p>
<p>修改表名</p>
<p>ALTER TABLE author<br>  RENAME TO book_author ;</p>
<p>表的删除</p>
<p>语法：drop table if exists 表名；</p>
<p>查看有哪些表：show tables；</p>
<p>if exists 只能在库，表的创建和删除的时候使用，列的操作不能使用。</p>
<p>通用的写法：</p>
<p>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;</p>
<p>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE 表名();</p>
<p>表的复制</p>
<p>仅仅复制表的结构</p>
<p>CREATE TABLE copy LIKE book_author ;<br>1<br>复制表的结构+数据</p>
<p>CREATE TABLE copy2<br>SELECT </p>
<ul>
<li>FROM<br>book_author ;</li>
</ul>
<p>只复制部分数据</p>
<p>CREATE TABLE copy3<br>SELECT<br>  id,<br>  au_name<br>FROM<br>  book_author<br>WHERE nation = ‘中国’ ;</p>
<p>仅仅复制某些字段（部分结构）：设置where不满足，那么就没有数据</p>
<p>CREATE TABLE copy4<br>SELECT<br>  id,<br>  au_name<br>FROM<br>  book_author<br>WHERE 0 ;</p>
<p>习题集</p>
<p>创建表dept1</p>
<p>USE myemployees;<br>CREATE TABLE dept1 (id INT (7), NAME VARCHAR (25)) ;</p>
<p>将表departments中的数据插入新表dept2中</p>
<p>CREATE TABLE dept2<br>SELECT<br>  department_id,<br>  department_name<br>FROM<br>  departments ;</p>
<p>创建表emp5</p>
<p>CREATE TABLE emp5 (<br>  id INT (7),<br>  first_name VARCHAR (25),<br>  last_name VARCHAR (25),<br>  dept_id INT (7)<br>) ;</p>
<p>将last_name的长度修改为50</p>
<p>ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);<br>1<br>根据表employees创建employee2</p>
<p>CREATE TABLE employee2 LIKE employees ;<br>1<br>删除表emp5</p>
<p>DROP TABLE IF EXISTS emp5;<br>1<br>将表empoyees2重命名为emp5</p>
<p>ALTER TABLE employee2<br>  RENAME TO emp5 ;</p>
<p>在表dept和emp5中添加新列test_column，并检查所做的操作</p>
<p>ALTER TABLE emp5<br>  ADD COLUMN test_column INT ;<br>DESC emp5;</p>
<p>直接删除表emp5中的列dept_id</p>
<p>ALTER TABLE emp5<br>  DROP COLUMN dept_id ;</p>
<h4 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h4><p>数值型：<br>整型<br>浮点型<br>定点数<br>浮点数<br>字符型：<br>较短的文本：char、varchar<br>较长的文本：text、blob（较长的二进制数据）<br>日期型：<br>整型<br>分类：Tinyint、Smallint、Mediumint、int/integer、bigint<br>特点<br>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值<br>如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用，并且默认变为无符号的整型！</p>
<p>小数<br>分类<br>浮点型<br>float（M，D）<br>double（M，D）<br>定点型<br>dec（M，D）<br>decimal（M，D）<br>特点<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值<br>M和D都可以省略，如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度<br>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用定点型<br>原则：所选择的类型越简单越好，能保存数值的类型越小越好</p>
<p>字符型<br>较短的文本：char、varchar<br>较长的文本：text，blob<br>特点：<br>写法 M的意思 特点 空间耗费 效率<br>char char(M) 最大的字符数，可以省略，默认为1 固定长度的字符 比较耗费 高<br>varchar varchar(M) 最大的字符数，不可以省略 可变长度的字符 比较节省 低</p>
<p>其他类型<br>binary和varbinary用于保存较短的二进制<br>enum：枚举，eg. enum(‘男’, ‘女’)<br>set：集合，eg. set(‘a’, ‘b’, ‘c’, ‘d’)<br>日期型<br>分类：<br>date：只保存日期<br>time：值保存时间<br>year：值保存年<br>datetime：保存日期+时间<br>timestamp：保存日期+时间，更能反映真实时间<br>特点：<br>​ 字节 范围 时区等的影响<br>datetime 8 1000-9999 不受<br>timestamp 4 1970-2038 受</p>
<h4 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h4><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p>
<p>分类：六大约束</p>
<p>not null：非空，用于保证该字段的值不能为空。比如姓名、学号等。<br>default：默认，用于保证该字段有默认值。比如性别。<br>primary key：主键，用于保证该字段的值具有唯一性，并且非空。比如学号、员工编号等。<br>unique：唯一，用于保证该字段的值具有唯一性，可以为空。比如座位号。<br>check：检查约束【mysql中不支持】。不日年龄、性别。<br>foreign key：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。在从表添加外键约束，用于应用主表中某列的值。比如学生表的专业编号，员工表的部门编号，员工表的工种编号。<br>添加约束的时机：</p>
<p>创建表时<br>修改表时<br>约束添加的分类：</p>
<p>列级约束：六大约束语法上都支持，但外键约束没有效果</p>
<p>表级约束：除了非空、默认，其他的都支持</p>
<p>位置    支持的约束类型    是否可以起约束名<br>列级约束    列的后面    语法都支持，但外键没有效果    不可以<br>表级约束    所有列的下面    默认和非空不支持，其他支持    可以（主键没有效果）<br>创建表时添加约束<br>添加列级约束</p>
<p>CREATE DATABASE students;<br>USE students;</p>
<p>CREATE TABLE stuinfo (<br>  id INT PRIMARY KEY,<br>  stuname VARCHAR (20) NOT NULL,    # 非空<br>  gender CHAR(1) CHECK (gender = ‘男’<br>    OR gender = ‘女’),<br>  seat INT UNIQUE,    # 唯一<br>  age INT DEFAULT 18,    # 默认<br>  majorID INT REFERENCES major (id)<br>) ;</p>
<p>CREATE TABLE major (<br>  id INT PRIMARY KEY,<br>  majorName VARCHAR (20)<br>) ;</p>
<p>DESC stuinfo;<br>SHOW INDEX FROM stuinfo;</p>
<p>语法：直接在字段名和类型后面追加约束类型即可。<br>只支持：默认、非空、主键、唯一（除了外键都支持）<br>添加表级约束</p>
<p>DROP TABLE IF EXISTS stuinfo ;</p>
<p>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT,</p>
<p>CONSTRAINT pk PRIMARY KEY(id),<br>CONSTRAINT uq UNIQUE(seat),<br>CONSTRAINT ck CHECK(gender=’男’ OR gender=’女’),<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)<br>);</p>
<p>SHOW INDEX FROM stuinfo;</p>
<p>语法：在各个字段的最下面</p>
<p>【constraint 约束名】 约束类型（字段名）</p>
<p>除了非空、默认，其他的都支持</p>
<p>通用的写法：</p>
<p>CREATE TABLE IF NOT EXISTS stuinfo (<br>  id INT PRIMARY KEY,<br>  stuname VARCHAR (20) NOT NULL,<br>  gender CHAR(1),<br>  seat INT UNIQUE,<br>  age INT DEFAULT 18,<br>  majorID INT,<br>  CONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major (id)<br>) ;</p>
<p>表级约束pk列级约束</p>
<p>支持类型    可以起约束名与否<br>列级约束    除了外键    不可以<br>表级约束    除了非空和默认    可以，但对主键无效<br>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p>
<p>主键和唯一的大对比</p>
<pre><code>   保证唯一性    是否允许为空    一个表中可以有多少个    是否允许组合</code></pre>
<p>1<br>主键 √ × 至多有1个 √，但不推荐<br>唯一 √ √ 可以有多个 √，但不推荐<br>外键特点</p>
<p>要求在从表设置外键关系</p>
<p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p>
<p>主表的关联列必须是一个key（一般是主键或唯一）</p>
<p>插入数据时，先插入主表，再插入从表</p>
<p>删除数据时，先删除从表，再删除主表</p>
<p>方式1：级联删除</p>
<p>ALTER TABLE stuinfo ad CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;<br>1<br>删除的时候，主表和从表对应的行都删了。</p>
<p>方式2：级联置空</p>
<p>ALTER TABLE stuinfo ad CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;<br>1<br>删除的时候，主表对应的行被删除了，从表引入的地方变为空值null。</p>
<p>修改表时添加约束<br>添加列级约束：alter table 表名 modify column 字段名 字段类型 新约束；</p>
<p>添加表级约束：alter table 表名 add 【constraint 约束名】 约束类型（字段名）【外键的引用】；</p>
<p>添加非空约束</p>
<p>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL;<br>1<br>添加默认约束</p>
<p>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br>1<br>添加主键</p>
<h4 id="列级约束的写法"><a href="#列级约束的写法" class="headerlink" title="列级约束的写法"></a>列级约束的写法</h4><p>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</p>
<h5 id="表级约束的写法"><a href="#表级约束的写法" class="headerlink" title="表级约束的写法"></a>表级约束的写法</h5><p>ALTER TABLE stuinfo ADD PRIMARY KEY(id);</p>
<p>添加唯一</p>
<h5 id="列级约束的写法-1"><a href="#列级约束的写法-1" class="headerlink" title="列级约束的写法"></a>列级约束的写法</h5><p>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</p>
<h5 id="表级约束的写法-1"><a href="#表级约束的写法-1" class="headerlink" title="表级约束的写法"></a>表级约束的写法</h5><p>ALTER TABLE stuinfo ADD UNIQUE(seat);</p>
<p>添加外键</p>
<p>ALTER TABLE (CONSTRAINT fk_stuinfo_major) stuinfo ADD FOREIGN KEY(majorid) REFERENCES major(id);<br>1<br>修改表时删除约束<br>删除非空约束</p>
<p>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;<br>1<br>删除默认约束</p>
<p>ALTER TABLE stuinfo MODIFY COLUMN age INT;<br>1<br>删除主键</p>
<p>ALTER TABLE stuinfo DROP PRIMARY KEY;<br>1<br>删除唯一</p>
<p>ALTER TABLE stuinfo DROP INDEX seat;<br>1<br>删除外键</p>
<p>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;<br>1<br>总结</p>
<p>非空</p>
<p>添加非空：alter table 表名 modify column 字段名 字段类型 not null；</p>
<p>删除非空：alter table 表名 modify column 字段名 字段类型；</p>
<p>默认</p>
<p>添加默认：alter table 表名 modify column 字段名 字段类型 default；</p>
<p>删除默认：alter table 表名 modify column 字段名 字段类型；</p>
<p>主键</p>
<p>添加主键：alter table 表名 add 【constraint 约束名】 primary key（字段名）；</p>
<p>删除主键：alter table 表名 drop primary key；</p>
<p>唯一</p>
<p>添加唯一：alter table 表名 add 【constraint 约束名】unique（字段名）；</p>
<p>删除唯一：alter table 表名 drop index 索引名；</p>
<p>外键</p>
<p>添加外键：alter table 表名 add 【constraint 约束名】foreign key（字段名） references 主表（被引用列）；</p>
<p>删除唯一：alter table 表名 drop foreign key 约束名；</p>
<h4 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h4><p>又称为自增长列</p>
<p>含义：可以不用手动的插入值，系统提供默认的序列值</p>
<p>特点：</p>
<p>标识列必须和主键搭配吗？不一定，但要求是一个key。<br>一个表可以有几个标识列？至多一个。<br>标识列的类型？只能是数值型（int（一般是int），float，double）<br>标识列可以通过**SET auto_increment_increment = 1;**设置步长；可以通过手动插入值设置起始值。<br>创建表时设置表时列</p>
<p>create table 表（</p>
<p>​ 字段名 字段类型 约束 auto_increment</p>
<p>）</p>
<p>CREATE TABLE tab_identity (<br>  id INT PRIMARY KEY AUTO_INCREMENT,<br>  NAME varcahr (20)<br>) ;</p>
<p>设置表时列的步长</p>
<p>SHOW VARIABLES LIKE ‘%auto_increment%’;<br>SET auto_increment_increment = 3;<br>1<br>2<br>设置表时列的起始值：想在什么地方更改自增长列的值，则手动插入值（不手动的时候，值是null）。</p>
<p>修改表时设置标识列</p>
<p>alter table 表 modify column 字段名 字段类型 约束 auto_increment</p>
<p>ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;<br>1<br>修改表时删除标识列</p>
<p>alter table 表 modify column 字段名 字段类型 约束</p>
<p>ALTER TABLE tab_identity MODIFY COLUMN id INT;<br>1</p>
<h3 id="TCL（Transaction-Control-Language）事务控制语言"><a href="#TCL（Transaction-Control-Language）事务控制语言" class="headerlink" title="TCL（Transaction Control Language）事务控制语言"></a>TCL（Transaction Control Language）事务控制语言</h3><p>事务的含义：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
<p>存储引擎：在mysql中的数据用各种不同的技术存储在文件（或内存）中。</p>
<p>通过show engines来查看mysql支持的存储引擎。<br>在mysql中用的最多的存储引擎有：innodb、myisam、memory等。其中innodb支持事务，而myisam、memory等不支持事务。<br>事务的ACID属性</p>
<p>原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。<br>隔离性（Isolation）：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。<br>事务的创建</p>
<p>隐式事务：事务没有明显的开启和结束的标记。比如insert、update、delete语句</p>
<p>显式事务：事务具有明显的开启和结束的标记</p>
<p>前提：必须先设置自动提交功能为禁用</p>
<p>SET autocommit=0;<br>1<br>步骤1：开启事务</p>
<p>SET autocommit=0;<br>START TRANSACTION;（可选）<br>2<br>步骤2：编写事务中的sql语句(select insert update delete，只有增删改查，不包括DDL语言)</p>
<p>语句1；</p>
<p>语句2；</p>
<p>…</p>
<p>步骤3：结束事务</p>
<p>commit；提交事务</p>
<p>rollback；回滚事务</p>
<p>savepoint 结点名：设置保存点</p>
<p>SET autocommit = 0 ;</p>
<p>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;<br>DELETE FROM accound WHERE id=28;<br>ROLLBACK TO a;</p>
<p>delete和truncate在事务使用时的区别</p>
<p>delete删除后支持回滚<br>SET autocommit = 0 ;<br>START TRANSACTION;<br>DELETE FROM account;<br>ROLLBACK;</p>
<p>truncate删除后不支持回滚<br>SET autocommit = 0 ;<br>START TRANSACTION;<br>TRUNCATE TABLE account;<br>ROLLBACK;</p>
<p>数据库的隔离级别</p>
<p>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：<br>脏读：对于两个事务T1，T2。T1读取了已经被T2更新但还没有被提交的字段之后，若T2回滚，T1读取的内容就是临时且无效的。主要是其他事务更新的数据<br>不可重复读：对于两个事务T1，T2。T1读取了一个字段，然后T2更新了该字段之后，T1再次读取同一个字段，值就不同了。<br>幻读：对于两个事务T1，T2。T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行之后，如果T1再次读取同一个表，就会多出几行。主要是其他事务插入的数据<br>数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。<br><strong>一个事务与其他事务隔离的程度称为隔离级别。</strong>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性弱。<br>数据库提供的4种事务隔离级别：img<br>Oracle支持2种事务隔离级别：READ COMMITED，SERIALIZABLE。Oracle默认的事务隔离级别是：READ COMMITED。<br>Mysql支持4种事务隔离级别。Mysql默认的事务隔离级别为：REPEATABLE READ。<br>每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前事务隔离级别。<br>查看当前的隔离级别：select @@tx_isolation;<br>设置当前mysql连接的隔离级别：set transaction isolation level read committed;<br>设置数据库系统的全局的隔离级别：set global transaction isolation level read committed;</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>含义：虚拟表，和普通表一样使用。并且使用视图时动态生成的，值保存了sql逻辑，不保存成查询结果。</p>
<p>mysql5.1版本出现的新特性，是通过表动态生成的数据</p>
<p>应用场景：</p>
<p>多个地方用到同样的查询结果<br>该查询结果使用的sql语句较复杂<br>案例1：查询姓张的学生名和专业名</p>
<p>普通写法<br>SELECT<br>  stuname,<br>  majorname<br>FROM<br>  suinfo s<br>  INNER JOIN major m<br>    ON s.majorid = m.<code>id</code><br>WHERE s.stuname LIKE ‘张%’ ;</p>
<p>视图写法<br>CREATE VIEW v1 AS<br>SELECT<br>  stuname,<br>  majorname<br>FROM<br>  suinfo s<br>  INNER JOIN major m<br>    ON s.majorid = m.<code>id</code> ;</p>
<p>SELECT </p>
<ul>
<li>FROM<br>v1<br>WHERE stuname LIKE ‘张%’ ;</li>
</ul>
<p>创建视图</p>
<p>语法：</p>
<p>create view 视图名 as 查询语句；</p>
<p>视图的好处：</p>
<p>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性<br>练习题：</p>
<p>习题1：查询姓名中包含a字符的员工名、部门名和工种信息</p>
<p>CREATE VIEW myv1 AS<br>SELECT<br>  last_name,<br>  department_name,<br>  job_title<br>FROM<br>  employees e<br>  JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code><br>  JOIN jobs j<br>    ON j.<code>job_id</code> = e.<code>job_id</code> ;</p>
<p>SELECT </p>
<ul>
<li>FROM<br>myv1<br>WHERE last_name LIKE ‘%a%’ ;</li>
</ul>
<p>习题2：查询各部门的平均工资级别</p>
<h5 id="创建视图查看每个部门的平均工资"><a href="#创建视图查看每个部门的平均工资" class="headerlink" title="创建视图查看每个部门的平均工资"></a>创建视图查看每个部门的平均工资</h5><p>CREATE VIEW myv2 AS<br>SELECT<br>  AVG(salary) ag,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id ;</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>SELECT<br>  myv2.<code>ag</code>,<br>  g.grade_level<br>FROM<br>  myv2<br>  JOIN job_grades g<br>    ON myv2.<code>ag</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p>
<p>习题3：查询平均工资最低的部门信息</p>
<h5 id="用习题2的视图myv2"><a href="#用习题2的视图myv2" class="headerlink" title="用习题2的视图myv2"></a>用习题2的视图myv2</h5><p>SELECT </p>
<ul>
<li>FROM<br>myv2<br>ORDER BY ag<br>LIMIT 1 ;</li>
</ul>
<p>习题4：查询平均工资最低的部门名和工资</p>
<p>CREATE VIEW myv3 AS<br>SELECT </p>
<ul>
<li>FROM<br>myv2<br>ORDER BY ag LIMIT 1 ;</li>
</ul>
<p>SELECT<br>  d.*,<br>  m.<code>ag</code><br>FROM<br>  myv3 m<br>  JOIN departments d<br>    ON m.<code>department_id</code> = d.<code>department_id</code> ;</p>
<p>视图的修改</p>
<p>方式1：create or replace view 视图名 as 查询语句；<br>方式2：alter view 视图名 as 查询语句；<br>删除视图</p>
<p>语法：drop view 视图名，视图名，…；<br>查看视图</p>
<p>语法：</p>
<p>show create view 视图名；</p>
<p>desc 视图名；</p>
<p>案例1：创建一个视图emp_v1，要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</p>
<p>CREATE OR REPLACE VIEW emp_v1 AS<br>SELECT<br>  last_name,<br>  salary,<br>  email<br>FROM<br>  employees<br>WHERE phone_number LIKE ‘011%’ ;</p>
<p>案例2：创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</p>
<p>CREATE OR REPLACE VIEW emp_v2 AS<br>SELECT<br>  MAX(salary) mx,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING MAX(salary) &gt; 12000 ;</p>
<p>SELECT </p>
<ul>
<li>FROM<br>emp_v2 ;</li>
</ul>
<p>SELECT<br>  d.*,<br>  m.mx<br>FROM<br>  departments d<br>  JOIN emp_v2 m<br>    ON m.department_id = d.<code>department_id</code> ;</p>
<p>视图的更新</p>
<p>增、删、改（视图基于的表也会发生更改）</p>
<p>CREATE OR REPLACE VIEW myv1 AS<br>SELECT<br>  last_name,<br>  email<br>FROM<br>  employees;</p>
<p>SELECT * FROM myv1;</p>
<h5 id="mZ插入"><a href="#mZ插入" class="headerlink" title="mZ插入"></a>mZ插入</h5><p>INSERT INTO myv1 VALUES(‘张飞’, ‘zhangfei’);</p>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>UPDATE myv1 SET last_name=’张无忌’ WHERE last_name = ‘张飞’;</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>DELETE FROM myv1 WHERE last_name=’张无忌’;</p>
<p>视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的。（注意：视图一般用于查询，而不是更新。）</p>
<p>包含以下关键字的sql语句：分组函数、distinct、group by、having、union或union all<br>常量视图<br>select中包含子查询<br>join<br>from 一个不能更新的视图<br>where子句的子查询应用了from子句中的表<br>视图和表的对比</p>
<p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view    只是保存了sql逻辑    增删改查，一般不能增删改<br>表    create table    保存了实际的数据    增删改查<br>测试题</p>
<p>题1：创建表</p>
<p>CREATE TABLE book (<br>  bid INT PRIMARY KEY,<br>  bname VARCHAR (20) UNIQUE nut NULL,<br>  price FLOAT DEFAULT 10,<br>  btypeid INT,<br>  FOREIGN KEY (btypeid) REFERENCES booktype (id)<br>) ;</p>
<p>题2：开启事务，向表中插入1行数据，并结束</p>
<p>SET autocommit = 0 ;<br>INSERT INTO book(bid, bname, price, btypeid)<br>VALUES(1, ‘小李飞刀’, 100, 1);<br>COMMIT;</p>
<p>题3：创建视图，实现查询价格大于100的书名和类型名</p>
<p>CREATE VIEW myv1 AS<br>SELECT<br>  bname,<br>  NAME<br>FROM<br>  book b<br>  INNER JOIN booktype t<br>    ON b.btypeid = t.id<br>WHERE price &gt; 100 ;</p>
<p>题4：修改视图，实现查询价格在90-120之间的书名和价格</p>
<p>CREATE OR REPLACE VIEW myv1 AS<br>SELECT<br>  bname,<br>  price<br>FROM<br>  book<br>WHERE price BETWEEN 90<br>  AND 120 ;</p>
<p>题5：删除刚才创建的视图</p>
<p>DROP VIEW myv1;<br>1</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>系统变量</p>
<p>说明：变量由系统提供，不是用户定义，属于服务器层面</p>
<p>注意：如果是全局级别，则需要加global；如果是会话级别，则需要加session；如果不写，则默认session</p>
<p>使用的语法：</p>
<p>查看所有的系统变量</p>
<p>SHOW GLOBAL|【SESSION】 VARIABLES;<br>1<br>查看满足条件的部分系统变量</p>
<p>SHOW GLOBAL|【SESSION】 VARIABLES LIKE ‘%char%’;<br>1<br>查看指定的某个系统变量的值</p>
<p>SELECT @@GLOBAL|【SESSION】.系统变量名;<br>1<br>为某个系统变量赋值</p>
<p>方式一</p>
<p>set GLOBAL|【SESSION】 系统变量名 = 值;<br>1<br>方式二</p>
<p>set @@GLOBAL|【SESSION】.系统变量名 = 值;<br>1<br>分类：</p>
<p>全局变量</p>
<p>服务器层面上的，必须拥有super权限才能为系统变量赋值。</p>
<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启。</p>
<p>查看所有的全局变量</p>
<p>SHOW GLOBAL VARIABLES;</p>
<ul>
<li>查看部分的全局变量</li>
</ul>
<p>SHOW GLOBAL VARIABLES LIKE ‘%char%’;</p>
<ul>
<li>查看指定的全局变量的值</li>
</ul>
<p>SELECT @@global.autocommit;<br>SELECT @@global.tx_isolation;</p>
<ul>
<li><p>为某个指定的全局变量赋值</p>
</li>
<li><p>方式1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@global.autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>会话变量</p>
<p>服务器为每一个连接的客户端都提供了系统变量。</p>
<p>作用域：仅仅针对于当前会话（连接）有效。</p>
<p>查看所有的会话变量</p>
<p>SHOW 【SESSION】 VARIABLES;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查看部分的会话变量</span><br><span class="line"></span><br><span class="line">SHOW 【SESSION】 VARIABLES LIKE ‘%char%’;</span><br></pre></td></tr></table></figure>

<p>查看指定的某个会话变量</p>
<p>SELECT @@【SESSION.】autocommit;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">为某个会话变量赋值</span><br><span class="line"></span><br><span class="line">方式1：</span><br><span class="line"></span><br><span class="line">set session autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方式2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@【session.】autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>自定义变量</p>
<p>变量是用户自定义的，不是由系统定义的</p>
<p>使用步骤：声明 赋值 使用（查看、比较、运算等）</p>
<p>分类</p>
<p>用户变量</p>
<p>作用域：针对于当前会话（连接）有效，等同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end的外面<br>声明并初始化（三种方式）</p>
<p>set @用户变量名=值；<br>set @用户变量名:=值；（推荐）<br>select @用户变量名:=值；</p>
<p>赋值（更新用户变量的值）</p>
<p>方式1：通过set或select（同上）</p>
<p>set @用户变量名=值；<br>set @用户变量名:=值；（推荐）<br>select @用户变量名:=值；</p>
<p>案例1：</p>
<p>SET @name=’John’;<br>SET @name=100;</p>
<p>方式2：通过select into</p>
<p>select 字段 into 变量名<br>from 表；</p>
<p>案例1：</p>
<p>SELECT<br>  COUNT(*) INTO @count<br>FROM<br>  employees ;</p>
<p>使用（查看用户变量的值）</p>
<p>select @用户变量名；</p>
<p>局部变量</p>
<p>作用域：仅仅在定义它的begin end中有效<br>应用在begin end中的第一句话<br>声明</p>
<p>declare 变量名 类型；</p>
<p>declare 变量名 类型 default 值；</p>
<p>赋值</p>
<p>方式1：通过set或select（同上）</p>
<p>set 局部变量名=值；<br>set 局部变量名:=值；（推荐）<br>select @局部变量名:=值；</p>
<p>方式2：通过select into</p>
<p>select 字段 into 局部变量名<br>from 表；</p>
<p>使用</p>
<p>select 局部变量名；</p>
<p>对比用户变量和局部变量：</p>
<p>作用域    定义和使用的位置    语法<br>用户变量    当前会话    会话中的任何地方    必须加@符号，不用限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句话    一般不用加@符号，需要限定类型<br>案例1：声明两个变量并赋初始值，求和，并打印</p>
<p>用户变量</p>
<p>SET @m=1;<br>SET @n=2;<br>SET @sum=@m+@n;<br>SELECT @sum;</p>
<p>局部变量</p>
<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 2;<br>DECLARE SUM INT;<br>SET SUM=m+n;<br>SELECT SUM;</p>
<h4 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h4><p>类似于java中的方法<br>好处：<br>提高代码的重用性<br>简化操作</p>
<h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><p>含义：一组预先编译好的sql语句的集合，理解成批处理语句</p>
<p>好处：</p>
<p>提高代码的重用性<br>简化操作<br>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>语法：</p>
<p>创建语法</p>
<p>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN<br>    存储过程体(一组合法的SQL语句)<br>END</p>
<p>注意</p>
<p>参数列表包含三部分：参数模式，参数名，参数类型</p>
<p>举例：in stuname varchar(20)<br>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又需要返回值<br>如果存储过程体仅仅只有一句话，begin end可以省略</p>
<p>存储过程体中的每条SQL语句的结尾要求必须加分号</p>
<p>存储过程的结尾可以使用 DELIMITER 重新设置</p>
<p>语法：DELIMITER 结束标记</p>
<p>案例：</p>
<p>DELIMITER $<br>1<br>调用语法</p>
<p>call 存储过程名(实参列表)；<br>空参列表</p>
<p>案例1：插入到admin表中五条记录</p>
<p>SELECT * FROM admin;<br>DELIMITER $</p>
<p>CREATE PROCEDURE myp1()<br>BEGIN<br>INSERT INTO admin(username, <code>password</code>)<br>VALUES<br>(‘john1’, ‘0000’),<br>(‘asd’, ‘0000’),<br>(‘joqqhn1’, ‘0000’),<br>(‘qa’, ‘0000’),<br>(‘ww’, ‘0000’);<br>END $</p>
<p>CALL myp1()$</p>
<p>创建带in模式参数的存储过程</p>
<p>案例1：创建存储过程实现：根据女神名，查询对应的男神信息</p>
<p>CREATE PROCEDURE myp2(IN beautyname VARCHAR(20))<br>BEGIN<br>SELECT bo.*<br>FROM boys bo<br>RIGHT JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p>
<p>CALL myp2(‘柳岩’)$<br>CALL myp2(‘王语嫣’)$</p>
<p>案例2：创建存储过程实现，用户是否登录成功</p>
<p>CREATE PROCEDURE myp4(IN username VARCHAR(20), IN passward VARCHAR(20))<br>BEGIN<br>DECLARE result INT DEFAULT 0;    # 声明并初始化</p>
<p>SELECT COUNT(*) INTO result    # 赋值<br>FROM admin<br>WHERE admin.username = username<br>AND admin.password = PASSWORD;</p>
<p>SELECT IF(result&gt;0, ‘成功！’, ‘失败！’); # 使用<br>END $</p>
<p>CALL myp4(‘张飞’, ‘8888’)$</p>
<p>创建带out模式的存储过程</p>
<p>案例1：根据女神名，返回对应的男神名</p>
<p>CREATE PROCEDURE myp5(IN beautyname VARCHAR(20), OUT boyname VARCHAR(20))<br>BEGIN<br>SELECT bo.boyname INTO boyname<br>FROM boys bo<br>INNER JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p>
<p>CALL myp5(‘王语嫣’, @bname)$<br>SELECT @bname$</p>
<p>案例2：根据女神名，返回对应的男神名和男神魅力值</p>
<p>CREATE PROCEDURE myp6(IN beautyname VARCHAR(20), OUT boyname VARCHAR(20), OUT usercp INT)<br>BEGIN<br>SELECT bo.boyname, bo.usercp INTO boyname, usercp<br>FROM boys bo<br>INNER JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p>
<p>CALL myp6(‘王语嫣’, @bname, @usercp)$<br>SELECT @bname, @usercp$</p>
<p>创建带inout模式参数的存储过程</p>
<p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p>
<p>CREATE PROCEDURE myp8(INOUT a INT, INOUT b INT)<br>BEGIN<br>SET a=a<em>2;<br>SET b=b</em>2;<br>END $</p>
<p>SET @m=10$<br>SET @n=20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$</p>
<p>练习题</p>
<p>习题1：创建存储过程实现传入用户名和密码，插入到admin表中</p>
<p>CREATE PROCEDURE test_pro1(IN username VARCHAR(20), IN loginpwd VARCHAR(20))<br>BEGIN<br>INSERT INTO admin(admin.<code>username</code>, PASSWORD)<br>VALUES(username, loginpwd);<br>END $</p>
<p>CALL test_pro1(‘litian’, ‘1234’)$<br>SELECT * FROM admin$</p>
<p>习题2：创建存储过程实现传入女神编号，返回女神名称和女神电话</p>
<p>CREATE PROCEDURE test_pro2(IN id INT, OUT NAME VARCHAR(20), OUT phone VARCHAR(20))<br>BEGIN<br>SELECT b.name, b.phone INTO NAME, phone<br>FROM beauty b<br>WHERE b.id=id;<br>END $</p>
<p>SET @n=’’$<br>SET @m=’’$<br>CALL test_pro2(1, @n, @m)$<br>SELECT @m,@n$</p>
<p>习题3：创建存储过程来实现传入两个女神生日，返回大小</p>
<p>CREATE PROCEDURE test_pro3(IN birth1 DATETIME, IN birth2 DATETIME, OUT result INT)<br>BEGIN<br>SELECT DATEDIFF(birth1, birth2) INTO result;<br>END $</p>
<p>CALL test_pro3(‘1990-2-3’, NOW(), @result)$<br>SELECT @result$</p>
<p>存储过程的删除</p>
<p>语法：drop procedure 存储过程名</p>
<p>DROP PROCEDURE myp1;<br>1<br>不能同时删除多个存储过程</p>
<p>查看存储过程的信息</p>
<p>语法：show create procedure 存储过程名</p>
<p>SHOW CREATE PROCEDURE myp2;<br>1<br>不能修改存储过程中的语句，需要修改的话，就删了重写。</p>
<p>练习题</p>
<p>练习题1：创建存储过程实现传入一个日期，格式化成xx年xx月xx日并返回</p>
<p>CREATE PROCEDURE test_pro4(IN mydate DATETIME, OUT strdate VARCHAR(20))<br>BEGIN<br>SELECT DATE_FORMAT(mydate, ‘%y年%m月%d天’) INTO strdate;<br>END $</p>
<p>CALL test_pro4(NOW(), @str)$<br>SELECT @str $</p>
<p>练习题2：创建存储过程实现传入女神名称，返回：女神 and 男神 格式的字符串</p>
<p>CREATE PROCEDURE test_pro5(IN beautyname VARCHAR(20), OUT str VARCHAR(50))<br>BEGIN<br>SELECT CONCAT(beautyname, ‘ and ‘, IFNULL(boyname, ‘null’)) INTO str<br>FROM boys bo<br>RIGHT JOIN beauty b<br>ON b.boyfriend_id=bo.id<br>WHERE b.name=beautyname;<br>END $</p>
<p>CALL test_pro5(‘王语嫣’, @result)$<br>SELECT @result$</p>
<p>练习题3：创建存储过程，根据传入的起始索引和条目数，查询beauty表的记录</p>
<p>CREATE PROCEDURE test_pro6(IN startindex INT, IN size INT)<br>BEGIN<br>SELECT * FROM beauty LIMIT startindex, size;<br>END $</p>
<p>CALL test_pro6(3, 3)$</p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>好处：</p>
<p>提高代码的重用性<br>简化操作<br>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>与存储过程的区别：</p>
<p>存储过程：可以有0个返回，也可以有多个返回（适合做批量插入、更新）<br>函数：有且仅有1个返回（适合处理数据后返回一个结果）<br>创建语法：</p>
<p>create function 函数名（参数列表） returns 返回类型</p>
<p>begin</p>
<p>函数体</p>
<p>end</p>
<p>注意事项：<br>参数列表：包含两部分：参数名 参数类型，注意：没有in，out，inout这种模式了<br>函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议<br>函数体中仅有一句话，则可以省略begin end<br>使用delimiter语句设置结束标记<br>调用语法：select 函数名(参数列表)</p>
<p>无参有返回</p>
<p>案例1：返回公司的员工个数</p>
<p>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN<br>DECLARE c INT DEFAULT 0;# 定义变量<br>SELECT COUNT(*) INTO c# 赋值<br>FROM employees;<br>RETURN c;<br>END $</p>
<p>SELECT myf1()$</p>
<p>有参有返回</p>
<p>案例1：根据员工名，返回他的工资</p>
<p>CREATE FUNCTION myf2(empname VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>SET @sal=0;<br>定义用户变量<br>SELECT salary INTO @sal# 赋值<br>FROM employees<br>WHERE last_name = empname;<br>RETURN @sal;<br>END $</p>
<p>SELECT myf2(‘kochhar’)$</p>
<p>案例2：根据部门名，返回该部门的平均工资</p>
<p>CREATE FUNCTION myf3(deptname VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>DECLARE sal DOUBLE;<br>SELECT AVG(salary) INTO sal<br>FROM employees e<br>JOIN departments d ON e.department_id = d.department_id<br>WHERE d.department_name=deptname;</p>
<p>RETURN sal;<br>END $</p>
<p>SELECT myf3(‘IT’)$</p>
<p>查看函数：</p>
<p>SHOW CREATE FUNCTION myf3;<br>1<br>删除函数：</p>
<p>DROP FUNCTION myf3;<br>1<br>案例1：创建函数，实现传入两个float，返回二者之和</p>
<p>CREATE FUNCTION test_fun1(num1 FLOAT, num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>DECLARE SUM FLOAT DEFAULT 0;<br>SET SUM=num1+num2;<br>RETURN SUM;<br>END $</p>
<p>SELECT test_fun1(1,2)$</p>
<p>流程控制结构<br>分类</p>
<p>顺序结构：结构从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上，重复执行一段代码<br>分支结构</p>
<p>if函数</p>
<p>功能：实现简单的双分支</p>
<p>语法：</p>
<p>select if(表达式1，表达式2，表达式3)</p>
<p>执行顺序：</p>
<p>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值</p>
<p>应用环境：任何地方</p>
<p>case结构</p>
<p>情况1：类似于java中的switch语句，一般用于实现等值判断</p>
<p>语法：</p>
<p>case 变量|表达式|字段</p>
<p>when 要判断的值 then 返回的值1或语句1；</p>
<p>when 要判断的值 then 返回的值2或语句2；</p>
<p>…</p>
<p>else 要返回的值n或语句n；</p>
<p>end case；</p>
<p>情况2：类似于java中的多重if语句，一般用于实现区间判断</p>
<p>语法：</p>
<p>case</p>
<p>when 要判断的条件1 then 返回的值1或语句1；</p>
<p>when 要判断的条件2 then 返回的值2或语句2；</p>
<p>…</p>
<p>else 要返回的值n或语句n；</p>
<p>end case；</p>
<p>特点：</p>
<p>可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end 中，或 begin end 的外面<br>也可以作为独立的语句去使用，只能放在begin end 中<br>如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case<br>如果都不满足，则执行else中的语句或值<br>else可以省略，如果else省略了，并且所有的when条件都不满足，则返回null<br>img</p>
<p>img</p>
<p>案例1：创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：90-100，显示A；80-90：显示B；60-80：显示C；否则显示D</p>
<p>CREATE PROCEDURE test_case(IN score INT)<br>BEGIN<br>CASE<br>WHEN score &gt;= 90 AND score &lt;= 100 THEN SELECT ‘A’;<br>WHEN score &gt;=80 THEN SELECT ‘B’;<br>WHEN score &gt;= 60 THEN SELECT ‘C’;<br>ELSE SELECT ‘D’;<br>END CASE;<br>END $</p>
<p>CALL test_case(95)$</p>
<p>if结构</p>
<p>功能：实现多重分支</p>
<p>语法：</p>
<p>if 条件1 then 语句1；</p>
<p>elseif 条件2 then 语句2；</p>
<p>…</p>
<p>【else 语句n；】</p>
<p>end if；</p>
<p>应用场合：应用在begin end中</p>
<p>案例2：创建存储过程，根据传入的成绩，来返回等级，比如传入的成绩：90-100，返回A；80-90：返回B；60-80：返回C；否则返回D</p>
<p>CREATE FUNCTION test_if(score INT) RETURNS CHAR<br>BEGIN<br>IF score &gt;= 90 AND score &lt;= 100 THEN RETURN ‘A’;<br>ELSEIF score &gt;=80 THEN RETURN ‘B’;<br>ELSEIF score &gt;= 60 THEN RETURN ‘C’;<br>ELSE RETURN ‘D’;<br>END IF;<br>END $</p>
<p>SELECT test_if(86)$</p>
<p>循环结构</p>
<p>分类：while、loop、repeat</p>
<p>循环控制：</p>
<p>iterate：类似于continue，继续；结束本次循环，继续下一次<br>leave：类似于break，跳出；结束当前所在循环<br>while</p>
<p>语法：</p>
<p>[标签：】while 循环条件 do</p>
<p>循环体；</p>
<p>end while 【标签】；</p>
<p>loop</p>
<p>语法：</p>
<p>【标签：】loop</p>
<p>循环体；</p>
<p>end loop 【标签】；</p>
<p>可以用来模拟简单的死循环</p>
<p>repeat</p>
<p>语法：</p>
<p>【标签：】repeat</p>
<p>循环体；</p>
<p>until 结束循环的条件</p>
<p>end repeat【标签】；</p>
<p>对比：</p>
<p>这人三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称<br>loop：一般用于实现简单的死循环<br>while：先判断后执行<br>repeat：先执行后判断，无条件至少执行一次<br>案例1：没有添加循环控制语句</p>
<p>批量插入，根据次数插入到admin表中多条记录</p>
<p>CREATE PROCEDURE pro_while1(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>WHILE i &lt;= insertcount DO<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘Rose’, i), ‘666’);<br>SET i=i+1;<br>END WHILE;<br>END $</p>
<p>CALL pro_while1(100)$<br>SELECT * FROM admin;</p>
<p>案例2：添加leave语句</p>
<p>批量插入，根据次数插入到admin表中20条记录</p>
<p>CREATE PROCEDURE test_while1(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>a:WHILE i &lt;= insertcount DO<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘xiaohua’, i), ‘000’);<br>IF i&gt;=20 THEN LEAVE a;<br>END IF;<br>SET i=i+1;<br>END WHILE a;<br>END $</p>
<p>CALL test_while1(100)$<br>SELECT * FROM admin;</p>
<p>案例3：添加iterate语句</p>
<p>批量插入，根据次数插入到admin表中多条记录，只插入偶数次</p>
<p>CREATE PROCEDURE test_while2(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>a:WHILE i &lt;= insertcount DO<br>SET i=i+1;<br>IF MOD(i,2) != 0 THEN ITERATE a;<br>END IF;<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘xiaohua’, i), ‘000’);<br>END WHILE a;<br>END $</p>
<p>CALL test_while2(100)$<br>SELECT * FROM admin;</p>
<p>案例4：已知表stringcontent，其中字段id 自增长；content varchar(20)，向该表中插入指定个数的随机的字符串</p>
<p>USE test;<br>DROP TABLE IF EXISTS stringcontent;<br>CREATE TABLE stringcontent(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>content VARCHAR(20)<br>);</p>
<p>DELIMITER $<br>CREATE PROCEDURE test_randstr_insert(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;# 定义一个循环变量i，表示插入次数<br>DECLARE str VARCHAR(26) DEFAULT ‘abcdefghijklmnopqrstuvwxyz’;<br>DECLARE startindex INT DEFAULT 1;# 代表起始索引<br>DECLARE len INT DEFAULT 1;# 代表截取的字符的长度<br>WHILE i&lt;=insertcount DO<br>SET len=FLOOR(RAND()*(20-startindex+1)+1);# 产生一个随机的整数，代表截取长度，1-(26-startindex+1)<br>SET startindex=FLOOR(RAND()*26+1);# 产生一个随机的整数，代表起始索引1-26<br>INSERT INTO stringcontent(content) VALUES(SUBSTR(str, startindex, len));<br>SET i=i+1;<br>END WHILE;<br>END $</p>
<p>CALL test_randstr_insert(10)$<br>SELECT * FROM stringcontent;<br>CALL test_randstr_insert(10)$<br>SELECT * FROM stringcontent;</p>
<p>返回该字符的密码形式<br>md5()</p>
<hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">lys-studys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/posts/15411/">http://example.com/posts/15411/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/50097/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Web_spider</div></div></a></div><div class="next-post pull-right"><a href="/posts/39404/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">c-4</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/44296/" title="redis"><img class="cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-22</div><div class="title">redis</div></div></a></div><div><a href="/posts/16097/" title="MySql"><img class="cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-27</div><div class="title">MySql</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By lys-studys</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我们相遇不是意外~ <a target="_blank" rel="noopener" href="https://lys-studys.github.io//">blog</a>!</div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/state/outPortal/loginPortal.action"><img class="icp-icon" src="/img/icp.png"/><span>粵ICP備xxxx</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'K6YAjTUpfqvIIJRgat2mpicY-gzGzoHsz',
      appKey: 'TiK1kxcHhW26MWKdEgTtxWlm',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script><script>(function(d, w, c) {
    w.ChatraID = '';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
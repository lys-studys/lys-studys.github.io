<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌上花开缓缓归</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-26T09:16:10.831Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lys-studys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>海量数据和bit_map</title>
    <link href="http://example.com/posts/56260/"/>
    <id>http://example.com/posts/56260/</id>
    <published>2021-03-26T07:35:50.000Z</published>
    <updated>2021-03-26T09:16:10.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="道海量数据处理"><a href="#道海量数据处理" class="headerlink" title="道海量数据处理"></a>道海量数据处理</h3><h4 id="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"><a href="#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？" class="headerlink" title="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h4><p>方案1; 可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p><ol><li>历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为,这里漏写个了a1）中。这样每个小文件的大约为300M。</li><li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li><li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li></ol><p>方案2:<br>    如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><p>    读者反馈@crowgns：</p><p>hash后要判断每个文件大小，如果hash分的不均衡有文件较大，还应继续hash分文件，换个hash算法第二次再分较大的文件，一直分到没有较大的文件为止。这样文件标号可以用A1-2表示（第一次hash编号为1，文件较大所以参加第二次hash，编号为2）<br>由于1存在，第一次hash如果有大文件，不能用直接set的方法。建议对每个文件都先用字符串自然顺序排序，然后具有相同hash编号的（如都是1-3，而不能a编号是1，b编号是1-1和1-2），可以直接从头到尾比较一遍。对于层级不一致的，如a1，b有1-1，1-2-1，1-2-2，层级浅的要和层级深的每个文件都比较一次，才能确认每个相同的uri。</p><h4 id="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h4><p>方案1:<br>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（,此处有误，更正为b0,b1,b2,b9）。<br>对这10个文件进行归并排序（内排序与外排序相结合）。</p><p>方案2: 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了</p><p>    （读者反馈@店小二：原文第二个例子中：“找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。”由于query会重复，作为key的话，应该使用hash_multimap 。hash_map 不允许key重复。@hywangw:店小二所述的肯定是错的，hash_map(query,query_count)是用来统计每个query的出现次数 又不是存储他们的值 出现一次 把count+1 就行了 用multimap干什么？多谢hywangw）。</p><p>方案3:<br>    与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p><h4 id="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h4><p>方案1:<br>顺序读文件中，对于每个词x，取，然后按照该值存到5000个小文件（记为）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p><h4 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h4><p>方案1: 首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><h4 id="在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。"><a href="#在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。" class="headerlink" title="在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。"></a>在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。</h4><p>方案1: 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32*2bit=1GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p><p>方案2: 也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h4 id="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h4><p>方案1:<br>在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大。<br>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。<br>（更多可以参考：第三章、寻找最小的k个数，以及第三章续、Top K算法问题的实现）</p><p>    读者反馈@QinLeopard：</p><p>第6题的方法中，是不是不能保证每个电脑上的前十条，肯定包含最后频率最高的前十条呢？<br>比如说第一个文件中：A(4), B(5), C(6), D(3)<br>第二个文件中：A(4),B(5),C(3),D(6)<br>第三个文件中: A(6), B(5), C(4), D(3)<br>如果要选Top(1), 选出来的结果是A，但结果应该是B。</p><p>    @July：我想，这位读者可能没有明确提议。本题目中的TOP10是指最大的10个数，而不是指出现频率最多的10个数。但如果说，现在有另外一提，要你求频率最多的 10个，相当于求访问次数最多的10个IP地址那道题，即是本文中上面的第4题。特此说明。</p><h4 id="7-怎么在海量数据中找出重复次数最多的一个？"><a href="#7-怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="7. 怎么在海量数据中找出重复次数最多的一个？"></a>7. 怎么在海量数据中找出重复次数最多的一个？</h4><p>方案1: 先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h4 id="8-上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"><a href="#8-上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。" class="headerlink" title="8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"></a>8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</h4><p>方案1<br>上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成。</p><h4 id="9-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"><a href="#9-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？" class="headerlink" title="9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"></a>9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</h4><p>方案1:<br>这题用trie树比较合适，hash_map也应该能行。</p><h4 id="10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"><a href="#10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。" class="headerlink" title="10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"></a>10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</h4><p>方案1:<br>    这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p><h4 id="11-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"><a href="#11-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。" class="headerlink" title="11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"></a>11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。</h4><p>方案1: 首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。</p><h4 id="12-100w个数中找出最大的100个数。"><a href="#12-100w个数中找出最大的100个数。" class="headerlink" title="12. 100w个数中找出最大的100个数。"></a>12. 100w个数中找出最大的100个数。</h4><p>方案1: 采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w<em>100)。<br>方案2:采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w</em>100)。<br>方案3: 在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p><h4 id="13-寻找热门查询："><a href="#13-寻找热门查询：" class="headerlink" title="13. 寻找热门查询："></a>13. 寻找热门查询：</h4><p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><ol><li><p>请描述你解决这个问题的思路；</p></li><li><p>请给出主要的处理流程，算法，以及算法的复杂度。</p></li></ol><p>方案1: 采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><p>    关于此问题的详细解答，请参考此文的第3.1节：第三章续、Top K算法问题的实现。</p><h4 id="14-一共有N个机器，每个机器上有N个数。每个机器最多存O-N-个数并对它们操作。如何找到N-2个数中的中数？"><a href="#14-一共有N个机器，每个机器上有N个数。每个机器最多存O-N-个数并对它们操作。如何找到N-2个数中的中数？" class="headerlink" title="14. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数中的中数？"></a>14. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数中的中数？</h4><p>方案1: 先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有2^32个）。我们把0到2^32-1的整数划分为N个范围段，每个段包含（2^32）/N个整数。比如，第一个段位0到2^32/N-1，第二段为（2^32）/N到（2^32）/N-1，…，第N个段为（2^32）（N-1）/N到2^32-1。然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于（N^2）/2，而在第k-1个机器上的累加数小于（N^2）/2，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第（N^2）/2-x位。然后我们对第k个机器的数排序，并找出第（N^2）/2-x个数，即为所求的中位数的复杂度是O（N^2）的。</p><p>方案2: 先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第（N^2）/2个便是所求。复杂度是O（N^2*lgN^2）的。</p><h4 id="15-最大间隙问题"><a href="#15-最大间隙问题" class="headerlink" title="15. 最大间隙问题"></a>15. 最大间隙问题</h4><p>给定n个实数，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。</p><p>方案1:<br>最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：</p><p>找到n个数据中最大和最小数据max和min。<br>用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为，且桶i 的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为：。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为），且认为将min放入第一个桶，将max放入第n-1个桶。<br>将n个数放入n-1个桶中：将每个元素x[i] 分配到某个桶（编号为index），其中（这括号里多了个“+”），并求出分到每个桶的最大最小数据。<br>最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶i的上界和桶j的下界之间产生j&gt;=i+1。一遍扫描即可完成。</p><h4 id="16-将多个集合合并成没有交集的集合"><a href="#16-将多个集合合并成没有交集的集合" class="headerlink" title="16. 将多个集合合并成没有交集的集合"></a>16. 将多个集合合并成没有交集的集合</h4><p>    给定一个字符串的集合，格式如：。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出。</p><p>(1) 请描述你解决这个问题的思路；</p><p>(2) 给出主要的处理流程，算法，以及算法的复杂度；</p><p>(3) 请描述可能的改进。</p><p>方案17:<br>采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于，首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。</p><h4 id="17-最大子序列与最大子矩阵问题"><a href="#17-最大子序列与最大子矩阵问题" class="headerlink" title="17. 最大子序列与最大子矩阵问题"></a>17. 最大子序列与最大子矩阵问题</h4><p>数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。</p><p>方案1:<br>    这个问题可以动态规划的思想解决。设b[i]表示以第i个元素a[i]结尾的最大子序列，那么显然。基于这一点可以很快用代码实现。</p><p>最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。</p><p>方案2: 可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。</p><p> </p><h3 id="第二部分、海量数据处理之Bti-map详解"><a href="#第二部分、海量数据处理之Bti-map详解" class="headerlink" title="第二部分、海量数据处理之Bti-map详解"></a>第二部分、海量数据处理之Bti-map详解</h3><p>    Bloom Filter已在上一篇文章海量数据处理之Bloom Filter详解中予以详细阐述，本文接下来着重阐述Bit-map。有任何问题，欢迎不吝指正。</p><p>什么是Bit-map<br>    所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>    如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：)</p><p>    然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0×01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一（如下图）：</p><p>      </p><p>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：</p><p>然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。下面的代码给出了一个BitMap的用法：排序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义每个Byte中有8个Bit位</span><br><span class="line">#include ＜memory.h＞</span><br><span class="line">#define BYTESIZE 8</span><br><span class="line">void SetBit(char *p, int posi)</span><br><span class="line">&#123;</span><br><span class="line">for(int i&#x3D;0; i ＜ (posi&#x2F;BYTESIZE); i++)</span><br><span class="line">&#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">*p &#x3D; *p|(0x01＜＜(posi%BYTESIZE));&#x2F;&#x2F;将该Bit位赋值1</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void BitMapSortDemo()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;为了简单起见，我们不考虑负数</span><br><span class="line">int num[] &#x3D; &#123;3,5,2,10,6,12,8,14,9&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;BufferLen这个值是根据待排序的数据中最大值确定的</span><br><span class="line">&#x2F;&#x2F;待排序中的最大值是14，因此只需要2个Bytes(16个Bit)</span><br><span class="line">&#x2F;&#x2F;就可以了。</span><br><span class="line">const int BufferLen &#x3D; 2;</span><br><span class="line">char *pBuffer &#x3D; new char[BufferLen];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;要将所有的Bit位置为0，否则结果不可预知。</span><br><span class="line">memset(pBuffer,0,BufferLen);</span><br><span class="line">for(int i&#x3D;0;i＜9;i++)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;首先将相应Bit位上置为1</span><br><span class="line">SetBit(pBuffer,num[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;输出排序结果</span><br><span class="line">for(int i&#x3D;0;i＜BufferLen;i++)&#x2F;&#x2F;每次处理一个字节(Byte)</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;0;j＜BYTESIZE;j++)&#x2F;&#x2F;处理该字节中的每个Bit位</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;判断该位上是否是1，进行输出，这里的判断比较笨。</span><br><span class="line">&#x2F;&#x2F;首先得到该第j位的掩码（0x01＜＜j），将内存区中的</span><br><span class="line">&#x2F;&#x2F;位和此掩码作与操作。最后判断掩码是否和处理后的</span><br><span class="line">&#x2F;&#x2F;结果相同</span><br><span class="line">if((*pBuffer&amp;(0x01＜＜j)) &#x3D;&#x3D; (0x01＜＜j))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,i*BYTESIZE + j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pBuffer++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">BitMapSortDemo();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p><p>基本原理及要点<br>使用bit数组来表示某些元素是否存在，比如8位电话号码</p><p>扩展<br>Bloom filter可以看做是对bit-map的扩展（关于Bloom filter，请参见：海量数据处理之Bloom filter详解）。</p><p>问题实例<br>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</p><p>    8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）</p><p>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p><p>    将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p><p>参考：</p><p><a href="http://www.cnblogs.com/youwang/archive/2010/07/20/1781431.html%E3%80%82">http://www.cnblogs.com/youwang/archive/2010/07/20/1781431.html。</a><br><a href="http://blog.redfox66.com/post/2010/09/26/mass-data-4-bitmap.aspx%E3%80%82">http://blog.redfox66.com/post/2010/09/26/mass-data-4-bitmap.aspx。</a><br>完。</p><p>版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明.<br>原文链接：<a href="https://blog.csdn.net/v_july_v/article/details/6685962">https://blog.csdn.net/v_july_v/article/details/6685962</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>支持亿级io底层基石epoll实战揭秘</title>
    <link href="http://example.com/posts/36817/"/>
    <id>http://example.com/posts/36817/</id>
    <published>2021-03-24T06:19:34.000Z</published>
    <updated>2021-03-24T11:18:47.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>绝大部分linux服务器，基本上会用到epoll.</p><h3 id="epoll是什么"><a href="#epoll是什么" class="headerlink" title="epoll是什么?"></a>epoll是什么?</h3><ol><li>io管理组件.</li><li>高性能.是select/poll的升级版本.</li><li>epoll用在什么地方?</li><li>和ntyco协程框架有什么关联?<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4>只要客户端对服务器进行一次tcp连接，就会产生一次io,如果十万个客户端同时对服务端建立连接，服务端就会产生十万socket，没连接一次就会产生一个io,就会产生十万个io,这时候就需要有个东西来管理它(十万个io)，(比如我怎么知道他来了数据呢?)<br>例子: 比如收快递用的蜂巢，当小哥把快递放到蜂巢，蜂巢就是统一管理快递的组件，所以说每个快递就好比一个io,蜂巢对应的就是管理io的组件,当蜂巢收到一个快递的时候，蜂巢就会通知用户来取这个快递，io的管理跟这个功能相似（io管理用来存fd的）.io多路复用，说明不只是你一个io，而是管理多个io.</li></ol><h4 id="epoll的产生-解决什么问题"><a href="#epoll的产生-解决什么问题" class="headerlink" title="epoll的产生(解决什么问题)"></a>epoll的产生(解决什么问题)</h4><p>如果没有多线程没有io管理，我们如何做一个服务器????</p><p>最初采用信号: 数据到达通过发送一个信号通知我们(这个信号-＞sigio现在还在沿用).性能极低，一两个客户端是没有问题的，一般用udp(因为udp以一个服务器为主)。</p><p>后来产生了线程:(几百个几千个服务端也是可用的，写代码非常简单)<br>    如果有线程没有io管理的情况该怎么做????<br>    一请求一线程: 当每一个accept来的时候(accept出现返回值的时候)就创建一个线程.当客户端退出的时候，这个线程也随之关闭，非常简单。每个线程读一个(是同步的).</p><p>有没有一些web服务器在用呢??<br>Apache服务器在用一请求一线程这种方式.</p><p>这种方式的弊端在哪里???<br>注定做不了很大的用户量，一个线程占用8MB的内存。吃内存.所以是不行的.</p><p>还有一种方式类似，是一请求一进程的方式:(叫做CGI)随着用户量多起来，并不好管理.</p><p>后续出现了select(io统一的管理)<br>select(maxfd. rset, wset, eset, timeout);</p><ol><li>maxfd表示最大的fd比如1,2,3,4,5 表示5, 比如2, 3, 4, 5, 6表示6.</li><li>rset是否可读</li><li>wset是否可写</li><li>eset是否有错误</li><li>timeout多长时间轮循一次.(多长时间检查一次)</li></ol><p>poll跟select类似。</p><p>现在来到了epoll跟蜂巢的概念一模一样的，</p><p>epoll真的能支持亿级并发吗?<br>epoll_creat(EPOLL_SIZE); EPOLL_SIZE只有零和一的区别，写10000也是和一同样的功能.<br>为零，表示什么用都没，不为零就能正常创建epoll.</p><p>epoll_wait(epoll_fd, events, EPOLL_SIZE, -1);<br>相当于蜂巢工作人员收快递，events相当于那个袋子,多长时间去一次，-1不是毫秒也不是啥，就不是一个准确的时间，表示有io才去取，没有io就一直阻塞.等于零表示一直没有，没有就直接过，如果大于零，随便一个数表示等待send.</p><p>水平触发和边沿触发问题????谁在什么时候触发????</p><p>触发: 是由tcp协议栈触发的,</p><ol><li>一次性触发。</li><li>一个事件没处理完一直触发.</li><li>对应的是水平触发: </li><li>对应的是边沿触发:<br>这里和长连接和短连接没有什么关系.</li></ol><p>问题: accept发生在epoll_wait之后吗?</p><p>当epoll_wait阻塞在一个地方的时候，如何解除阻塞的呢?<br>通过回调函数，协议栈通过epoll这个模块，通过调用回调函数来解除epoll_wait,这里tcp通过回调，这个回调叫做colback，回调到哪里呢?回调到epoll里边，来解除epoll_wait的阻塞状态.<br>所以上边的问题，是对的，只有epoll_wait被触发之后，才能进行数据的收取.这样才能判断fd是listen的还是我们程序本身的.</p><p>以下四种对epoll的做法都是不一样的，所以对应的方式也是不一样的.</p><ol><li>单线程可不可以做epoll? -&gt; redis.</li><li>多线程可不可以做epoll? -&gt; nattyserver(服务器的框架).</li><li>多核做epoll? -&gt; ntyco</li><li>多进程做epoll? -&gt; nginx</li></ol><p>redis单线程为何这么快?<br>redis:<br>    1. 纯内存的操作.(没有那些io,本身就很快).<F5><br>    2. 单线程是说的一个线程里边才有epoll,别的线程没有，也就是说没有线程之间的切换，加锁等操作.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++函数对象-sort排序规则</title>
    <link href="http://example.com/posts/53699/"/>
    <id>http://example.com/posts/53699/</id>
    <published>2021-03-23T03:21:48.000Z</published>
    <updated>2021-03-23T12:53:04.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="函数对象类由来"><a href="#函数对象类由来" class="headerlink" title="函数对象类由来"></a>函数对象类由来</h3><p>如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名.</p><p>函数对象的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CAverage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    double operator()(int a1, int a2, int a3)</span><br><span class="line">    &#123;  &#x2F;&#x2F;重载()运算符</span><br><span class="line">        return (double)(a1 + a2 + a3) &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CAverage average;  &#x2F;&#x2F;能够求三个整数平均数的函数对象</span><br><span class="line">    cout &lt;&lt; average(3, 2, 3);  &#x2F;&#x2F;等价于 cout &lt;&lt; average.operator(3, 2, 3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">程序的输出结果是：</span><br><span class="line">2. 66667</span><br><span class="line"></span><br><span class="line">()是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</span><br><span class="line"></span><br><span class="line">average 是一个对象，average(3, 2, 3) 实际上就是 average.operator(3, 2, 3)，这使得 average 看上去像函数的名字，故称其为函数对象。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="函数对象应用实例1-在-accumulate-算法中的应用"><a href="#函数对象应用实例1-在-accumulate-算法中的应用" class="headerlink" title="函数对象应用实例1:在 accumulate 算法中的应用"></a>函数对象应用实例1:在 accumulate 算法中的应用</h3><p>STL 中有以下实现“累加”功能的算法(函数模板):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template &lt;class InIt, class T, class Pred&gt;</span><br><span class="line">T accumulate(InIt first, InIt last, T val, Pred op);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下：该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下:                                                                                                             </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class InIt, class T, class Pred&gt;</span><br><span class="line">T accumulate(InIt first, Init last, T init, Pred op)</span><br><span class="line">&#123;</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此模板被实例化后，op(init, *first)必须要有定义，则 op 只能是函数指针或者函数对象。因此调用该 accmulate 模板时，形参 op 对应的实参只能是函数名、函数指针或者函数对象。</p><p>下面的程序通过 accumulate 模板求一个 vector 中元素的平方和，其中用到了函数对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt; &#x2F;&#x2F;accumulate 在此头文件定义</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintInterval(T first, T last)</span><br><span class="line">&#123; &#x2F;&#x2F;输出区间[first,last)中的元素</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int SumSquares(int total, int value)</span><br><span class="line">&#123;</span><br><span class="line">    return total + value * value;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class SumPowers</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int power;</span><br><span class="line">public:</span><br><span class="line">    SumPowers(int p) :power(p) &#123; &#125;</span><br><span class="line">    const T operator() (const T &amp; total, const T &amp; value)</span><br><span class="line">    &#123; &#x2F;&#x2F;计算 value的power次方，加到total上</span><br><span class="line">        T v &#x3D; value;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; power - 1; ++i)</span><br><span class="line">            v &#x3D; v * value;</span><br><span class="line">        return total + v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int SIZE &#x3D; 10;</span><br><span class="line">    int a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;</span><br><span class="line">    vector&lt;int&gt; v(a1, a1 + SIZE);</span><br><span class="line">    cout &lt;&lt; &quot;1) &quot;; PrintInterval(v.begin(), v.end());</span><br><span class="line">    int result &#x3D; accumulate(v.begin(), v.end(), 0, SumSquares);</span><br><span class="line">    cout &lt;&lt; &quot;2) 平方和：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    result &#x3D; accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(3));</span><br><span class="line">    cout &lt;&lt; &quot;3) 立方和：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    result &#x3D; accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(4));</span><br><span class="line">    cout &lt;&lt; &quot;4) 4次方和：&quot; &lt;&lt; result;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">1)1 2 3 4 5 6 7 8 9 10</span><br><span class="line">2)平方和:385</span><br><span class="line">3)立方和3025</span><br><span class="line">4)4次方和:25333</span><br></pre></td></tr></table></figure><p>上述函数的倒数第八行，第四个参数是 SumSquares 函数的名字。函数名字的类型是函数指针，因此本行将 accumulate 模板实例化后得到的模板函数定义如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int accumulate(vector &lt;int&gt;::iterator first, vector &lt;int&gt;::iterator last, int init, int(*op)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">for (; first !&#x3D; last; ++first)</span><br><span class="line">    init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure><p>形参 op 是一个函数指针，而op(init, *first)就调用了指针 op 指向的函数，在第 37 行的情况下就是函数 SumSquares。</p><p>第 39 行，第四个参数是 SumPowers<int>(3)。SumPowers 是类模板的名字，SumPowers<int> 就是类的名字。类的名字后面跟着构造函数的参数列表，就代表一个临时对象。因此 SumPowers<int>(3) 就是一个 SumPowers<int> 类的临时对象。</p><p>编译器在编译此行时，会将 accumulate 模板实例化成以下函数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int accumulate(vector&lt;int&gt;::iterator first, vector&lt;int&gt;::iterator last, int init, SumPowers&lt;int&gt; op)</span><br><span class="line">&#123;</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参 op 是一个函数对象，而op(init, *first)等价于：<br>op.operator()(init, *first);</p><p>即调用了 SumPowers<int> 类的 operator() 成员函数。</p><p>对比 SumPowers 和 SumSquares 可以发现，函数对象的 operator() 成员函数可以根据对象内部的不同状态执行不同操作，而普通函数就无法做到这一点。因此函数对象的功能比普通函数更强大。</p><h3 id="函数对象应用实例2：在sort算法中的应用"><a href="#函数对象应用实例2：在sort算法中的应用" class="headerlink" title="函数对象应用实例2：在sort算法中的应用"></a>函数对象应用实例2：在sort算法中的应用</h3><p>STL 中的排序模板 sort 能将区间从小到大排序。sort 算法有两个版本。第一个版本的原型如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class_Randlt&gt;</span><br><span class="line">void sort(_Randlt first, _RandIt last);</span><br></pre></td></tr></table></figure><p>该模板可以用来将区间 [first, last) 中的元素从小到大排序，要求 first、last 是随机访问迭代器。元素比较大小是用&lt;进行的。如果表达式a&lt;b的值为 true，则 a 排在 b 前面；如果a&lt;b的值为 false，则 b 未必排在 a 前面，还要看b&lt;a是否成立，成立的话 b 才排在 a 前面。要使用这个版本的 sort 算法，待排序的对象必须能用&lt;运算符进行比较。</p><p>sort 算法第二个版本的原型如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class_Randlt, class Pred&gt;</span><br><span class="line">void sort(_Randlt first, _RandIt last, Pred op);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个版本和第一个版本的差别在于，元素 a、b 比较大小是通过表达式op(a, b)进行的。如果该表达式的值为 true，则 a 比 b 小；如果该表达式的值为 false，也不能认为 b 比 a 小，还要看op(b, a)的值。总之，op 定义了元素比较大小的规则。下面是一个使用 sort 算法的例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;  &#x2F;&#x2F;sort算法在此头文件中定义</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Printlnterva1(T first, T last)</span><br><span class="line">&#123;  &#x2F;&#x2F;用以输出 [first, last) 区间中的元素</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) : v(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool operator &lt; (const A &amp; a1, const A &amp; a2)</span><br><span class="line">&#123;  &#x2F;&#x2F;重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错</span><br><span class="line">    return a1.v &lt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line">bool GreaterA(const A &amp; a1, const A &amp; a2)</span><br><span class="line">&#123;  &#x2F;&#x2F;v值大的元素作为较小的数</span><br><span class="line">    return a1.v &gt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line">struct LessA</span><br><span class="line">&#123;</span><br><span class="line">    bool operator() (const A &amp; a1, const A &amp; a2)</span><br><span class="line">    &#123;  &#x2F;&#x2F;v的个位数小的元素就作为较小的数</span><br><span class="line">        return (a1.v % 10) &lt; (a2.v % 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; operator &lt;&lt; (ostream &amp; o, const A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    o &lt;&lt; a.v;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a1[4] &#x3D; &#123; 5, 2, 4, 1 &#125;;</span><br><span class="line">    A a2[5] &#x3D; &#123; 13, 12, 9, 8, 16 &#125;;</span><br><span class="line">    sort(a1, a1 + 4);</span><br><span class="line">    cout &lt;&lt; &quot;1)&quot;; Printlnterva1(a1, a1 + 4);  &#x2F;&#x2F;输出 1)1 2 4 5</span><br><span class="line">    sort(a2, a2 + 5);  &#x2F;&#x2F;按v的值从小到大排序</span><br><span class="line">    cout &lt;&lt; &quot;2)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 2)8 9 12 13 16</span><br><span class="line">    sort(a2, a2 + 5, GreaterA);  &#x2F;&#x2F;按v的值从大到小排序</span><br><span class="line">    cout &lt;&lt; &quot;3)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 3)16 13 12 9 8</span><br><span class="line">    sort(a2, a2 + 5, LessA());  &#x2F;&#x2F;按v的个位数从小到大排序</span><br><span class="line">    cout &lt;&lt; &quot;4)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 4)12 13 16 8 9</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译至第 45 行时，编译器将 sort 实例化得到的函数原型如下：<br>void sort(A* first, A* last, bool (*op)(const A &amp;, const A &amp;) );</p><p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中 op 指向 GreaterA,因此就用 GreaterA 定义的规则来比较大小。</p><p>编译至第 47 行时，编译器将 sort 实例化得到的函数原型如下：<br>void sort( A* first, A* last, LessA op);</p><p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中，op(a, b) 等价于 op.opeartor(a, b)，因此就用 LessA 定义的规则来比较大小。</p><p>STL 中定义了一些函数对象类模板，都位于头文件 functional 中。例如，greater 模板的源代码如下：<br>template <class T><br>struct greater<br>{<br>    bool operator()(const T&amp; x, const T&amp; y) const{<br>        return x &gt; y;<br>    }<br>};<br>假设有以下数组：<br>int a[4] = {3, 5, 34, 8};</p><p>要将该数组从大到小排序，则只需写：<br>sort( a, a+4, greater<int>() );</p><p>要使用 greater 模板，须确保&gt;运算符本来就有定义，或经过了适当的重载。</p><p>list 容器的 sort 成员能将元素从小到大排序。它也有两个版本：一个是没有参数的函数，比较大小用&lt;运算符；另一个是函数模板，原型如下：<br>template <class Pred><br>void sort(Pred op);</p><p>sort 函数允许自定义比较大小的规则，即 op(x, y) 为真就认为 x 比 y 小。例如，假设有：<br>list<int> lst;</p><p>如果希望将 lst 中的元素按其整数数值从大到小排序，只需写：<br>lst.sort( greater<int>() );</p><p>在使用关联容器和许多算法时，都可以用函数对象来定义比较大小的规则，以及其他一些规则和操作。</p><h3 id="STL-中的函数对象类模板"><a href="#STL-中的函数对象类模板" class="headerlink" title="STL 中的函数对象类模板"></a>STL 中的函数对象类模板</h3><p>函数对象类模板    成员函数 T operator ( const T &amp; x, const T &amp; y) 的功能<br>plus <T>    return x + y;<br>minus &lt; &gt;    return x - y;<br>multiplies <T>    return x * y;<br>divides <T>    return x / y;<br>modulus <T>    return x % y;<br>     成员函数 bool operator( const T &amp; x, const T &amp; y) 的功能<br>equal_to <T>    return x == y;<br>not_equal_to <T>    return x! = y;<br>greater <T>    return x &gt; y;<br>less <T>    return x &lt; y;<br>greater_equal <T>    return x &gt; = y;<br>less_equal <T>    return x &lt;= y;<br>logical_and <T>    return x &amp;&amp; y;<br>logical_or <T>    return x || y;<br>     成员函数 T operator( const T &amp; x) 的功能<br>negate <T>    return - x;<br>     成员函数 bool operator( const T &amp; x) 的功能<br>logical_not <T>    return ! x;<br>例如，如果要求两个 double 型变量 x、y 的乘积，可以写：<br>multiplies<double> () (x, y)</p><p>less 是 STL 中最常用的函数对象类模板，其定义如下：<br>template <class_Tp><br>struct less<br>{<br>    bool operator() (const_Tp &amp; __x, const_Tp &amp; __y) const<br>    { return __x &lt; __y; }<br>};<br>要判断两个 int 变量 x、y 中 x 是否比 y 小，可以写：<br>if( less<int>()(x, y) ) { … }</p><p>引入函数对象后 STL 中的“大”、“小”和“相等”概念<br>前面提到过，默认情况下，STL 中的容器和算法比较元素的大小是通过&lt;运算符进行的。通过 10.3.4 节可知，sort 和 list::sort 都可以通过一个函数对象或函数自定义比较元素大小的规则。例如以下的 sort 版本：<br>template &lt;class_RandIt, class Pred&gt;<br>void sort(_RandIt first, _RandIt last, Pred op);</p><p>实际调用 sort 时，和 op 对应的实参可以是一个函数对象或者函数的名字。sort 在执行过程中用 op(x, y) 比较 x 和 y 的大小，因此可以将 op 称为自定义的“比较器”。</p><p>关联容器中的元素是从小到大排序的。使用关联容器时，也可以用自定义的比较器取代&lt;运算符，以规定元素之间的大小关系。STL 中还有许多算法都可以自定义比较器。在自定义比较器 op 的情况下，以下三种说法是等价的：<br>x 小于 y。<br>op(x, y) 的返回值为 true。<br>y 大于 x。</p><p>重点:<br>经过自己的测试，每两个数要比较两次<br>A 与 B 比较 return true 说明A比B小 A 排在B的前面<br>B 与 A 比较 return true 说明B比A小 B 排在A的前面<br>so 这就是问题 到底是A大还是B大？？</p><p>我以前一直这样记忆：<br>return true ==== 说明第一个参数排在第二个参数前面<br>return false ==== 说明第一个参数排在第二个参数后面<br>其实这样记忆没有错 but<br>sort函数的潜规则就是：<br>如果两个数相等 必须返回false<br>————————————————</p><h3 id="STL-sort-函数实现详解"><a href="#STL-sort-函数实现详解" class="headerlink" title="STL sort 函数实现详解"></a>STL sort 函数实现详解</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>#include <algorithm></p><p>template&lt; class RandomIt &gt;<br>void sort( RandomIt first, RandomIt last );</p><p>template&lt; class RandomIt, class Compare &gt;<br>void sort( RandomIt first, RandomIt last, Compare comp );<br>使用方法非常简单，STL提供了两种调用方式，一种是使用默认的&lt;操作符比较，一种可以自定义比较函数。可是为什么它通常比我们自己写的排序要快那么多呢？</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>原来，STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p><p>普通的快速排序<br>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p><p>如果S中的元素只有0个或1个，结束。<br>取S中的任何一个元素作为枢轴pivot。<br>将S分割为L、R两端，使L内的元素都小于等于pivot，R内的元素都大于等于pivot。<br>对L、R递归执行上述过程。<br>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称为median-of-three，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p><p>分割的方法通常采用两个迭代器head和tail，head从头端往尾端移动，tail从尾端往头端移动，当head遇到大于等于pivot的元素就停下来，tail遇到小于等于pivot的元素也停下来，若head迭代器仍然小于tail迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p><p>看一张来自维基百科上关于快速排序的动态图片，帮助理解。</p><p>内省式排序 Introsort<br>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 O(n2)。David R.Musser于1996年提出一种混合式排序算法：Introspective Sorting（内省式排序），简称IntroSort，其行为大部分与上面所说的median-of-three Quick Sort完全相同，但是当分割行为有恶化为二次方的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 O(nlgn)，又比一开始就使用堆排序来得好。</p><p>代码分析<br>下面是完整的SGI STL sort()源码（使用默认&lt;操作符版）</p><p>template <class _RandomAccessIter><br>inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {<br>  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);<br>  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,<br>                 _LessThanComparable);<br>  if (__first != __last) {<br>    __introsort_loop(__first, __last,<br>                     __VALUE_TYPE(__first),<br>                     __lg(__last - __first) * 2);<br>    __final_insertion_sort(__first, __last);<br>  }<br>}<br>其中，__introsort_loop便是上面介绍的内省式排序，其第三个参数中所调用的函数__lg()便是用来控制分割恶化情况，代码如下：</p><p>template <class Size><br>inline Size __lg(Size n) {<br>    Size k;<br>    for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;<br>    return k;<br>}<br>即求lg(n)（取下整），意味着快速排序的递归调用最多 2*lg(n) 层。</p><p>内省式排序算法如下：</p><p>template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;<br>void __introsort_loop(_RandomAccessIter __first,<br>                      _RandomAccessIter __last, _Tp*,<br>                      _Size __depth_limit)<br>{<br>  while (__last - __first &gt; __stl_threshold) {<br>    if (__depth_limit == 0) {<br>      partial_sort(__first, __last, __last);<br>      return;<br>    }<br>    –__depth_limit;<br>    _RandomAccessIter __cut =<br>      __unguarded_partition(__first, __last,<br>                            _Tp(__median(*__first,<br>                                         <em>(__first + (__last - __first)/2),<br>                                         *(__last - 1))));<br>    __introsort_loop(__cut, __last, (_Tp</em>) 0, __depth_limit);<br>    __last = __cut;<br>  }<br>}</p><ol><li>首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。</li><li>若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。</li><li>若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。__unguarded_partition()函数采用的便是上面所讲的使用两个迭代器的方法，代码如下：<br>template &lt;class _RandomAccessIter, class _Tp&gt;<br>_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, <pre><code>                                 _RandomAccessIter __last,                                  _Tp __pivot) </code></pre>{<br> while (true) {<pre><code> while (*__first &lt; __pivot)     ++__first; --__last; while (__pivot &lt; *__last)     --__last; if (!(__first &lt; __last))     return __first; iter_swap(__first, __last); ++__first;</code></pre> }<br>}</li><li>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。<br>递归上述过程，直到元素规模小于__stl_threshold，然后返回sort函数，对整个元素序列调用一次插入排序，此时序列中的元素已基本有序，所以插入排序也很快。至此，整个sort函数运行结束。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lambda</title>
    <link href="http://example.com/posts/65250/"/>
    <id>http://example.com/posts/65250/</id>
    <published>2021-03-21T06:53:13.000Z</published>
    <updated>2021-03-21T08:03:48.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="由来（要解决什么问题）"><a href="#由来（要解决什么问题）" class="headerlink" title="由来（要解决什么问题）"></a>由来（要解决什么问题）</h3><p>使用STL时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。<br>对于只使用一次的函数对象类，能否直接在使用它的地方定义呢？Lambda表达式能够解决这个问题。使用Lambda表达式可以减少程序中函数对象类的数量，使得程序更加优雅。</p><h3 id="lambda表达式的定义形式如下"><a href="#lambda表达式的定义形式如下" class="headerlink" title="lambda表达式的定义形式如下"></a>lambda表达式的定义形式如下</h3><p>[部变量访问方式说明符] (参数表) -&gt; 返回值类型<br>{<br>   语句块<br>}</p><p>下面是一个合法的Lambda表达式：<br>[=] (int x, int y) -&gt; bool {return x%10 ＜ y%10;}</p><p>Lambda 表达式实际上是一个函数，只是它没有名字。下面的程序段使用了上面的 Lambda 表达式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[4] &#x3D; &#123;11, 2, 33, 4&#125;;</span><br><span class="line">sort(a, a+4, [&#x3D;](int x, int y) -&gt; bool &#123; return x%10 &lt; y%10; &#125; ); &#x2F;&#x2F; 带-&gt;函数返回值的</span><br><span class="line">for_each(a, a+4, [&#x3D;](int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125; ); &#x2F;&#x2F; 省略-&gt;函数返回值的。</span><br><span class="line"></span><br><span class="line">这段程的输出结果是：</span><br><span class="line">11 2 33 4</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ol><li>程序第 2 行使得数组 a 按个位数从小到大排序。具体的原理是：sort 在执行过程中，需要判断两个元素 x、y 的大小时，会以 x、y 作为参数，调用 Lambda 表达式所代表的函数，并根据返回值来判断 x、y 的大小。这样，就不用专门编写一个函数对象类了。这里的外部传入的x， y<br>不能被改变，否则编译报错的.</li><li>for_each 的第 3 个参数是一个 Lambda 表达式。for_each 执行过程中会依次以每个元素作为参数调用它，因此每个元素都被输出。这里的x也不允许被改变的.</li></ol><h4 id="外部变量访问方式说明符"><a href="#外部变量访问方式说明符" class="headerlink" title="[外部变量访问方式说明符]"></a>[外部变量访问方式说明符]</h4><p>外部变量: 一般指定义在{}作用域外边的变量，参数的话跟正常函数一样，传引用和传值的区别.<br>“外部变量访问方式说明符”可以是=或&amp;，表示{}中用到的、定义在{}外面的变量在{}中是否允许被改变。=表示不允许，&amp;表示允许。当然，在{}中也可以不使用定义在外面的变量。</p><p>实际上，“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。例如：</p><ol><li>[=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；</li><li>[&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。</li></ol><h4 id="参数表"><a href="#参数表" class="headerlink" title="(参数表)"></a>(参数表)</h4><p>跟普通的函数参数的形式一样。</p><h4 id="gt-返回值类型"><a href="#gt-返回值类型" class="headerlink" title="-&gt;返回值类型"></a>-&gt;返回值类型</h4><p>“-&gt; 返回值类型”可以省略。</p><h4 id="语句块"><a href="#语句块" class="headerlink" title="{语句块}"></a>{语句块}</h4><p>正常函数书写形式一样。</p><h4 id="用到外部变量-外部变量改变"><a href="#用到外部变量-外部变量改变" class="headerlink" title="用到外部变量(外部变量改变)"></a>用到外部变量(外部变量改变)</h4><p>程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[4] &#x3D; &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">    int total &#x3D; 0;</span><br><span class="line">    for_each(a, a + 4, [&amp;](int &amp; x) &#123; total +&#x3D; x; x *&#x3D; 2; &#125;);</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;  &#x2F;&#x2F;输出 10</span><br><span class="line">    for_each(a, a + 4, [&#x3D;](int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">10</span><br><span class="line">2 4 6 8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[&amp;]表示该 Lambda 表达式中用到的外部变量 total 是传引用的，其值可以在表达式执行过程中被改变（如果使用[=]，编译无法通过）。该 Lambda 表达式每次被 for_each 执行时，都将 a 中的一个元素累加到 total 上，然后将该元素加倍。</p><h4 id="最终程序"><a href="#最终程序" class="headerlink" title="最终程序"></a>最终程序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;   </span><br><span class="line">    int x &#x3D; 100,y&#x3D;200,z&#x3D;300;</span><br><span class="line">    auto ff  &#x3D; [&#x3D;,&amp;y,&amp;z](int n) &#123;</span><br><span class="line">        cout &lt;&lt;x &lt;&lt; endl;</span><br><span class="line">        y++; z++;</span><br><span class="line">        return n*n;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; ff(15) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; &quot;,&quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">100</span><br><span class="line">225</span><br><span class="line">201, 301</span><br></pre></td></tr></table></figure><p>定义了一个变量 ff，ff 的类型是 auto，表示由编译器自动判断其类型（这也是 C++11 的新特性）。本行将一个 Lambda 表达式赋值给 ff，以后就可以通过 ff 来调用该 Lambda 表达式了。<br>通过 ff，以 15 作为参数 n 调用上面的 Lambda 表达式。该 Lambda 表达式指明，对于外部变量 y、z，可以修改其值；对于其他外部变量，例如 x，不能修改其值。因此在该表达式执行时，可以修改外部变量 y、z 的值，但如果出现试图修改 x 值的语句，就会编译出错。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>algorithm-实现</title>
    <link href="http://example.com/posts/4524/"/>
    <id>http://example.com/posts/4524/</id>
    <published>2020-12-31T06:56:51.000Z</published>
    <updated>2021-01-25T12:13:38.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STL库剖析</title>
    <link href="http://example.com/posts/4515/"/>
    <id>http://example.com/posts/4515/</id>
    <published>2020-12-31T05:07:27.000Z</published>
    <updated>2021-01-25T12:13:38.777Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/Rane/p/12635027.html">先参考网站</a></p><h3 id="STL标准模板类库"><a href="#STL标准模板类库" class="headerlink" title="STL标准模板类库"></a>STL标准模板类库</h3><p>分为三部分:<br>    1. 容器: 对数据结构的封装<br>    2. 算法:<br>    3. 迭代器</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="STL库" scheme="http://example.com/categories/STL%E5%BA%93/"/>
    
    
    <category term="STL库" scheme="http://example.com/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>leedcode-链表中等</title>
    <link href="http://example.com/posts/17385/"/>
    <id>http://example.com/posts/17385/</id>
    <published>2020-12-30T02:54:10.000Z</published>
    <updated>2021-01-25T12:13:38.877Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>看题解第二个<br>`<br>递归方法</p><p>tion for singly-linked list.</p><ul><li><p>struct ListNode {</p></li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode *next;</code></pre></li><li><pre><code>ListNode() : val(0), next(nullptr) &#123;&#125;</code></pre></li><li><pre><code>ListNode(int x) : val(x), next(nullptr) &#123;&#125;</code></pre></li><li><pre><code>ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</code></pre></li><li><p>};</p></li><li><p>/<br>class Solution {<br>public:<br>  ListNode* swapPairs(ListNode* head) {</p><pre><code>  if(head == nullptr || head-&gt;next == nullptr) return head;  ListNode *next = head-&gt;next;  head-&gt;next = swapPairs(next-&gt;next);  next-&gt;next = head;  return next;</code></pre><p>  }<br>};</p><pre><code></code></pre></li></ul><p>迭代方法</p><p>class Solution {<br>public:<br>    ListNode* swapPairs(ListNode* head) {<br>        ListNode *pre = new ListNode(0);<br>        pre-&gt;next = head;<br>        ListNode *pre1 = pre;<br>        while(pre1-&gt;next != nullptr &amp;&amp; pre1-&gt;next-&gt;next != nullptr){<br>            ListNode *node1 = pre1-&gt;next;<br>            ListNode *node2 = node1-&gt;next;<br>            pre1-&gt;next = node2;<br>            node1-&gt;next = node2-&gt;next;<br>            node2-&gt;next = node1;<br>            pre1 = node1;<br>        }<br>        return pre-&gt;next;<br>    }<br>};</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>big_data</title>
    <link href="http://example.com/posts/60234/"/>
    <id>http://example.com/posts/60234/</id>
    <published>2020-12-27T13:01:28.000Z</published>
    <updated>2021-01-25T12:13:38.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="十道海量数据处理题"><a href="#十道海量数据处理题" class="headerlink" title="十道海量数据处理题"></a>十道海量数据处理题</h3><h4 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h4><p>　此题，在我之前的一篇文章算法里头有所提到，当时给出的方案是：IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p><p>　　再详细介绍下此方案：首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><h4 id="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。"><a href="#搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。" class="headerlink" title="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。"></a>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。</h4><p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p>　　典型的Top K算法，还是在这篇文章里头有所阐述。 文中，给出的最终算法是：第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成排序；然后，第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。 即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。</p><p>　　或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><h4 id="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h4><p>方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。</p><p>　　如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p><h4 id="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h4><p>还是典型的TOP K算法，解决方案如下： 方案1： 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。</p><p>　　对这10个文件进行归并排序（内排序与外排序相结合）。</p><p>　　方案2： 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。</p><p>　　方案3： 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p><h4 id="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"><a href="#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？" class="headerlink" title="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h4><p>　方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p><p>　　遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</p><p>　　遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p><p>　　求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p><p>　　方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><p>　　Bloom filter日后会在本BLOG内详细阐述。</p><h4 id="在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。"><a href="#在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。" class="headerlink" title="在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。"></a>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h4><p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p><p>　　方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h4 id="腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h4><p>与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法： 方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p><p>　　dizengrong： 方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；这里我们把40亿个数中的每一个用32位的二进制来表示假设这40亿个数开始放在一个文件中。</p><p>　　然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找</p><p>再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1</p><p>　　并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ……. 以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</p><p>　　附：这里，再简单介绍下，位图方法： 使用位图法判断整形数组是否存在重复 判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。</p><p>　　位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。</p><h4 id="怎么在海量数据中找出重复次数最多的一个？"><a href="#怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="怎么在海量数据中找出重复次数最多的一个？"></a>怎么在海量数据中找出重复次数最多的一个？</h4><p>　　 方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h4 id="上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"><a href="#上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。" class="headerlink" title="上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"></a>上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</h4><p>方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p><h4 id="一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"><a href="#一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。" class="headerlink" title="一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"></a>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</h4><p>方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p><p>　　附、100w个数中找出最大的100个数。</p><p>　　方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p><p>　　方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。</p><p>　　方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。</p><h3 id="十个海量数据处理方法大总结"><a href="#十个海量数据处理方法大总结" class="headerlink" title="十个海量数据处理方法大总结"></a>十个海量数据处理方法大总结</h3><p>　　ok，看了上面这么多的面试题，是否有点头晕。是的，需要一个总结。接下来，本文将简单总结下一些处理海量数据问题的常见方法。</p><p>　　下面的方法全部来自<a href="http://hi.baidu.com/yanxionglu/blog/%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%AF%B9%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%B8%80%E4%B8%AA%E4%B8%80%E8%88%AC%E6%80%A7%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%8C%E5%BD%93%E7%84%B6%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E8%83%BD%E5%B9%B6%E4%B8%8D%E8%83%BD%E5%AE%8C%E5%85%A8%E8%A6%86%E7%9B%96%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B9%9F%E5%9F%BA%E6%9C%AC%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%9F%BA%E6%9C%AC%E7%9B%B4%E6%8E%A5%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%85%AC%E5%8F%B8%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%9C%80%E4%BC%98%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA%E3%80%82">http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。</a></p><p>　　一、Bloom filter</p><p>　　适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p><p>　　基本原理及要点：</p><p>　　对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p><p>　　还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p><p>　　举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p><p>　　注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p><p>　　扩展：</p><p>　　Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p><p>　　问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p><p>　　根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p><p>　　二、Hashing</p><p>　　适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存</p><p>　　基本原理及要点：</p><p>　　hash函数选择，针对字符串，整数，排列，具体相应的hash方法。</p><p>　　碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p><p>　　扩展：</p><p>　　d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p><p>　　问题实例：</p><p>　　1).海量日志数据，提取出某日访问百度次数最多的那个IP。</p><p>　　IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p><p>　　三、bit-map</p><p>　　适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p><p>　　基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码</p><p>　　扩展：bloom filter可以看做是对bit-map的扩展</p><p>　　问题实例：</p><p>　　1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</p><p>　　8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。</p><p>　　2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p><p>　　将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。</p><p>　　四、堆</p><p>　　适用范围：海量数据前n大，并且n比较小，堆可以放入内存</p><p>　　基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。</p><p>　　扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p><p>　　问题实例：</p><p>　　1)100w个数中找最大的前100个数。</p><p>　　用一个100个元素大小的最小堆即可。</p><p>　　五、双层桶划分—-其实本质上就是【分而治之】的思想，重在分的技巧上！</p><p>　　适用范围：第k大，中位数，不重复或重复的数字</p><p>　　基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p><p>　　扩展：</p><p>　　问题实例：</p><p>　　1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p><p>　　有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p><p>　　2).5亿个int找它们的中位数。</p><p>　　这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p><p>　　实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p><p>　　六、数据库索引</p><p>　　适用范围：大数据量的增删改查</p><p>　　基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p><p>　　七、倒排索引(Inverted index)</p><p>　　适用范围：搜索引擎，关键字查询</p><p>　　基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p><p>　以英文为例，下面是要被索引的文本： T0 = “it is what it is” T1 = “what is it” T2 = “it is a banana”</p><p>我们就能得到下面的反向文件索引：</p><p>“a”: {2} “banana”: {2} “is”: {0, 1, 2} “it”: {0, 1, 2} “what”: {0, 1}</p><p>　检索的条件”what”,”is”和”it”将对应集合的交集。</p><p>　　正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p><p>　　扩展：</p><p>　　问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p><p>　　八、外排序</p><p>　　适用范围：大数据的排序，去重</p><p>　　基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p><p>　　扩展：</p><p>　　问题实例：</p><p>　　1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。</p><p>　　这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p><p>　　九、trie树</p><p>　　适用范围：数据量大，重复多，但是数据种类小可以放入内存</p><p>　　基本原理及要点：实现方式，节点孩子的表示方式</p><p>　　扩展：压缩实现。</p><p>　　问题实例：</p><p>　　1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。</p><p>　　2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？</p><p>　　3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</p><p>　　十、分布式处理 mapreduce</p><p>　　适用范围：数据量大，但是数据种类小可以放入内存</p><p>　　基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p><p>　　扩展：</p><p>　　问题实例：</p><p>　　1).The canonical example application of MapReduce is a process to count the appearances ofeach different word in a set of documents:</p><pre><code>　　2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。　　3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？　　经典问题分析　　上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。　　可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序　　所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。　　如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。　　当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。　　实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。　 而外排序的方法会消耗大量的IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>ip协议</title>
    <link href="http://example.com/posts/37850/"/>
    <id>http://example.com/posts/37850/</id>
    <published>2020-12-23T07:57:39.000Z</published>
    <updated>2020-12-27T12:59:20.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP是网络控制消息协议,属于网络层协议,ICMP协议用来在网络设备间传递各种差错和控制信息,并对于收集各种网络信息,诊断和排除各种网络故障等方面起着至关重要的作用.使用基于ICMP的应用时,需要对ICMP的工作原理非常熟悉.</p><p>平时用到的ping命令,就是使用的ICMP协议,用来检测网络的连通性(通或者不通问题),<br>通过主机A向主机(服务器),现在想检测主机A与服务器之间的联通性,使用ICMP协议首先从A主机发送一个message消息到服务器,不管到哪里或者断了,都会回复一个消息(return Message),就可以通过回复的消息来判断中间的网络是怎么样的(ip等路由信息都通过return message来判断),大致流程是这样的.</p><p>网关: 用来转发不同网段之间的数据包.<br>如果是主机A想想访问服务器A,就是先判断服务器A的网络ip是不是和服务器的ip属于同一个网段,如果是就直接访问,如果不是就得交给网关进行转发,网关的作用就是转发不同网段之间的数据包.</p><p>ICMP重定向:<br>    例子,图:ICMP重定向<br>    主机A判断和服务器A的是不是属于同一个网段，这里判断显然不是，就会通过默认的网关，RTB进行消息转发，转发给了RTA,RTA再找到服务器A,这里的RTB的操作就是冗余的.这种情况下网关(RTB)会返回一个ICMP重定向的消息，告诉主机A,下次的路径.直接可以访问TRA就可已到达．这里所说的RTB那条路径是次优路径，RTA那条路径是次优路径是最优路径．<br>ICMP重定向的作用: 解决了次优路径.(这里只是控制消息还有我们的差错还有查询)</p><p>ICMP差错检测<br>图：ICMP差错检测<br>主机A会给主机B发送一个ICMP Echo Requst消息,经过传播到达服务器A ,服务器A 会回复ICMP Rcho Reply的消息．这是正常的情况．<br>如果说没有返回这个消息，就说明出现问题了，</p><p>ICMP Echo Requst 和ICANN Echo Reply分别用来查询和响应某些信息，进行差错检测.</p><p>ICMP错误报告<br>图 ICMP错误报告<br>主机会给服务器发送消息，中间经过路由器，如果中间出现问题（IP冲突或者没有路由）路由会回复一个信息（ICMP目的不可达）<br>当网络设备无法访问目标网络时，会自动发送ICMP目的不可达报文到发送端设备.</p><p>ICMP数据包格式:<br>    1. 帧头<br>    2. 网络头<br>    3. ICMP<br>    4. FCS<br>ICMP中包括:<br>    1. type(0-7)<br>    2. code(7-15)<br>    3. checksum(15-31)<br>ICMP的报文内容(不同类型和代码标识不同的内容)．<br>type表示ICMP消息类型，Code表示同一消息类型中的不同信息．<br>返回的ICMP目的不可达就是通过Type类型和Code值．<br>图　ICMP消息类型和编码类型．<br>网络不可达: 没有路由<br>主机不可达: 主机没有IP或者说IP地址配置错误.<br>协议不可达: acl协议（或者中间设备）给他过滤了．<br>端口不可达: 端口不对外开放.</p><p>ICMP应用-ping<br>主动方发送一个ICMP请求，对方发送一个ICMP回应,<br>确认情况下ping一般发送五个请求包，对方会给我们回五个回应．</p><p>ICMP应用-Tracert<br>用来跟踪数据包所经过的路径.<br>原理就是控制TTL值，TTL值是用来防环的，如果TTL值为0的时候这个数据包就会被丢弃，而且每经过一次路由器，TTL就会减一.缺省值为255.</p><p>运行过程:<br>    开始的时候，主机会把ttl设置为1，发送一个TTL为1的报文,首先主机A会把报文交给网关，网关再次发送给路由器，（在网关TTL为1,发送出去就会变成0,到b路由器判断为0,报文丢弃，返回一个信息(ICMP消息不可达)给主机A）,主机A收到了这个消息，就会知道第一个设备经过的是哪里，下次会再次发送一个TTL为2的报文，以此类推.就可以判断经过的路径.<br>图: icmp应用-Tracert</p><p>Tracert: 回复的是ICMP.</p><p>模拟机上用的是Tracertroute<br>Tracertroute: 回复的是UDP.</p><p>抓包真机上能抓到，模拟器上抓不到icmp重定向.</p><h3 id="rqp协议"><a href="#rqp协议" class="headerlink" title="rqp协议"></a>rqp协议</h3><p>在操作系统和网络设备没有或者不需要设置ARP参数.很少用到．<br>有助于故障诊断:<br>    1. 通过ARP包的特征就能判断网络构架是否正确．<br>    2. 有没有发生依赖．<br>    3. 有没有错包<br>    4. 有没有广播分报等信息.</p><p>由于ARP本身的缺陷，使其成为内网的安全隐患(ARP协议攻击前边有说过),</p><h3 id="浅谈协议"><a href="#浅谈协议" class="headerlink" title="浅谈协议"></a>浅谈协议</h3><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>Address Resolution Protocol，地址解析协议，根据IP地址获取物理地址。</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存，由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>Network Address Translation，网络地址转换，一种将私有（保留）地址转化为合法IP地址的转换技术。</p><p>在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但又想和因特网上的主机通信时，可使用NAT方法。这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有专用网内部的想和因特网上的主机通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>Internet Control Message Protocol，Internet控制报文协议，用于在IP主机、路由器之间传递控制消息。</p><p>控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>Dynamic Host Configuration Protocol，动态主机配置协议，是一个局域网的网络协议。</p><p>DHCP使用UDP协议工作，主要有两个用途：一是给内部网络或网络服务供应商自动分配IP地址，二是作为用户或者内部网络管理员对所有计算机作中央管理的手段。</p><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>Routing Information Protocol，路由信息协议，是一个内部网关协议，是一种基于距离矢量的路由协议，以路由跳数作为计数单位的路由协议，适合用于比较小型的网络环境。它选择路由的度量标准是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>Open Shortest Path First，开放式最短路径优先，是一个内部网关协议，是对链路状态路由协议的一种实现，用Dijastra算法实现。它选择路由的度量标准是带宽，延迟。</p><h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>Border Gateway Protocol，边界网关协议，是一个外部网关协议，用来连接因特网上的独立系统，在自治系统之间动态交换路由信息。</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><h4 id="到底该如何理解HTTP长连接"><a href="#到底该如何理解HTTP长连接" class="headerlink" title="到底该如何理解HTTP长连接"></a>到底该如何理解HTTP长连接</h4><p>想要理解HTTP长连接就必须理解socket连接.<br>套接字是什么?<br>Socket是什么?是操作系统提供的tcp协议之上的接口.</p><p>这里就会涉及到TCP协议，该协议处在传输层，那么什么来实现TCP协议呢?<br>TCP协议在linux源码中实现了三次握手等操作.也就是说TCP是在os中进行详细实现的.<br>HTTP协议(请求)就是一个特定格式的数据,</p><p>重申操作系统会实现TCP协议.</p><p>在linux系统内部:<br>建立TCP链接—首先调用tcp_connect()完成三次握手,</p><p>HTTP格式:</p><p>访问<a href="https://www.baidu,com/">https://www.baidu,com/</a><br>会默认的设置一个请求头 Connextion:(http 0.9/http 1.0)默认的是close.(如果是http1.1版本的话　就是keepAlive （这里就是长连接)).构造完成请求头，然后发送给百度的服务器．</p><p>浏览器步骤:<br>    1. 构造数据(构造成指定格式的数据(HTTP格式)).<br>    2. 调用操作系统的API(所提供的功能.–发送数据的功能—TCP连接.)<br>    3. 基于TCP连接再发送数据.</p><p>操作系统是负责传输数据，而数据格式解析等操作都是交给应用程序(浏览器/Tomcat)来完成的．</p><p>HTTP的长连接参数为啥是 keep_alive/close这个参数呢?他有什么特殊的含义吗?<br>注意区分(tcp中有一个keep_alive(这个定义的心跳))我么这里所说的是HTTP中的keep_alive.</p><p>下边的两行构造出来的就是HTTP请求:<br><a href="https://www.baidu.com/">https://www.baidu.com/</a><br>Connextion: keep_alive</p><p>当我们访问百度的时候我们只向百度服务器只发送了一个HTTP的请求吗?</p><p>当我们输入baidu.com的时候，会发出75个HTTP请求,难道会建立75个socket吗?<br>??????<br>如果使用的是HTTP的短连接: 就会建立75个Socket.<br>如果使用的是HTTP长连接:<br>    如果不建立75个Socket,如果建立10个Socket那个这75个HTTP请求如何发呢?</p><p>这里就涉及到了多个HTTP请求共用一个Socket连接,一个socket连接能处理多少个HTTP请求，这个在Tomact中会有配置的.</p><p>我们想要访问一个服务器就需要先建立socket连接,然后再发送HTTP请求(就是通过Socket发送HTTP类型的数据),Tomcat接受这些数据之后就会处理这些数据,Tomact如何处理这些数据这里就涉及到了长连接,当Tomact接收到这个请求后，就会判断这个请求头中connection:是不是close类型的，如果这个参数是close类型的，Tomact就认为是短连接，如果是短连接Tomact就会先处理完这个请求，总而言之先解析头部，再解析请求，把这个请求的结果的响应给浏览器．在响应头里边也有一个connection的参数短连接的话参数也为close，对于Tomcat请求处理完了就会把socket关掉，对于浏览器当他接收到响应之后,就会渲染页面渲染完成之后，也会把socket关掉,这里就是短连接….close的先后顺序在网络中，不能很好的控制的．<br>双方没有谁主动的问题，只要收到connection:close.就会去主动关闭.</p><p>下边说什么是长连接:<br>    如果Connextion参数为keep_alive,当浏览器发送这HTTP请求，Tomact接收到这个请求后，解析出来是keep_alive(保持活跃),<br>    这里的保持活跃说的是，接收到HTTP请求这个socket保持活跃,所以说在Tomcat处理完成之后会给一个反馈信息，这个反馈信息就不会再包含connection:close这个参数了，当前这个socket谁(socket和Tomact)都不会去关，从而使得Socket的(长连接)没有关闭（保持开着的状态),Tomact能同时存在活跃的socket,可以同时有好多个浏览器来连tomcat的8080端口,Tomact会控制有多少个活跃的socket个数，当浏览器在向tomcat建立socket连接的时候，还有一个参数来控制能够来处理多少个HTTP请求，就比如建立了一条长连接的socket(),然后通过这个socket()发送若干次http的请求，参数为maxKeepAliveRequests,就是长连接处理参数的请求,在一次建立socket之后，然后接收HTTP格式(这里都是connection为keep_alive.保持长连接)的请求，假设参数设置为3，就是前两个反馈信息（反馈头部）设置相关闭参数，等收到第三个请求之后，反馈头部就会加上connection:close.这个参数，返回给浏览器，这时Tomcat(服务器)就会调用socket.close()这个方法，然后浏览器收到响应头部这个反馈信息后，也会调用浏览器的socket.close的方法,进而实现套接字的关闭,这个参数的作用到这里解释完毕，注意一下,这个参数的默认参数为100,就是一个Socket连接只能处理100个http请求.</p><pre><code>为什么要加上100这个限制呢?一直处理不好吗?这里涉及到socket中的两个buffer，发送端有sendbuffer, 服务端recvbuffer,这里的buffer是在操作系统里边的，当我们写一个套接字，没有相关的处理数据（写发等）等逻辑，服务端为例，服务端就会把HTTP请求的那些信息暂存于buffer,服务端再进行数据的读取操作，就是从recvbuffer中获取的数据.我们可以实现一个功能模拟(client)网站连接一个服务端一直发送大量的数据，到达一定的时候他就不会再进行发送了，那么问题来了，客户端怎么知道服务端的buffer满了呢?这就跟tcp协议有关，就好比是tcp协议中的窗口，服务端每次接受到一个数据或者一组数据，就会返回有一个信息反馈，如果我这里满了就会告诉服务端不要再发了,这个可以手动更改，serversocket.setReceiveBufferSize()来修改这个缓冲区的大小，tomcat从recvbuffer中获取数据的，</code></pre><p>最大连接数，这里说的就是socket的连接个数，这里通过控制socket的个数来达到控制最大连接数的，代码底层有一个最大线程数，还有一个最大连接数，这两个区别是什么呢?<br>  最大线程数:　就是线程池的大小．<br>  Tomact中用的是bio的方式，在这种方式下,两者的值是一样的,只有用nio的方式他们连个才会不一样．<br>  bio的方式:<br>      就是我能够同时处理的socket的数量，在线程池开一定数量的线程，比如线程数为100,每个线程开一个socket连接,基于这种方式在bio里边最大连接数和最大线程数是一样的.</p><p>Tomact整体读数据的流程:<br>    读取buffer中的数据，字节格式，然后解析http协议,获得请求头部,判断连接方式(connection: keep还是什么)，响应获得一个rquest的对象，然后servle处理这个request的对象，然后会调用socket,output的对象发出响应，然后根据头部解析的结果来判断要不要调用套接字的关闭与否．</p><p>Tomact底层是调用的socket的,</p><p>setsotimeout()来设置套接字的等待时间，就是想从buffer中拿数据，但是buffer中目前又不存在数据，所以说要等多久，这里就是我们设置的这个时间，这就是会阻塞的原因.如果说Tomcat也想设置socket这个参数该怎么办呢，就要设置keepAliveTimeout这个函数了，如果时间到了，还是没有读到，Tomcat就会调用套接字的close方法.</p><p>Tomact长连接就是读完最后一次数据的20秒后关闭socket.<br>图:Tomact请求过程</p><p>如果七个HTTP请求访问jsp页面，会反馈多少个HTTP请求?(Google浏览器)<br>会反会9个HTTP,第一个为index.jsp返回jsp页面，后续七个为servletDemo? = 1直到等于7,最后会默认发送一个图标,favicon.ico．那么一共建立了几个socket连接呢? 这个显示了6个socket连接，问题来了，这个6从哪里来的，是Tomact还是浏览器哪个设置的.<br>这个6是浏览器设置的,浏览器是客户端,就是拿到一个网页，其中有7个请求，一个浏览器也能同时建立多个socket,谷歌里边默认会建立六个，这就是浏览器并发请求的数量,这里有9个HTTP请求，六个socket这里就必然会涉及到共享，哪几个http请求用的是同一个socket,第一个请求必然会建立一个socket连接，发送完反馈信息之后，再发送第二http请求的时候有必要再建立一个socket呢？没有必要，这里就可以看出前两个.js和http1用的是同一个socket连接,第三个(http2)这个请求会建立新的socket，那么第四个会不会新建立一个呢？不一定的,其他几个HTTP就会并发的建立socket来发送http请求．这只是一种情况，第一个和第二个会通过一个socket来发送数据，而下边几个http请求，可能会占用同一个socket也可能自己新创建,并发的执行，谁跟谁用一个socket我们没有办法确定的.</p><p>注意: 如果在频繁的建立连接的过程过程中，也可能会用到同一个socket．<br>学完这个完成:<br>可用在项目中的jvm,mysql,Tomact调优. </p><p>参数: keepAliveTimeout,maxConnections,maxKeepAliveRequests的作用</p><h3 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h3><h3 id="DNS域名解析详细过程"><a href="#DNS域名解析详细过程" class="headerlink" title="DNS域名解析详细过程"></a>DNS域名解析详细过程</h3><h4 id="根域名"><a href="#根域名" class="headerlink" title="根域名"></a>根域名</h4><p>ICANN公司(US)来负责管理顶级域名比如说是(.com).<br>一般的话给这些域名分为两类:<br>    1. 一般的(.com)(.net)(.org)大概700个.<br>    2. 国别(.cn 中国)(.uk)英国,大概200个.</p><p>ICANN不会亲自管理这些域名,每一个域名有一个托管商,由托管商来管理这些域名的具体管理事项.<br>ICANN会将所有事物都委托给管商,(.cn)就是中国互联网网络信息中心(CNNIC),最大的托管商verisign,ICANN是非盈利组织, verisign是商业公司托管有((.com)(.net)(.tv)),</p><p>下面说域名注册费用问题:<br>    比如注册(.com)的费用,10美元.<br>    ICANN : 0.8美元.<br>    verisign: 7.85美元.<br>    注册商: 剩余的.</p><p>verisign几乎的垄断利润,ICANN通过发布新的域名,反垄断.</p><p>根域名:<br>    <a href="http://www.abc.com.注意com后边有一个点,这个就是根域名,因为所有的域名都有根域名,所以这个点(根域名)被隐藏了/">www.abc.com.注意com后边有一个点,这个就是根域名,因为所有的域名都有根域名,所以这个点(根域名)被隐藏了</a>.</p><p>细说一下: <a href="http://www.abc.com.的访问过程/">www.abc.com.的访问过程</a>:<br>    1. 查询根域名得到.com顶级域名的服务器地址.<br>    2. 查询顶级域名得到.abc次级域名的服务器地址.<br>    3. 最后通过查询次级域名,得到了ip地址.<br>INACC: 在这里的作用是维护了一个列表维护了所有的顶级域名服务器地址,这个列表名叫DNS根区,保存这个文件的服务器就是根域名服务器,全世界目前有13台根域名节点,分别是a.root-servers.net…m.root-servers.net(就是a 到 m).为什么是13台,因为早期的DNS解析结果是512字节的数据包,数据包只能容纳13台服务器的地址,现在13台服务器由12家组织独立运营,每家组织为了保持根域名的稳定性,在每个编号下边都会运行很多台机器,现在世界有五百多台机器用于根节点的查询,</p><h4 id="DNS域名解析协议"><a href="#DNS域名解析协议" class="headerlink" title="DNS域名解析协议"></a>DNS域名解析协议</h4><p>图 域名解析图</p><p>我们输入浏览器的是域名,但是电脑是通过IP访问的,这里就需要有一个地址簿(域名IP对应表),电脑能通过域名来查询到对应的IP.电脑拿到IP之后再去访问网站,这里所说的地址簿就是DNS服务器.</p><p>知识储备根域名的知识:</p><p>DNS服务器:<br>    相关设计:<br>        由于需求是人都能上网,并且这些人都分布在世界各地,所以对服务器的要求是高可用,分布式(满足世界各地).在这种要求下DNS服务器就被设计成了树状结构:<br>            根: 用点来表示(.)<br>            跟下边是若干顶级域名,常见的顶级域名:<br>                (.com), (.cn), (.net),<br>            顶级域名解析服务器就是返回权威DNS域名解析服务器.权威域名:<br>                (baidu.com),(163.com)<br>            权威域名解析服务器就能返回具体的域名对应的IP地址.比如<a href="http://www.163.com的ip地址/">www.163.com的ip地址</a>,<br>            网络运营商会就近部署一些缓存域名服务器,如果缓存中有IP就直接返回,就不用到根域名,顶级域名,和权威域名解析服务器上进行逐级解析了,提高解析性能.</p><p>解析的处理流程:<br>    比如<a href="http://www.163.com如何解析的/">www.163.com如何解析的</a>.<br>    1. 电脑会查询相对应的IP,首先看电脑的hosts文件是否有相关的配置,如果存在就直接使用,如果没有电脑就会想本地的DNS域名解析服务器(由服务运营上来提供比如电信,联通等,一般也会部署到他们的机房里边)发出一次请求.<br>    2. 本地的DNS收到请求,会查看本地的缓存中是否存在<a href="http://www.163.com所对应的ip,如果有直接返回,如果没有就会向根域名(根域名是一种高级的域名,全球一共13套)发出一次请求/">www.163.com所对应的ip,如果有直接返回,如果没有就会向根域名(根域名是一种高级的域名,全球一共13套)发出一次请求</a>.<br>    3. 根域名收到请求后不会直接返回<a href="http://www.163.com的ip,而是看他的顶级域名是多少,这里是.com,他只会返回(返回.com)顶级域名的服务器给本地dns,然后本地dns会访问.com的顶级域名dns服务器/">www.163.com的IP,而是看他的顶级域名是多少,这里是.com,他只会返回(返回.com)顶级域名的服务器给本地DNS,然后本地DNS会访问.com的顶级域名DNS服务器</a>.<br>    4. 顶级域名服务器就会返回常规域名,这里的常规域名是163.com,这里就会返回一个权威域名的服务器,本地DNS就会访问权威域名服务器,他这里有<a href="http://www.163.com的ip,就会返回他所对应的ip,本地dns拿到ip后就会返回给电脑,我们电脑拿到ip就会与目标服务器进行链接/">www.163.com的ip,就会返回他所对应的ip,本地DNS拿到ip后就会返回给电脑,我们电脑拿到ip就会与目标服务器进行链接</a>.<br>    5. 这就是一次DNS解析的全过程,<br>    6. 总结:<br>        电脑只是对本地域名解析服务器发起了一次请求,递归解析的过程都是DNS服务器帮忙处理,并且每次DNS服务器在拿到结果后,会把相关信息缓存到本地DNS缓存中,这样等下一次有相同的域名来访问的时候,他就会取到一个对应的ip进行访问,这样也能提高解析性能.</p><p>DNS服务器除了返回对应的IP还有两个作用:<br>    1. 负载均衡<br>    2. 就近访问:<br>        对于我们的应用为了保证他的高可用,我们一般将代码和数据部署在多个机房,每个机房都有自己的IP,并且这些机房托管在不同的运营商和不同的地域,同时对于我们的用户肯定希望北京的用户就近访问北京的数据中心,上海的用户就近访问上海的数据中心,如果是电信宽带就会访问电信数据中心,联通的就是联通数据中心,这样就能尽可能避免跨地域跨运营商之间的网络延迟,提升访问速度,这就是就近访问.</p><pre><code>如何实现就近访问呢?这里就需要我们的全局负载均衡器(简称GSLB).看一看他的执行方式上例子:    假设你有多个应用,这个应用穿过多个机房,并且这些机房托管在不同的运营商,用户的域名为file.abc.com,当一个客户端访问这个域名的时候,首先将这个域名转换成IP,所以客户端会向本地的DNS发起一个域名解析请求,跟上班一样,根域名请求.com等级域名,再从顶级服务器得到abc.com,再访问权威域名服务器,为了支持跨地名跨运营商的就近访问,配置的就不是file.abc.com的ip而是配置的是CNAME(别名),本地域名会通过这个CNAME(别名)访问GSLB服务器,请求查看他本地的运营商和地址,就知道用户的运营商和地址是什么了,这样GSLB就会返回一个和用户相同的运营商,并且返回一个最近机房的IP,给本地DNS,本地的DNS再加上IP返回给电脑,电脑拿着这个ip就能访问就近的机房.这样就通过DNS协议完成了高效的访问.</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>hashtable和hashmap</title>
    <link href="http://example.com/posts/55244/"/>
    <id>http://example.com/posts/55244/</id>
    <published>2020-12-23T01:35:48.000Z</published>
    <updated>2020-12-27T12:59:20.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指offer手撕</title>
    <link href="http://example.com/posts/24772/"/>
    <id>http://example.com/posts/24772/</id>
    <published>2020-12-22T08:02:41.000Z</published>
    <updated>2020-12-27T12:59:20.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problemset/all/?search=%E6%89%BE%E5%88%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0">跳转网页</a></p><h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50 第一个只出现一次的字符"></a>剑指 Offer 50 第一个只出现一次的字符</h3><p>一个循环<br>for(char c: s) = for(char c; c != ‘\0’; c++); 这里的c是下标index值.</p><p>一次遍历再加上哈希映射O(n) + O(1).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char firstUniqChar(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, bool&gt; dic;</span><br><span class="line">        for(char c : s)&#123;</span><br><span class="line">            dic[c] &#x3D; (dic.find(c) &#x3D;&#x3D; dic.end());</span><br><span class="line">        &#125;</span><br><span class="line">        for(char c : s)&#123;</span><br><span class="line">            if(dic[c]) return c;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43 1～n 整数中 1 出现的次数"></a>剑指 Offer 43 1～n 整数中 1 出现的次数</h3><p>看题解吧!!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int countDigitOne(int n) &#123;</span><br><span class="line">                long digit &#x3D; 1;</span><br><span class="line">                int high &#x3D; n &#x2F; 10, cur &#x3D; n % 10, low &#x3D; 0;</span><br><span class="line">                int res &#x3D; 0;</span><br><span class="line">        while(high !&#x3D; 0 || cur !&#x3D; 0)&#123;</span><br><span class="line">            if(cur &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                                res +&#x3D; high * digit;</span><br><span class="line">                            </span><br><span class="line">            &#125;</span><br><span class="line">            else if(cur &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                                res +&#x3D; high * digit + low + 1;</span><br><span class="line">                            </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                                res +&#x3D; (high + 1) * digit;</span><br><span class="line">                            </span><br><span class="line">            &#125;</span><br><span class="line">                        low +&#x3D; cur * digit;</span><br><span class="line">                        cur &#x3D; high % 10;</span><br><span class="line">                        high &#x2F;&#x3D; 10;</span><br><span class="line">                        digit *&#x3D; 10;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return res; </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44 数字序列中某一位的数字"></a>剑指 Offer 44 数字序列中某一位的数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int findNthDigit(int n) &#123;</span><br><span class="line">                if(n &#x3D;&#x3D; 0) &#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">                int digit &#x3D; 1; &#x2F;&#x2F; 数位（个位&#x2F;十位&#x2F;百位&#x2F;...，就是1&#x2F;2&#x2F;3&#x2F;...）</span><br><span class="line">                long start &#x3D; 1; &#x2F;&#x2F; 属于该数位的所有数的起始点数（个位是1，十位是10，百位是100）</span><br><span class="line">                long index_count &#x3D; digit * 9 * start; &#x2F;&#x2F; 该数位的数一共的索引个数（不是数字个数）</span><br><span class="line"></span><br><span class="line">        while(n &gt; index_count ) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 找出 n 属于那个数位里的索引</span><br><span class="line">                        n -&#x3D; index_count; </span><br><span class="line">                        ++ digit;</span><br><span class="line">                        start *&#x3D; 10;</span><br><span class="line">                        index_count &#x3D; digit * 9 * start;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                &#x2F;&#x2F; 上面的循环结束后：</span><br><span class="line">                &#x2F;&#x2F; digit 等于原始的 n 所属的数位；start 等于原始的 n 所属数位的数的起始点</span><br><span class="line">                &#x2F;&#x2F; index_count 等于原始的 n 所属数位的索引总个数（不重要了，下面不用）</span><br><span class="line">                &#x2F;&#x2F; n 等于在当前数位里的第 n - 1 个索引（索引从 0 开始算起）</span><br><span class="line"></span><br><span class="line">                long num &#x3D; start + (n - 1) &#x2F; digit; &#x2F;&#x2F; 算出原始的 n 到底对应哪个数字</span><br><span class="line">                int remainder &#x3D; (n - 1) % digit; &#x2F;&#x2F; 余数就是原始的 n 是这个数字中的第几位</span><br><span class="line"></span><br><span class="line">                string s_num &#x3D; to_string(num); &#x2F;&#x2F; 将该数字转为 string 类型</span><br><span class="line">                return int(s_num[remainder] - &#39;0&#39;); &#x2F;&#x2F; n 对应着第 remainder 位，再转成 int</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39 数组中出现次数超过一半的数字"></a>剑指 Offer 39 数组中出现次数超过一半的数字</h3><h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I 数组中数字出现的次数"></a>剑指 Offer 56 - I 数组中数字出现的次数</h3><h3 id="剑指-Offer-56-II数组中数字出现的次数-II"><a href="#剑指-Offer-56-II数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II数组中数字出现的次数 II"></a>剑指 Offer 56 - II数组中数字出现的次数 II</h3><h3 id="剑指-Offer-57-II和为s的连续正数序列"><a href="#剑指-Offer-57-II和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II和为s的连续正数序列"></a>剑指 Offer 57 - II和为s的连续正数序列</h3><h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52 两个链表的第一个公共节点"></a>剑指 Offer 52 两个链表的第一个公共节点</h3><h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31 栈的压入、弹出序列"></a>剑指 Offer 31 栈的压入、弹出序列</h3><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22 链表中倒数第k个节点"></a>剑指 Offer 22 链表中倒数第k个节点</h3><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04 二维数组中的查找"></a>剑指 Offer 04 二维数组中的查找</h3><h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I 在排序数组中查找数字 I"></a>剑指 Offer 53 - I 在排序数组中查找数字 I</h3><h3 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51  数组中的逆序对"></a>剑指 Offer 51  数组中的逆序对</h3><h3 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15 二进制中1的个数"></a>剑指 Offer 15 二进制中1的个数</h3><h3 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16 数值的整数次方"></a>剑指 Offer 16 数值的整数次方</h3><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09 用两个栈实现队列"></a>剑指 Offer 09 用两个栈实现队列</h3><h3 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41 数据流中的中位数"></a>剑指 Offer 41 数据流中的中位数</h3><h3 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60 n个骰子的点数"></a>剑指 Offer 60 n个骰子的点数</h3><h3 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25 合并两个排序的链表"></a>剑指 Offer 25 合并两个排序的链表</h3><h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03 数组中重复的数字"></a>剑指 Offer 03 数组中重复的数字</h3><h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57 和为s的两个数字"></a>剑指 Offer 57 和为s的两个数字</h3><h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33 二叉搜索树的后序遍历序列"></a>剑指 Offer 33 二叉搜索树的后序遍历序列</h3><h3 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37 序列化二叉树"></a>剑指 Offer 37 序列化二叉树</h3><h3 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62 圆圈中最后剩下的数字"></a>剑指 Offer 62 圆圈中最后剩下的数字</h3><h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40 最小的k个数"></a>剑指 Offer 40 最小的k个数</h3><h3 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34 二叉树中和为某一值的路径"></a>剑指 Offer 34 二叉树中和为某一值的路径</h3><h3 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67 把字符串转换成整数"></a>剑指 Offer 67 把字符串转换成整数</h3><h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21 调整数组顺序使奇数位于偶数前面</h3><h3 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17 打印从1到最大的n位数"></a>剑指 Offer 17 打印从1到最大的n位数</h3><h3 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19 正则表达式匹配"></a>剑指 Offer 19 正则表达式匹配</h3><h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12 矩阵中的路径"></a>剑指 Offer 12 矩阵中的路径</h3><h3 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61 扑克牌中的顺子"></a>剑指 Offer 61 扑克牌中的顺子</h3><h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II  0～n-1中缺失的数字"></a>剑指 Offer 53 - II  0～n-1中缺失的数字</h3><h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38 字符串的排列"></a>剑指 Offer 38 字符串的排列</h3><h3 id="剑指-Offer-59-II队列的最大值"><a href="#剑指-Offer-59-II队列的最大值" class="headerlink" title="剑指 Offer 59 - II队列的最大值"></a>剑指 Offer 59 - II队列的最大值</h3><h3 id="1539-第-k-个缺失的正整数"><a href="#1539-第-k-个缺失的正整数" class="headerlink" title="1539 第 k 个缺失的正整数"></a>1539 第 k 个缺失的正整数</h3><h3 id="LCP-11-期望个数统计"><a href="#LCP-11-期望个数统计" class="headerlink" title="LCP 11 期望个数统计"></a>LCP 11 期望个数统计</h3><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I 斐波那契数列"></a>剑指 Offer 10- I 斐波那契数列</h3><h3 id="38-字符串中的第一个唯一字符-7"><a href="#38-字符串中的第一个唯一字符-7" class="headerlink" title="38 字符串中的第一个唯一字符  7"></a>38 字符串中的第一个唯一字符  7</h3><h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54 二叉搜索树的第k大节点"></a>剑指 Offer 54 二叉搜索树的第k大节点</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leedcode" scheme="http://example.com/categories/leedcode/"/>
    
    
    <category term="leedcode" scheme="http://example.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://example.com/posts/44296/"/>
    <id>http://example.com/posts/44296/</id>
    <published>2020-12-22T01:19:04.000Z</published>
    <updated>2020-12-22T05:21:42.082Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>重点:<br>    1. 缓存穿透, 缓存击穿, 缓存雪崩.<br>    2. redis数据结构各种提问.<br>    3. redis持久化以及集群方案问题.</p><h3 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么?"></a>redis是什么?</h3><p>内存数据库(存储在内存中磁盘中的),数据结构数据库就是KV数据库(key-value).这里能想到memcached这个数据库也是内存数据库也是KV数据库(key-value)唯一不同的就是value只支持string类型,这个不能称为数据结构数据库.</p><h4 id="什么是数据结构数据库"><a href="#什么是数据结构数据库" class="headerlink" title="什么是数据结构数据库?"></a>什么是数据结构数据库?</h4><p>主要是key_value中的，value提供的数据结构,v:(string ,list(链表),hash(类似c/c++中的map&lt;type,type&gt; ), set(存储的值唯一就是去重),zset(实现的一个有序集合，用来实现一个实时的排行榜，比如游戏中的排名,mysql就很得隔一定时间刷新一遍．)，stream(存储的是消息队列，zeromq专门实现消息队列的一种方式，消息队列主要解决服务间通信的问题，能保证消息的缓冲作用，这些消息最终能到达另一个服务．))</p><h4 id="数据库详细理解"><a href="#数据库详细理解" class="headerlink" title="数据库详细理解:"></a>数据库详细理解:</h4><pre><code>什么叫内存式的数据结构呢例子:    client端, 服务器, redis.    服务器对redis进行操作的时候，就是对value中的数据结构进行操作．如何进行操作的呢?</code></pre><p>　　　　客户端通过发送命令的方式(这里是服务端对redis信息写入读取的方式)，比如操作类型为string类型，通过命令set hello word,写入redis中，如果想取出数据就需要get hello.　clent端如果登录会通过服务器取得redis中的个人信息，（这就是操作redis的操作流程）.</p><p>图: redis结构</p><h4 id="为什么使用这个redis-他的特性和功能是什么呢"><a href="#为什么使用这个redis-他的特性和功能是什么呢" class="headerlink" title="为什么使用这个redis?他的特性和功能是什么呢?"></a>为什么使用这个redis?他的特性和功能是什么呢?</h4><p>以前我们通过服务器对mysql进行数据的操作，频繁的访问mysql的话，mysql的(存栈)(这两个字可能存在问题)他是有限的,怎么解决这个问题，就是在中间增加一个缓存数据库(redis),同样的一个登录操作，如果加上了redis是如何的操作: (服务端操作)<br>    1. 首先查询redis.<br>    2. 如果没有,去mysql查询.mysql中的查询的值会保存到redis中，下次查询就会直接从这里读取信息.<br>    3. 如果有，redis返回.<br>    mysql的读写速度比redis的读写速度慢很多的.这样一来客户端登录如果从redis读取数据，会比从mysql中读取数据快很多,<br>    所以说引入redis就是为了解决mysql读写速度慢的问题，因为关系型数据库都是通过操作磁盘的方式，对b/b+树加索引，然后才去查询，redis都在内存中，他的读写速度非常块．<br>    总结redis的优点:<br>        1. 读写速度比关系型数据快.<br>        2. redis(操作数据结构能实现关系型数据库很难完成的功能)，比如zset实时的排行版，set在mysql中可能得设置唯一键问题，list根据插入顺序来完成一个有序性,hash在mysql中需要加入很多的字段，但是我们的hash只需要维护一个key-value．</p><p>多读源码，发现细节，得心应手!!!!</p><h3 id="重点来了"><a href="#重点来了" class="headerlink" title="重点来了"></a>重点来了</h3><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>产生的原因:(数据源(关系型数据库)存在数据，缓存(redis)不存在或者key过期了,如果此时有大量的请求过来，这些数据压力都会涌入mysql)</p><p>详细分析: 在clent端通过服务器对redis进行操作，查询到redis没有这个key值或者key值已经过期，这个时候就会重新进入mysql进行查询，如果这个查询非常多的话，就会产生过多的这样的问题，这种情况下redis就会成为一种负担，每次花费大量的开销来进行redis的查询,这是徒劳的.</p><h5 id="缓存击穿解决方法"><a href="#缓存击穿解决方法" class="headerlink" title="缓存击穿解决方法"></a>缓存击穿解决方法</h5><p>如果大量访问这个key值，<br>加锁:　具体方法用带成功返回值的命令 set(key, 1), 解锁就是　+ok set(key, 0).后面的请求就会知道这里加了锁，就不会将所有的请求加载到mysql.</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>解析问题: 数据源不存在，(缓存)redis也不存在.<br>这样会存在大量的重复的操作进入redis和mysql,这样一直访问redis或者mysql会造成对别的请求不可用的问题.</p><p>解决方案: 布隆过滤器<br>解决思路:<br>    一定不存在的问题用什么数据结构来解决?<br>    用哈希的方式hash<keybool>如果存在的话直接从redis中去取，不存在就去mysql去取,存储的数据比较多占用的内存比较高.<br>    布隆过滤器采用的是一个位图 (bitmap)固定长度的数组，每一位就是0或者1,<br>    图: 前哈希后布隆</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存重启或者大量缓存失效(这里主要是后者),一般是使用expire出现的问题,</p><p>那么问题来了:为什么将数据设置成过期呢(expire)?<br>不设置过期，数据就会越来越多，在redis缓存中一般记录最近查找的值，为了维护查询效率，就会设置这个过期时间，一定时间处理一些数据.<br>如果是重启，可以通过持久化的方式进行解决.</p><p>如果是大量缓存失效的问题?<br>如果大量缓存失效，就会导致大量的请求涌入到mysql中,跟缓存击穿很像，大量请求在mysql中堆积,</p><h5 id="缓存雪崩解决方案"><a href="#缓存雪崩解决方案" class="headerlink" title="缓存雪崩解决方案"></a>缓存雪崩解决方案</h5><p>缓存击穿可以加锁，这里也可以加锁，不同于缓存击穿的就是这里不是一个key引发的问题了，可能涉及到多个key.</p><ol><li>错开失效时间</li><li>加锁: 在服务器等待，直到得到锁再访问，防止大量数据访问mysql.</li><li>加消息队列: 把访问设置为一个队列，依次访问.<br>2, 3两种方式并不能解决根本的问题，如果给key加锁，响应的会有一定的延迟，这样服务器会堆积很多的请求，既没有去请求mysql也没有返回信息,这样没办法从根本解决问题.</li></ol><p>所以说从设计上来解决这个问题，就是1的方法(错开失效时间)(具体设计: 设置key过期的时候，避免同时失效.)</p><p>图: redis数据结构</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>跳表,用来zset有序集合</li><li>字典 hashtable</li></ol><p>相同数量级下，数据存储采用跳表和字典，空间占用怎么样?</p><h4 id="问题来了跳表是啥"><a href="#问题来了跳表是啥" class="headerlink" title="问题来了跳表是啥?"></a>问题来了跳表是啥?</h4><p>图:跳表结构<br>首先是一个有序的单链表（升序）．跳表就是加入了层级的查询的方式，这是一种完美的跳表，但是实际中的跳表会有增删改查等操作，(待续)</p><p>增加节点的值:<br>    zadd hello world 10<br>    zadd hello world 20 就是第一个节点为10,第二个节点为20，这些节点的级别数是随机的，这也是数量大于128的时候才能接近完美的跳边(满足二分查找的效率).对这个推论有一个论文可查!!读它.</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><pre><code>读源码看出它是通过两个hashtable来实现的，数组+hash来确定位置，避免冲的时候会用挂链表的方法解决冲突.为什么是两个数组呢?因为集中大量的插入的时候,短的数组不够用了，就需要rehash的方式，把第一个数组中的数拷贝到第二个数组中（第二个数组长度是第一个长度的2倍），如果数据量很大的时候，就需要通过渐进式rehash的方式，进行拷贝，如果是原来的rehash拷贝，如果这里也用这个原样拷贝的方式，会很浪费cpu的资源，不能够提供及时的服务.渐进式rehash的方式，两种方法:    1. 对dict操作的时是 增删改查　操作的时候rehash 1次    2. while(rehash时间 &lt; 1ms)&#123;        rehash 100个循环.    &#125;</code></pre><p>这里开始解决上边提到的问题:<br>    跳表的数据浪费主要是跳边建立的层级，<br>    图: rehash比较图 这里的rehash看上边对渐进式rehash.</p><h3 id="数据结构存储相关的知识"><a href="#数据结构存储相关的知识" class="headerlink" title="数据结构存储相关的知识"></a>数据结构存储相关的知识</h3><p>时间与空间均衡的过程(模型一直在变化)<br>这里就涉及到zset底层采用什么样存储方式?<br>图: 时间与空间均衡的过程</p><h3 id="redis持久化和集群"><a href="#redis持久化和集群" class="headerlink" title="redis持久化和集群"></a>redis持久化和集群</h3><p>持久化: 就是持久化我们的写操作,读操作没有必要持久化.<br>持久化的两种方式:<br>    1. rdb: 一段时间的写操作．<br>    2. aof: 每一次的写操作.<br>    这两种方式在配置中进行的，一般同时开启两种，采用混用的方式.<br>    有时候会丢掉一段时间的数据，这里就是只打开了rdb这种方式，</p><p>集群方式:<br>    1. 主从: 主要解决单点故障问题(redis突然宕机或者是硬盘损坏数据就会丢失，通过主从数据（数据备份）)来解决．<br>    这里就是redis高可用的基础,<br>    遵循cap原则:<br>        c: 一致性 : 修改密码依然登录．<br>        a: 可用性 : 一个节点宕机了，别的节点依然可以提供服务．<br>        p: 分区容错性 : 比如两个地区不了连同了，依然能支持cap原则.</p><pre><code>高可用: 合理的时间返回合理的结果．2. 哨兵:     解决高可用的问题．    图: 哨兵解释图    需要奇数个节点进行投票选集要替换的节点.    如果哨兵死掉，就会切换哨兵，但是也要保证是奇数个哨兵.3. cluster集群:    对redis横向扩展的问题,    图: cluster点的扩展, 三个节点如果加入新的节点，就需要crc(key) 取莫运算16384,插入节点的位置，别的方法还有一致性哈希.</code></pre><p>为什么单线程那么快呢?</p><h2 id="补充-每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作"><a href="#补充-每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作" class="headerlink" title="补充: 每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作."></a>补充: 每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作.</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Tcp/Ip协议栈</title>
    <link href="http://example.com/posts/40290/"/>
    <id>http://example.com/posts/40290/</id>
    <published>2020-12-19T14:43:48.000Z</published>
    <updated>2020-12-21T14:14:13.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="今天主题，手写协议栈"><a href="#今天主题，手写协议栈" class="headerlink" title="今天主题，手写协议栈"></a>今天主题，手写协议栈</h3><h4 id="什么叫协议栈"><a href="#什么叫协议栈" class="headerlink" title="什么叫协议栈?"></a>什么叫协议栈?</h4><p>简单来说现有来两个端，A端，B端,假设A端向B端发送数据，计算机网络采用的是五层结构(应传网数物)，A端通过send()函数把应用层数据(hello)发送给B端口,中间需要在每一层加上相关的协议(前边有讲)头部或者尾部，因为这些协议的组成类似于栈的结构，详细说就是在A端放封装的协议，在B端是以相反的顺序进行解封的，符合了栈的结构特性，先进后出,所以名字叫协议栈．</p><p>物理层确切的来说就是，双绞线等传输的电信号/光信号.<br>在数据链路层拿到的就是数字信号(010101这样的).</p><p>网卡属于哪一层?<br>网卡起到了A/D转换的功能(A模拟，D数字).网卡他不是协议栈里边的东西，详细说网卡就是把物理层的数据转换为数据链路层的数据．send()刚好相反．所以说他哪一层都不属于!</p><h4 id="实现一个协议栈之前了解"><a href="#实现一个协议栈之前了解" class="headerlink" title="实现一个协议栈之前了解"></a>实现一个协议栈之前了解</h4><p>zero-copy零拷贝.<br>例子: 在一个服务器或者客户端:<br>    A 网卡　B内核协议栈　C应用程序.<br>    AB属于内核态，ｃ属于用户态.<br>    从网络中该服务器收到了一个信息，比如hello, 会通过网卡copy到内核协议栈中，网卡数据到达内核协议栈这个东西用什么来进行储存呢，这里有一个有名的东西叫SK-buffer.第二次拷贝就是调用receive函数（receive_buffer），从协议栈拷贝到引用程序里边(就是说应用程序通过receive_buffer来拷贝得到应用程序)，一般数据的传输就是经过这两次的拷贝，下面特殊的零拷贝来了<br>什么叫做零拷贝?<br>网卡是一个外设，内存之外的就是外存,外设也有存储空间，网卡通过A/D转换把信息放到自己存储空间的时候，由于外设存在存储空间，就通过DMA的方式，映射到内存里边，内存里的数据跟网卡里存储的数据是一样．注意这里不叫复制，复制是通过cpu把源地址的东西拷贝到目的地址，DMA和Cpu没什么特别大的关系，内存被映射的地方称为mmap,在应用程序操作这个内存的时候，不能叫读取，读取是指从外存读入到内存．在内存中不叫读(叫操作).这样数据进入内存之后，我们cpu直接进行数据操作就可以了，所以这就是零拷贝.</p><p>协议栈就是基于DMA的方式，先把裸数据放到内存，再进行内存数据的操作．<br>图协议栈的基础实现．</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>以太网协议头</p><p>目的地址(6字节)　源地址(6字节)　类型(2字节)　数据和填充(46字节-1500字节)　CRC(4字节).</p><p>用户数据的存储不能是一个指针，只能是一个数字首地址(柔性数组也叫零长数组,不占用任何空间)，这样发出去的包能找到所对应的数值．<br>柔性数组应用场景:<br>    1. 数组的内存分配好了．<br>    2. 数组的大小未知（但是可以通过其他方式计算的）．</p><p>数据的操作:<br>    网卡来一段数据，发送给内核协议栈标识为可读（fd指向网卡内存标识可读，我们操作的是内存中的数据，跟文件读取不一样），我们应用程序来操作内存中的数据拷贝的数据.</p><p>ringbuffer:<br>    就是把外存的信息启动mmap映射到内存，构建一个环形队列，就是ringbuffer.直接去next就能到下一个数据.断开前后指针，直接操作，在内存中不用拷贝(没有用到cpu的mv指令).</p><p>弄清楚netmap了之后，下边带你在ubuntu(linux)环境下部署环境.</p><h4 id="netmap环境部署"><a href="#netmap环境部署" class="headerlink" title="netmap环境部署"></a><a href="https://blog.csdn.net/weixin_43326322/article/details/108265924">netmap环境部署</a></h4><h5 id="修改网卡名称"><a href="#修改网卡名称" class="headerlink" title="修改网卡名称"></a>修改网卡名称</h5><p>在我的Ubuntu版本上，网关默认的就是eth类型,如果默认的网卡名称是ens32.这里需要修改为eth类型.</p><p>sudo vim /etc/default/grub<br>修改里面 GRUB_CMDLINE_LINUX=“net.ifnames=0 biosdevname=0”<br>.重新生成grub引导配置文件 ：sudo grub-mkconfig -o /boot/grub/grub.cfg</p><p>安装netmap（抓包工具配合网络小助手发送信息可以查看包的信息）</p><ol><li>git clone <a href="https://gitee.com/mirrors/netmap.git">https://gitee.com/mirrors/netmap.git</a></li><li>./configure</li><li>sudo make</li><li>sudo make install</li><li>insmod netmap.ko</li></ol><p>将ens33修改为eth0<br>sudo vim /etc/network/interfaces进行ifconfig，发现网卡名称并没有变，不知道是不是因为没有重启的原因。所以进行重启。再重启之前，再网上看到了重启后找不到网络的错误，所以进行了下面的设置，但是建议配置完上面的步骤后进行重启.<br>sudo vim /etc/netplan/01-network-manager-all.yaml</p><p>重启查看：ifconfig</p><h4 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;poll.h&gt;</span><br><span class="line">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#define NETMAP_WITH_LIBS</span><br><span class="line">#include &lt;net&#x2F;netmap_user.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#pragma pack(1) &#x2F;&#x2F;以一个字节对齐，因为以四个字节对齐会有一个空挡.四字节对齐sizeof(odppkt)44字节，一个对齐就是42字节.</span><br><span class="line">#define ETH_ALEN 6</span><br><span class="line">#define PROTO_IP 0x0800</span><br><span class="line">#define PROTO_UDP 17</span><br><span class="line">struct ethhdr&#123;&#x2F;&#x2F;以太网格式 </span><br><span class="line">    unsigned char h_dest[ETH_ALEN];&#x2F;&#x2F;目的地址</span><br><span class="line">    unsigned char h_src[ETH_ALEN];&#x2F;&#x2F;源地址</span><br><span class="line">    unsigned short h_proto;&#x2F;&#x2F;类型</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct iphdr &#123;&#x2F;&#x2F;ip协议格式</span><br><span class="line">              &#x2F;&#x2F;4位版本号，四位首部长度(表示的是字节数不是字节数要*4变成字节: 15 * 4 &#x3D; 60).</span><br><span class="line">    unsigned char version:4,</span><br><span class="line">                  hdrlen:4;</span><br><span class="line">    unsigned char tos;&#x2F;&#x2F;八位服务类型(TOS)实时服务&#x2F;非实时服务等</span><br><span class="line">    unsigned char totlen;&#x2F;&#x2F;十六位总长度</span><br><span class="line">    unsigned short id;&#x2F;&#x2F;十六位标识</span><br><span class="line">    unsigned short flags: 3,&#x2F;&#x2F;三位标志位</span><br><span class="line">                   offset: 13;&#x2F;&#x2F;十三位偏移</span><br><span class="line">    unsigned short ttl; &#x2F;&#x2F;8位生存时间.(生存时间).</span><br><span class="line">    unsigned char proto;&#x2F;&#x2F;8位协议，解析这里判断传输层的协议.</span><br><span class="line">    unsigned char check;&#x2F;&#x2F;16位首部检验和</span><br><span class="line">    unsigned int sip;&#x2F;&#x2F;源地址ip 四个字节</span><br><span class="line">    unsigned int dip;&#x2F;&#x2F;目的地址ip</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;udp的头部.简单</span><br><span class="line">struct udphdr&#123;&#x2F;&#x2F;都是两个字节</span><br><span class="line">    unsigned short sport;</span><br><span class="line">    unsigned short dport;</span><br><span class="line">    unsigned short length;</span><br><span class="line">    unsigned short check; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现一个udp的包</span><br><span class="line">struct udppkt&#123;</span><br><span class="line">    struct ethhdr eh;    &#x2F;&#x2F;14</span><br><span class="line">    struct iphdr ip;     &#x2F;&#x2F;20</span><br><span class="line">    struct udphdr udp;   &#x2F;&#x2F;8</span><br><span class="line">    unsigned char body[];&#x2F;&#x2F;用户数据如何定义？</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F;把网卡的数据映射到内存三种方式1.dpdk kin 2.net map 3.pf_ring</span><br><span class="line">    struct nm_desc *nmr &#x3D; nm_open(&quot;netmap:eth0&quot;, NULL, 0, NULL);&#x2F;&#x2F;映射网卡，就是打开的映射网卡的那块内存.</span><br><span class="line">    if(nmr &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct pollfd pfd &#x3D; &#123;0&#125;;</span><br><span class="line">    pfd.fd &#x3D; nmr-&gt;fd;</span><br><span class="line">    pfd.events &#x3D; POLLIN;</span><br><span class="line">    </span><br><span class="line">    while(1)&#123;</span><br><span class="line">       int ret &#x3D;  poll(&amp;pfd, 1, -1);&#x2F;&#x2F;单独一个IO不用用epoll;</span><br><span class="line">        if(ret &lt; 0) continue;</span><br><span class="line">        if(pfd.revents &amp; POLLIN)&#123;</span><br><span class="line">            struct nm_pkthdr h;</span><br><span class="line">            unsigned char *stream &#x3D; nm_nextpkt(nmr, &amp;h);&#x2F;&#x2F;取下一个包,从环形队列拿出buffer</span><br><span class="line">            struct ethhdr *eh &#x3D; (struct ethhdr*)stream;&#x2F;&#x2F;给他强转为以太网格式，判断是不是我们要的以太网．以此类推各个层的协议是否合适如果不合适直接丢弃.</span><br><span class="line">            if(ntohs(eh-&gt;h_proto) &#x3D;&#x3D; PROTO_IP )&#123;&#x2F;&#x2F;大小端判断转换字节续的问题只要超过两位就转换.</span><br><span class="line">                &#x2F;&#x2F;如果是个ip;</span><br><span class="line">                struct udppkt *udp &#x3D; (struct udppkt*)stream;&#x2F;&#x2F;发送出去的时候网络中有一个统一的字节序，这个不用管.</span><br><span class="line">                if(udp-&gt;ip.proto &#x3D;&#x3D; PROTO_UDP )&#123;</span><br><span class="line">                    int udplen &#x3D; ntohs(udp-&gt;udp.length);&#x2F;&#x2F;整个长度，我们把八个字节后的body部分打印出来.</span><br><span class="line">                    udp-&gt;body[udplen - 8] &#x3D; &#39;\0&#39;;</span><br><span class="line">                    printf(&quot;%s\n&quot;, udp-&gt;body);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>这里需要结合信息的传输逻辑来思考．</p><ol><li>首先网关接受信息，需要进行网关ip的确定．</li><li>编译我们的程序．打开运行工具insmod netmap.ko　</li><li>运行程序查看包的信息.</li></ol><p>两个问题:</p><ol><li>发包之后不能ping通.(因为数据从我们的应用程序走，不通过正常路径走，icmp协议没有实现)</li><li>过一段时间就不能再发送包了.（arp协议没有实现）<br>arp(协议) —&gt;arp(应用)<br>icmp(协议)—&gt;ping(应用)</li></ol><p>用户态协议栈.(网卡优化,比如零拷贝减少了复制的次数)<br>内核协议栈可以通过看端口有没有被占用.</p><p>c10m（千万并发问题）用来解决，用到的是零拷贝.<br>————————————————-第一部分完结—————————————-</p><h3 id="Tcp-Ip协议栈深度解析"><a href="#Tcp-Ip协议栈深度解析" class="headerlink" title="Tcp/Ip协议栈深度解析"></a>Tcp/Ip协议栈深度解析</h3><h4 id="如何实现tcp"><a href="#如何实现tcp" class="headerlink" title="如何实现tcp"></a>如何实现tcp</h4><p>前四块就是协议的实现.</p><ol><li>协议头</li><li>三次握手/四次挥手，11状态迁移</li><li>tcp的顺序,如何保证有序，延迟ack/滑动窗口</li><li>定时器，rtt,满启动与拥塞控制.</li><li>posix send.recv接口的实现,epoll如何实现.(epoll可读可写的事件从哪里触发的到的)</li></ol><h4 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h4><p>客户端: client<br>服务器: server</p><p>第一次: c-&gt;s syn置1,seq =23452 (随机值)<br>第二次: s-&gt;c 回复一个ack置1, acknum = 23453(seq + 1返回,表示前边都已经确认了再加上本身的1,syn置1, seq有一个随机值5436)值为无符号整形，到达上限会重新开始.<br>第三次: c–&gt;s ack置1,acknum = 5437(seq + 1).</p><h5 id="三次握手如何实现"><a href="#三次握手如何实现" class="headerlink" title="三次握手如何实现"></a>三次握手如何实现</h5><p>第一次握手，服务端如何保存客户端的握手信息？<br>创建一个连接队列，（名字叫半连接状态队列）实现的时候叫syn队列.<br>第三次握手，服务端如何保存客户端的握手信息?<br>同样也会创建一个连接队列（名字叫全连接队列），收到第三次握手时服务端会把信息与半链接状态队列中的信息进行比较，如果一致半连接队列中的数据会被直接把节点拿)到全连接状态队列，(accept队列),这些节点会伴随整个连接过程的．这些节点叫tcb(tcp控制块).</p><p>accept函数:<br>    从accept队列里面取出一个节点，并分配一个fd</p><p>listen(fd, backlog);<br>fd : 是服务器listen的fd.<br>backlog : 半连接队列和全连接队列的总长度(两个队列中只是节点的转移，不考虑删除等操作).<br>一般的时候syn队列中节点比较多.accept队列中的节点少，甚至为零.</p><p>如果大量的泛洪攻击服务器的话会产生什么后果?</p><p>如果客户端不给服务端回ack的话会有什么后果?服务器出现什么状态?<br>会出现半连接队列满的情况，服务器会崩溃，内核会爆．</p><p>图: tcp三次握手的五种状态<br>tcp的十一种状态:<br>    1.<br>    2.<br>    3.<br>    4.<br>    5. </p><p>四次挥手</p><p>在三次握手的时候就会区分客户和服务端，在四次挥手的时候就不会区分客户端和服务端．只有一端对应另一端（主动方和被动方）．<br>A方调用了close发送fin给B方,就是关闭了A方对B方的发送通道,被动方会发一个ACK,B(被动方)也会返送一个fin给主动方,主动方也会返回一个ACK,</p><p>第二次和第三次可以合在一起?<br>可以! 在什么时候可以合在一起呢?<br>和延迟ACK有关系,第一次返回ACK的时候，如果出现延迟的时候，恰好被动方也调用了close这个时候就会把连个包放在一起发送,就会变成三次挥手了,如果在第一个返回ACK后，隔一段时间再发fin就是两次,</p><p>十一种状态主要保存在哪里,每一个tcp,每一个socket,每一个连接都会有一个状态，这个状态保存在哪里?<br>tcb中的，绝对是tcb中的(这个就是上边说的那个节点).</p><p>图:四次挥手状态迁移图<br>如果出现很多close_wait状态现象是什么情况?</p><p>在被动方调用close这个函数不正常就会产生close_wait这个状态.</p><p>time_wait: 作用是什么呢?<br>第一个作用:确保最后一个ack能接收到，如果这个ack丢失，处在LAST_ACK状态就会定一个定时器，如果时间到了就会重新发送一个fin.<br>第二个作用: 防止上一次的数据和下一次数据的链接混淆.</p><p>四次挥手除了图中的五个状态，还会有另外的一种closing状态,中间的两条线都是被动方发过去的，一共有三种情况:<br>    1. 先发ack过一段时间发fin,会出现FIN_WAIT2的状态.<br>    2. 先发fin过一段时间发ack这个时候会出现closing状态.(没办法确定第一次的fin有没有到)<br>    3. ack + fin 同时发送这时候就会出现time_wait状态.</p><p>tcp如何保证顺序的?<br>由于包在网络中传输的过程路径选择等原因造成包的变成无序的，在一个包到了之后会儿等待两百毫秒,比如1号包到了等两百毫秒，如果2号包到了之后会重置定时器,再等200毫秒,在超时的时候，会判断那个包之前的包都收到了，就对应的回一个确认消息（这个包的序号），通过延迟ack来确认这个包是有顺序的．</p><p>既然tcp是可靠传输，为什么还会出现udp可靠传输呢?<br>udp有两种应用:<br>    1. 下载，有tcp的拥塞控制.<br>    2. udp的实时性:<br>        延迟ack也是为了增加tcp的传输效率<br>        udp牺牲了这种效率来完成实时性.</p><p>如何确定发送包的多少呢?<br>慢启动与拥塞控制<br>慢启动: 就是成指数增长,就比如说1, 2, 4,…<br>这里涉及到了拥塞控制门限值，第一次初始化他是有一个默认值的，超过这个值的时候就会自然增长（就是加1这样的），总的来说前面是指数增长后边是线性增长,直到这个包收不到的时候（发生拥塞了（默认为是网络带宽的问题）），产生拥塞的那个值除以2, 再正常增长，开始那个指数增长就是慢开始，后边指数增长的时候就是拥塞控制，慢启动计算出来的这个值就是滑动窗口的大小．</p><p>发送窗口:<br>    发送的端会通过两个指针把发送队列分成三部分，已经发送，允许发送，不允许发送．允许发送的窗口的大小就是慢启动计算出来的那个值．<br>    对应允许发送窗口的接收方的就是使用了延迟ack来确定的．</p><p>(ack)定时器的时间如何设置?(ack延时多久回复一个ack呢)<br>第一个挥手收到的ack(这里所确定的确定定时器)，这里的定时器的超时如何设置?<br>从三次握手的时候第一个ack回复的时候就会记录一个这个样的值，称为rtt(从发送到确认这段时间的der塔值),他的公式为rtt = 0.9*old_rtt + 0.1 * new_rtt,采用这个公式完成消抖(上下抖动过高)的过程,这样就能计算出下一次的rtt, new_rtt(上一个rtt),old_rtt表示上上一个，用相关的系数来消除new_rtt过高或者过低引起的抖动问题.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>c++8</title>
    <link href="http://example.com/posts/28273/"/>
    <id>http://example.com/posts/28273/</id>
    <published>2020-12-19T01:47:32.000Z</published>
    <updated>2020-12-21T14:14:13.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ping命令的实现"><a href="#ping命令的实现" class="headerlink" title="ping命令的实现"></a>ping命令的实现</h3><p><a href="https://blog.csdn.net/qq_33724710/article/details/51576444">相关实现</a></p><h3 id="udp实现可靠通信"><a href="#udp实现可靠通信" class="headerlink" title="udp实现可靠通信"></a>udp实现可靠通信</h3><p><a href="https://blog.csdn.net/gettogetto/article/details/76736365">udp可靠性通信</a></p><h3 id="什么情况必须用UDP代替tcp"><a href="#什么情况必须用UDP代替tcp" class="headerlink" title="什么情况必须用UDP代替tcp"></a>什么情况必须用UDP代替tcp</h3><h3 id="DNS服务器解析"><a href="#DNS服务器解析" class="headerlink" title="DNS服务器解析"></a>DNS服务器解析</h3><p><a href="https://www.cnblogs.com/gopark/p/8430916.html">详细解释</a><br><a href="https://www.cnblogs.com/gopark/p/8430936.html">DNS解析过程详解</a></p><h3 id="高并发直接对数据库访问-优化"><a href="#高并发直接对数据库访问-优化" class="headerlink" title="高并发直接对数据库访问,优化"></a>高并发直接对数据库访问,优化</h3><h3 id="数据库底层实现"><a href="#数据库底层实现" class="headerlink" title="数据库底层实现"></a>数据库底层实现</h3><h3 id="最大连续子数组和"><a href="#最大连续子数组和" class="headerlink" title="最大连续子数组和"></a>最大连续子数组和</h3><h3 id="单-cpu-多线程实现"><a href="#单-cpu-多线程实现" class="headerlink" title="单 cpu 多线程实现"></a>单 cpu 多线程实现</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="交换单链表的第-n-个节点和倒数第-m-个节点"><a href="#交换单链表的第-n-个节点和倒数第-m-个节点" class="headerlink" title="交换单链表的第 n 个节点和倒数第 m 个节点"></a>交换单链表的第 n 个节点和倒数第 m 个节点</h3><h3 id="写一个程序判定系统是大端模式还是小端模式"><a href="#写一个程序判定系统是大端模式还是小端模式" class="headerlink" title="写一个程序判定系统是大端模式还是小端模式"></a>写一个程序判定系统是大端模式还是小端模式</h3><h3 id="实现-memmove-函数"><a href="#实现-memmove-函数" class="headerlink" title="实现 memmove()函数"></a>实现 memmove()函数</h3><h3 id="attribute-关键字"><a href="#attribute-关键字" class="headerlink" title="attribute 关键字"></a>attribute 关键字</h3><h3 id="位域的概念"><a href="#位域的概念" class="headerlink" title="位域的概念"></a>位域的概念</h3><h3 id="memory-barry"><a href="#memory-barry" class="headerlink" title="memory barry"></a>memory barry</h3><h3 id="int-foo-5-int-const-char-是什么意思"><a href="#int-foo-5-int-const-char-是什么意思" class="headerlink" title="int * (*foo[5]) (int, const char *) 是什么意思"></a>int * (*foo[5]) (int, const char *) 是什么意思</h3><h3 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h3><h3 id="操作系统从上电到启动的过程"><a href="#操作系统从上电到启动的过程" class="headerlink" title="操作系统从上电到启动的过程"></a>操作系统从上电到启动的过程</h3><h3 id="KVM-和-Xen-的区别"><a href="#KVM-和-Xen-的区别" class="headerlink" title="KVM 和 Xen 的区别"></a>KVM 和 Xen 的区别</h3><h3 id="特权指令和敏感指令的区别"><a href="#特权指令和敏感指令的区别" class="headerlink" title="特权指令和敏感指令的区别"></a>特权指令和敏感指令的区别</h3><h3 id="Linux-从用户态切换到内核态的过程"><a href="#Linux-从用户态切换到内核态的过程" class="headerlink" title="Linux 从用户态切换到内核态的过程"></a>Linux 从用户态切换到内核态的过程</h3><h3 id="操作系统访问-IO-的过程"><a href="#操作系统访问-IO-的过程" class="headerlink" title="操作系统访问 IO 的过程"></a>操作系统访问 IO 的过程</h3><h3 id="软中断和硬中断的区别"><a href="#软中断和硬中断的区别" class="headerlink" title="软中断和硬中断的区别"></a>软中断和硬中断的区别</h3><h3 id="C-语言编译链接的过程"><a href="#C-语言编译链接的过程" class="headerlink" title="C 语言编译链接的过程"></a>C 语言编译链接的过程</h3><h3 id="函数调用压栈的过程"><a href="#函数调用压栈的过程" class="headerlink" title="函数调用压栈的过程"></a>函数调用压栈的过程</h3><h3 id="以及现在操作系统对栈的优化"><a href="#以及现在操作系统对栈的优化" class="headerlink" title="以及现在操作系统对栈的优化"></a>以及现在操作系统对栈的优化</h3><h3 id="进程和线程的区别-进程间通信机制"><a href="#进程和线程的区别-进程间通信机制" class="headerlink" title="进程和线程的区别,进程间通信机制,"></a>进程和线程的区别,进程间通信机制,</h3><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议,"></a>TCP 协议,</h3><h3 id="static-关键字的用法"><a href="#static-关键字的用法" class="headerlink" title="static 关键字的用法,"></a>static 关键字的用法,</h3><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别,"></a>堆和栈的区别,</h3><h3 id="C-语言内存分配"><a href="#C-语言内存分配" class="headerlink" title="C 语言内存分配"></a>C 语言内存分配</h3><h3 id="对高负载有了解么"><a href="#对高负载有了解么" class="headerlink" title="对高负载有了解么"></a>对高负载有了解么</h3><h3 id="对高并发有了解么"><a href="#对高并发有了解么" class="headerlink" title="对高并发有了解么?"></a>对高并发有了解么?</h3><h3 id="Arraylist-的原理"><a href="#Arraylist-的原理" class="headerlink" title="Arraylist 的原理"></a>Arraylist 的原理</h3><h3 id="场景题-设计判断论文抄袭的系统"><a href="#场景题-设计判断论文抄袭的系统" class="headerlink" title="场景题:设计判断论文抄袭的系统"></a>场景题:设计判断论文抄袭的系统</h3><h3 id="堆排序的原理"><a href="#堆排序的原理" class="headerlink" title="堆排序的原理"></a>堆排序的原理</h3><h3 id="抽象工厂和工厂方法模式的区别"><a href="#抽象工厂和工厂方法模式的区别" class="headerlink" title="抽象工厂和工厂方法模式的区别"></a>抽象工厂和工厂方法模式的区别</h3><h3 id="工厂模式的思想"><a href="#工厂模式的思想" class="headerlink" title="工厂模式的思想"></a>工厂模式的思想</h3><h3 id="Forward-和-redirect-的区别"><a href="#Forward-和-redirect-的区别" class="headerlink" title="Forward 和 redirect 的区别"></a>Forward 和 redirect 的区别</h3><h3 id="线程池的使用时的注意事项"><a href="#线程池的使用时的注意事项" class="headerlink" title="线程池的使用时的注意事项"></a>线程池的使用时的注意事项</h3><h3 id="Spring-中-autowire-和-resourse-关键字的区别"><a href="#Spring-中-autowire-和-resourse-关键字的区别" class="headerlink" title="Spring 中 autowire 和 resourse 关键字的区别"></a>Spring 中 autowire 和 resourse 关键字的区别</h3><h3 id="Hashmap-的原理"><a href="#Hashmap-的原理" class="headerlink" title="Hashmap 的原理"></a>Hashmap 的原理</h3><h3 id="Hashmap-的大小为什么指定为-2-的幂次"><a href="#Hashmap-的大小为什么指定为-2-的幂次" class="headerlink" title="Hashmap 的大小为什么指定为 2 的幂次"></a>Hashmap 的大小为什么指定为 2 的幂次</h3><h3 id="讲一下线程状态转移图"><a href="#讲一下线程状态转移图" class="headerlink" title="讲一下线程状态转移图"></a>讲一下线程状态转移图</h3><h3 id="消息队列了解么"><a href="#消息队列了解么" class="headerlink" title="消息队列了解么"></a>消息队列了解么</h3><h3 id="分布式了解么"><a href="#分布式了解么" class="headerlink" title="分布式了解么"></a>分布式了解么</h3><h3 id="来个算法题-一个无序数组-其中一个数字出现的次数大于其他数字之和-求"><a href="#来个算法题-一个无序数组-其中一个数字出现的次数大于其他数字之和-求" class="headerlink" title="来个算法题:一个无序数组,其中一个数字出现的次数大于其他数字之和, 求"></a>来个算法题:一个无序数组,其中一个数字出现的次数大于其他数字之和, 求</h3><h3 id="这个数字-主元素"><a href="#这个数字-主元素" class="headerlink" title="这个数字 (主元素)"></a>这个数字 (主元素)</h3><h3 id="答完再来一个-一个数组-有正有负-不改变顺序的情况下-求和最大的最-长子序列"><a href="#答完再来一个-一个数组-有正有负-不改变顺序的情况下-求和最大的最-长子序列" class="headerlink" title="答完再来一个:一个数组,有正有负,不改变顺序的情况下,求和最大的最 长子序列"></a>答完再来一个:一个数组,有正有负,不改变顺序的情况下,求和最大的最 长子序列</h3><h3 id="项目用到什么数据库-隔离级别-每个隔离级别各做了什么"><a href="#项目用到什么数据库-隔离级别-每个隔离级别各做了什么" class="headerlink" title="项目用到什么数据库?隔离级别?每个隔离级别各做了什么"></a>项目用到什么数据库?隔离级别?每个隔离级别各做了什么</h3><h3 id="数据库的索引-mysql-不同引擎索引的区别"><a href="#数据库的索引-mysql-不同引擎索引的区别" class="headerlink" title="数据库的索引?mysql 不同引擎索引的区别"></a>数据库的索引?mysql 不同引擎索引的区别</h3><h3 id="垃圾回收算法的过程"><a href="#垃圾回收算法的过程" class="headerlink" title="垃圾回收算法的过程"></a>垃圾回收算法的过程</h3><h3 id="数据库的索引"><a href="#数据库的索引" class="headerlink" title="数据库的索引"></a>数据库的索引</h3><h3 id="对算法有什么了解-答主先回答了动态规划-解释了一下-dp-的思想"><a href="#对算法有什么了解-答主先回答了动态规划-解释了一下-dp-的思想" class="headerlink" title="对算法有什么了解?答主先回答了动态规划,解释了一下 dp 的思想"></a>对算法有什么了解?答主先回答了动态规划,解释了一下 dp 的思想</h3><h3 id="快排的思想讲一下"><a href="#快排的思想讲一下" class="headerlink" title="快排的思想讲一下"></a>快排的思想讲一下</h3><h3 id="tcp-怎么保证可靠传输-中间穿插了好多小问题"><a href="#tcp-怎么保证可靠传输-中间穿插了好多小问题" class="headerlink" title="tcp 怎么保证可靠传输(中间穿插了好多小问题)"></a>tcp 怎么保证可靠传输(中间穿插了好多小问题)</h3><h3 id="Tcp-的拥塞控制"><a href="#Tcp-的拥塞控制" class="headerlink" title="Tcp 的拥塞控制"></a>Tcp 的拥塞控制</h3><h3 id="让你设计一个即时聊天的系统"><a href="#让你设计一个即时聊天的系统" class="headerlink" title="让你设计一个即时聊天的系统"></a>让你设计一个即时聊天的系统</h3><h3 id="支付宝转账-是如何实现-几个小时通知转账成功的-面试官想让回答长连接-答主一直没-get-到点"><a href="#支付宝转账-是如何实现-几个小时通知转账成功的-面试官想让回答长连接-答主一直没-get-到点" class="headerlink" title="支付宝转账,是如何实现,几个小时通知转账成功的(面试官想让回答长连接,答主一直没 get 到点)"></a>支付宝转账,是如何实现,几个小时通知转账成功的(面试官想让回答长连接,答主一直没 get 到点)</h3><h3 id="解释一下长连接"><a href="#解释一下长连接" class="headerlink" title="解释一下长连接"></a>解释一下长连接</h3><h3 id="手撕算法-一棵二叉排序树-给定一个数-找到与给定数差值最小的数"><a href="#手撕算法-一棵二叉排序树-给定一个数-找到与给定数差值最小的数" class="headerlink" title="手撕算法:一棵二叉排序树,给定一个数,找到与给定数差值最小的数"></a>手撕算法:一棵二叉排序树,给定一个数,找到与给定数差值最小的数</h3><h3 id="场景题-设计一个系统-解决抢购时所需要的大量的短链接的功能-如何保证高并发-如何设计短链接"><a href="#场景题-设计一个系统-解决抢购时所需要的大量的短链接的功能-如何保证高并发-如何设计短链接" class="headerlink" title="场景题:设计一个系统,解决抢购时所需要的大量的短链接的功能,如何保证高并发,如何设计短链接"></a>场景题:设计一个系统,解决抢购时所需要的大量的短链接的功能,如何保证高并发,如何设计短链接</h3><h3 id="设计题-设计一个系统-记录-qq-用户前一天的登录状态-提供-16g-内存和2tb-的硬盘-要做到查询指定qq号的前一天的登录状态-快速查询-O-1-复杂度"><a href="#设计题-设计一个系统-记录-qq-用户前一天的登录状态-提供-16g-内存和2tb-的硬盘-要做到查询指定qq号的前一天的登录状态-快速查询-O-1-复杂度" class="headerlink" title="设计题:设计一个系统,记录 qq 用户前一天的登录状态,提供 16g 内存和2tb 的硬盘,要做到查询指定qq号的前一天的登录状态,快速查询 O(1)复杂度"></a>设计题:设计一个系统,记录 qq 用户前一天的登录状态,提供 16g 内存和2tb 的硬盘,要做到查询指定qq号的前一天的登录状态,快速查询 O(1)复杂度</h3><h3 id="手撕算法-两个排序的数组-A-和-B-分别含有-m-和-n-个数-找到两个排序数组的中位-数-答主用的二分-时间复杂度为-O-log-m-n-。结果面试官不满意-让用归并的思-想做-时间复杂度其实更高了"><a href="#手撕算法-两个排序的数组-A-和-B-分别含有-m-和-n-个数-找到两个排序数组的中位-数-答主用的二分-时间复杂度为-O-log-m-n-。结果面试官不满意-让用归并的思-想做-时间复杂度其实更高了" class="headerlink" title="手撕算法:两个排序的数组 A 和 B 分别含有 m 和 n 个数,找到两个排序数组的中位 数,答主用的二分,时间复杂度为 O(log (m+n))。结果面试官不满意,让用归并的思 想做,时间复杂度其实更高了"></a>手撕算法:两个排序的数组 A 和 B 分别含有 m 和 n 个数,找到两个排序数组的中位 数,答主用的二分,时间复杂度为 O(log (m+n))。结果面试官不满意,让用归并的思 想做,时间复杂度其实更高了</h3><h3 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h3><h3 id="数据库的引擎"><a href="#数据库的引擎" class="headerlink" title="数据库的引擎"></a>数据库的引擎</h3><h3 id="算法题-给一个整数数组-找到两个数使得他们的和等于一个给定的数"><a href="#算法题-给一个整数数组-找到两个数使得他们的和等于一个给定的数" class="headerlink" title="算法题:给一个整数数组,找到两个数使得他们的和等于一个给定的数"></a>算法题:给一个整数数组,找到两个数使得他们的和等于一个给定的数</h3><h3 id="自己写一个-tomcat-服务器-你会怎么写"><a href="#自己写一个-tomcat-服务器-你会怎么写" class="headerlink" title="自己写一个 tomcat 服务器,你会怎么写"></a>自己写一个 tomcat 服务器,你会怎么写</h3><h3 id="一千万用户并发抢购-怎么设计"><a href="#一千万用户并发抢购-怎么设计" class="headerlink" title="一千万用户并发抢购,怎么设计"></a>一千万用户并发抢购,怎么设计</h3><h3 id="讲一下数据的-acid"><a href="#讲一下数据的-acid" class="headerlink" title="讲一下数据的 acid"></a>讲一下数据的 acid</h3><h3 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h3><h3 id="什么是隔离性"><a href="#什么是隔离性" class="headerlink" title="什么是隔离性"></a>什么是隔离性</h3><h3 id="Mysql-的隔离级别"><a href="#Mysql-的隔离级别" class="headerlink" title="Mysql 的隔离级别"></a>Mysql 的隔离级别</h3><h3 id="每个隔离级别是如何解决"><a href="#每个隔离级别是如何解决" class="headerlink" title="每个隔离级别是如何解决"></a>每个隔离级别是如何解决</h3><h3 id="然后面试官设置了每个参数-给了是个线程-让描述出完整的线程池执行的流程"><a href="#然后面试官设置了每个参数-给了是个线程-让描述出完整的线程池执行的流程" class="headerlink" title="然后面试官设置了每个参数,给了是个线程,让描述出完整的线程池执行的流程"></a>然后面试官设置了每个参数,给了是个线程,让描述出完整的线程池执行的流程</h3><h3 id="Linux-了解么"><a href="#Linux-了解么" class="headerlink" title="Linux 了解么"></a>Linux 了解么</h3><h3 id="怎么查看系统负载"><a href="#怎么查看系统负载" class="headerlink" title="怎么查看系统负载"></a>怎么查看系统负载</h3><h3 id="Cpu-load-的参数如果为-4-描述一下现在系统处于什么情况"><a href="#Cpu-load-的参数如果为-4-描述一下现在系统处于什么情况" class="headerlink" title="Cpu load 的参数如果为 4,描述一下现在系统处于什么情况"></a>Cpu load 的参数如果为 4,描述一下现在系统处于什么情况</h3><h3 id="Linux-查找磁盘上最大的文件的命令"><a href="#Linux-查找磁盘上最大的文件的命令" class="headerlink" title="Linux,查找磁盘上最大的文件的命令"></a>Linux,查找磁盘上最大的文件的命令</h3><h3 id="Linux-如何查看系统日志文件"><a href="#Linux-如何查看系统日志文件" class="headerlink" title="Linux,如何查看系统日志文件"></a>Linux,如何查看系统日志文件</h3><h3 id="手撕算法-leeetcode-原题-22-Generate-Parentheses-给定-n-对括号-请写一个函数-以将其生成新的括号组合-并返回所有组合结果。"><a href="#手撕算法-leeetcode-原题-22-Generate-Parentheses-给定-n-对括号-请写一个函数-以将其生成新的括号组合-并返回所有组合结果。" class="headerlink" title="手撕算法:leeetcode 原题 22,Generate Parentheses,给定 n 对括号,请写一个函数 以将其生成新的括号组合,并返回所有组合结果。"></a>手撕算法:leeetcode 原题 22,Generate Parentheses,给定 n 对括号,请写一个函数 以将其生成新的括号组合,并返回所有组合结果。</h3><h3 id="数据库的索引原理"><a href="#数据库的索引原理" class="headerlink" title="数据库的索引原理"></a>数据库的索引原理</h3><h3 id="非聚簇索引和聚簇索引"><a href="#非聚簇索引和聚簇索引" class="headerlink" title="非聚簇索引和聚簇索引"></a>非聚簇索引和聚簇索引</h3><h3 id="索引的使用注意事项"><a href="#索引的使用注意事项" class="headerlink" title="索引的使用注意事项"></a>索引的使用注意事项</h3><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h3 id="从底层解释最左匹配原则"><a href="#从底层解释最左匹配原则" class="headerlink" title="从底层解释最左匹配原则"></a>从底层解释最左匹配原则</h3><h3 id="Mysql-对联合索引有优化么-会自动调整顺序么-哪个版本开始优化"><a href="#Mysql-对联合索引有优化么-会自动调整顺序么-哪个版本开始优化" class="headerlink" title="Mysql 对联合索引有优化么?会自动调整顺序么?哪个版本开始优化?"></a>Mysql 对联合索引有优化么?会自动调整顺序么?哪个版本开始优化?</h3><h3 id="手撕一个单例模式"><a href="#手撕一个单例模式" class="headerlink" title="手撕一个单例模式"></a>手撕一个单例模式</h3><h3 id="快速排序的思想讲一下"><a href="#快速排序的思想讲一下" class="headerlink" title="快速排序的思想讲一下"></a>快速排序的思想讲一下</h3><h3 id="给个数组-模拟快排的过程"><a href="#给个数组-模拟快排的过程" class="headerlink" title="给个数组,模拟快排的过程"></a>给个数组,模拟快排的过程</h3><h3 id="手写快排"><a href="#手写快排" class="headerlink" title="手写快排"></a>手写快排</h3><h3 id="反爬虫的机制-有哪些方式"><a href="#反爬虫的机制-有哪些方式" class="headerlink" title="反爬虫的机制,有哪些方式"></a>反爬虫的机制,有哪些方式</h3><h3 id="手撕算法-反转单链表"><a href="#手撕算法-反转单链表" class="headerlink" title="手撕算法:反转单链表"></a>手撕算法:反转单链表</h3><h3 id="手撕算法-实现类似微博子结构的数据结构-输入一系列父子关系-输出一"><a href="#手撕算法-实现类似微博子结构的数据结构-输入一系列父子关系-输出一" class="headerlink" title="手撕算法:实现类似微博子结构的数据结构,输入一系列父子关系,输出一"></a>手撕算法:实现类似微博子结构的数据结构,输入一系列父子关系,输出一</h3><h3 id="个类似微博-评论的父子结构图设计题-一个图书馆管理系统-数据库怎么设计-需求自己定"><a href="#个类似微博-评论的父子结构图设计题-一个图书馆管理系统-数据库怎么设计-需求自己定" class="headerlink" title="个类似微博 评论的父子结构图设计题,一个图书馆管理系统,数据库怎么设计,需求自己定"></a>个类似微博 评论的父子结构图设计题,一个图书馆管理系统,数据库怎么设计,需求自己定</h3><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><h3 id="手撕算法-爬楼梯-写出状态转移方程"><a href="#手撕算法-爬楼梯-写出状态转移方程" class="headerlink" title="手撕算法: 爬楼梯,写出状态转移方程"></a>手撕算法: 爬楼梯,写出状态转移方程</h3><h3 id="智力题-时针分针什么时候重合"><a href="#智力题-时针分针什么时候重合" class="headerlink" title="智力题:时针分针什么时候重合"></a>智力题:时针分针什么时候重合</h3><h3 id="多线程条件变量为什么要在-while-体里"><a href="#多线程条件变量为什么要在-while-体里" class="headerlink" title="多线程条件变量为什么要在 while 体里"></a>多线程条件变量为什么要在 while 体里</h3><h3 id="会不会滥用设计模式"><a href="#会不会滥用设计模式" class="headerlink" title="会不会滥用设计模式"></a>会不会滥用设计模式</h3><h3 id="多线程的理解-如何保证线程安全"><a href="#多线程的理解-如何保证线程安全" class="headerlink" title="多线程的理解,如何保证线程安全"></a>多线程的理解,如何保证线程安全</h3><h3 id="场景题-千万用户抢购-如何处理高并发-并且有一个链接-指向前一天抢"><a href="#场景题-千万用户抢购-如何处理高并发-并且有一个链接-指向前一天抢" class="headerlink" title="场景题:千万用户抢购,如何处理高并发,并且有一个链接,指向前一天抢"></a>场景题:千万用户抢购,如何处理高并发,并且有一个链接,指向前一天抢</h3><h3 id="购成功的用-户-如何设计这个系统和数据库"><a href="#购成功的用-户-如何设计这个系统和数据库" class="headerlink" title="购成功的用 户,如何设计这个系统和数据库"></a>购成功的用 户,如何设计这个系统和数据库</h3><h3 id="如果后台处理抢购请求的服务器-每次最多承受-200-的负载-系统该怎么设计"><a href="#如果后台处理抢购请求的服务器-每次最多承受-200-的负载-系统该怎么设计" class="headerlink" title="如果后台处理抢购请求的服务器,每次最多承受 200 的负载,系统该怎么设计"></a>如果后台处理抢购请求的服务器,每次最多承受 200 的负载,系统该怎么设计</h3><h3 id="最小公倍数和最大公约数"><a href="#最小公倍数和最大公约数" class="headerlink" title=":最小公倍数和最大公约数"></a>:最小公倍数和最大公约数</h3><h3 id="个完整请求的流程"><a href="#个完整请求的流程" class="headerlink" title="个完整请求的流程"></a>个完整请求的流程</h3><h3 id="Mysql-的容灾备份"><a href="#Mysql-的容灾备份" class="headerlink" title="Mysql 的容灾备份"></a>Mysql 的容灾备份</h3><h3 id="写一个两个有序链表合并成一个有序链表"><a href="#写一个两个有序链表合并成一个有序链表" class="headerlink" title="写一个两个有序链表合并成一个有序链表"></a>写一个两个有序链表合并成一个有序链表</h3><h3 id="死锁是什么呢"><a href="#死锁是什么呢" class="headerlink" title="死锁是什么呢"></a>死锁是什么呢</h3><h3 id="怎么解决死锁"><a href="#怎么解决死锁" class="headerlink" title="怎么解决死锁"></a>怎么解决死锁</h3><h3 id="http-请求流程"><a href="#http-请求流程" class="headerlink" title="http 请求流程"></a>http 请求流程</h3><h3 id="为什么负载均衡"><a href="#为什么负载均衡" class="headerlink" title="为什么负载均衡"></a>为什么负载均衡</h3><h3 id="怎么实现负载均衡"><a href="#怎么实现负载均衡" class="headerlink" title="怎么实现负载均衡"></a>怎么实现负载均衡</h3><h3 id="数据库挂了怎么办-除了热备份还有什么方法"><a href="#数据库挂了怎么办-除了热备份还有什么方法" class="headerlink" title="数据库挂了怎么办?除了热备份还有什么方法"></a>数据库挂了怎么办?除了热备份还有什么方法</h3><h3 id="算法-找出两个数组相等的数-不能用其他数据结构"><a href="#算法-找出两个数组相等的数-不能用其他数据结构" class="headerlink" title="算法:找出两个数组相等的数,不能用其他数据结构"></a>算法:找出两个数组相等的数,不能用其他数据结构</h3><h3 id="算法-给定一个数字-一个数组-找出数组中相加等于这两个数的和-不能用数据结构"><a href="#算法-给定一个数字-一个数组-找出数组中相加等于这两个数的和-不能用数据结构" class="headerlink" title="算法:给定一个数字,一个数组,找出数组中相加等于这两个数的和,不能用数据结构"></a>算法:给定一个数字,一个数组,找出数组中相加等于这两个数的和,不能用数据结构</h3><h3 id="算法-如何判断一个树是不是另一颗树的子树"><a href="#算法-如何判断一个树是不是另一颗树的子树" class="headerlink" title="算法:如何判断一个树是不是另一颗树的子树"></a>算法:如何判断一个树是不是另一颗树的子树</h3><h3 id="如何解决并发访问的错误I-操作怎么保证线程安全"><a href="#如何解决并发访问的错误I-操作怎么保证线程安全" class="headerlink" title="如何解决并发访问的错误I++操作怎么保证线程安全"></a>如何解决并发访问的错误I++操作怎么保证线程安全</h3><h3 id="场景题-设计一个下单系统-下单成功后可以给用户发优惠券"><a href="#场景题-设计一个下单系统-下单成功后可以给用户发优惠券" class="headerlink" title="场景题:设计一个下单系统,下单成功后可以给用户发优惠券"></a>场景题:设计一个下单系统,下单成功后可以给用户发优惠券</h3><h3 id="接上面场景题-服务器挂了-优惠券还没发怎么办"><a href="#接上面场景题-服务器挂了-优惠券还没发怎么办" class="headerlink" title="接上面场景题:服务器挂了,优惠券还没发怎么办"></a>接上面场景题:服务器挂了,优惠券还没发怎么办</h3><h3 id="数据库挂了怎么怎么办"><a href="#数据库挂了怎么怎么办" class="headerlink" title="数据库挂了怎么怎么办"></a>数据库挂了怎么怎么办</h3><h3 id="怎么保证一致性"><a href="#怎么保证一致性" class="headerlink" title="怎么保证一致性"></a>怎么保证一致性</h3><h3 id="分布式事务知道么"><a href="#分布式事务知道么" class="headerlink" title="分布式事务知道么"></a>分布式事务知道么</h3><h3 id="介绍分布式事务"><a href="#介绍分布式事务" class="headerlink" title="介绍分布式事务"></a>介绍分布式事务</h3><h3 id="锁的实现原理"><a href="#锁的实现原理" class="headerlink" title="锁的实现原理"></a>锁的实现原理</h3><h3 id="怎么解决缓存和主存的一致性问题"><a href="#怎么解决缓存和主存的一致性问题" class="headerlink" title="怎么解决缓存和主存的一致性问题"></a>怎么解决缓存和主存的一致性问题</h3><h3 id="缓存还没更新到主存-服务器挂了怎么办"><a href="#缓存还没更新到主存-服务器挂了怎么办" class="headerlink" title="缓存还没更新到主存,服务器挂了怎么办"></a>缓存还没更新到主存,服务器挂了怎么办</h3><h3 id="数据库挂了怎么办"><a href="#数据库挂了怎么办" class="headerlink" title="数据库挂了怎么办"></a>数据库挂了怎么办</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h3 id="什么时候用读锁"><a href="#什么时候用读锁" class="headerlink" title="什么时候用读锁"></a>什么时候用读锁</h3><h3 id="什么时候用写锁"><a href="#什么时候用写锁" class="headerlink" title="什么时候用写锁"></a>什么时候用写锁</h3><h3 id="数据库的瓶颈"><a href="#数据库的瓶颈" class="headerlink" title="数据库的瓶颈"></a>数据库的瓶颈</h3><h3 id="常见的内存泄漏-内存溢出-怎么解决"><a href="#常见的内存泄漏-内存溢出-怎么解决" class="headerlink" title="常见的内存泄漏/内存溢出?怎么解决"></a>常见的内存泄漏/内存溢出?怎么解决</h3><h3 id="手写一个有序数组的合并"><a href="#手写一个有序数组的合并" class="headerlink" title="手写一个有序数组的合并?"></a>手写一个有序数组的合并?</h3><h3 id="用最小的时间复杂度判断单链表是否有交点。"><a href="#用最小的时间复杂度判断单链表是否有交点。" class="headerlink" title="用最小的时间复杂度判断单链表是否有交点。"></a>用最小的时间复杂度判断单链表是否有交点。</h3><h3 id="手写二叉树的按层级进行遍历"><a href="#手写二叉树的按层级进行遍历" class="headerlink" title="手写二叉树的按层级进行遍历"></a>手写二叉树的按层级进行遍历</h3><h3 id="算法-翻转一个-int-型的大数-Linux-管道的作用。"><a href="#算法-翻转一个-int-型的大数-Linux-管道的作用。" class="headerlink" title="算法:翻转一个 int 型的大数,Linux 管道的作用。"></a>算法:翻转一个 int 型的大数,Linux 管道的作用。</h3><h3 id="手撕代码-版本号-每次加一-到-99-变成进位"><a href="#手撕代码-版本号-每次加一-到-99-变成进位" class="headerlink" title="手撕代码: 版本号,每次加一,到 99 变成进位"></a>手撕代码: 版本号,每次加一,到 99 变成进位</h3><h3 id="udp-和-tcp-区别"><a href="#udp-和-tcp-区别" class="headerlink" title="udp 和 tcp 区别"></a>udp 和 tcp 区别</h3><h3 id="linux-基本命令-给个-ip-地址-char"><a href="#linux-基本命令-给个-ip-地址-char" class="headerlink" title="linux 基本命令 给个 ip 地址(char*)"></a>linux 基本命令 给个 ip 地址(char*)</h3><h3 id="写个程序判断是否合法"><a href="#写个程序判断是否合法" class="headerlink" title="写个程序判断是否合法"></a>写个程序判断是否合法</h3><h3 id="日志中有用户名-上线、下线时间-如何统计每秒的用户在线数"><a href="#日志中有用户名-上线、下线时间-如何统计每秒的用户在线数" class="headerlink" title="日志中有用户名,上线、下线时间,如何统计每秒的用户在线数"></a>日志中有用户名,上线、下线时间,如何统计每秒的用户在线数</h3><h3 id="智力题-8-个球球-找不一样的"><a href="#智力题-8-个球球-找不一样的" class="headerlink" title="智力题,8 个球球,找不一样的"></a>智力题,8 个球球,找不一样的</h3><h3 id="怎么定位移动端的元素"><a href="#怎么定位移动端的元素" class="headerlink" title="怎么定位移动端的元素"></a>怎么定位移动端的元素</h3><h3 id="代码-是-kmp-算法的那个题目-楼主一看就知道自己写不出来-就说能不能写"><a href="#代码-是-kmp-算法的那个题目-楼主一看就知道自己写不出来-就说能不能写" class="headerlink" title="代码: 是 kmp 算法的那个题目,楼主一看就知道自己写不出来,就说能不能写"></a>代码: 是 kmp 算法的那个题目,楼主一看就知道自己写不出来,就说能不能写</h3><h3 id="两个-for-循环-面试官愉快的同意了-写完程序-面试官让写测试用例-测试这"><a href="#两个-for-循环-面试官愉快的同意了-写完程序-面试官让写测试用例-测试这" class="headerlink" title="两个 for 循环,面试官愉快的同意了 写完程序,面试官让写测试用例,测试这"></a>两个 for 循环,面试官愉快的同意了 写完程序,面试官让写测试用例,测试这</h3><h3 id="个程序-说出程序的问题-指导我改正-人超级-nice"><a href="#个程序-说出程序的问题-指导我改正-人超级-nice" class="headerlink" title="个程序 说出程序的问题,指导我改正,人超级 nice"></a>个程序 说出程序的问题,指导我改正,人超级 nice</h3><h3 id="链表逆转"><a href="#链表逆转" class="headerlink" title="链表逆转"></a>链表逆转</h3><h3 id="自己建立个链表测试一下那个程序"><a href="#自己建立个链表测试一下那个程序" class="headerlink" title="自己建立个链表测试一下那个程序"></a>自己建立个链表测试一下那个程序</h3><h3 id="链表的冒泡-不可以换数据-交换节点的那种"><a href="#链表的冒泡-不可以换数据-交换节点的那种" class="headerlink" title="链表的冒泡(不可以换数据,交换节点的那种)"></a>链表的冒泡(不可以换数据,交换节点的那种)</h3><h3 id="手写代码-手写冒泡排序"><a href="#手写代码-手写冒泡排序" class="headerlink" title="手写代码:手写冒泡排序"></a>手写代码:手写冒泡排序</h3><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><h3 id="死锁原因及解决方法"><a href="#死锁原因及解决方法" class="headerlink" title="死锁原因及解决方法"></a>死锁原因及解决方法</h3><h3 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h3><h3 id="手写代码-寻找二维数组的鞍点"><a href="#手写代码-寻找二维数组的鞍点" class="headerlink" title="手写代码:寻找二维数组的鞍点"></a>手写代码:寻找二维数组的鞍点</h3><h3 id="c-语言各种变量所在的节"><a href="#c-语言各种变量所在的节" class="headerlink" title="c 语言各种变量所在的节"></a>c 语言各种变量所在的节</h3><h3 id="C-虚函数的实现"><a href="#C-虚函数的实现" class="headerlink" title="C++虚函数的实现"></a>C++虚函数的实现</h3><h3 id="有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。"><a href="#有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。" class="headerlink" title="有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。"></a>有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。</h3><h3 id="两个单向链表-有公共节点-有多少种结构。-考虑有环和无环的各种情况"><a href="#两个单向链表-有公共节点-有多少种结构。-考虑有环和无环的各种情况" class="headerlink" title="两个单向链表,有公共节点,有多少种结构。(考虑有环和无环的各种情况)"></a>两个单向链表,有公共节点,有多少种结构。(考虑有环和无环的各种情况)</h3><h3 id="epoll-的工作模式。"><a href="#epoll-的工作模式。" class="headerlink" title="epoll 的工作模式。"></a>epoll 的工作模式。</h3><h3 id="100G-的文件-分发的-100-个机器上-机器之间互相联通-带宽千兆。最少数据是多少。-这一题答的稀烂-想挂电话"><a href="#100G-的文件-分发的-100-个机器上-机器之间互相联通-带宽千兆。最少数据是多少。-这一题答的稀烂-想挂电话" class="headerlink" title="100G 的文件,分发的 100 个机器上,机器之间互相联通,带宽千兆。最少数据是多少。(这一题答的稀烂,想挂电话)"></a>100G 的文件,分发的 100 个机器上,机器之间互相联通,带宽千兆。最少数据是多少。(这一题答的稀烂,想挂电话)</h3><h3 id="二叉树查找最近"><a href="#二叉树查找最近" class="headerlink" title="二叉树查找最近"></a>二叉树查找最近</h3><h3 id="公共祖先、求平方根"><a href="#公共祖先、求平方根" class="headerlink" title="公共祖先、求平方根"></a>公共祖先、求平方根</h3><h3 id="翻转二叉树-写代码"><a href="#翻转二叉树-写代码" class="headerlink" title="翻转二叉树 写代码"></a>翻转二叉树 写代码</h3><h3 id="tcp-关闭连接的过程-为什么要四次"><a href="#tcp-关闭连接的过程-为什么要四次" class="headerlink" title="tcp 关闭连接的过程, 为什么要四次?"></a>tcp 关闭连接的过程, 为什么要四次?</h3><h3 id="问了操作系统的内存管理-分页和分段的区别"><a href="#问了操作系统的内存管理-分页和分段的区别" class="headerlink" title="问了操作系统的内存管理, 分页和分段的区别"></a>问了操作系统的内存管理, 分页和分段的区别</h3><h3 id="银行家算法原理"><a href="#银行家算法原理" class="headerlink" title="银行家算法原理"></a>银行家算法原理</h3><h3 id="写程序-翻转链表"><a href="#写程序-翻转链表" class="headerlink" title="写程序 翻转链表"></a>写程序 翻转链表</h3><h3 id="算法题-atoi-实现-主要看代码细节"><a href="#算法题-atoi-实现-主要看代码细节" class="headerlink" title="算法题:atoi 实现,主要看代码细节"></a>算法题:atoi 实现,主要看代码细节</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++_7</title>
    <link href="http://example.com/posts/49861/"/>
    <id>http://example.com/posts/49861/</id>
    <published>2020-12-16T07:59:42.000Z</published>
    <updated>2020-12-21T14:14:13.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="构造和析构函数"><a href="#构造和析构函数" class="headerlink" title="构造和析构函数"></a>构造和析构函数</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="练习" scheme="http://example.com/categories/%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="练习" scheme="http://example.com/tags/%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++_thread_pool</title>
    <link href="http://example.com/posts/49877/"/>
    <id>http://example.com/posts/49877/</id>
    <published>2020-12-16T05:18:20.000Z</published>
    <updated>2020-12-21T14:14:13.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程池的管理"><a href="#线程池的管理" class="headerlink" title="线程池的管理"></a>线程池的管理</h3><p>性能要求</p><ol><li>多线程的数量．（对应数组开辟相对应的线程数量）</li><li>能够执行我们传入的任意函数．（func打包操作(c++中打包成一个对象)一个任务）func函数是不统一的，但是打包的任务是统一的．把这个任务依次放到队列中．线程池能到队列中取任务．这里形成了一种生产者消费者模型．放任务的为生产者，取任务(线程池)为消费者.</li><li>执行过程中按优先级顺序．(每个任务有一个优先级，把任务写入队列，按优先级排序，这里涉及到优先队列)</li></ol><h3 id="类的分析与设计-从小到大"><a href="#类的分析与设计-从小到大" class="headerlink" title="类的分析与设计(从小到大)"></a>类的分析与设计(从小到大)</h3><ol><li>一个类代表任务类</li><li>一个代表我们的线程池</li></ol><p>涉及到知识点:<br>    bind()绑定函数，函数名和函数参数打包在一起，并不去执行，如果传入的参数不为引用的时候，不改变外部参数的值，而是进行拷贝了一份，想到局部变量.<br>    以下部分在关键字中讲解:<br>    1. ref()<br>    2. forward()<br>    3. move()<br>    4. 条件变量 </p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Pattern_设计模式</title>
    <link href="http://example.com/posts/21795/"/>
    <id>http://example.com/posts/21795/</id>
    <published>2020-12-14T07:42:50.000Z</published>
    <updated>2020-12-21T14:14:13.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="设计模式作用"><a href="#设计模式作用" class="headerlink" title="设计模式作用"></a>设计模式作用</h3><pre><code>对于一些没思路的问题，比如开发大整数类，我们有思路进行开发，但是有一些问题我们没有思路，这里就要借助设计模式．</code></pre><h3 id="访问者模式及解决的问题"><a href="#访问者模式及解决的问题" class="headerlink" title="访问者模式及解决的问题"></a>访问者模式及解决的问题</h3><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>用一个子类对象绑定在父类的指针上，如何用父类指针还原指的是那个子类对象．<br>dynamic_cast&lt;&gt;();为啥基(父)类为多态的，换而言之为什么要求这个对象头上有一个虚函数表地址．这里得理解dynamic_cast&lt;&gt;()如何判断是哪个类(父类,或者子类)的对象，就需要根据虚函数表的地址来判断是哪个类．（每个类都有一个自己的虚函数表，地址是不一样的,同个类的对象地址是一样的，这样就可以判断每个对象的虚函数表地址，如果是哪个类的就是那个类所定义的对象).所以说原有的基类都是多态的．所以说就需要析构函数为虚函数．继承中提到如果有继承基类析构函数就一定为虚函数．<br>析构函数为虚函数作用:<br>    1. delete的时候能析构掉子类的空间，<br>    2. 析构函数为虚函数就说明基类一定是多态的，dynamic_cast就可以在基类和相关派生类中间做相关的判断了．为了支持dynamic_cast这个函数不能给他硬生生的加一个虚函数，就只能给他加一个规则，把析构函数写成虚函数.</p><p>自己写的程序是每次新加一个小功能，据需要改多个地方，有些时候甚至不能在编译阶段报错，这里就要借助访问者模式了．把错误报在编译阶段．</p><p>访问者模式的优点:<br>    1. 解决了上述报错的bug，新增加一个派生类，后续的需改会报错．<br>    2. 比起if else的查找更为快速，直接从this指针来进行函数的调用的．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class B; &#x2F;&#x2F; +5</span><br><span class="line">class C; &#x2F;&#x2F; *2</span><br><span class="line">class D; &#x2F;&#x2F; -4</span><br><span class="line">class E; &#x2F;&#x2F; +6</span><br><span class="line">class F; &#x2F;&#x2F; -7</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public :</span><br><span class="line">    class IVisitor &#123;</span><br><span class="line">            public :</span><br><span class="line">                virtual void visit(A *) &#x3D; 0;</span><br><span class="line">                virtual void visit(B *) &#x3D; 0;</span><br><span class="line">                virtual void visit(C *) &#x3D; 0;</span><br><span class="line">                virtual void visit(D *) &#x3D; 0;</span><br><span class="line">                virtual void visit(E *) &#x3D; 0;</span><br><span class="line">                virtual void visit(F *) &#x3D; 0;</span><br><span class="line">            </span><br><span class="line">    &#125;;</span><br><span class="line">    virtual void Accept(IVisitor *vis) &#123;</span><br><span class="line">                vis-&gt;visit(this);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        virtual ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public A &#123;</span><br><span class="line">    public :</span><br><span class="line">    void Accept(IVisitor *vis) &#123;</span><br><span class="line">                vis-&gt;visit(this);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A &#123;</span><br><span class="line">    public :</span><br><span class="line">    void Accept(IVisitor *vis) &#123;</span><br><span class="line">                vis-&gt;visit(this);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D : public A &#123;</span><br><span class="line">    public :</span><br><span class="line">    void Accept(IVisitor *vis) &#123;</span><br><span class="line">                vis-&gt;visit(this);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class E : public A &#123;</span><br><span class="line">    public :</span><br><span class="line">    void Accept(IVisitor *vis) &#123;</span><br><span class="line">                vis-&gt;visit(this);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class F : public A &#123;</span><br><span class="line">    public :</span><br><span class="line">    void Accept(IVisitor *vis) &#123;</span><br><span class="line">                vis-&gt;visit(this);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OutputVisitor : public A::IVisitor &#123;</span><br><span class="line">    public :</span><br><span class="line">    virtual void visit(A *obj) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;this is father class A&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void visit(B *obj) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;this is a class B object&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void visit(C *obj) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;this is a class C object&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void visit(D *obj) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;this is a class D object&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void visit(E *obj) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;this is a class E object&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    virtual void visit(F *obj) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;this is a class F object&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CalcVisitor : public A::IVisitor &#123;</span><br><span class="line">    public :</span><br><span class="line">        CalcVisitor(int val &#x3D; 1) : val(val) &#123;&#125;</span><br><span class="line">        virtual void visit(A *obj) &#123;&#125;</span><br><span class="line">        virtual void visit(B *obj) &#123; val +&#x3D; 5;  &#125;</span><br><span class="line">        virtual void visit(C *obj) &#123; val *&#x3D; 2;  &#125;</span><br><span class="line">        virtual void visit(D *obj) &#123; val -&#x3D; 4;  &#125;</span><br><span class="line">        virtual void visit(E *obj) &#123; val +&#x3D; 6;  &#125;</span><br><span class="line">        virtual void visit(F *obj) &#123; val -&#x3D; 7;  &#125;</span><br><span class="line">        int val;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        srand(time(0));</span><br><span class="line">        A *arr[10];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        switch (rand() % 5) &#123;</span><br><span class="line">                        case 0: arr[i] &#x3D; new B(); break;</span><br><span class="line">                        case 1: arr[i] &#x3D; new C(); break;</span><br><span class="line">                        case 2: arr[i] &#x3D; new D(); break;</span><br><span class="line">                        case 3: arr[i] &#x3D; new E(); break;</span><br><span class="line">                        case 4: arr[i] &#x3D; new F(); break;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        OutputVisitor vis1;</span><br><span class="line">        CalcVisitor vis2;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                arr[i]-&gt;Accept(&amp;vis1);</span><br><span class="line">                arr[i]-&gt;Accept(&amp;vis2);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        cout &lt;&lt; vis2.val &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式:<br>    保证某个类的对象在全局环境中只存在一个．</p><p>如何保证对象只有一个呢:<br>    只创建一个??(答案是否定的)<br>    把系统默认的构造函数隐藏起来就是变为私有的．更改完成之后如何创建对象呢?这里考虑到我们以前所说的类方法，类方法不属于对象，即使没有对象也有类方法，但是同时他也属于类内的方法，所以类方法能访问到类的私有成员属性和类方法，所以调用getInstance()方法获得都是同一个HttpServe的对象．<br>bug1:  在把指向类的指针删除后，依然可以访问到地址，就说明调用到了析构函数，所以把析构函数干掉即可(把析构函数设置成为私有的).设置完成后，在外部任何调用delete的行为都通过不了编译.这里就是所说的把程序潜在的bug尽可能暴露在编译期.<br>bug2:<br>    多线程的情况会出现问题:<br>        1. 加一个互斥锁(懒汉模式，非做不可的时候才做)<br>        2. 在类属性初始化的时候进行类的构造．一运行就初始化完成，别的时候就不允许再构造了.(饿汉模式)<br>        懒汉模式的改进:<br>            在每次调用这个getInstance()这个函数的时候，就会加锁，这就会影响单例模式在多线程的下的执行效率，在锁的前边加了if(instance == nullptr) 双重验证，细品这个if都不能删除，第一个影响效率，第二个会报错．</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象联想到抽象类(抽象类提供的是接口),</p><p>工厂模式为什么是抽象的?<br>工厂生产产品,只有产品的类型确定了，工厂的类型才确定了.抽象类描述的产品对外表现形式．<br>看完产品可以对比工厂的<br>工厂—抽象类—-工厂对外表现.<br>只有工厂能生产(new)创建一个对象，外边的不可以使用构造函数，但是子类可以.所以给他设置成保护属性．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class ICar &#123;</span><br><span class="line">    public :</span><br><span class="line">    class IFactory &#123;</span><br><span class="line">            public :</span><br><span class="line">                virtual ICar *crearte() &#x3D; 0;</span><br><span class="line">            </span><br><span class="line">    &#125;;</span><br><span class="line">        virtual void run() &#x3D; 0;</span><br><span class="line">    protected:</span><br><span class="line">        ICar() &#123;&#125;</span><br><span class="line">        ~ICar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BenzCar : public ICar &#123;</span><br><span class="line">        BenzCar() &#123;&#125;</span><br><span class="line">    public :</span><br><span class="line">    class Facory : public ICar::IFactory &#123;</span><br><span class="line">            public :</span><br><span class="line">        virtual ICar *crearte() &#123;</span><br><span class="line">                        return new BenzCar();</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;;</span><br><span class="line">    virtual void run() &#123;</span><br><span class="line">                cout &lt;&lt; &quot;Benz run&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BmwCar : public ICar &#123;</span><br><span class="line">        BmwCar() &#123;&#125;</span><br><span class="line">    public :</span><br><span class="line">    class Facory : public ICar::IFactory &#123;</span><br><span class="line">            public :</span><br><span class="line">        virtual ICar *crearte() &#123;</span><br><span class="line">                        return new BmwCar();</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;;</span><br><span class="line">    virtual void run() &#123;</span><br><span class="line">                cout &lt;&lt; &quot;Bmw run&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AudiCar : public ICar &#123;</span><br><span class="line">        AudiCar() &#123;&#125;</span><br><span class="line">    public :</span><br><span class="line">    class Facory : public ICar::IFactory &#123;</span><br><span class="line">            public :</span><br><span class="line">        virtual ICar *crearte() &#123;</span><br><span class="line">                        return new AudiCar();</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;;</span><br><span class="line">    virtual void run() &#123;</span><br><span class="line">                cout &lt;&lt; &quot;Audi run&quot; &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ICar::IFactory *fac[3] &#x3D; &#123;new BenzCar::Facory(), new AudiCar::Facory, new BmwCar::Facory()&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        srand(time(0));</span><br><span class="line">        ICar *cars[10];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                cars[i] &#x3D; fac[rand() % 3]-&gt;crearte();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                cars[i]-&gt;run();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>在有很多的if else的语句中会出现好多的判断，这样就会用到责任链模式，</p><pre><code class="c/c++">#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;class ICar &#123;    public :    class IFactory &#123;            public :                virtual ICar *crearte() = 0;    &#125;;    class IHandler &#123;            public :                IHandler() : next(nullptr) &#123;&#125;                virtual bool is_valid(int x) = 0;                virtual ICar *do_it() = 0;                IHandler *next;    &#125;;        virtual void run() = 0;    protected:        ICar() &#123;&#125;        ~ICar() &#123;&#125;&#125;;class BenzCar : public ICar &#123;        BenzCar() &#123;&#125;    public :    class Facory : public ICar::IFactory, public ICar::IHandler &#123;            public :        virtual ICar *crearte() &#123;                        return new BenzCar();        &#125;        virtual bool is_valid(int x) &#123;                        return x == 0;        &#125;        virtual ICar *do_it() &#123;                        return this-&gt;crearte();        &#125;    &#125;;    virtual void run() &#123;                cout &lt;&lt; &quot;Benz run&quot; &lt;&lt; endl;    &#125;&#125;;class BmwCar : public ICar &#123;        BmwCar() &#123;&#125;    public :    class Facory : public ICar::IFactory, public ICar::IHandler &#123;            public :        virtual ICar *crearte() &#123;                        return new BmwCar();        &#125;        virtual bool is_valid(int x) &#123;                        return x == 1;        &#125;        virtual ICar *do_it() &#123;                        return this-&gt;crearte();        &#125;    &#125;;    virtual void run() &#123;                cout &lt;&lt; &quot;Bmw run&quot; &lt;&lt; endl;    &#125;&#125;;class AudiCar : public ICar &#123;        AudiCar() &#123;&#125;    public :    class Facory : public ICar::IFactory, public IHandler &#123;            public :        virtual ICar *crearte() &#123;                        return new AudiCar();        &#125;        virtual bool is_valid(int x) &#123;                        return x == 2;        &#125;        virtual ICar *do_it() &#123;                        return this-&gt;crearte();        &#125;    &#125;;    virtual void run() &#123;                cout &lt;&lt; &quot;Audi run&quot; &lt;&lt; endl;    &#125;&#125;;class ChainMaster &#123;    public :    static ICar::IHandler *getInstance() &#123;        if (head == nullptr) &#123;                        buildChain();        &#125;                return head;    &#125;    private :        static ICar::IHandler *head;    static void buildChain() &#123;                head = new BmwCar::Facory();                head-&gt;next = new AudiCar::Facory();                head-&gt;next-&gt;next = new BenzCar::Facory();                return ;    &#125;&#125;;ICar::IHandler *ChainMaster::head = nullptr;int main() &#123;        srand(time(0));        ICar *cars[10];    for (int i = 0; i &lt; 10; i++) &#123;                int req = rand() % 3;        for (auto p = ChainMaster::getInstance(); p; p = p-&gt;next) &#123;            if (p-&gt;is_valid(req)) &#123;                                cars[i] = p-&gt;do_it();            &#125;        &#125;    &#125;    for (int i = 0; i &lt; 10; i++) &#123;                cars[i]-&gt;run();    &#125;        return 0;&#125;</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>algorithm1</title>
    <link href="http://example.com/posts/598/"/>
    <id>http://example.com/posts/598/</id>
    <published>2020-12-09T04:31:40.000Z</published>
    <updated>2020-12-21T14:14:13.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="C-引用和指针区别"><a href="#C-引用和指针区别" class="headerlink" title="C++:引用和指针区别,"></a>C++:引用和指针区别,</h3><h3 id="解释内存泄露"><a href="#解释内存泄露" class="headerlink" title="解释内存泄露"></a>解释内存泄露</h3><h3 id="堆和堆排序"><a href="#堆和堆排序" class="headerlink" title="堆和堆排序,"></a>堆和堆排序,</h3><h3 id="贪心递归和动态规划"><a href="#贪心递归和动态规划" class="headerlink" title="贪心递归和动态规划,"></a>贪心递归和动态规划,</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归:"></a>递归:</h4><ol><li>将一个大的问题划分成多个子问题</li><li>子问题的逐个合并，形成原问题的解.</li></ol><p>注: 递归的每个子问题不寻求最优解，典型的递归例如: 归并排序.</p><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心:"></a>贪心:</h4><ol><li>将一个大问题划分为多个子问题</li><li>每一个子问题寻求最优解(只顾到当前位置的最优解)</li><li>最后所有的最优解合并得到原问题的解.</li></ol><p>注: 每个子问题寻求最优解,且前一个子问题的最优解和下一个子问题的最优解不一定有依赖关系，典型的贪心思想: 迪杰斯特拉算法(单源最短路径问题)</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h4><pre><code>与上一个的区别是: 是否依赖上一个子问题的最优解，简而言之，就是上一个问题选出的结果一定会参与到此次子问题的解的过程，贪心算法不一定依赖，动态规划就是依赖.</code></pre><p>将一个大的问题划分为多个子问题，对每一个子问题寻求最优解，且前一个问题的最优解是下一个问题的最优解前提，最终得到原问题的解．</p><p>注: 典型例子: 关键路径问题.</p><h3 id="dp-自顶向下和自底向上区别-1-道-dp-水题"><a href="#dp-自顶向下和自底向上区别-1-道-dp-水题" class="headerlink" title="dp 自顶向下和自底向上区别,1 道 dp 水题,"></a>dp 自顶向下和自底向上区别,1 道 dp 水题,</h3><h3 id="最短路算法-dijkstra"><a href="#最短路算法-dijkstra" class="headerlink" title="最短路算法-dijkstra"></a>最短路算法-dijkstra</h3><p><a href="https://blog.csdn.net/l_i_n_q_i_n_g/article/details/81704559">三种最短路算法</a></p><h4 id="开放性问题-超大地图的最短路"><a href="#开放性问题-超大地图的最短路" class="headerlink" title="开放性问题,超大地图的最短路"></a>开放性问题,超大地图的最短路</h4><h3 id="图论-第一道-dijkstra-的改进-如果要求路径上不能超过-5-个红绿灯怎么做-费用流"><a href="#图论-第一道-dijkstra-的改进-如果要求路径上不能超过-5-个红绿灯怎么做-费用流" class="headerlink" title="图论:第一道 dijkstra 的改进,如果要求路径上不能超过 5 个红绿灯怎么做, 费用流"></a>图论:第一道 dijkstra 的改进,如果要求路径上不能超过 5 个红绿灯怎么做, 费用流</h3><h3 id="操作系统-虚拟存储器功能"><a href="#操作系统-虚拟存储器功能" class="headerlink" title="操作系统(虚拟存储器功能)"></a>操作系统(虚拟存储器功能)</h3><h3 id="算法题-区间查询最大值-要求查询复杂度为-O-1-正解为-st-表-线段树也过了"><a href="#算法题-区间查询最大值-要求查询复杂度为-O-1-正解为-st-表-线段树也过了" class="headerlink" title="算法题:区间查询最大值,要求查询复杂度为 O(1),正解为 st 表,线段树也过了."></a>算法题:区间查询最大值,要求查询复杂度为 O(1),正解为 st 表,线段树也过了.</h3><p><a href="https://blog.csdn.net/qq_43332980/article/details/107411295">st表代码入口</a></p><h3 id="求完全二叉树的节点个数-要求最优解法-我写的是递归-复杂度O-logn-logn"><a href="#求完全二叉树的节点个数-要求最优解法-我写的是递归-复杂度O-logn-logn" class="headerlink" title="求完全二叉树的节点个数,要求最优解法,我写的是递归,复杂度O(logn*logn)"></a>求完全二叉树的节点个数,要求最优解法,我写的是递归,复杂度O(logn*logn)</h3><h3 id="算法面-1-道动态规划-其实是区间-dp-经典题矩阵链乘的改版"><a href="#算法面-1-道动态规划-其实是区间-dp-经典题矩阵链乘的改版" class="headerlink" title="算法面:1 道动态规划,其实是区间 dp 经典题矩阵链乘的改版."></a>算法面:1 道动态规划,其实是区间 dp 经典题矩阵链乘的改版.</h3><h3 id="1-道算法题-跟异构智能面试-1-面的第二题一样-都是剑指-offer-的-1-道题-是回自型的矩阵找-x-y-位置的数是几"><a href="#1-道算法题-跟异构智能面试-1-面的第二题一样-都是剑指-offer-的-1-道题-是回自型的矩阵找-x-y-位置的数是几" class="headerlink" title="1 道算法题,跟异构智能面试 1 面的第二题一样,都是剑指 offer 的 1 道题,是回自型的矩阵找(x,y)位置的数是几"></a>1 道算法题,跟异构智能面试 1 面的第二题一样,都是剑指 offer 的 1 道题,是回自型的矩阵找(x,y)位置的数是几</h3><h3 id="算法题-atoi-实现"><a href="#算法题-atoi-实现" class="headerlink" title="算法题:atoi 实现."></a>算法题:atoi 实现.</h3><h3 id="介绍决策树-谈了-3-种决策树及其区别和适应场景"><a href="#介绍决策树-谈了-3-种决策树及其区别和适应场景" class="headerlink" title="介绍决策树,谈了 3 种决策树及其区别和适应场景"></a>介绍决策树,谈了 3 种决策树及其区别和适应场景</h3><h3 id="数据结构-红黑树-决策树"><a href="#数据结构-红黑树-决策树" class="headerlink" title="数据结构:红黑树,决策树."></a>数据结构:红黑树,决策树.</h3><p>问和决策树的关系(毛线关系没有。。。),解释了红黑性,</p><h3 id="以及为什么每次操作都是稳定-O-logn-的复杂度"><a href="#以及为什么每次操作都是稳定-O-logn-的复杂度" class="headerlink" title="以及为什么每次操作都是稳定 O(logn)的复杂度"></a>以及为什么每次操作都是稳定 O(logn)的复杂度</h3><h3 id="操作系统-虚拟存储器"><a href="#操作系统-虚拟存储器" class="headerlink" title="操作系统:虚拟存储器"></a>操作系统:虚拟存储器</h3><h3 id="题-2-翻转链表"><a href="#题-2-翻转链表" class="headerlink" title="题 2:翻转链表"></a>题 2:翻转链表</h3><h3 id="手动实现-upper-bound"><a href="#手动实现-upper-bound" class="headerlink" title="手动实现 upper_bound"></a>手动实现 upper_bound</h3><h3 id="手动实现-next-premutation"><a href="#手动实现-next-premutation" class="headerlink" title="手动实现 next_premutation."></a>手动实现 next_premutation.</h3><h3 id="链表排序-不允许直接交换节点的值"><a href="#链表排序-不允许直接交换节点的值" class="headerlink" title="链表排序,不允许直接交换节点的值."></a>链表排序,不允许直接交换节点的值.</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络:"></a>计算机网络:</h3><pre><code>描述他发一句 hello world 到我这边显示,中间经历了哪些过程,我</code></pre><p>从应用层开始一层层往下分析答的,主要说 http 和 tcp,网络层和链路层有些忘,<br>但主要的几个协议和子网划分什么的也答了,面试官比较满意<br>最后还给了我一提了些建议,总之面试体验挺棒</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c++6</title>
    <link href="http://example.com/posts/43760/"/>
    <id>http://example.com/posts/43760/</id>
    <published>2020-12-05T02:48:10.000Z</published>
    <updated>2020-12-13T13:35:06.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="使用typedef声明新类型及函数指针"><a href="#使用typedef声明新类型及函数指针" class="headerlink" title="使用typedef声明新类型及函数指针"></a>使用typedef声明新类型及函数指针</h3><p>问: 使用typedef定义函数指针的类型,(输入参数为int, 输出参数为int);<br>当时想到的是结构体和别的类型重命名,由于没有认识到函数也是一种类型(这里接触过但是用的少还是比较陌生,这里重新演示);</p><ol><li>使用typedef声明新类型名</li></ol><p>　　C语言支持一种叫做typedef的机制，它允许你为各种数据类型定义新名字。typedef声明的写法和普通的声明基本相同，只是吧typedef这个关键字出现在声明的前面。例如，下面这个声明：</p><ol><li><p>char  *ptr_to_char;<br>把变量ptr_to_char声明为一个指向字符的指针。但是，在你添加关键字typedef后，声明变为<br>typedef  char  *ptr_to_char;<br>这个声明把标识符ptr_to_char作为指向字符的指针类型的新名字。你可以像使用任何预定义名字一样在下面的声明中使用这个新名字。例如：</p></li><li><p>ptr_to_char a;<br>声明a是一个指向字符的指针。<br>使用typedef声明类型可以减少使声明变得又臭又长的危险，尤其时那些复杂的声明。而且，如果你以后觉得应该修改程序所使用的一些数据的类型时，修改一个typedef声明比修改程序中与这种类型有关的所有变量（和函数）的所有声明要容易得多。<br>【提示】<br>你应该使用typedef而不是#define来创建新的类型名，因为后者无法正确的处理指针类型。例如：<br>#define d_ptr_to_char char *<br>d_ptr_to_char a,b;正确地声明了a，但是b却被声明为一个字符。在定义更为复杂的类型名字是，如函数指针或指向数组的指针，使用typedef更为合适。<br>摘自：《C和指针》（3.3 typedef）</p></li><li><p>使用typedef声明函数指针<br>【形式】：typedef 返回类型(*新类型)(参数表): </p></li></ol><p>typedef  char  (*PTRFUN)( int );<br>PTRFUN pFun;<br>char  glFun( int  a){  return ;}<br>void  main()<br>{<br>     pFun = glFun;<br>     (*pFun)(2);<br>}</p><p>　　typedef的功能是定义新的类型。第一句就是定义了一种PTRFUN的类型，并定义这种类型为指向某种函数的指针，这种函数以一个int为参数并返回char类型。后面就可以像使用int,char一样使用PTRFUN了。</p><p>【示例】</p><p>#include &lt;stdio.h&gt;<br>#include &lt;assert.h&gt;</p><p>typedef  int  (*FP_CALC)( int , int  ); //定义一个函数指针类型</p><p>int  add( int  a,  int  b )<br>{<br>    return  a + b;</p><p>}</p><p>int  sub( int  a,  int  b )<br>{<br>    return  a - b;</p><p>}</p><p>int  mul( int  a,  int  b )<br>{<br>    return  a * b;</p><p>}</p><p>int  div ( int  a,  int  b )<br>{<br>    return  b ? a/b : -1;</p><p>}</p><p>//定义一个函数，参数为op，返回一个指针,该指针类型为拥有两个int参数、<br>//返回类型为int的函数指针。它的作用是根据操作符返回相应函数的地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FP_CALC calc_func( char  op )</span><br><span class="line">&#123;</span><br><span class="line">    switch ( op  )</span><br><span class="line">    &#123;</span><br><span class="line">        case  &#39;+&#39; :</span><br><span class="line">        return  add;</span><br><span class="line">        case  &#39;-&#39; :</span><br><span class="line">        return  sub;</span><br><span class="line">        case  &#39;*&#39; :</span><br><span class="line">        return  mul;</span><br><span class="line">        case  &#39;&#x2F;&#39; :</span><br><span class="line">        return  div ;</span><br><span class="line">        default :</span><br><span class="line">        return  NULL;</span><br><span class="line">                   </span><br><span class="line">    &#125;</span><br><span class="line">                   </span><br><span class="line">    return  NULL;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">&#x2F;&#x2F;最终用户直接调用的函数，该函数接收两个int整数，</span><br><span class="line">&#x2F;&#x2F;和一个算术运算符，返回两数的运算结果</span><br><span class="line">int  calc( int  a,  int  b,  char  op )</span><br><span class="line">&#123;</span><br><span class="line">    FP_CALC fp &#x3D; calc_func(op);</span><br><span class="line"></span><br><span class="line">    if (fp)</span><br><span class="line">        return  fp(a,b);</span><br><span class="line">    else</span><br><span class="line">        return  -1;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">void  main()</span><br><span class="line">&#123;</span><br><span class="line">    int  a &#x3D; 100, b &#x3D; 20;</span><br><span class="line">             </span><br><span class="line">    printf ( &quot;calc(%d, %d, %c) &#x3D; %d\n&quot; , a, b,  &#39;+&#39; , calc(a, b,  &#39;+&#39; ) );</span><br><span class="line">    printf ( &quot;calc(%d, %d, %c) &#x3D; %d\n&quot; , a, b,  &#39;-&#39; , calc(a, b,  &#39;-&#39; ) );   </span><br><span class="line">    printf ( &quot;calc(%d, %d, %c) &#x3D; %d\n&quot; , a, b,  &#39;*&#39; , calc(a, b,  &#39;*&#39; ) );   </span><br><span class="line">    printf ( &quot;calc(%d, %d, %c) &#x3D; %d\n&quot; , a, b,  &#39;&#x2F;&#39; , calc(a, b,  &#39;&#x2F;&#39; ) ); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_33701564/article/details/89836216">文章链接出处</a></p><h3 id="静态存储区和动态存储区堆和栈的区别"><a href="#静态存储区和动态存储区堆和栈的区别" class="headerlink" title="静态存储区和动态存储区堆和栈的区别"></a>静态存储区和动态存储区堆和栈的区别</h3><p>C/c++程序经过编译连接后形成的二进制映像文件，这文件包含：<br>栈，堆，数据段（只读数据段，已经初始化读写数据段，未初始化数据段即BBS）和代码段组成.<br>存储去包含 动态区域(堆,栈),静态区域(数据段,代码段);</p><ol><li>栈区(stack):</li></ol><p>由编译器自动分配释放，存放函数的参数值，局部变量等值。其操作方式类似于数据结构中的栈。</p><ol start="2"><li>堆区(heap):</li></ol><p>堆允许程序在运行时动态地申请某个大小的内存。</p><p>一般由程序员分配释放，若程序员不释放，则可能会引起内存泄漏。</p><p>注堆和数据结构中的堆栈不一样，其类是与链表。</p><ol start="3"><li>程序代码区: 存放函数体的二进制代码.</li></ol><p>所有的语句编译后会生成CPU指令存储在代码区.</p><ol start="4"><li><p>数据段:三部分组成</p><ol><li><p>只读数据段:<br> 只读数据段是程序使用的一些不会被更改的数据，使用这些数据的方式类似查表式的操作，由于这些变量不需要更改，因此只需要放置在只读存储器中即可。一般是const修饰的变量以及程序中使用的文字常量一般会存放在只读数据段中。</p></li><li><p>已初始化的读写数据段:<br> 已初始化数据是在程序中声明，并且具有初值的变量，这些变量需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并且有初值，以供程序运行时读写。在程序中一般为已经初始化的全局变量，已经初始化的静态局部变量(static修饰的已经初始化的变量)</p></li></ol><ol start="3"><li>未初始化段(BSS): BSS段通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。<br>特点是可读写的，在程序执行之前BSS段会自动清0。</li></ol></li></ol><p>未初始化数据是在程序中声明，但是没有初始化的变量，这些变量在程序运行之前不需要占用存储器的空间。与读写数据段类似，它也属于静态数据区。但是该段中数据没有经过初始化。未初始化数据段只有在运行的初始化阶段才会产生，因此它的大小不会影响目标文件的大小。在程序中一般是没有初始化的全局变量和没有初始化的静态局部变量。</p><p>附加说明:<br>    常量区(特殊的常量存储区,属于静态存储区):<br>        1. 常量占用内存,只读状态,决不可修改<br>        2. 常量字符串就是放在这里的，程序结束后由系统释放</p><h4 id="动态存储方式"><a href="#动态存储方式" class="headerlink" title="动态存储方式"></a>动态存储方式</h4><p>所谓动态存储方式是指在程序运行期间根据需要进行动态的分配存储空间的方式。<br>动态存储变量是在程序执行过程中，使用它时才分配存储单元， 使用完毕立即释放。<br>典型的例子是函数的形式参数，在函数定义时并不给形参分配存储单元，只是在函数被调用时，才予以分配，调用函数完毕立即释放。如果一个函数被多次调用，则反复地分配、释放形参变量的存储单元。</p><h5 id="动态存储区："><a href="#动态存储区：" class="headerlink" title="动态存储区："></a>动态存储区：</h5><ol><li>栈和堆<br>栈:会存放函数的返回地址、参数和局部变量。<br>堆：我们通过 new 算符和 malloc 函数分配得到的空间。<br>堆和栈在内存中分配位置，跟硬件架构和操作系统都有关系。<br>x86中栈都是由高地址向低地址分配，堆是由低地址向高地址分配，不过在 Windows 和 Linux 中堆和栈的位置相反，另外存放静态数据、代码的区域位置也有一些不同。<br>栈是属于线程的，每一个线程会有一个自己的栈。</li><li>局部自动变量<br>存放在栈区，在栈区里面其实又可以分成好几个区域，他们叫做栈桢，一个栈桢就是一个函数，需要调用该函数的时候就如入栈，函数return的时候就会弹出栈，所以他们的生命周期是从函数的开始直到函数结束。<br>而栈帧里面又存放着什么呢，栈帧存放着以下几种东西：参数变量的地址，局部变量的地址，return的地址（还有栈指针和基指针，想知道这个是就什么百度吧）</li><li>自动变量(未加static声明的局部变量) ；</li><li>函数调用时的现场保护和返回地址等；</li><li>动态变量<br>通常是由malloc new等分配的空间，生命周期是从分配的那一刻直到free结束。<h4 id="静态存储方式"><a href="#静态存储方式" class="headerlink" title="静态存储方式"></a>静态存储方式</h4>所谓静态存储方式是指在程序编译期间分配固定的存储空间的方式。<br>该存储方式通常是在变量定义时就分定存储单元并一直保持不变，<br>直至整个程序结束。全局变量，静态变量等就属于此类存储方式。  <h5 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区:"></a>静态存储区:</h5>一定会存在的而且会永恒存在、不会消失，这样的数据包括常量、常变量（const 变量）、静态变量、全局变量等。<br>静态 、常量、全局变量就是存放在静态存储区，他们在程序编译完成后就已经分配好了，生命周期持续至程序结束。</li></ol><h4 id="一-预备知识—程序的内存分配"><a href="#一-预备知识—程序的内存分配" class="headerlink" title="一. 预备知识—程序的内存分配"></a>一. 预备知识—程序的内存分配</h4><p>一个由C/C++编译的程序占用的内存分为以下几个部分:<br>        1. 栈区（stack）：由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其  操作方式类似于数据结构中的栈。<br>        2. 堆区（heap） ：一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>        3. 全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，   未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>        4. 文字常量区：常量字符串就是放在这里的程序结束后由系统释放<br>        5. 程序代码区：存放函数体的二进制代码。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>从以上分析可知， 静态存储变量是一直存在的， 而动态存储变量则时而存在时而消失。我们又把这种由于变量存储方式不同而产生的特性称变量的生存期。<br>生存期表示了变量存在的时间。 生存期和作用域是从时间和空间这两个不同的角度来描述变量的特性，这两者既有联系，又有区别。 一个变量究竟属于哪一种存储方式， 并不能仅从其作用域来判断，还应有明确的存储类型说明。</p><p>内存中用户存储空间的分配情况（三种）：<br>程序区：存放程序语句<br>静态存储区：全局变量，局部静态变量</p><p>存放全局变量，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。</p><p>动态存储区：函数形参变量（在调用函数时给形参分配存储空间），局部动态变量(auto register)，函数调用现场保护和返回地址等。</p><h4 id="二-堆和栈的区别"><a href="#二-堆和栈的区别" class="headerlink" title="二. 堆和栈的区别"></a>二. 堆和栈的区别</h4><ol><li>申请方式<br>(1)栈（satck）:由系统自动分配。<br>　　1）程序运行时由编译器自动分配的一块连续的内容，存放函数的参数值，局部变量的值等。<br>例如，声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间。<br>　　2）程序结束时由编译器自动释放</li></ol><p>　　3) 栈由系统自动分配，程序员无法控制</p><p>　　4）只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>　　5）存取方式，先进后出</p><p>(2)堆（heap）:<br>    1）在内存开辟另一块不连续的存储区域。一般由程序员分配释放，<br>　　2）若程序员不释放，程序结束时由系统回收<br>　　3）首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。<br>    需程序员自己申请（调用malloc,realloc,calloc）,并指明大小，并由程序员进行释放。容易产生memory leak.eg:</p><p>char  p;<br>      p = (char *)malloc(sizeof(char));<br>但是，p本身是在栈中。</p><hr><p>在c中malloc函数 </p><p>如p1 = (char *)malloc(10);<br>在C++中用new运算符<br>如p2 = (char *)malloc(10);<br>但是注意p1、p2本身是在栈中的。 </p><ol start="2"><li>申请大小的限制<pre><code> （1）栈：在windows下栈是向底地址扩展的数据结构，是一块连续的内存区域(它的生长方向与内存的生长方向相反)。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数）。</code></pre></li></ol><p>栈的大小是固定的。如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><pre><code>     （2）堆：堆是高地址扩展的数据结构（它的生长方向与内存的生长方向相同），是不连续的内存区域。这是由于系统使用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由底地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</code></pre><ol start="3"><li>系统响应：<br>（1）栈：只要栈的空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<pre><code>  （2）堆：首先应该知道操作系统有一个记录空闲内存地址的链表，但系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的free语句才能正确的释放本内存空间。另外，找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</code></pre>说明：</li></ol><p>（1）对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。</p><p>（2）对于栈来讲，则不会存在这个问题，</p><ol start="4"><li>申请效率的比较<br>   （1）栈由系统自动分配，速度快。但程序员是无法控制的<br>   （2）堆是由malloc分配的内存，一般速度比较慢，而且容易产生碎片，不过用起来最方便。</li></ol><p>另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈，是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p><ol start="5"><li>堆和栈中的存储内容<pre><code> （1）栈：在函数调用时，第一个进栈的主函数中后的下一条语句的地址，然后是函数的各个参数，参数是从右往左入栈的，然后是函数中的局部变量。注：静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续执行。</code></pre>（2）堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li><li>存取效率的比较</li></ol><p>（1）堆：char *s1=”hellow tigerjibo”;hellow tigerjibo是在编译是就确定的。</p><p>（2）栈：char s1[]=”hellow tigerjibo”;hellow tigerjibo是在运行时赋值的；</p><p>用数组比用指针速度更快一些，指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上读取。</p><p>栈在读取时直接就把字符串中的元素读到寄存器cl中，而堆则要先把指针值读到edx中，在根据edx读取字符，显然慢了。</p><p>补充：<br>       栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。</p><pre><code>   堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</code></pre><ol start="7"><li>分配方式：<br>（1）堆都是动态分配的，没有静态分配的堆。<br>（2）栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的。它的动态分配是由编译器进行释放，无需手工实现。</li></ol><hr><p>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 </p><p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><hr><p>堆和栈的区别主要分：<br>操作系统方面的堆和栈，如上面说的那些，不多说了。<br>还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。  </p><h3 id="关键字extern"><a href="#关键字extern" class="headerlink" title="关键字extern"></a>关键字extern</h3><p>就是跨文件调用函数或变量,只占用一个存储空间,需要加上extern关键字.</p><h4 id="extern-和-extern-“c”的区别"><a href="#extern-和-extern-“c”的区别" class="headerlink" title="extern 和 extern “c”的区别"></a>extern 和 extern “c”的区别</h4><p>extern c是区分c和c++两个编一个过程生成的函数名字的格式,加上c就是在c++中此段代码用c编译过程编译生成的文件为c的格式,</p><h3 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h3><h3 id="c-中的值"><a href="#c-中的值" class="headerlink" title="c++中的值"></a>c++中的值</h3><h4 id="左右值及其引用"><a href="#左右值及其引用" class="headerlink" title="左右值及其引用"></a>左右值及其引用</h4><p><a href="https://blog.csdn.net/linuxheik/article/details/78929128">左右值及其引用</a></p><h4 id="左右值的区别"><a href="#左右值的区别" class="headerlink" title="左右值的区别"></a>左右值的区别</h4><p>（1）两者区别：</p><p>　　①左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</p><p>　　②右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p><p>（2）右值的分类</p><p>　　①将亡值（xvalue，eXpiring value）：指生命期即将结束的值，一般是跟右值引用相关的表达式，这样表达式通常是将要被移动的对象，如返回类型为T&amp;&amp;的函数返回值（如std::move）、经类型转换为右值引用的对象（如static_cast&lt;T&amp;&amp;&gt;(obj)）、xvalue类对象的成员访问表达式也是一个xvalue（如Test().memberdata，注意Test()是个临时对象）</p><p>　　②纯右值（prvalue， PureRvalue）：按值返回的临时对象、运算表达式产生的临时变对象、原始字面量和lambda表达式等。</p><h4 id="右值引用和左值引用"><a href="#右值引用和左值引用" class="headerlink" title="右值引用和左值引用"></a>右值引用和左值引用</h4><p>（1）右值引用和左值引用</p><p>　　①右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。</p><p>　　②左值引用是具名变量/对象的别名，右值引用是匿名变量/对象的别名。</p><p>　　③左值和右值是独立于它的类型的，即左右值与类型没有直接关系，它们是表达式的属性。具名的右值引用是左值，匿名的右值引用是右值。如Type&amp;&amp; t中t是个具名变量（最简单的表达式），t的类型是右值引用类型，但具有左值属性。而Type&amp;&amp; func()中的返回值（是个表达式）是右值引用类型，但具有右值属性（因为是个匿名对象）。</p><p>—-以上为网页摘抄部分——————————————————————————————————</p><p>ｃ语言中有变量，除了变量之外还有引用，是变量的别名．</p><p>值有两种类型:<br>    1. 左值:</p><pre><code>2. 右值:</code></pre><p>绑定在两种类型的引用:<br>    1. 左值引用:　一个&amp;符号称为左值引用. 用来绑定左值.</p><pre><code>2. 右值引用: 两个&amp;&amp;符号称为右值引用.用来绑定右值.</code></pre><p>问题来了?<br>左值引用一定绑定在左值上?右值引用一定绑定在右值上?<br>答案是否定的.看上边给的网站中的图解.</p><p>如何判断是左值还是右值，在该代码行的下一行能通过该变量的访问到的值为左值(++i)，不能访问到得值为右值(i++);注意下一行为函数的情况．左值是可以进行操作的((++i)++)这里是对的，右值一般是不允许被操作的((i++)++)这里会报错的.<br>注意: 引用在绑定的时候判断的是引用的类型，不是值的类型．就比如一个函数传入为右值，在里边就有可能变为左值.本来传入参数绑定的是右值，再往下传就变成了左值，这对我们后续的实现造成很大困扰，就没有办法正确绑定到右值引用上？如何解决呢?<br>需要介绍的两个传值方法(两个函数):(这两种方法就是为了实现完美传值的过程)<br>    1. forward: 把相关类型的值变为任意类型的值引用，可以是左值引用，也可以是右值引用．</p><pre><code>2. move: 简单是强制性变右值的一种方法(函数).</code></pre><p>为啥强制变右值的这个函数叫move(跟所变的类型没啥关联)?<br>这就是C++中的移动构造函数:<br>    一个对象属性，通过一个中间对象赋值给我们所赋值的对象，这里产生了一个拷贝构造函数，中间对象，完全是多余的．那么我们可以把指向原来对象存储信息的指针指向NULL（防止再次调用，会涉及到内存里的东西）,想要赋值的对象的指针指向这个存储区，这样少了开辟存储区和存储区拷贝两个操作．这种操作调用的就不是拷贝构造函数，而是移动构造函数，以前所说的拷贝构造函数(左值拷贝构造),移动构造函数是(右值拷贝构造函数)表明这个参数为一个临时对象，出了这个函数就不会再用了．临时对象的值拷贝直接抢过来，（如果有指针）让他原来的指针指向空．</p><pre><code>让c++重新回到神坛的是因为引入了右值这个概念，移动构造效率更快了．（就是在相关对象拷贝的过程中），以前都是左值拷贝，现在我们如果知道当前值为临时值（传入值）的话，就可以直接使用移动构造函数．拷贝构造的时间复杂度O(n),移动构造是O(1)的．</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void f2(int &amp;x) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;in function f2 : &quot; &lt;&lt; x &lt;&lt; &quot; is left value&quot; &lt;&lt; endl;</span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f2(int &amp;&amp;x) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;in function f2 : &quot; &lt;&lt;  x &lt;&lt; &quot; is right value&quot; &lt;&lt; endl;</span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(int &amp;x) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; &quot; is left value&quot; &lt;&lt; endl;</span><br><span class="line">        f2(forward&lt;int &amp;&gt;(x));</span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(int &amp;&amp;x) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; &quot; is right value&quot; &lt;&lt; endl;</span><br><span class="line">        f2(forward&lt;int &amp;&amp;&gt;(x));</span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public :</span><br><span class="line">    A(int n &#x3D; 10) : n(n) &#123;</span><br><span class="line">                arr &#x3D; new int[this-&gt;n];</span><br><span class="line">                for (int i &#x3D; 0; i &lt; this-&gt;n; i++) arr[i] &#x3D; i;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    A(const A &amp;obj) : n(obj.n) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl;</span><br><span class="line">                this-&gt;arr &#x3D; new int[n];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">                        this-&gt;arr[i] &#x3D; obj.arr[i];</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    A(A &amp;&amp;obj) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;move constructor&quot; &lt;&lt; endl;</span><br><span class="line">                this-&gt;n &#x3D; obj.n;</span><br><span class="line">                this-&gt;arr &#x3D; obj.arr;</span><br><span class="line">                obj.arr &#x3D; nullptr;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    A operator+(const A &amp;obj) &#123;</span><br><span class="line">                A temp(this-&gt;n + obj.n);</span><br><span class="line">                for (int i &#x3D; 0; i &lt; this-&gt;n; i++) temp.arr[i] &#x3D; arr[i];</span><br><span class="line">                for (int i &#x3D; 0; i &lt; obj.n; i++) temp.arr[i + this-&gt;n] &#x3D; obj.arr[i];</span><br><span class="line">                return temp;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    void output() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">                        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                return ;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">                cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;</span><br><span class="line">                delete[] arr;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    private :</span><br><span class="line">        int *arr;</span><br><span class="line">        int n;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        int n &#x3D; 123;</span><br><span class="line">        cout &lt;&lt; (++n)++ &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        f(n++);</span><br><span class="line">        f(move(++n));</span><br><span class="line">        A *p &#x3D; new A();</span><br><span class="line">        A a &#x3D; move(*p);</span><br><span class="line">        delete p;</span><br><span class="line">        a.output();</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p><a href="https://blog.csdn.net/just_kong/article/details/99289539">原子操作</a></p><h3 id="delete-过程"><a href="#delete-过程" class="headerlink" title="delete[]过程"></a>delete[]过程</h3><p><a href="https://blog.csdn.net/mywcyfl/article/details/36645505#t0">delete争辩之旅</a></p><ol><li><p>new[]会在申请到的内存前面加入一些信息表示这申请到的内存被划分为了多少单元（即new出的数组有多长），这个信息只用于确定调用多少次析构函数时用到，在确定释放多大内存空间时用不到，因为系统自然知道要释放的内存大小是多少，系统在内存分配表中有记录。</p></li><li><p>delete和delete[]都是会正确的把全部的内存释放掉的，但是delete只会调用数组第一个元素的析构函数，delete[]会调用全部数组单元的析构函数，这就用到了上一条中new[]存储的数组长度，delete[]利用这个长度确定在哪些地方调用多少次析构函数。</p></li><li><p>delete和delete[]只在调用析构函数上有差别，在释放内存上是一样的，而且两者释放内存时为了确定要释放多长的内存它们都是通过查系统的内存分配表来实现的，1中说道的长度仅仅在delete[]确定调用多少析构函数时用到。因为管理内存是操作系统的事（因此操作系统知道这内存分配了多少），但调用析构函数则是编译器的事（因此编译器需要知道要调用多少次，这就是1中提到的new[]做的事）。</p></li><li><p>通过上面三条，我们知道delete和delete[]只有在面对自定义对象数组时才有差别，面对系统内置对象时是无差别的，即：</p></li></ol><p>int* p = new int{10]，那么delete p和delete{] p是没任何差别的。</p><p>那么问题来了</p><p>因为大家都知道<br>1，int *p = new int 是分配一个单元，int *p = new int[100]是分配100个单元，<br>2，delete p 是删除释放一个单元，delete [] p 是释放 多个单元，具体的数据目是查系统的分配表得到的；<br>3，那么既然可以查表，为什么不直接让delete 和 delete[]合并为一个操作，具体释放多少查表得到既可以了，<br>可能是设计师考虑到了什么东西了吧，比如效率等,但是我想不出来，请大家帮我解释一下<br>你问的很好，许多人不知道对于内置类型来说，delete和delete []是一样的，看起来你是知道的                                          原因如下，事实上new和delete都是两步操作，分配（释放）堆内存和调用构造（析构）函数<br>对于堆内存的释放，确实不需要做额外的事情，delete和delete []无差别<br>区别就在于调用析构函数这一步，如果用delete只会调用第一个对象的析构，只有调用delete[]才会调用全部的析构</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">    public: </span><br><span class="line">    A()&#123;</span><br><span class="line">                cout &lt;&lt; &quot;A&quot;&lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    ~A()&#123;</span><br><span class="line">                cout &lt;&lt; &quot;~A&quot;&lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">        A *p &#x3D; new A[10];</span><br><span class="line">        p +&#x3D; 5;</span><br><span class="line">        delete[] p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 因为有私货。比如数组 int a[10], 在地址a的前面可能有cookei，记录了数组的长度等信息。不同的编译器实现方式不同。</p><p>class Test{ …  };</p><p>Test* p1 = new Test;<br>Test* p2 = new Test[10];</p><p>Test* p=0;</p><p>p=p1;<br>delete  p;   //编译器怎么知道p对应了1个对象需要析构？</p><p>p=p2;<br>delete {] p;  //编译器怎么知道p对应了N个对象需要析构，还有一定是精确的10个对象需要析构？</p><p>[]就是提示编译器去找cookei, 根据cookei做处理</p><h3 id="字符串和指针作为返回值"><a href="#字符串和指针作为返回值" class="headerlink" title="字符串和指针作为返回值"></a>字符串和指针作为返回值</h3><p>　　这里的字符串是常量，比如”ABCDS”;<br>        后边有有详细讲解，这里如果函数边一个直接返回字符换，一个定义一个指针指向字符串的地址；下边是题:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *str()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">char *str1()&#123;</span><br><span class="line">        char *ptr &#x3D; &quot;hello&quot;;</span><br><span class="line">        return ptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">        printf(&quot;%s&quot;, str());</span><br><span class="line">        printf(&quot;%s&quot;, str1());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">test.cpp: In function ‘char* str()’:</span><br><span class="line">test.cpp:14:12: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]</span><br><span class="line">     return &quot;hello&quot;;</span><br><span class="line">            ^</span><br><span class="line">test.cpp: In function ‘char* str1()’:</span><br><span class="line">test.cpp:18:17: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]</span><br><span class="line">     char *ptr &#x3D; &quot;hello&quot;;</span><br><span class="line">                 ^</span><br><span class="line">hellohello</span><br><span class="line">real</span><br><span class="line">0m0.009s</span><br><span class="line">user</span><br><span class="line">0m0.001s</span><br><span class="line">sys</span><br><span class="line">0m0.008s</span><br><span class="line"></span><br><span class="line">分析字符串为静态存储区，跟着整个程序执行开始到执行结束都会存在，如果是一个局部变量，调用函数会申请栈区空间，函数执行完毕空间会被释放，如果把这个释放的空间赋值为别的值，那么返回这个局部变量就毫无意义了．这个例子是对的，知识类型有些警告信息． </span><br></pre></td></tr></table></figure><h3 id="c语言中内存对齐"><a href="#c语言中内存对齐" class="headerlink" title="c语言中内存对齐"></a>c语言中内存对齐</h3><p>结构体：<br>char a;<br>int b;<br>char c;</p><p>结构体声明不分配内存，只有在定义才会（这里右图），大小为<br>a: 1 0 0 0<br>b: 1 1 1 1<br>c: 1 0 0 0<br>12个字节，0为对齐填充的，1就是原本的.</p><p>如果这个:<br>    结构体:<br>        char a;<br>        char b;<br>        int c;<br>    a+b: 1 1 0 0;<br>    c  : 1 1 1 1;<br>    共用8个字节．</p><p>里边有内存对齐的由来和原理,结构体的对齐，如何优化节省内存的．<br><a href="https://blog.csdn.net/c1664510416/article/details/82427584">失传的c结构体打包技艺</a></p><p>结构数组和数组不一样，定一个普通的指针类型，就可以直接用指针指向数组首地址．而结构体指针需要指向&amp;结构体首地址．如:<br>    struct Book * ptr;<br>    ptr = &book;</p><p>两个结构体之间可以进行赋值的，前提是两个结构体里边的类型是一致的．结构体作为函数形参，这里有个值传递的过程，用到了这些．在传递过程结构体可以是非常大的，非常耗费时间空间，那么函数指针就来了．就几个字节指向结构体．</p><h3 id="typedef的应用详解对应第一条"><a href="#typedef的应用详解对应第一条" class="headerlink" title="typedef的应用详解对应第一条"></a>typedef的应用详解对应第一条</h3><p>曾经忽视了typedef这个关键字的小伙伴看仔细了,typedef是c语言最重要的关键字(之一),<br>世界第一门高级编程语言是Fortran.IBM公司开发.<br>c语言的诞生用typedef实现了,Fortran语言的完美过度,</p><h4 id="typedef和define的区别"><a href="#typedef和define的区别" class="headerlink" title="typedef和define的区别:"></a>typedef和define的区别:</h4><pre><code>typedef:是对类型的封装,对原有的数据类型起别名．define:是替换操作.</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">typedef int INTEGER;</span><br><span class="line">#define PTRINT int * (如果是define的话PTRINT b,c;被换成int *b, c; 定义了一个指正类型.);</span><br><span class="line">typedef int* PTRINT; (这样就被正常的替换为int *b, *c;)</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    INTEGER a &#x3D; 520;</span><br><span class="line">    PTRINT b, c;</span><br><span class="line">    b &#x3D; &amp;a;</span><br><span class="line">    c &#x3D; b;</span><br><span class="line">    printf(&quot;add of a &#x3D; %p\n&quot;, c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子二：</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define der main</span><br><span class="line">&#x2F;&#x2F;typedef int integr; 情况二；</span><br><span class="line">&#x2F;&#x2F;#define integr int  情况一；</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    unsigned integr a;</span><br><span class="line">    a &#x3D; -1;</span><br><span class="line">    printf(&quot;a &#x3D; %u\n&quot;, a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一个编译完成：</span><br><span class="line">情况１．的编译情况．</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">        unsigned int a;</span><br><span class="line">        a &#x3D; -1;</span><br><span class="line">        printf(&quot;a &#x3D; %u\n&quot;, a);</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">情况二的编译情况．</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef int integr;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    unsigned integr a;</span><br><span class="line">    a &#x3D; -1;</span><br><span class="line">    printf(&quot;a &#x3D; %u\n&quot;, a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">情况二的错误：</span><br><span class="line">test3.cpp:17:21: error: expected initializer before ‘a’</span><br><span class="line">     unsigned integr a;</span><br><span class="line">                     ^</span><br><span class="line">test3.cpp:18:5: error: ‘a’ was not declared in this scope</span><br><span class="line">     a &#x3D; -1;</span><br><span class="line">     ^</span><br><span class="line">可以分析出来，integr是一个类型的别名，仅仅是一个别名，在解析时不会带有该关键字的相关属性．</span><br></pre></td></tr></table></figure><p>typedef int INTEGER, *PTRINT;可以定义两个．第二个是int *类型．</p><h4 id="秀出边际的typedef"><a href="#秀出边际的typedef" class="headerlink" title="秀出边际的typedef"></a>秀出边际的typedef</h4><p>函数名的实质:<br>    1. 函数名在c语言中的理解方法和变量名其实没区别．编译器会把这个函数的函数体对应的代码段和这个函数的函数名(实质是符号)对应起来，等我们在使用这个函数名符号时，编译器会将函数的函数体实际上做替换．因为函数体都不止4字节，而函数名这个符号只能对应1个地址，所以实际对应的是函数体那一个代码段的首地址<br>    2. 拿ｃ语言中的语法来讲，函数名就是这个函数的函数指针．</p><ol><li><p>秀儿:<br> int (*ptr)[3];数组指针，这里声明数组的名字为（）里的东西，［］是数组的长度．typedef为别名的替换．<br> 从左往右看，是一个指针，然后指向一个长度为三的数组．是一个数组指针．<br> typedef int (*PTR_TO_APPAY)[3];</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int (*PTR_TO_APPAY)[3];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int array[3] &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">    PTR_TO_APPAY ptr_to_arry &#x3D; &amp;array;</span><br><span class="line">    int i;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, (*ptr_to_arry)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>double 秀:　<br> int (<em>fun)(void); 名字后边为()表明指向了一个函数，这里定义的是指向一个输入为void返回值为int的函数指正名字为fun.<br> 起别名：<br> typedef int (</em> PTR_TO_FUN)(void);给这个部分(int (*)(void))起别名为PTR_TO_FUN.<br> 最直观的视觉冲击就是fun函数就是加上了不同约束的变量，可以用一个名字表示整个函数的调用．其实本来就是用一个指针记录函数入口．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int (*PTR_TO_FUN)(void);</span><br><span class="line"></span><br><span class="line">int fun(void)&#123;</span><br><span class="line">    return 520;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    PTR_TO_FUN ptr_to_fun &#x3D; &amp;fun;</span><br><span class="line">    printf(&quot;%d\n&quot;, (*ptr_to_fun)());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>天秀:<br> int <em>(<em>array[3])(int);<br> 解读：从左往右找到第一个名字array,左边是</em>,右边是[],优先级[]比</em>高，先是一个数组，后是一个指针，指针数组（数组中每个元素都是一个指针的意思），这里我们把（*array[3]）当成一个个体Ａ；<br> 那么声明语句就变成int <em>(A)(int); 是不是一个指针函数，因为</em>比左边的()的优先级低，所以先是一个函数后是一个指针，返回值是一个指向整形变量的指针，为了灵活声明，不过于冗余:</p><pre><code> typedef int *(*PTR_TO_FUN)(int); PTR_TO_FUN array[3]; 这两句更为简单.</code></pre></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int fun(int num)&#123;</span><br><span class="line">        printf(&quot;%d\t&quot;, num);</span><br><span class="line">        return num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *funA(int num)&#123;</span><br><span class="line">        printf(&quot;%d\t&quot;, num);</span><br><span class="line">        return &amp;num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int *funB(int num)&#123;</span><br><span class="line">            printf(&quot;%d\t&quot;, num);</span><br><span class="line">            return &amp;num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int *funC(int num)&#123;</span><br><span class="line">            printf(&quot;%d\t&quot;, num);</span><br><span class="line">            return &amp;num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef int *(*PTR_TO_FUN)(int);</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">        printf(&quot;fun : 1 %x, 2 %x&quot;, &amp;fun, fun);</span><br><span class="line">        PTR_TO_FUN array[3] &#x3D; &#123;&amp;funA, &amp;funB, &amp;funC&#125;;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">        printf(&quot;add of num : %p\n&quot;, (*array[i])(i));</span><br><span class="line">    &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>针对3天秀补充:补充函数名的＆和＊的来由（模棱两可来自兼容):</p><p><a href="https://blog.csdn.net/sinat_31039061/article/details/103901436">数组名和函数名是什么东西</a><br>按照&amp;运算符本来的意义，它要求其操作数是一个对象，但函数名不是对象（函数是一个对象），本来&amp;func是非法的，但很久以前有些编译器已经允许这样做，c/c++标准的制定者出于对象的概念已经有所发展的缘故，也承认了&amp;func的合法性。同理，数组也是一样的道理。<br>所以，既然 &amp; 不 &amp; 都可以，那么* 不 * 也都可以。<br>这样也就解释了为什么( * (void( *  ) ())0x100000 )()或者((void( *  ) ())0x100000)()都对。<br>对于以函数名或者数组名作为函数的参数来说，&amp; 不&amp; 都无所谓，<br>对于函数调用来说，函数名字前加不加 * 都无所谓。<br>但是对于数组，&amp;a+1，和a+1作为右值来说还是要加以区分，&amp;a+1相当于指针+1（指向下个数组），a+1相当于地址加1(指向下个元素)，（unsigned int）a+1相当于数值+1，结果是不一样的<br>也可以将指向数组首地址或函数体的指针常量存储到内存的断中，进行一些自动初始化的操作。</p><ol start="4"><li>变态秀:<br> void (<em>funA(int, void (*funB)(int)))(int);<br> 老规矩从左往右找第一个 funA,是一个指针函数,funA(int, void(*funB)(int)) 简化为</em>funA(参数);<br> 简化: void (*funA(参数))(int);<br> 更换形式:<pre><code> typedef void (*PTR_TO_FUN)(void); PTR_TO_FUN funA(int, PTR_TO_FUN);</code></pre></li></ol><p>指针函数：就是一个函数，谁放在*后边他就是谁，<br>不要返回局部变量的指针!!!!<br>如果返回局部变量指针后，会给警告试图返回局部变量的提示信息，因为局部变量是通过压栈弹栈执行的，弹栈的时候所定义的局部变量信息被删除，就找不到了．函数内部定义的变量就是局部变量，他的作用域就是函数体内，出了函数就什么也不是，而直接返回字符串为什么没问题呢，因为字符串没有定义到函数体内，他会找到一个固定的常量存储区，因为字符串是不可变的，所以他存储的位置不在函数里边，</p><p>函数指针:<br>    是一个指向函数的指针，</p><h3 id="LRU算法-c-实现"><a href="#LRU算法-c-实现" class="headerlink" title="LRU算法(c++实现)"></a>LRU算法(c++实现)</h3><p>LRU算法<br>LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法，是为虚拟页式存储管理服务的。LRU算法的提出，是基于这样一个事实：已经很久没有使用的页面很可能在未来较长的一段时间内不会被用到。因此，我们只需要在每次调换时，找到最近最久未使用的那个页面调出内存。这就是LRU算法的全部内容。</p><p>实现<br>使用双向链表和哈希表实现LRU算法</p><p>双向链表用于保存key-value，队头的元素表示最近一次被访问的元素，队尾的元素表示最近最久未使用的元素<br>哈希表提供key到key对应节点在双向链表中的位置的映射<br>实现了get操作和put操作</p><p>get：传入key，得到value，并将对应节点移动到双向链表头部（因为这个节点是最近被访问的节点）<br>put：传入key-value对，分三种情况处理<br>若key已存在，则先删除对应节点，再把key-value插入双向链表头部（因为这个节点是最近被访问的节点）<br>若双向链表长度大于或等于最大元素个数，则删除双向链表队尾元素（最近最久未使用的元素），再把key-value插入双向链表头部<br>若上面两个条件不满足，只需要把key-value插入双向链表头部<br>与有的博客中实现方式不同的是，我用一个变量size_保存双向链表的长度，因为std::list的size方法是O(n)时间复杂度的（具体可看我另一篇转载的博客）。做了这个改进后，get和put的时间复杂度都为O(1)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">    public:</span><br><span class="line">        LRUCache(int capacity) : cap_(capacity), size_(0) &#123;&#125;</span><br><span class="line">        int get(int key)&#123;</span><br><span class="line">        if(key2pos_.find(key) !&#x3D; key2pos_.end()) &#123;</span><br><span class="line">            put(key, key2pos_[key]-&gt;second);</span><br><span class="line">            return key2pos_&#123;key]-&gt;second;        </span><br><span class="line">            &#125;</span><br><span class="line">        return -1;    </span><br><span class="line">        &#125;</span><br><span class="line">        void put(int key, int value)&#123;</span><br><span class="line">        if(key2pos_.find(key) !&#x3D; key2pos_.end()) &#123;</span><br><span class="line">            data_.erase(key2pos_&#123;key]);</span><br><span class="line">            --size_;</span><br><span class="line">                    </span><br><span class="line">        &#125; else if(size_ &gt;&#x3D; cap_) &#123;</span><br><span class="line">            key2pos_.erase(data_.back().first);</span><br><span class="line">            data_.pop_back();</span><br><span class="line">            --size_;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            data_.push_front(&#123;key, value&#125;);</span><br><span class="line">            key2pos_[key] &#x3D; data_.begin();</span><br><span class="line">            ++size_;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        void print()&#123;</span><br><span class="line">            for(auto&amp; v : data_)</span><br><span class="line">            cout &lt;&lt; v.first &lt;&lt; &quot;: &quot; &lt;&lt; v.second &lt;&lt; &quot;;&quot;;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    private:</span><br><span class="line">        int cap_;</span><br><span class="line">        int size_;</span><br><span class="line">        list&lt;pair&lt;int, int&gt;&gt; data_;</span><br><span class="line">        unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; key2pos_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="malloc原理和内存碎片"><a href="#malloc原理和内存碎片" class="headerlink" title="malloc原理和内存碎片"></a>malloc原理和内存碎片</h3><p><a href="https://blog.csdn.net/shixin_0125/article/details/78829123">malloc原理和内存碎片</a></p><h3 id="作用域和链接属性"><a href="#作用域和链接属性" class="headerlink" title="作用域和链接属性"></a>作用域和链接属性</h3><p>ｃ语言编译器可以确认４种不同类型的作用域:<br>    1. 代码块作用域:<br>        1. 在代码块中定义的变量，具有代码块作用域．作用范围是从变量定义的位置开始，到标志代码块结束的右大括号（｝）处．<br>        2. 尽管函数的形式参数不在大括号内定义，但其同样具有代码块作用域，隶属于包含函数体的代码块．<br>    2. 文件作用域:<br>        任何在所有代码块之外声明的标识符都具有文件作用域（file scope），它表示这些标识符从它们的声明之处直到它所处的源文件结尾处都是可以访问的。上图中的1，2都属于文件作用域。<br>    3. 原型作用域:<br>        1. 原型作用域只适用于那些在函数原型中声明的参数名．函数在声明的时候可以不写参数的名字(但参数类型是必须要写上的)，其实函数原型的参数名还可以随便写一个名字，不必与形式参数相匹配（当然，这样做没任何意义!）<br>    4. 函数作用域:<br>        函数作用域只适用与goto语句的标签，作用将goto语句的标签限制在同一个函数内部，以及防止出现重名标签．</p><p>定义: 当一个变量被定义的时候，编译器为变量申请内存空间并填充一些值．<br>声明: 当一个变量被声明的时候，编译器就知道该变量被定义在其他地方．<br>声明是通知编译器该变量及相关的类型已存在，不需要再为此申请内存空间．<br>局部变量即是定义又是声明．<br>定义只能来一次，否则就叫重复定义某个同名变量；而声明可以有很多次．</p><p>链接属性:<br>    1. external(外部的):<br>        多个文件中声明的同名标识符标识同一个实体．<br>    2. internal(内部的):<br>        单个文件中声明的同名标识符表示同一个实体．<br>    3. none(无):<br>        声明的同名标识符被当做独立不同的实体．</p><p>这里联想前边的extern关键字，就是说他的:(文件作用域标识符：全局变量的和函数的声明肯定是)</p><ol><li>只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性．</li><li>默认情况下，具备文件作用域的标识符拥有external属性．也就是说标识符允许跨文件访问，对于external属性的标识符，无论在不同文件中声明多少次，表示的都是同一个实体．</li><li>使用static关键字可以使得原先拥有external属性的标识符变为internal属性．这里有两点需要注意:<ol><li>使用static关键字修改链接属性，只对具有文件作用域的标识符生效（对于拥有其他作用域的标识符是另一种功能：静态变量）</li><li>链接属性只能修改一次，也就是说一旦将标识符的链接属性表位internal,就无法变回external了.在函数名和全局变量前边加上static关键字，就变成了internal属性，别的文件就无法访问了．</li></ol></li></ol><p>.c （编译）.o  + lib(链接)　<br>源文件生成机器文件（目标文件），源文件和库文件（函数）链接得到可执行程序．<br>链接属性：</p><p>生存期:<br>    1. ｃ语言的变量拥有两种生存期:<br>        1. 静态存储期<br>        2. 自动存储期<br>    2. 具有文件作用域的变量属于静态存储期，函数也属于静态存储期．属于静态存储区的变量在函数执行期间将一直占据存储空间，知道程序关闭才释放．（像全局变量）<br>    3.<br>    具有代码块作用的变量一般情况下属于自动存储器．属于自动存储期的变量在代码块结束时将自动释放存储空间．（函数的形式参数，局部变量）</p><p>例子！！！:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int A;</span><br><span class="line">static int B;</span><br><span class="line">extern int C;</span><br><span class="line"></span><br><span class="line">void func(int m, int n)&#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">分析：A,B,C，void func(int , int )&#123;&#125; 和　int main(void)&#123;&#125;都是属于文件作用域的静态存储期，其中的函数内部的a,b,c,和形参m,n都是属于代码块作用域因此他的生存期是自动存储期，变量所占的空间在代码块结束的时候被自动释放（离开右大括号的时候）．</span><br><span class="line"></span><br><span class="line">以上这些都是根据都是根据变量的存储类型决定的:</span><br><span class="line">    1. 存储类型其实是指存储变量值的内存类型，ｃ语言提供了5种不同的存储类型:</span><br><span class="line">        1. auto: 在代码块中声明的变量默认的存储类型就是自动变量，使用关键字auto来描述．形式参数，局部变量，包括复合语句中定义的局部变量，都是自动变量（自动变量拥有代码块作用域，自动存储期，空链接属性（ｎｏｎｅ））</span><br><span class="line">        !!!例子:</span><br><span class="line">        &#96;&#96;&#96;c&#x2F;c++</span><br><span class="line">         int main()&#123;</span><br><span class="line">            auto int i, j ,k;&#x2F;&#x2F;(由于auto是默认的存储类型，所以写不写都可以的)</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        什么时候要写呢？</span><br><span class="line">        有时候想要用局部变量屏蔽全局变量的时候，就需要在局部变量前加上auto</span><br><span class="line">         int i;</span><br><span class="line">         int main()&#123;</span><br><span class="line">            auto int i;&#x2F;&#x2F;(这里用auto来强调i，区分前边的i,就是起强调作用而已．)</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><pre><code>    2. register:（寄存器变量）    将一个变量声明为寄存器变量，那么该变量就有可能被存放于ｃｐｕ的寄存器中．编译器会根据寄存器变量的使用情况，来判断是否要存入寄存器，不存入寄存器的就会变成普通的auto变量．    寄存器变量和自动变量再很多方面是一样的，他们都拥有代码块作用域，自动存储器和空连接属性．    不过这里有一点需要注意的是: 当你将变量声明为寄存器变量，那么你就没办法通过取址运算符获取变量的地址．    3. static:（静态局部变量:        1. 使用static来声明局部变量，那么就可以将局部变量指定为静态局部变量．        2. static使得局部变量具有静态存储期，所以它的生存期与全局变量一样，直到程序结束才释放．    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">void func(void)&#123;</span><br><span class="line">    static int count &#x3D; 0;&#x2F;&#x2F;改变了他的生存周期，就会输出1, 2, 3....10;但是他的作用域是不变的，</span><br><span class="line">    printf(&quot;count &#x3D; %d\n&quot;, count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    count++;&#x2F;&#x2F;由于作用域不边，这里就会报错．</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>    加餐: static和extern关键字:        作用于文件作用域的static和extern,static关键字使得默认具有external链接属性的标识符变成internal链接属性，而extern关键字是用于告诉编译器这个变量或函数在别的地方已经定义过了，先去别的地方找找，不要急着报错．    总的来说使用auto和rigester关键字声明变量的话，是自动存储区，static或extern关键字声明的话就是静态存储区．    4. extern:    5. typedef </code></pre><h3 id="c语言的三种预处理功能"><a href="#c语言的三种预处理功能" class="headerlink" title="c语言的三种预处理功能:"></a>c语言的三种预处理功能:</h3><p><a href="https://blog.csdn.net/qq_25408423/article/details/81592947">C语言三种预处理功能</a></p><ol><li><p>宏定义:<br>不带参数:<br> 如#define PI 3.14 如果没有#undef PI 就是存在于整个函数的处理期，有的话就是终止于undef.<br>　　支持嵌套定义．<br>　　<br>　　带参数:<br> #和##是两个预处理运算符．<br> 在带参数的宏定义中，#运算符后面应该跟一个参数，预处理器会把这个参数转换为一个字符串．<br> ##运算符被成为记号连接运算符，比如可以用##运算符连接两个参数．</p><p> ！！！define实现printf: 看图</p><pre><code> #define SHOWLIST(...) printf(# __VA_ARGS__) int main()&#123;     SHOWLIST(Fishc, 520, 3.14\n);     return 0; &#125; 例子2:     #define PRINT(format, ...) printf(# format, ##__VA_ARGS__)     int main()&#123;         PRINT(num = %d\n, 520);//　结果num = 520         PRINT(hello Fish!\n);//　结果 hello Fish!     &#125;</code></pre><p>　　　　</p></li><li><p>文件包含</p></li><li><p>条件编译</p></li></ol><p>处理完上边的事情，才会走到编译阶段．编译工作的任务之一就是语法检查，所以编译器不会对宏定义进行语法检查．</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>解决频繁调用函数，频繁的申请栈空间导致的时间空间上的浪费，引入了内联函数，因为宏定义出现了各种问题．<br>引入了内联函数来解决程序中函数调用的效率问题．<br>函数前边加上inline 关键字．就是内联函数，跟宏定义一样．直接在调用位置进行代码展开，优点就是避免了宏定义的缺点．</p><p>因为内联函数嵌入调用者代码中的操作是一种优化操作，因此只有进行优化编译时才会执行代码嵌入处理．若编译过程中没有优化选项＇-O＇,那么内联函数的代码就不会被真正的嵌入到调用者代码中，而是只作为普通函数调用来处理．所以编译的时候应该这么写: gcc test3.c -O .</p><p>普通函数执行，从mian 去函数的部分去执行(申请栈空间)，然后再回来执行．<br>内联函数，是执行main函数执行到，内联函数进行展开．</p><p>是不是都定义成内联函数就好了？<br>内联函数虽然节省了函数调用的时间消耗，但由于每一个函数出现的地方都用进行替换，因此增加了代码编译的时间．另外，并不是所有的函数都能够编程内联函数．<br>而且现在编译器很智能，就算你不写inline，他也会自动将一些函数优化成内联函数．<br>总结: 编译器比你更了解哪些函数应该内联那些不能内联，所以这个知识点你只需要知道就好了…..</p><h3 id="多态-c-实现"><a href="#多态-c-实现" class="headerlink" title="多态(c++实现)"></a>多态(c++实现)</h3><p><a href="https://www.cnblogs.com/-believe-me/p/11743099.html">多态详解代码演示</a></p><p>多态性:<br>    1. 专用多态:<br>        1. 重载多态: 重载多态包括前面学过的普通函数及类的成员函数的重载还有运算符的重载。<br>        2. 强制多态: 是指讲一个变元的类型加以变化，以符合一个函数或者操作的要求，举一个简单例子就清楚啦。<br>    2. 通用多态:<br>        1. 包含多态: 指的是类族中定义于不同类中的同名函数的多态的行为，主要是通过虚函数来实现。<br>        2. 参数多态: 采用函数模板，它可以用来创建一个通用的函数，以支持多种不同形参，避免重载函数的函数体重复设计，通过给出不同的类型参数，使得一个结构有多种类型。以实现参数多态。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="补漏" scheme="http://example.com/categories/%E8%A1%A5%E6%BC%8F/"/>
    
    
    <category term="补漏" scheme="http://example.com/tags/%E8%A1%A5%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux2</title>
    <link href="http://example.com/posts/33531/"/>
    <id>http://example.com/posts/33531/</id>
    <published>2020-12-05T01:37:58.000Z</published>
    <updated>2020-12-08T02:58:56.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="linux软连接和硬链接"><a href="#linux软连接和硬链接" class="headerlink" title="linux软连接和硬链接"></a>linux软连接和硬链接</h3><p>在linux系统中有种文件是链接文件，可以为解决文件的共享使用。链接的方式可以分为两种，一种是硬链接（Hard Link），另一种是软链接或者也称为符号链接（Symbolic Link).<br>文件列表中第一列权限位标识第一个字符显示的是文件类型，-为一般文件，d为目录，而l显示的就是链接文件。</p><h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><p>软连接就是window的快捷的方式,这个快捷方式没有指向文件内容(data)部分,只是记录了源文件的名字或者说索引信息,通关源文件名字来找到所要查找的内容部分,但是删除源文件后,快捷方式文件也变得无效.</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>硬链接就是新建立一个新的文件名子(index)指向的同一个数据区,通过多个索引能找到同一个数据区的内容,删除源文件的信息,依然可以通过另一个名字来找到该文件的数据内容,允许多个文件名索引到数据区,这里有一个记录链接的数字,就是为了确定数据区内容的删除时间,如果这个值为零操作系统就会把数据区删除,把内存释放,不为零就会把数据去的内容保存.只有当最后一个链接被删除后，此时如果有新数据要存储到磁盘上，被删除的文件的数据块及目录的链接才会被释放，空间被新数据暂用覆盖。</p><h4 id="软连接和硬链接特点"><a href="#软连接和硬链接特点" class="headerlink" title="软连接和硬链接特点"></a>软连接和硬链接特点</h4><p>软连接和硬链接的特点：</p><p>软链接:</p><ol><li>软链接是存放另一个文件的路径的形式存在。</li><li>软链接可以 跨文件系统 ，硬链接不可以。</li><li>软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。</li><li>软链接可以对目录进行链接。</li></ol><p>硬链接：</p><ol><li>硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>不允许给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li><li>删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ol><p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p><p>linux 中的具体实现:<br>    一，软链接<br>    　　touch f1<br>    　　创建符号链接，两个文件inode不同<br>    　　ln -s f1 f3<br>    二，硬链接<br>    　　touch f1<br>    　　创建硬链接, 两个文件inode相同<br>    　　ln  f1 f2<br>    硬链接和软链接，最大的不同就是删除源文件的后续操作，   硬链接删除f1后，f2依旧存在，且文件只有把文件以及相关硬链接全部删除，才会最终删除。用户就可以建立硬连接到重要文件，以防止“误删”的功能<br>    　　硬链接让所有文件指向同一个inode节点，文件只有一个，但展示为多个<br>    软链接删除f1后，f3从此失效，且文件不复存在。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。<br>    测试：<br>    删除符号链接f3, 对f1和f2无影响<br>    删除硬链接f2，对f1和f3无影响<br>    删除源文件f1，对硬链接f2无影响，f3失效<br>    删除源文件f1，f2，文件彻底删除</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>

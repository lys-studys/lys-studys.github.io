<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌上花开缓缓归</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-24T04:04:29.442Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lys-studys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP/TCP/HTTPS协议/高并发之NIO底层原理详解</title>
    <link href="http://example.com/posts/47384/"/>
    <id>http://example.com/posts/47384/</id>
    <published>2021-04-23T23:28:16.000Z</published>
    <updated>2021-04-24T04:04:29.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTTP和TCP之前已经写过，这里只是做一个简单的查漏补缺和总结概括．</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTPS协议的由来"><a href="#HTTPS协议的由来" class="headerlink" title="HTTPS协议的由来"></a>HTTPS协议的由来</h4><p>由于HTTP天生”明文”的特点，整个传输过程完全透明，任何人都能够在链路中获取，修改或者伪造请求/响应报文，数据不具有可信性．<br>使用HTTPS时，所有的HTTP请求和响应在发送到网络之前，都要进行加密.</p><p>HTTP裸奔协议: 最直观的感受在访问某些网站的时候，本来是没有广告，访问之后却显示了广告，很可能是响应报文被篡改了．<br>如果用HTTP协议完成银行转账，如果请求报文被篡改了，肯定是非常的不安全的．</p><p>HTTPS协议就是在HTTP协议的基础上加了一个安全层SSL/TSL<br>　　　　　　　　　　　　　　　　　　　HTTP<br>应用层　　　　　　　HTTP　　　　　　　SSL/TSL<br>传输层　　　　　　　TCP　　　　　　　　TCP<br>网络层　　　　　　　IP　　　　　　　　IP<br>数据链路层　　　　　网络接口　　　　　网络接口</p><p>第二列为HTTP协议, HTTP直接和TCP建立交互<br>第三列为HTTPS协议（HTTP + SSL/TSL），HTTP直接和安全层交互，安全层再和TCP层进行直接交互.正向为加密过程，反向则为解密过程．</p><h4 id="SSL-TLS来由"><a href="#SSL-TLS来由" class="headerlink" title="SSL/TLS来由"></a>SSL/TLS来由</h4><p>SSL即安全套接层(Secure Socket Layer),由网景公司于1994年发明，IETF在1999年把它改名为TLS(传输层安全，Transport Layer Security),正式标准化，到今天TLS已经发展出了主流的三个版本，分别是2006年的1.1,2008年的1.2,2018年的1.3,每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准.</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p>摘要算法能够把任意长度的数据”压缩”成固定长度，而且独一无二的摘要字符串，好像是给这段数据生成了一个数字”指纹”．任意微小的数据差异，都可以完成不同的摘要．所以可以通过把明文信息的摘要和明文一起加密进行传输，数据传输到对方之后再进行解密，重新对数据进行摘要，在对比就能发现数据有没有被篡改．这样就保证了数据的完整性.<br>一个定长串映射成一个长串，定长串经过微小变动，长串会发生明显　变化．<br>比如　abcd——hash　function—&gt;KLFGDFGHOO<br>　　　abce——hash　function—&gt;PLDGDFFHEA　　　</p><p>常用的摘要算法:<br>    1. md5<br>    2. sha1<br>    3. sha2<br>    4. sha1 256</p><h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>对称秘钥加密算法: 编解码使用形同秘钥的算法,如(AES,RC$,ChaCha20).</p><p>经典对称加密实例: XOR(抑或操作)<br>1110101010111010 原文<br>0101101101010101 秘钥</p><p>1011000111101111　秘文<br>0101101101010101 秘钥</p><p>原文和秘钥进行异或运算得到秘文<br>秘文和秘钥进行异或运算得到原文</p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>非对称秘钥加密算法: 他有两个秘钥，一个叫公钥，一个叫秘钥，两个秘钥是不同的，公钥可以公开给任何人使用，而私钥必须严格保密．非对称加密可以解决”秘钥交换”的问题．网站秘密保管私钥，在网上任意发布公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密．而黑客因为没有私钥，所以就无法破解密文．非对称秘钥加密系统通常需要大量的数学运算，比较慢．如(DH,DSA,RSA,ECC).</p><p>非对称两种方式:<br>    1. 使用公钥加密　使用私钥解密<br>    2. 使用私钥加密　使用公钥解密</p><p>公钥加密和私钥解密相对来说是比较安全地，应为公钥是公有的，私钥只有自己能用，如果用公钥解密，容易被破解掉.</p><h4 id="TLS详解"><a href="#TLS详解" class="headerlink" title="TLS详解"></a>TLS详解</h4><p>TLS里使用的混合加密方式，即把对称加密和非对称加密结合起来．两者互相取长补短，即能高效地加密解密，又能安全地秘钥交换，大致流程如下:<br>    1. 通信开始的时候使用非对称算法如RSA,RCDHE先解决秘钥交换的问题．<br>    2.<br>    3. </p><h5 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h5><p>首先Client和Server端完成三次握手，完成握手之后，然后client会对Server端发送一个请求，请求的是加密套件列表{散列算法－对称加密算法－非对称加密算法}．这些加密套件是Client端支持的加密套件比如支持哪些散列算法哪些对称加密算法哪些非对称加密算法等等．在进行加密的时候client 和Server都必须都能支持才能实现加解密，所以服务端先看一下本地的实现，查看是否client端提供的是否服务端都支持，如果支持的话，然后选择一种最安全的方法，这时客户端把选择的信息反馈给client端，比如（从客户端支持的加密套件列表中选择一个加密套件，公钥数字证书）．并且服务端也会公钥传给客户端，然后客户端会验证证书，然后生成一个随机秘钥，（这里的秘钥用于对称加密秘钥）并且会用公钥（服务器端给到的公钥数字证书里边存在）进行加密．然后服务端再用私钥解密，获取秘钥，最后使用对称秘钥加密算法进行秘钥双向传输.</p><p>公钥数字证书组成:<br>    ca信息，公钥用户信息，公钥，权威机构的签名，有效期．</p><p>问题来了，在建立三次握手的时候有个前提，就是拿到服务器的ip,这里的安全如何保证?如果DNS的信息被劫持，改成黑客的IP地址，是不是就直接可黑客的服务器完成信息通信，后果不堪设想!!<br>解决办法: DNS返回后，验证是不是我要访问的那个服务器，而不是黑客的服务器呢?<br>这里就是服务端给客户端返回的是公钥数字证书，这里边有相关的信息，通过验证证书来完成指定服务器的正确与否.</p><h5 id="身份验证-数字证书"><a href="#身份验证-数字证书" class="headerlink" title="身份验证(数字证书)"></a>身份验证(数字证书)</h5><p>图: https流程.png<br>数字证书组成: ca信息，　公钥用户信息，公钥，权威机构的签名，有效期.</p><p>数字证书的作用:<br>    1. 通过数字证书向浏览器验证身份,<br>    2. 数字证书里面包含了公钥.</p><p>数字证书的申请和验证<br>如何申请:<br>    1. 生成自己的公钥和私钥，服务器自己保留私钥.<br>    2. 向CA机构提交公钥，公司，域名信息等待认证．（最简单的域名和IP的匹配）<br>    3. CA机构通过线上，线下多种途径验证你提交信息的真实性，合法性．<br>    4. 信息审核通过，CA机构则会向你签发认证的数字证书，包含了公钥，组织信息，CA信息，有效时间，证书序列号，同时生成一个签名；<br>    签名步骤: hash(你用于申请证书所提交的明文信息)＝信息摘要；CA在使用私钥对信息摘要进行加密，密文就是证书的数字签名．</p><p>公钥数字证书又由谁来验证呢?<br>颁发证书的机构，CA机构来进行验证，根证书不能再数字证书里边的，他在浏览器或者操作系统里边保存的，</p><p>证书验证细节:<br>    首先把证书名的信息取出来，以及涉及到的算法（hash算法），把明文信息通过hash算法得到一个摘要(一段信息)，然后拿着CA给的公钥(加密是CA给的私钥加密的)进行解密得到解密得到的摘要，两个摘要对比如果一直就说明证书是正确的没有被改动．这就是浏览器对服务器端发送的证书认证的过程，</p><p>问题又来了，谁能保证CA机构是正确的或者是可信任的呢? 如果CA机构信息是伪造的也是不安全的.这里就是由根证书来验证．</p><p>证书是一个证书链，有每层的证书，最高的是根证书，这个不会发给客户端，这个证书是浏览器或者操作系统里边内置的．</p><h3 id="深入分析3大linux-io内核模型（一共有五大）"><a href="#深入分析3大linux-io内核模型（一共有五大）" class="headerlink" title="深入分析3大linux io内核模型（一共有五大）"></a>深入分析3大linux io内核模型（一共有五大）</h3><p>什么是io模型？<br>取决于应用如何调用内核的io函数（阻塞，非阻塞；同步，异步）．</p><p>linux内核IO模型:<br>　　　　　　io模型　　　　　　　　　　　　　同步异步　　　　阻塞非阻塞<br>    1. 阻塞IO　　　　　　　　　　　　　　　　同步　　　　　　阻塞<br>    2. 非阻塞io　　　　　　　　　　　　　　　同步　　　　　　非<br>    3. IO多路复用　　　　　　　　　　　　　　同步　　　　　　非<br>    4. 信号驱动　　　　　　　　　　　　　　　同步　　　　　　非<br>    5. 异步IO　　　　　　　　　　　　　　　　异步　　　　　　非</p><h4 id="同步异步阻塞非阻塞的定义"><a href="#同步异步阻塞非阻塞的定义" class="headerlink" title="同步异步阻塞非阻塞的定义"></a>同步异步阻塞非阻塞的定义</h4><p>同步异步: 强调结果返回的形式；<br>以借东西为例: (计算机层面计应用和内核)<br>同步:     比如你跟你同学去借钱，你走到他面前他把钱借给你了，你拿着钱走了，这里直接给你了就是同步，系统调用就是给系统一个需求或者调用一个接口，系统返回给一个结果</p><p>异步:<br>比如你跟你同学借钱，你走到他面前当时他没钱，你就说等你有钱了，你再来给我．这里没有直接拿到结果的就是异步．系统调用等同.</p><p>阻塞非阻塞: 强调对调用端的影响（服务端和客户端）<br>还是以借钱为例:<br>阻塞:  两个人同时找你借钱，一个人来借钱，这时你采取服务一个人在服务另一个人的方式处理借钱这件事情，在处理一个人的时候，另一个人只能阻塞在一旁．</p><p>非阻塞:<br>两个人同时找你借钱，你两个人同时处理．</p><p>非阻塞IO只是一种概念上的，现实如果实现会出现问题，这里用到了IO多路给他进行优化，这里BIO指的是阻塞IO,NIO一般说指的是非阻塞IO,严格意义上来说是一种new io,它包含了非阻塞IO和IO多路复用的优化．</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>强制类型转换与内存对齐问题</title>
    <link href="http://example.com/posts/6688/"/>
    <id>http://example.com/posts/6688/</id>
    <published>2021-04-23T15:48:03.000Z</published>
    <updated>2021-04-23T15:58:24.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>天行健，菜鸟以自强不息!!</p><h3 id="语言强制类型转换"><a href="#语言强制类型转换" class="headerlink" title="语言强制类型转换  "></a>语言强制类型转换  </h3><p> <br>理解：不论是什么类型，在内存中存储的都是二进制，所以之间可以相互转换，而每个内存单元为一个字节，所以强制类型转换就是在分配这些字节。<br>概要：</p><p>C语言中，任何一个变量都必须占有一个地址，而这个地址空间内的0-1代码就是这个变量的值。不同的数据类型占有的空间大小不一，但是他们都必须有个地址，而这个地址就是硬件访问的依据，而名字只是提供给程序员的一种记住这个地址的方便一点的方法。但是，不同的变量在机器中都是0-1代码，所以，我们不能简单的通过检查一个值的位来判断它的类型。</p><p>例如，定义如下：</p><p>int a;</p><p> float b;</p><p>double c;</p><p> long double d;</p><p>(假设它们所占的字节分别是4、8、8、10，而且连续存储于某个地址空间，起始地址是100，则我们可以得到如下内存分布)</p><p>a变量就是由以地址100开始到103结束的4个字节内存空间内的0-1代码组成。b变量则是由以地址104开始到112结束的8个字节内存空间内的0-1代码组成。而在机器中，这些内存都是连续的0-1代码，机器并不知道100<del>103是整型而104</del>111是float型，所有这些类型都是编译器告知的。当我们用a时，由于前面把a定义为int型，则编译器知道从a的地址开始向后取4个字节再把它解释成int型。那么(float)a，就是先按照int类型取出该数值，再将该数值按照int to float的规则转换成float型。所以强制类型转换就是按照某个变量的类型取出该变量的值，再按照**<em>to**</em>的规则进行强制转转换。如果是(类型名)常数，则是将该常数按照常数to类型 的规则进行强制转换。</p><p>指针也是一个变量，它自己占据一个4个字节的地址空间（由于程序的寻址空间是2^32次方，即4GB，所以用4个字节表示指针就已经能指向任何程序能够寻址到的空间了，所以指针的大小为4字节），他的值是另一个东西的地址，这个东西可以是普通变量，结构体，还可以是个函数等等。由于，指针的大小是4字节，所以，我们可以将指针强制转换成int型或者其他类型。同样，我们也可以将任何一个常数转换成int型再赋值给指针。所有的指针所占的空间大小都是4字节，他们只是声明的类型不同，他们的值都是地址指向某个东西，他们对于机器来说没有本质差别，他们之间可以进行强制类型转换。<br>指针 to 指针的强制类型转换是指将指针所指的内容的类型由原先的类型转换为后面的类型。</p><p> </p><p>int a = 1;</p><p>int *p = &a;</p><p>float <em>p1 = (float</em>)p;</p><p>则p和p1的值都是&amp;a，但是<em>p是将&amp;a地址中的值按照int型变量进行解释，而</em>p1则是将&amp;a地址中的值按照float型变量进行解释。</p><p>鉴于指针之间这种灵活的强制类型转换的需求和出于简化代码的考虑，ANSI C引入了空指针即void*。void指针又名万能指针，在现在的很多程序中，当参数不确定时就用万能指针代替，这一类的指针在线程\进程函数里特别常见。</p><p>ANSI C规定，void指针可以复制给其他任意类型的指针，其他任意类型的指针也可以复制给void指针，他们之间复制不需要强制类型转换。当然任何地址也可以复制给void型指针。我们在《网络编程》中经常会看到accept(socket, (struct sockaddr *)&amp;saddr_c, &amp;lenth)之类的语句在&amp;saddr_c之前需要增加代码(struct sockaddr <em>)是因为当此函数被设计的时候ANSI C还没有提出void</em>的概念。所有的地址统一用struct sockaddr类型标识，该函数的第二个参数也是指向struct sockaddr类型的指针，此处是强制类型转换。</p><p>当然，在某些编译器中不同类型的指针也可以进行直接赋值，但一般情况下会给出类型不匹配的警告。要求程序员显示的给出指针强制类型转换可以提醒程序员小心使用指针，对于明确程序目的具有一定的好处。</p><ol><li>指针类型强制转换</li></ol><p>int m;</p><p>int *pm = &m;</p><p>char *cp = (char *)&m;</p><p>pm指向一个整型，cp指向整型数的第一个字节</p><ol start="2"><li>结构体之间的强制转换</li></ol><p>struct str1 a;</p><p> </p><p>struct str2 b;</p><p>a=(struct str1) b;                  //this is wrong</p><p>a=<em>((struct str1</em>)&amp;b);         //this is correct</p><p> </p><ol start="3"><li>关于一个程序的解释</li></ol><p> </p><p>int main(void)</p><p>{</p><pre><code>    int a［4] = &#123;1, 2, 3, 4&#125;;    int *ptr1=(int *)(&amp;a+1);    int *ptr2=(int *)((int)a+1);    int *c = *(a + 1);    printf(&quot;%x, %x,%x\n&quot;, ptr1[-1], *ptr2,*c);    return 0;</code></pre><p>}</p><p>输出分别为4 和2000000,2 </p><p>式子&amp;a+1表示的是指针加法运算，而不是普通的数值加法运算</p><ol><li>&amp;a+1</li></ol><p>   &amp;a表示数组指针，&amp;a+1表示指向下一个数组，强制转换为int型指针，减一即指向a［3]=4;在前面两篇文章中有详细解释。而ptr1［-1]= <em>(ptr1 - 1) 由于ptr1是指针，指向数组a后面的下一个元素，而ptr1-1就是ptr1这个指针往前移动一个单位，移动之后这个指针指向了数组a的最后一个元素。所以就有</em>(ptr1-1)=4。</p><ol start="2"><li>(int *)((int)a+1)</li></ol><p>       指针ptr2的处理是把数组名a强制转换成整型变量，然后再加1，然后再强制转换成整型指针，即是让ptr2指向a[0]的第二个字节，此时打印的内容就是ptr2所指向的往后4个字节的内容，也就是a{0}的后三个字节和a[1]的第一个字节上面的图没有画出里面的内容。此时需要考虑大小端问题。</p><p>    </p><p>    字节序分两种，大端字节序(big-endian) ，小端字节序(little-endian)   </p><p>    1、所谓大端(big-endian)序，就是高优先位对应高有效位。就是读取或者存放数据时，最低位 对应高地址 。</p><p>    2、所谓小端(little-endian)序，就是高优先位对应低有效位 。就是读取或者存放数据时，最低 位对应低地址 。</p><p>       由于x86平台是小端序的，因此将会打印出0200 0000，如果题目中没有说明在x86平台，那答案是不确定的，取决于具体的平台，例如ARM平台就是大端序的。 </p><ol start="3"><li>*(a + 1)  </li></ol><p>      *(a + 1)  此时的a已经是一个常指针了，这个表达式计算出a所指向元素后面的第2个元素的地址，然后对它解引用得到相应的值。这个表达式等价于int last = a［1]</p><p>结构体类型的强制类型转换</p><p>结构体和int等类型一样，都是数据类型。其他类型怎么转换，结构体就怎么转换，没有什么特殊的地方。<br>楼主可能想知道的不是结构体怎样强制转换这个问题吧，猜测，楼主想知道如下几个问题：<br>如果将一个结构体强制类型转换为另一个结构体（或者类型），那这个结构体的成员会怎样了？<br>如果将一个结构体强制类型转换为另一个结构体（或者类型），那么这个结构体成员的数值又会是什么了？<br>解答：</p><ol><li>结构体的本质是：我们和C语言约定了一段内存空间的长短，及其内容的安排。假设下面两个结构体：<br>struct A1<br>{<br>     int a;<br>     char b;</li></ol><p>};</p><p>struct A2<br>{<br>        char a;<br>        int b;</p><p>};<br>接着，用struct A1和struct A2定义变量，并赋初值：<br>struct A1 x = {10, ‘A’};<br>struct A2 y = {‘A’, 10};<br>现在最重要的是，要知道x和y的内存情况：<br>x的内存安排是：前4B，后1B；<br>y的内存安排是：前1B，后4B。<br>如果有struct A2 z;<br>z.a = ((struct A2)x).a;<br>那么，C语言会对x的空间，按照struct A2的格局进行解释:</p><pre><code>也就是说，将x的第一个字节看成第一个成员，且按ASCII码处理数据，而将后面的4B看成第二个成员，并按补码格式解释数据。内存对齐小结：在C语言面试和考试中经常会遇到内存字节对齐的问题。今天就来对字节对齐的知识进行小结一下。首先说说为什么要对齐。为了提高效率，计算机从内存中取数据是按照一个固定长度的。以32位机为例，它每次取32个位，也就是4个字节（每字节8个位，计算机基础知识，别说不知道）。字节对齐有什么好处？以int型数据为例，如果它在内存中存放的位置按4字节对齐，也就是说1个int的数据全部落在计算机一次取数的区间内，那么只需要取一次就可以了。如图a-1. 1. 如果不对齐，很不巧，这个int数据刚好跨越了取数的边界，这样就需要取两次才能把这个int的数据全部取到，这样效率也就降低了。                        </code></pre><p>                                    </p><pre><code>内存对齐是会浪费一些空间的。但是这种空间上得浪费却可以减少取数的时间。这是典型的一种以空间换时间的做法。空间与时间孰优孰略这个每个人都有自己的看法，但是C语言既然采取了这种以空间换时间的策略，就必然有它的道理。况且，在存储器越来越便宜的今天，这一点点的空间上的浪费就不算什么了。需要说明的是，字节对齐不同的编译器可能会采用不同的优化策略，以下以GCC为例讲解结构体的对齐.一、原则：1. 结构体内成员按自身按自身长度自对齐。自身长度，如char=1，short=2，int=4，double=8,。所谓自对齐，指的是该成员的起始位置的内存地址必须是它自身长度的整数倍。如int只能以0,4,8这类的地址开始2. 结构体的总大小为结构体的有效对齐值的整数倍结构体的有效对齐值的确定：1）当未明确指定时，以结构体中最长的成员的长度为其有效值2）当用#pragma pack(n)指定时，以n和结构体中最长的成员的长度中较小者为其值。3）当用__attribute__ ((__packed__))指定长度时，强制按照此值为结构体的有效对齐值二、例子1. struct AA&#123;        char a;        int b;        char c; &#125;aa结果，sizeof（aa）=12何解？首先假设结构体内存起始地址为0，那么地址的分布如下0  a1  234  b5  b6  b7  b8  c91011char的字对齐长度为1，所以可以在任何地址开始，但是，int自对齐长度为4，必须以4的倍数地址开始。所以，尽管1-3空着，但b也只能从4开始。再加上c后，整个结构体的总长度为9，结构体的有效对齐值为其中最大的成员即int的长度4，所以，结构体的大小向上扩展到12，即9-11的地址空着。2. struct AA&#123;        char a;    char c;         int b;    &#125;aasizeof（aa）=8，为什么呢0  a1  c234  b5  b6  b7  b因为c为char类型，字对齐长度为1，所以可以有效的利用1-3间的空格。看见了吧，变量定义的位置的不同时有可能影响结构体的大小的哦！3. #pragma pack(2)struct AA&#123;        char a;        int b;        char c; &#125;aasizeof（aa）=10,为什么呢？a到c只占9字节长度，因为结构体的有效对齐长度在pack指定的2和int的4中取较小的值2。故取2的倍数10。如果当pack指定为8呢?那就仍然按4来对齐，结果仍然是12。 4. </code></pre><p>struct AA{</p><pre><code>    char a;    int b;    char c; </code></pre><p>}<strong>attribute</strong>((<strong>8</strong>))aa</p><p>sizeof(aa)=16,）</p><p>为咩？其实a到c仍然只占9字节长度，但结构体以8对齐，故取8的倍数16.</p><p>如果其指定2，则结果为10</p><p>如果pragma pack和<strong>attribute</strong> 同时指定呢？以<strong>attribute</strong> 的为准。</p><p>需要说明的是，不管pragma pack和__attribute__如何指定，结构体内部成员的自对齐仍然按照其自身的对齐值。</p><p> 另外，不同的编译器可能会对内存的分布进行优化，</p><p> 例如有些编译器会把立体1中的程序优化成例题2的样子。但这属于编译器的问题，</p><p> 这里不做详细讨论。如果要作为编程的参考的话，最好当做编译器不会做优化，</p><p> 尽量在保持代码清晰的情况下，自己手动将例题1优化成例题2的样子。</p><p> 如果是做题的话，按照以上原则做就可以了，不用考虑不同编译器的特性。</p><p>(参考老K的代码world)[<a href="https://blog.csdn.net/qq_33366098/article/details/78137422]">https://blog.csdn.net/qq_33366098/article/details/78137422]</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c/c++" scheme="http://example.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>均匀的生成随机数</title>
    <link href="http://example.com/posts/37274/"/>
    <id>http://example.com/posts/37274/</id>
    <published>2021-04-23T13:28:11.000Z</published>
    <updated>2021-04-23T14:44:47.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>艰难困苦　玉如于成　！！</p><p>假设已知rand2()可以均匀的生成［1,2]的随机数，现在想均匀的生成{1,4]的随机数，该如何考虑？<br>第一次接触这个问题，那么很可能会这么考虑——令两个rand2()相加，再做一些必要的边角处理。如下：<br>rand2() + rand2() = ? ==＞{2,4]<br>   1    +   1     = 2<br>   1    +   2     = 3<br>   2    +   1     = 3<br>   2    +   2     = 4<br>出现概率:<br>1: 1/4;<br>2: 2/4 = 1/2<br>3: 1/4<br>结论是概率出现次数并不均等，所以说不能作为随机数的最终结果.<br>下边先得出我们想要的范围，然后再考虑去重的问题．</p><p>为了把生成随机数的范围规约成{1,n]，于是在上一步的结果后减1<br>(rand2()-1) + rand2() = ? ==＞ {1,3]<br>   0       +   1     = 1<br>   0       +   2     = 2<br>   1       +   1     = 2<br>   1       +   2     = 3<br>可以看到，使用这种方法处理的结果，最致命的点在于——其生成的结果不是等概率的。在这个简单的例子中，产生2的概率是50%，而产生1和3的概率则分别是25%。原因当然也很好理解，由于某些值会有多种组合，因此仅靠简单的相加处理会导致结果不是等概率的。</p><p>因此，我们需要考虑其他的方法了。</p><p>仔细观察上面的例子，我们尝试对 (rand2()-1) 这部分乘以 2，改动后如下：</p><p>(rand2()-1) × 2 + rand2() = ? ==＞ ［1,3]<br>   0            +   1     = 1<br>   0            +   2     = 2<br>   2            +   1     = 3<br>   2            +   2     = 4<br>神奇的事情发生了，奇怪的知识增加了。通过这样的处理，得到的结果恰是［1,4]的范围，并且每个数都是等概率取到的。因此，使用这种方法，可以通过rand2()实现rand4()。</p><p>也许这么处理只是我运气好，而不具有普适性？那就多来尝试几个例子。比如：</p><p>(rand9()-1) × 7 + rand7() = result<br>     a               b</p><p>可以看到，这个例子可以等概率的生成［1,63]范围的随机数。再提炼一下，可以得到这样一个规律：</p><p>已知 rand_N() 可以等概率的生成[1, N]范围的随机数<br>那么：<br>(rand_X() - 1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数<br>即实现了 rand_XY()</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>那么想到通过rand4()来实现rand2()呢？这个就很简单了，已知rand4()会均匀产生[1,4]的随机数，通过取余，再加1就可以了。如下所示，结果也是等概率的。</p><p>rand4() % 2 + 1 = ?<br>   1 % 2    + 1 = 2<br>   2 % 2    + 1 = 1<br>   3 % 2    + 1 = 2<br>   4 % 2    + 1 = 1<br>事实上，只要rand_N()中N是2的倍数，就都可以用来实现rand2()，反之，若N不是2的倍数，则产生的结果不是等概率的。比如：</p><p>rand6() % 2 + 1 = ?<br>   1 % 2    + 1 = 2<br>   2 % 2    + 1 = 1<br>   3 % 2    + 1 = 2<br>   4 % 2    + 1 = 1<br>   5 % 2    + 1 = 2<br>   6 % 2    + 1 = 1</p><p>rand5() % 2 + 1 = ?<br>   1 % 2    + 1 = 2<br>   2 % 2    + 1 = 1<br>   3 % 2    + 1 = 2<br>   4 % 2    + 1 = 1<br>   5 % 2    + 1 = 2</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>ok，现在回到本题中。已知rand7()，要求通过rand7()来实现rand10()。</p><p>有了前面的分析，要实现rand10()，就需要先实现rand_N()，并且保证N大于10且是10的倍数。这样再通过rand_N() % 10 + 1 就可以得到[1,10]范围的随机数了。</p><p>而实现rand_N()，我们可以通过part 1中所讲的方法对rand7()进行改造，如下：</p><p>(rand7()-1) × 7 + rand7()  ==&gt; rand49()<br>但是这样实现的N不是10的倍数啊！这该怎么处理？这里就涉及到了“拒绝采样”的知识了，也就是说，如果某个采样结果不在要求的范围内，则丢弃它。基于上面的这些分析，再回头看下面的代码，想必是不难理解了。</p><p>class Solution extends SolBase {<br>    public int rand10() {<br>        while(true) {<br>            int num = (rand7() - 1) * 7 + rand7(); // 等概率生成[1,49]范围的随机数<br>            if(num &lt;= 40) return num % 10 + 1; // 拒绝采样，并返回[1,10]范围的随机数<br>        }<br>    }<br>}</p><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p>这部分具体的代码是参考官方题解的，不过是我自己在理解了part 1和part 2之后才看懂的，一开始看真不知道为什么（/(ㄒoㄒ)/~~…</p><p>根据part 1的分析，我们已经知道(rand7() - 1) * 7 + rand7() 等概率生成[1,49]范围的随机数。而由于我们需要的是10的倍数，因此，不得不舍弃掉[41, 49]这9个数。优化的点就始于——我们能否利用这些范围外的数字，以减少丢弃的值，提高命中率总而提高随机数生成效率。</p><p>class Solution extends SolBase {<br>    public int rand10() {<br>        while(true) {<br>            int a = rand7();<br>            int b = rand7();<br>            int num = (a-1)*7 + b; // rand 49<br>            if(num &lt;= 40) return num % 10 + 1; // 拒绝采样</p><pre><code>        a = num - 40; // rand 9        b = rand7();        num = (a-1)*7 + b; // rand 63        if(num &lt;= 60) return num % 10 + 1;        a = num - 60; // rand 3        b = rand7();        num = (a-1)*7 + b; // rand 21        if(num &lt;= 20) return num % 10 + 1;    &#125;&#125;</code></pre><p>}<br>分析一下<br>第一个if:<br>    范围: 1~49<br>    49个数每个数字的出现概率都是1/49</p><p>第二个if:<br>    范围: 1~60<br>    60个数每个数的出现概率都是1/60</p><p>第三个if:<br>    范围: 1~20<br>    20个数每个数的出现概率都是1/20</p><p>每一部分都采取了拒绝采样处理: 避免掉了%10之后数字分配不均的问题．这样就做到了１０以内每个数字出现在每个if都是等概率的．<br>验证代码需要大数据求次数，可以说近似平均,</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随机数" scheme="http://example.com/categories/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
    
    <category term="随机数" scheme="http://example.com/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++多态虚函数表详解及多重继承和多继承情况</title>
    <link href="http://example.com/posts/46373/"/>
    <id>http://example.com/posts/46373/</id>
    <published>2021-04-17T12:15:07.000Z</published>
    <updated>2021-04-18T13:30:35.578Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>该部分由于没办法传入图手写的有些出入，可看源码．<br>主要涉及的知识: C++ 多态 多继承 多重继承 虚函数表 虚函数指针 动态绑定</p><p>概述：C++相对其他面向对象语言来说，之所以灵活、高效。很大程度的占比在于其多态技术和模板技术。C++虚函数表是支撑C++多态的重要技术，它是C++动态绑定技术的核心。</p><h3 id="多态内存分布"><a href="#多态内存分布" class="headerlink" title="多态内存分布"></a>多态内存分布</h3><p>假设有一个基类ClassA，一个继承了该基类的派生类ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。<br>我们在代码中运用多态这个特性时，通常以两种方式起手: </p><ol><li>ClassA *a = new ClassB();</li><li>ClassB b; ClassA *a = &b;<br>以上两种方式都是用基类指针去指向一个派生类实例，区别在于第1个用了new关键字而分配在堆上，第2个分配在栈上.<br>————————————————</li></ol><p>详谈内存分配:<br>—————-ClassA *a = new ClassB();]————————————————-ClassB b, ClassA *a = &b;<br>———————————————————————————]————————————————–]<br>———-栈区——:–ClassA *a;————————————————]——ClassB实例————-(1) ClassA指针指向—<br>———————————————————————————]——虚函数表指针———–ClassB栈上对象实例—<br>———————————————————————————]——其他成员————————————<br>———————————————————————————]————————————————–]<br>—-虚地址空间——:———–(1)注释: ClassA指针指向ClassB堆上对象实例.——-]————————————————–<br>———————————————————————————]————————————————–]<br>———————–ClassB实例————————————————]————————————————–<br>——-堆区———:–虚函数表指针———————————————-]————————————————–<br>———————–其他成员————————————————–]————————————————–<br>———————————————————————————]————————————————-]<br>–未初始化全局区—-:-(.bss)—-(2)注释:-vptr指向ClassB类的虚函数表————–]————————————————-<br>———————————————————————————]————————————————-]<br>–已初始化全局区—-:-(.data)—————————————————-]————————————————–<br>———————————————————————————]————————————————-]<br>———————-ClassB类的虚函数表—————————————–]ClassB类的虚函数表——–(2)vptr指向————<br>只读数据段(.rodata)-:-虚函数指针01———————————————–]虚函数指针01———–ClassB类的虚函数表——–<br>———————-虚函数指针02———————————————–]虚函数指针02————————————-<br>———————-0———————————————————-]——-0—————————————–<br>———————————————————————————]————————————————-]<br>———————-非虚函数—————————————————]非虚函数—————-(3)ClassB类的虚函数指针指向<br>—-代码段(.text)—:-虚函数—-(3)ClassB类的虚函数指针指向Class类的虚函数代码段.]虚函数———————ClassB类的虚函数代码段<br>———————————————————————————]————————————————–<br>———————————————————————————]————————————————-]</p><p>注解:<br>    第一列: (三个箭头)<br>        箭头1: 栈区指向堆区         (1)所示<br>        箭头2: 堆区指向只读代码段   (2)所示<br>        箭头3: 只读代码段指向代码段 (3)所示<br>    第二列: (三个箭头)<br>        箭头1: ClassA *a 指向ClassB实例 (1)所示<br>        箭头2: 虚函数表指针指向虚函数01 (2)所示<br>        箭头3: 虚函数指针指向虚函数     (3)所示</p><p>请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。<br>以左图为例，ClassA *a是一个栈上的指针。<br>该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向**该类的虚函数表(这里是类ClassB)**的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。</p><h3 id="类的虚函数表与类实例的虚函数指针"><a href="#类的虚函数表与类实例的虚函数指针" class="headerlink" title="类的虚函数表与类实例的虚函数指针"></a>类的虚函数表与类实例的虚函数指针</h3><p>首先不考虑继承的情况。如果一个类中有虚函数，那么该类就有一个虚函数表。<br>这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。<br>从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。</p><p>看图分析:<br>    ClassA类的实例01<br>    —————-            [类ClassA的虚函数表          类ClassA的虚函数<br>    虚函数表指针————–&gt; [虚函数指针01      ——–&gt; ClassA::vfun10<br>    成员变量01           -  &gt;   [虚函数指针02      ——–&gt; ClassA::vfun20<br>    普通函数指针      -         […                         …<br>                   -            [0<br>                -<br>     ClassA类的实例02                                        ClassA的普通函数<br>    —————–　　　　　　　　　　　　　　　　　　　——————-<br>     虚函数表指针                                            ClassA::func10<br>     成员变量01                                              ClassA::func20<br>     普通函数指针                                            …</p><h3 id="多态代码及多重继承情况"><a href="#多态代码及多重继承情况" class="headerlink" title="多态代码及多重继承情况"></a>多态代码及多重继承情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassA() &#123; cout &lt;&lt; &quot;ClassA::ClassA()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassA() &#123; cout &lt;&lt; &quot;ClassA::~ClassA()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassA::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">void func2() &#123; cout &lt;&lt; &quot;ClassA::func2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassA::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassA::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int aData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassB : public ClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassB() &#123; cout &lt;&lt; &quot;ClassB::ClassB()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassB() &#123; cout &lt;&lt; &quot;ClassB::~ClassB()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassB::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassB::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int bData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassC : public ClassB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassC() &#123; cout &lt;&lt; &quot;ClassC::ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassC() &#123; cout &lt;&lt; &quot;ClassC::~ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func2() &#123; cout &lt;&lt; &quot;ClassC::func2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassC::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">    int cData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在第二部分中，我们讨论了在没有继承的情况下，虚函数表的逻辑结构。<br>那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。<br>请看上面代码</p><ol><li><p>ClassA是基类, 有普通函数: func1() func2() 。虚函数: vfunc1() vfunc2() ~ClassA()</p></li><li><p> ClassB继承ClassA, 有普通函数: func1()。虚函数: vfunc1() ~ClassB()</p></li><li><p>ClassC继承ClassB, 有普通函数: func2()。虚函数: vfunc2() ~ClassB()<br>基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份.</p><pre><code>   a-----------------&gt; ClassA类的实例01              类ClassA的虚函数表               类ClassA的虚函数 </code></pre><p>ClassA *a = new ClassA();     ClassA的虚函数表指针  ——-&gt;虚函数指针01  ——————&gt;ClassA::vfunc10</p><pre><code>                       ClassA::aData                 虚函数指针02  ------------------&gt;ClassA::vfunc20                       ClassA::func10                ...                              ...                       ClassA::func20                0                                                       ...</code></pre></li></ol><hr><p>a                            ClassB类的实例01               类ClassB的虚函数表               类ClassB的虚函数<br>ClassA *a = new ClassB()—-&gt;ClassB的虚函数表指针           虚函数指针01                     ClassB::vfunc10<br>                             ClassA::aData                  虚函数指针02                     ClassA::vfunc20<br>                             ClassA::func10                 …                              …<br>                             ClassA::func20                 0<br>                             …<br>                            —————————<br>                             ClassB:bData<br>                             ClassB:func10<br>                             …</p><hr><p>ClassB继承与ClassA，其虚函数表是在ClassA虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassA *a &#x3D; new ClassB();</span><br><span class="line">a-&gt;func1();                    &#x2F;&#x2F; &quot;ClassA::func1()&quot;   隐藏了ClassB的func1()</span><br><span class="line">a-&gt;func2();                    &#x2F;&#x2F; &quot;ClassA::func2()&quot;</span><br><span class="line">a-&gt;vfunc1();                   &#x2F;&#x2F; &quot;ClassB::vfunc1()&quot;  重写了ClassA的vfunc1()</span><br><span class="line">a-&gt;vfunc2();                   &#x2F;&#x2F; &quot;ClassA::vfunc2()&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结果不难想象，看上图，ClassA类型的指针a能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同<br>这个结果已经说明了C++的隐藏、重写(覆盖)特性。</p><p>同理，也就不难推导出ClassC的逻辑结构图了<br>类的继承情况是: ClassC继承ClassB，ClassB继承ClassA<br>这是一个多次单继承的情况。(多重继承)</p><pre><code>                                    ClassC类的实例01                    ClassC的虚函数表        类ClassC的虚函数</code></pre><p>ClassA *a = new ClassC();————-&gt;[ClassC的虚函数表指针                虚函数指针01            ClassB::vfunc1()<br>ClassB *b = new ClassC();————-&gt;[                                    虚函数指针02            ClassC::vfunc2()<br>                                         ClassA::aData                      …                     …<br>                                         ClassA::func1()                    0<br>                                         ClassA::func2()<br>                                         …<br>                                         ——————–<br>                                         ClassB::bData<br>                                         ClassB::func1()<br>                                         …<br>                                         ——————–<br>                                         ClassC::cData<br>                                         ClassC::func20()<br>                                         …<br>                                         ——————–</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassA* a &#x3D; new ClassC;</span><br><span class="line">a-&gt;func1();          &#x2F;&#x2F; &quot;ClassA::func1()&quot;   隐藏ClassB::func1()               </span><br><span class="line">a-&gt;func2();          &#x2F;&#x2F; &quot;ClassA::func2()&quot;隐藏ClassC::func2()</span><br><span class="line">a-&gt;vfunc1();     &#x2F;&#x2F; &quot;ClassB::vfunc1()&quot;ClassB把ClassA::vfunc1()覆盖了</span><br><span class="line">a-&gt;vfunc2();     &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;ClassC把ClassA::vfunc2()覆盖了</span><br><span class="line"></span><br><span class="line">ClassB* b &#x3D; new ClassC;</span><br><span class="line">b-&gt;func1();&#x2F;&#x2F; &quot;ClassB::func1()&quot;有权限操作时，子类优先</span><br><span class="line">b-&gt;func2();&#x2F;&#x2F; &quot;ClassA::func2()&quot;隐藏ClassC::func2()</span><br><span class="line">b-&gt;vfunc1();&#x2F;&#x2F; &quot;ClassB::vfunc1()&quot;ClassB把ClassA::vfunc1()覆盖了</span><br><span class="line">b-&gt;vfunc2();&#x2F;&#x2F; &quot;ClassB::vfunc2()&quot;ClassC把ClassA::vfunc2()覆盖了</span><br></pre></td></tr></table></figure><h3 id="多继承下的虚函数表-同时继承多个基类"><a href="#多继承下的虚函数表-同时继承多个基类" class="headerlink" title="多继承下的虚函数表 (同时继承多个基类)"></a>多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassA1() &#123; cout &lt;&lt; &quot;ClassA1::ClassA1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassA1() &#123; cout &lt;&lt; &quot;ClassA1::~ClassA1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassA1::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassA1::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassA1::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int a1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassA2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassA2() &#123; cout &lt;&lt; &quot;ClassA2::ClassA2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassA2() &#123; cout &lt;&lt; &quot;ClassA2::~ClassA2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassA2::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassA2::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassA2::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc4() &#123; cout &lt;&lt; &quot;ClassA2::vfunc4()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int a2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassC : public ClassA1, public ClassA2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassC() &#123; cout &lt;&lt; &quot;ClassC::ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassC() &#123; cout &lt;&lt; &quot;ClassC::~ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassC::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassC::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassC::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc3() &#123; cout &lt;&lt; &quot;ClassC::vfunc3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ClassA1是第一个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()。<br>ClassA2是第二个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()，vfunc4()。<br>ClassC依次继承ClassA1、ClassA2。普通函数func1(),虚函数vfunc1() vfunc2() vfunc3()。</p><pre><code>                             ClassC类的实例01               类ClassC的虚函数表01    类ClassC的虚函数</code></pre><p>ClassA1 *a1 = new ClassC();      ClassC的虚函数表指针01         虚函数指针01———-&gt; ClassC::vfun1()<br>ClassA2 *a2 = new ClassC();      ClassC的虚函数表指针02         虚函数指针02———-&gt; ClassC::vfun2()<br>                                 ClassA1::a1Data                虚函数指针03———-&gt; ClassC::vfun3()<br>                                 ClassA1::func1()               *<br>                                 …                            (上边以classA1为基础)<br>                                 ClassA2::a2Data                类ClassC的虚函数表02    类ClassC的虚函数<br>                                 ClassA2::func1()               虚函数指针01———-&gt; ClassC::vfun1()<br>                                 …                            虚函数指针02———-&gt; ClassC::vfun2()<br>                                 ClassC::cData                  虚函数指针03———-&gt; ClassA2::func4()<br>                                 ClassC::func1()                0                       …<br>                                 …                            (上边以classA2为基础)<br>注意:<br>    1. 父类没有而子类有的,添加到第一个表中<br>    2. 父类有而子类没有的,不覆盖.</p><p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。<br>如图，虚函数表指针01指向的虚函数表是以ClassA1的虚函数表为基础的，子类的ClassC::vfunc1(),和vfunc2()的函数指针覆盖了虚函数表01中的虚函数指针01的位置、02位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。<br>当有多个虚函数表时，虚函数表的结果是0代表没有下一个虚函数表。” * “号位置在不同操作系统中实现不同，代表有下一个虚函数表。<br>注意: </p><ol><li>子类虚函数会覆盖每一个父类的每一个同名虚函数。</li><li>父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。</li><li>父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。</li></ol><p>最后给出代码和结果:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   ClassA1 *a1 &#x3D; new ClassC;</span><br><span class="line">a1-&gt;func1();               &#x2F;&#x2F; &quot;ClassA1::func1()&quot;    隐藏子类同名函数</span><br><span class="line">a1-&gt;vfunc1();              &#x2F;&#x2F; &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA1虚函数</span><br><span class="line">a1-&gt;vfunc2();              &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA1虚函数</span><br><span class="line">没有a1-&gt;vfunc3()，父类没有这个虚函数</span><br><span class="line"></span><br><span class="line">ClassA2 *a2 &#x3D; new ClassC;</span><br><span class="line">a2-&gt;func1();               &#x2F;&#x2F; &quot;ClassA2::func1()&quot;    隐藏子类同名函数</span><br><span class="line">a2-&gt;vfunc1();              &#x2F;&#x2F; &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA2虚函数</span><br><span class="line">a2-&gt;vfunc2();              &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA2虚函数</span><br><span class="line">a2-&gt;vfunc4();              &#x2F;&#x2F; &quot;ClassA2::vfunc4()&quot;   未被子类重写的父类虚函数</span><br><span class="line"></span><br><span class="line">ClassC *c &#x3D; new ClassC;</span><br><span class="line">c-&gt;func1();                &#x2F;&#x2F; &quot;ClassC::func1()&quot;</span><br><span class="line">c-&gt;vfunc1();               &#x2F;&#x2F; &quot;ClassC::vfunc1()&quot;</span><br><span class="line">c-&gt;vfunc2();               &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;</span><br><span class="line">c-&gt;vfunc3();               &#x2F;&#x2F; &quot;ClassC::vfunc3()&quot;</span><br><span class="line">c-&gt;vfunc4();               &#x2F;&#x2F; &quot;ClassA2::func4()&quot; </span><br></pre></td></tr></table></figure></p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">&#x2F;&#x2F;函数占位参数如下</span><br><span class="line">    &#x2F;&#x2F; void se(int)-</span><br><span class="line">&#x2F;&#x2F;函数重载，允许函数名重复，但是参数数量不同</span><br><span class="line">&#x2F;&#x2F;函数重载条件</span><br><span class="line">    &#x2F;&#x2F;1.同一个作用下</span><br><span class="line">    &#x2F;&#x2F;2.函数名相同</span><br><span class="line">    &#x2F;&#x2F;3.函数参数类型不同，或者参数个数或顺序不一样。 </span><br><span class="line">    &#x2F;&#x2F;函数返回值不可以作为函数重载的条件 </span><br><span class="line">using namespace std;</span><br><span class="line">int func(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125; </span><br><span class="line">int func(int a, int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b+c;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F;因为函数参数个数不用而进行的函数重载</span><br><span class="line">int  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; func(5,6) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; func(5,6,7) &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么要重载？：<br>       C++为了致力于简化编程，能通过函数重名来打到简化编程的目的。 C++允许在同一范围中声明几个功能类似的同名函数。可以提高开发效率，增加可读性。</p><p>对于不同的数据类型取绝对值，需要定义不同的函数</p><p>int iabs(int a)<br>{<br>    return a&gt;0 ? a：-a;<br>}</p><p>double fabs(doule a)<br>{<br>    return a&gt;0 ? a：-a;<br>}<br>重载规则：<br>       1、函数名相同</p><p>       2、函数形参个数、顺序、类型不同</p><p>同时符合以上两个条件可构成重载，返回值不同不可以构成重载。</p><p>底层实现：<br>       C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p><p>C++定义同名重载函数：<br>#include<iostream><br>using namespace std;<br>int func(int a, double b){<br>    return ((a) + (b));<br>}<br>int func(double a, float){<br>    return ((a) + (b));<br>}<br>int func(float a, int b){<br>    return ((a) + (b));<br>}<br>int main(){<br>    return 0;<br>}</p><p>底层实现：用nm命令查看目标文件的符号清单</p><p>00000000000000a7 t_GLOBAL_sub_I_Z4funcid<br>000000000000005e T main<br>0000000000000069 t _Z41_static_iniyialization_and_destruction_0ii<br>0000000000000020 T _Z4funcdf (这里d为double的简化,f为float的简化)<br>000000000000003e T _Z4funcfi (这里f为float的简化,i为int的简化)<br>0000000000000000 T _Z4funcid ()</p><p><a href="https://blog.csdn.net/qq_36359022/article/details/81870219">参考网站可跳转</a></p><hr><p>ad代表double，f代表float，i代表int，加上参数首字母以区分同名函数。</p><p>extern “C”：<br>       C++要实现对C语言的完全兼容。首先要语法兼容，其次是C库兼容。</p><p>       C++编写的代码，若去调用C编出来的库，是行不通的，因为C代码编译并不会发生命名倾轧行为，而C++代码编译会产生命名倾轧行为，所以函数名不匹配，则无法调用到C库中的函数。</p><p>       消除倾轧的方法，在C++代码包含C库的头文件，加入extern “C”。可在linux中自行编译一个C库，C++代码去调用，来证明无法链接到库函数。</p><p>extern “C”{//让里面的内容不发生倾轧行为<br>          ……//例如：#include “head1.h”<br>          }</p><p>       总之一句话，倾轧是C++为了实现函数重载而设计的，不倾轧的extern “C”则是为了兼容C而后实现的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划入门</title>
    <link href="http://example.com/posts/10547/"/>
    <id>http://example.com/posts/10547/</id>
    <published>2021-04-07T03:47:55.000Z</published>
    <updated>2021-04-08T03:51:46.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>春雨随广，不润无根之草．<br>佛门随宽，不渡无缘之客.</p><p>线性结构的特点是什么？非线性结构的特点是什么?: </p><p>线性结构元素之间的关系是一对一的，在线性结构中只有一个开始结点和一个终端结点，其他的每一个结点有且仅有一个前驱和一个后继结点。而非线性结构则没有这个特点，元素之间的关系可以是一对多的或多对多的。</p><p>基本思想:<br>    1. 状态:<br>        1. 最优子结构<br>        2. 无后效性<br>    2. 转移方程:<br>        1. 分类讨论<br>        2. 细心枚举</p><h4 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h4><p>动态规划主要分为两个核心部分，一是确定DP状态，二是确定DP方程.</p><p>DP状态两大原则:<br>    1. 最优子结构<br>    2. 无后效性</p><h5 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h5><p>什么是最优子结构？<br>  将原有问题划分为一个个子问题，即为子结构。而对于每一个子问题，即为子结构。而对每一个子问题，其最优值均由【更小规模的子问题的最优值】推导而来，即为最优子结构.<br>  因此DP状态设置之前，需要将原有问题划分成一个个子问题，且需要确保子问题的最优值由【更小规模子问题的最优值】推出，此时子问题的最优值即为【DP状态】的定义.</p><h5 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h5><p>就是我们只关心子问题的最优值，不关心子问题的最优值是怎么得到的.<br>简明来说就是，就是我们不关心当前子问题是哪一个子问题得来的，（多做题慢慢体会就会发现，就是不用记录哪个问题得来的，能得出来就可.</p><p>最后概括一下:<br>    最优子结构就是DP状态最优值由更小规模的DP状态最优值推出，此处DP状态即为子问题，而无后效性就是无论DP状态是如何得到的，都不会影响后续DP状态的取值.</p><h4 id="线性DP概述"><a href="#线性DP概述" class="headerlink" title="线性DP概述"></a>线性DP概述</h4><p>DP总而言之将原问题划分成多个子问题，且大规模子问题的最优解只与小规模子问题的最优解有关，与小规模子问题最优解是如何得到的无关，最后我们发现，首先弄一个结构存储最优解，如何得到的是我们需要实现的使我们要思考的这个就是DP的精髓所在。（也就是问题变换的精髓）。</p><h4 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h4><h5 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h5><p>子序列:<br>    1. 可以不连续<br>    2. 相对位置不变</p><p>模型讲解:<br>    求一个无序数组的最长上升子序列，如果是第一次见到这样的问题，那肯定没有什么思路，这个时候采取惯用的思路—-减少长度(从局部到全部),从小规模的问题着手思考.</p><p>如果长度为１呢???? 答案显然为1.</p><p>如果长度为2呢???? 这时需要考虑第二个数是否比第一个数大，如果比第一个数大，则答案为2,否则为1.</p><p>如果长度为3呢????<br>那么我们需要枚举第三个数是否比第二个数或者第一个数大，如果比它大，则可以直接从第二个或第一个数的答案直接转移而来。因此我们可以如下订制【DP状态】,f{i}仅考虑前i个数，以第i个数为结尾的最长上升子序列的最大长度.</p><p>由此推导出转移方程: 如何得到的使我们需要考虑的，状态不要涉及.<br>    f｛i｝= max(1, f{j} + 1); a{j} ＜ a{i}, j ＜i.</p><p>模型分析:<br>    该模型【DP状态】的关键在于固定了最后一个数字，而这样做的原因在于对一个最长上升序列，我们只需要注意它最后一个数字，对于其前面的数字我们并不关心。<br>    该模型的时间复杂度为O(n^2), 其中n为数组的长度，另外该模型可用二分优化到O(nlogn).自行了解.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    int sz &#x3D; nums.size(), ans &#x3D; 0;</span><br><span class="line">    vector&lt;int&gt; f(sz, 0);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; sz; i++)&#123;</span><br><span class="line">        int temp &#x3D; 1;</span><br><span class="line">        for(int j &#x3D; i - 1; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[j])</span><br><span class="line">            temp &#x3D; max(temp, f[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] &#x3D; temp;</span><br><span class="line">        ans &#x3D; max(ans, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h5><p>给定两个字符串text1和text2,返回和两个字符串的最长公共子序列的长度。</p><p>一个字符串的【子序列】是指这样一个新的字符串:<br>    他是由原字符串在不改变字符的相对顺序的情况下删除某个字符串(也可以不删除任何字符)后组成的新字符串。</p><p>例如, ace是abcde的子序列, aec不是abcde的子序列。两个字符串的【公共子序列】是这两个字符串所共同拥有的子序列。　若这两个字符串没有公共子序列，则返回0;</p><p>与LIS模型不同的是，最长公共子序列涉及到了两个字符数组，不再是基于单数组的问题。</p><p>根据LIS模型【DP状态】设置的经验，以及【线性DP】的核心特点，即DP状态沿着各个维度线性增长，我们可以如下制定【DP状态】，f[i][j]表示第一个串的前i个字符与第二个字符的前j个字符的最长公共子序列的长度.</p><p>该状态的转移方程没有上一个模型那么直接，因此我们需要分类讨论.</p><ol><li><p>假如text[i] != text[j], 即text1[i]无法与text2[j]匹配，因此f[i][j] = max(f[i][j - 1], f[i - 1][j]);</p></li><li><p>text1[i] == text2[j], 则text1[i]可以和text2[j]完成匹配，因此我们可以增加一种转移方式，f[i][j] = d[i - 1][j - 1] + 1.</p></li></ol><p>时间复杂度O(nm),n m 分别是text1,text2串的长度.</p><pre><code>             1. f[i - 1][j]</code></pre><p>方程: f[i][j] =  2. f[i][j - 1]<br>                 3. d[i - 1][j - 1] + 1, text1[i] = text2[j];</p><p>代码实现:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int longestCommand(text1, text2)&#123;</span><br><span class="line">    int n &#x3D; text1.size(), m &#x3D; text2().size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;f(n + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; m; j++)&#123;</span><br><span class="line">            f[i][j] &#x3D; max(f[i - 1][j], f[i][j - 1]);</span><br><span class="line">            if(text1[i - 1] &#x3D;&#x3D; test2[j - 1])</span><br><span class="line">            f[i][j] &#x3D; f[i - 1][j - 1] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h5 id="最长公共上升子序列-LCIS"><a href="#最长公共上升子序列-LCIS" class="headerlink" title="最长公共上升子序列(LCIS)"></a>最长公共上升子序列(LCIS)</h5><h5 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h5><p>题目描述:<br>    给定一个三角形，找出自顶向下的最小路径和，每一步只能移动到下一行中相邻的结带点上。</p><pre><code>相邻的节点在这里指的是下标与上一层结点下标相同或者等于上层节点下标＋1的两个节点.(就是正上方节点，和正上方节点右边节点.比如５就是３和４。　   2 3   4</code></pre><p>   6   5   7<br>4    1    8   3</p><p>自顶向下的最小路径和为11即 2 + 3 + 5 + 1 = 11.</p><p>说明:<br>    如果只用O(n)的额外空间(n 为三角形的总行数)来解决这个问题，那么你的算法很加分.</p><p>模型详解:<br>    该模型即为【线性DP】基础模型之一: 数字三角形， 即最常见的二维坐标系【DP模型】。<br>    考虑到【线性DP】中DP状态沿着各个维度线性增长的这一特点，以及本题所求的从上到下的最小路径和，不难得出状态f[i][j]表示从顶点出发到达第i行第j列这个点时的最小路径和.</p><p>由于题目中限制(i, j)只能由(i - 1, j - 1)和(i - 1, j)两个点到达，因此我们可以得到如下【DP方程】:<br>    f[i][j] = triange[i][j] + min(f[i - 1][j - 1],f[i - 1][j]);</p><p>书写代码时需要注意边界的处理,如对于特定的(i, j)来说，数字三角形中不存在(i - 1, j - 1) 或 (i - 1, j).</p><p>这个模型我们可以得到:<br>    二维坐标系中也可以进行线性DP的，而且我们可以直接根据坐标点设置DP状态．</p><p>代码实现:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int minnum(vector&lt;vector&lt;int&gt;&gt;&amp; trangle)&#123;</span><br><span class="line">    int n &#x3D; trangle.size(), ans &#x3D; INT_MAX;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; trangle.size(); j++)&#123;</span><br><span class="line">            if(j &#x3D;&#x3D; trangle[i].size() - 1)&#123;</span><br><span class="line">                f[i + 1][j + 1] &#x3D; trangle[i][j] + f[i][j];</span><br><span class="line">            &#125;else if(j &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                f[i + 1][j + 1] &#x3D; trangle[i][j] + f[i][j + 1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                f[i + 1][j + 1] &#x3D; trangle[i][j] + min(f[i][j + 1], f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>滚动数组优化:</p><p>上述【DP转移方程】的时间复杂度为O(n^2)。空间复杂度也为O(n^2),但根据题目中的提示，本题是可以优化至O(n)空间复杂度.</p><p>这种优化方法称为【滚动数组优化】，在【DP问题】中非常常见，主要适用于f[i][j]仅由f[i - 1][k]转移而来的情况.</p><p>例如本题中，【DP转移方程】如下:<br>    f[i][j] = trangle[i][j] + min(f[i - 1][j - 1], f[i - 1][j]);</p><p>不难发现, f[i][j] 仅由f[i - 1][j - 1]和f[i - 1][j]所决定，因此对于一个固定的i,我们可以从n到1倒叙枚举j,由此可以优化至如下转移方程:<br>    f[j] = trangle[i][j] + min(f[i - 1], f[j])<br>因为顺序会把前边的数据覆盖掉，从后往前（因为从上到下取最优子结构）所以避免了覆盖，可以依然从上往下取最优子结构。</p><p>完整代码:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int minnum(vector&lt;vector&lt;int&gt;&gt;&amp; trangle)&#123;</span><br><span class="line">    int n &#x3D; trangle.size(), ans &#x3D; INT_MAX;</span><br><span class="line">    vector&lt;int&gt; f(n + 1, 0);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; trangle[i].size() - 1; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">            if(j &#x3D;&#x3D; trangle[i].size() - 1)&#123;</span><br><span class="line">                f[j + 1] &#x3D; trangle[i][j] + f[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(j &#x3D;&#x3D; 0)</span><br><span class="line">                f[j + 1] &#x3D; trangle[i][j] + f[j + 1];</span><br><span class="line">            else</span><br><span class="line">                f[j + 1] &#x3D; trangle[i][j] + min(f[j + 1], f[j]);</span><br><span class="line">            if(i &#x3D;&#x3D; n - 1)</span><br><span class="line">            ans &#x3D; min(ans, f[j + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>总结:<br>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p><ol><li>如何识别这是一道线性DP的问题????     (满足线性增长，部分线性增长)。</li><li>DP状态是如何设置?????                (状态的定义)</li><li>如何根据DP状态得到DP转移方程????     (动态转移方程书写)</li></ol><h5 id="DP思路在深入总结"><a href="#DP思路在深入总结" class="headerlink" title="DP思路在深入总结!!!!"></a>DP思路在深入总结!!!!</h5><ol><li><p>DP状态的确定有两个原则，一是最优子结构，二是无后效性，简要概括就是将原问题划分为多个子问题，且大规模问题最优值仅与小规模子问题最优值有关.</p></li><li><p>此处的大规模与小规模，就是DP问题的关键所在，也是DP问题分类的重要标准。 </p></li><li><p>确定完DP状态后，只需要分类讨论，细心枚举各种情况，即可得到DP转移方程。</p></li></ol><h5 id="线性DP特点回顾"><a href="#线性DP特点回顾" class="headerlink" title="线性DP特点回顾"></a>线性DP特点回顾</h5><p>线性划分DP规模的动态规划算法被统称为线性DP。在线性DP中，DP状态从小规模转移到大规模的同时，DP状态沿着各个维度线性增长。</p><h5 id="背包-第四种DP模型"><a href="#背包-第四种DP模型" class="headerlink" title="背包(第四种DP模型)"></a>背包(第四种DP模型)</h5><h6 id="01背包-滚动数组"><a href="#01背包-滚动数组" class="headerlink" title="01背包(滚动数组)"></a>01背包(滚动数组)</h6><p>01背包的基本模型如下:<br>一共有N个物品，其中第i个物品的体积为Vi, 价值为Wi。现要求选择一些物品放入一个容积为M的背包中，使得物品总体积不超过M的前提下,物品总价值最大。</p><p>现在我们来思考下如何根据线性DP的知识来解决这个问题?</p><p>线性DP的特点是DP状态沿着各个维度线性增长。而本问题中只有三个参数，分别是物品编号，物品体积以及物品价值。由于我们要求的是物品价值最大，因此不难想到DP状态为f[i][j],表示仅考虑前i个物品，所选物品总体积为j时的最大物品总价值。</p><p>确定DP状态后，我们来考虑DP转移方程是什么???</p><p>对于第i个物品来说，它只有两种状态，即要么取，要么不取。如果不取第i个物品，则f[i][j] = f[i - 1][j]; 如果取第i个物品，则f[i][j] = f[i - 1][j - vi] + wi,因此我们能得到如下DP转移方程:<br>    f[i][j] = max(f[i - 1][j], f[i - 1][j - vi] + wi);<br>其中初值f[0][0] = 0, f[0][i] 为负无穷，其中i 属于[1, M], 最终答案为max{f[N][j]},j属于[0, M],代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[0][i] &#x3D; INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0][0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt;&#x3D; M; j++)&#123;</span><br><span class="line">            if(j &gt;&#x3D; v[i])</span><br><span class="line">               f[i][j] &#x3D; max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);</span><br><span class="line">            else </span><br><span class="line">               f[i][j] &#x3D; f[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; M; i++)</span><br><span class="line">    ans &#x3D; max(ans, f[N][i]);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察上述代码不难发现,f[i][j]仅由f[i - 1][j]和法f[i - 1][j - v[i]]决定，这就给了我们一个思考角度，能否将二维数组f的第一维去掉????</p><p>答案显然是可以的，我们可以倒序枚举j，使得更新f[j]时f[j - v[i]]还未被更新，即f[j - v[i]]代表的实际是f[i - 1][j - v[i]]的值,看一下优化后的代码:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;</span><br><span class="line">        f[j] &#x3D; INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; M; j &gt;&#x3D; v[i]; j--)&#123;</span><br><span class="line">            f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>根据这段代码不难发现，第i轮，更新到f[j]时，f[j]与f[j - v[i]]代表的是i - 1轮的值，即f[i - 1][j] 与 f[i - 1][j - v[i]].而我们更新完f[j]后，f[j]的值即变为f[i][j]的值，由此我们大大降低了该算法的空间开销，这种优化方法叫做滚动数组.</p><h6 id="完全背包-二进制拆分"><a href="#完全背包-二进制拆分" class="headerlink" title="完全背包(二进制拆分)"></a>完全背包(二进制拆分)</h6><p>了解完01背包模型后，我们继续介绍完全背包模型，其基本问题如下:<br>    一共有N类物品，其中第i类物品的体积为vi,价值为Wi,且每类物品可以选无数个，现要求选择一些物品放入一个容积为M的背包中，使得物品的总体积不超过M的前提下，物品总价值最大.</p><pre><code>不难发现,完全背包和01背包最大的差别就在于每一类物品可以选多少个,其中完全背包每一类物品可以选无数个,而01背包中每一类物品只能选一个.了解完模型之后我们继续思考如何解决该问题.与01背包模型比较类似,本问题也只有三个参数,分别是物品编号,物品体积以及物品价值.因此我们按照01背包的DP状态,即f[i][j]表示仅考虑前i类物品,所选物品总体积为j时的最大物品总价值.由于每一类物品可以选无数次,因此对于f[i][j]来说,如果不可取     f[i][j] = f[i - 1][j],如果取一个则   f[i][j] = f[i - 1][j - v[i]] + w[i],如果取两个则   f[i][j] = f[i - 1][j - 2 * v[i]] + 2*w[i],如果是x个则    f[i][j] = f[i - 1][j - x * v[i]] + x * w[i].因此可以得到  f[i][j] = max(f[i - 1][j], f[i - 1][j - x * v[i]] + x * w[i]), x &gt;= 0;但这样我们需要不断的遍历x导致时间复杂度过高,我们还需继续优化.(这里的x只是一个参数)f[i][j] = max(f[i - 1][j], f[i - 1][(j - v[i]) - x * v[i]] + w[i] + x * w[i]) ,x &gt;= 0;又因为f[i][j - v[i]] = max(f[i - 1][(j - v[i]) - x * v[i] + x * w[i]]), x &gt;= 0.因此只需正序遍历j,即保证求取f[i][j]时,f[i][j - v[i]]已经得到,DP转移方程就可以优化为:f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);对于01背包中f[i][j] = f[i - 1][j - v[i]] + w[i],完全背包中每个物品可以取多次,因此转移方程变为f[i][j] = f[i][j - v[i]] + w[i];</code></pre><p>代码如下:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[0][j] &#x3D; IN_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0][0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt;&#x3D; M; j++)&#123;</span><br><span class="line">            if(j &gt;&#x3D; v[i])</span><br><span class="line">                f[i][j] &#x3D; max(f[i - 1][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">            else </span><br><span class="line">                f[i][j] &#x3D; f[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int  i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[N][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    滚动数组优化:<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[0][j] &#x3D; IN_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0][0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; v[i]; j &lt;&#x3D; M; j++)&#123;</span><br><span class="line">                f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int  i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[N][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h6 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h6><p>多重背包模型,基本问题如下所示:<br>    一共有N类物品,其中第i类物品的体积为V[i],价值为W{i},且每类物品只有C[i]个(c[i] &gt;= 0),现要求选择一些物品放入一个容积为M的背包中,使得物品的总体积不超过M的前提下,物品总价值最大.</p><pre><code>将该问题与01背包模型进行对比,可以发现唯一差别在于01背包中每一类物品的c[i] = 1, 因此我们可以将多重背包换成01背包进行求解.首先比较容易想到的是,我们可以进行暴力拆分,即将一类物品拆分为c[i]个,总物品数量从N变为(求和符号)(1- N) c[i]()就是把每个物品变成一个新的物品来计算,,因此我们可以直接用01背包模型来进行求解.具体代码如下:     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[i] &#x3D; INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int k &#x3D; 1; k &lt;&#x3D; c[i]; k++)&#123;</span><br><span class="line">            for(int j &#x3D; M; j  &gt;&#x3D; v[i]; j--)&#123;</span><br><span class="line">                f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>    直接暴力拆分使问题变得简单,但是时间复杂度却显著提高为 O(M *c[i](i = 1 ~n 求累加和))．我们还需继续优化!!!!!    直接暴力拆分使得该问题变得简单，但是时间复杂度却显著增加，为 图片。于是我们需要思考有没有什么方法可以对该问题进行优化？</code></pre><p>考虑二进制的思想，我们考虑把第  种物品换成若干件物品，使得原问题中第  种物品可取的每种策略——取  件——均能等价于取若干件代换以后的物品。另外，取超过  件的策略必不能出现。方法是：将第  种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为  ，且  是满足  的最大整数。例如，如果  为 13，就将这种物品分成系数分别为 1, 2, 4, 6 的 4 件物品。分成的这几件物品的系数和为  ，表明不可能取多于  件的第  种物品。另外这种方法也能保证对于  间的每一个整数，均可以用若干个系数的和表示，这个证明可以分  和  两段来分别讨论得出，并不难，希望题主自己思考尝试一下。这样就将第  种物品分成了  种物品，将原问题转化为了复杂度为  的 01 背包问题，是很大的改进。</p><p>二进制优化：</p><p>二进制优化的思想还是很巧妙的，根据c【i】得到一组这样的数 2^0,2^1,2^2,2^3…..2^(k-1) , c-2^k+1  其中k是满足2^k小于c的最大值，就像c=7=111，2^k=100=4  ;</p><p> c=9=1001, 2^k=1000=8  ;  c=8=1000  2^k=0100=4   </p><p>得到这组数的目的是什么呢，</p><p>1到c之间的所有数都可以由这组数组合得到（选取相加），而从这组数里任意选任意个（每个数最多只能选一次）加在一起得到的数也必定是1~c这个闭区间内的</p><p>例如14=1110   他对应的这组数为：1，2，4，7  可以试一试，通过前三个组合可以得到1<del>7之间的所有数，而加上7就可以得到8</del>14之间的所有数，因此可以得到1~14之间的任何数，所以我们可以只对这组数逐一进行01背包，而不用从1到c都要01背包一次，算是把O（c）的部分优化成了O（logc）</p><p> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void erjinzhi()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,k,m;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(k&#x3D;1;(k&lt;&lt;1)&lt;&#x3D;c[i];k&lt;&lt;&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">for(j&#x3D;V;j&gt;&#x3D;k*v[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]&#x3D;max(dp[j],dp[j-k*v[i]]+k*w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m&#x3D;c[i]-k+1;</span><br><span class="line">for(j&#x3D;V;j&gt;&#x3D;m*v[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]&#x3D;max(dp[j],dp[j-m*v[i]]+m*w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单调队列优化</p><p> </p><p>参考了这篇博客的思想 <a href="http://blog.csdn.net/flyinghearts/article/details/5898183">http://blog.csdn.net/flyinghearts/article/details/5898183</a>  以及k爷的代码<a href="http://blog.csdn.net/lxy767087094/article/details/54730613%EF%BC%8C%E5%8A%A0%E4%B8%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3">http://blog.csdn.net/lxy767087094/article/details/54730613，加上自己的理解</a></p><p>那篇博客大体思想讲的很好，实现过程是用了两个队列，一个辅佐队列，不易理解</p><p> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int num,value;</span><br><span class="line">&#125;que[100000];</span><br><span class="line">int tail,head;</span><br><span class="line">void push(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">while(tail&gt;head&amp;&amp;que[tail-1].value&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">que[tail].num&#x3D;x;</span><br><span class="line">que[tail++].value&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">void singlequeue()</span><br><span class="line">&#123;</span><br><span class="line">int i,d,j;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]&#x3D;min(c[i],V&#x2F;v[i]);</span><br><span class="line">for(d&#x3D;0;d&lt;v[i];d++)</span><br><span class="line">&#123;</span><br><span class="line">head&#x3D;tail&#x3D;0;</span><br><span class="line">for(j&#x3D;0;j&lt;&#x3D;(V-d)&#x2F;v[i];j++)</span><br><span class="line">&#123;</span><br><span class="line">push(j,dp[j*v[i]+d]-j*w[i]);</span><br><span class="line">while(que[head].num&lt;j-c[i]&amp;&amp;tail&gt;head)</span><br><span class="line">head++;</span><br><span class="line">dp[j*v[i]+d]&#x3D;que[head].value+j*w[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结!!!!!!:<br>    背包问题特点</p><p>至此我们介绍完了三大常见的背包模型，分别是「0/1 背包」、「完全背包」、「多重背包」，其区别仅仅在于每一类物品可以选多少个。其中「0/1 背包」是每一类物品只能选一个，「完全背包」则是每一类物品可以选无数个，而「多重背包」则是第 i 类物品最多可以选 图片个。<br>因此我们可以归纳「背包问题」的特点：有 N 类物品，每类物品可以选 1 个、无数个或 图片个，问是否存在一种选取方案，使其满足某种条件。或者是否存在一种选取方案，使其满足某种条件的同时，得到某种参数的最值。<br>这样归纳可能还是过于抽象，因此我们将在下文「习题练习」中讲解一些具体的题型来帮助大家理解。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="动态规划" scheme="http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>链表和树</title>
    <link href="http://example.com/posts/8091/"/>
    <id>http://example.com/posts/8091/</id>
    <published>2021-04-01T11:36:29.000Z</published>
    <updated>2021-04-08T03:23:11.349Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>结构定义:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>海量数据和bit_map</title>
    <link href="http://example.com/posts/56260/"/>
    <id>http://example.com/posts/56260/</id>
    <published>2021-03-26T07:35:50.000Z</published>
    <updated>2021-03-26T09:16:10.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="道海量数据处理"><a href="#道海量数据处理" class="headerlink" title="道海量数据处理"></a>道海量数据处理</h3><h4 id="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"><a href="#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？" class="headerlink" title="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h4><p>方案1; 可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p><ol><li>历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为,这里漏写个了a1）中。这样每个小文件的大约为300M。</li><li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li><li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li></ol><p>方案2:<br>    如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><p>    读者反馈@crowgns：</p><p>hash后要判断每个文件大小，如果hash分的不均衡有文件较大，还应继续hash分文件，换个hash算法第二次再分较大的文件，一直分到没有较大的文件为止。这样文件标号可以用A1-2表示（第一次hash编号为1，文件较大所以参加第二次hash，编号为2）<br>由于1存在，第一次hash如果有大文件，不能用直接set的方法。建议对每个文件都先用字符串自然顺序排序，然后具有相同hash编号的（如都是1-3，而不能a编号是1，b编号是1-1和1-2），可以直接从头到尾比较一遍。对于层级不一致的，如a1，b有1-1，1-2-1，1-2-2，层级浅的要和层级深的每个文件都比较一次，才能确认每个相同的uri。</p><h4 id="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h4><p>方案1:<br>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（,此处有误，更正为b0,b1,b2,b9）。<br>对这10个文件进行归并排序（内排序与外排序相结合）。</p><p>方案2: 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了</p><p>    （读者反馈@店小二：原文第二个例子中：“找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。”由于query会重复，作为key的话，应该使用hash_multimap 。hash_map 不允许key重复。@hywangw:店小二所述的肯定是错的，hash_map(query,query_count)是用来统计每个query的出现次数 又不是存储他们的值 出现一次 把count+1 就行了 用multimap干什么？多谢hywangw）。</p><p>方案3:<br>    与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p><h4 id="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h4><p>方案1:<br>顺序读文件中，对于每个词x，取，然后按照该值存到5000个小文件（记为）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p><h4 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h4><p>方案1: 首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><h4 id="在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。"><a href="#在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。" class="headerlink" title="在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。"></a>在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。</h4><p>方案1: 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32*2bit=1GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p><p>方案2: 也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h4 id="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h4><p>方案1:<br>在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大。<br>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。<br>（更多可以参考：第三章、寻找最小的k个数，以及第三章续、Top K算法问题的实现）</p><p>    读者反馈@QinLeopard：</p><p>第6题的方法中，是不是不能保证每个电脑上的前十条，肯定包含最后频率最高的前十条呢？<br>比如说第一个文件中：A(4), B(5), C(6), D(3)<br>第二个文件中：A(4),B(5),C(3),D(6)<br>第三个文件中: A(6), B(5), C(4), D(3)<br>如果要选Top(1), 选出来的结果是A，但结果应该是B。</p><p>    @July：我想，这位读者可能没有明确提议。本题目中的TOP10是指最大的10个数，而不是指出现频率最多的10个数。但如果说，现在有另外一提，要你求频率最多的 10个，相当于求访问次数最多的10个IP地址那道题，即是本文中上面的第4题。特此说明。</p><h4 id="7-怎么在海量数据中找出重复次数最多的一个？"><a href="#7-怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="7. 怎么在海量数据中找出重复次数最多的一个？"></a>7. 怎么在海量数据中找出重复次数最多的一个？</h4><p>方案1: 先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h4 id="8-上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"><a href="#8-上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。" class="headerlink" title="8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"></a>8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</h4><p>方案1<br>上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成。</p><h4 id="9-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"><a href="#9-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？" class="headerlink" title="9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"></a>9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</h4><p>方案1:<br>这题用trie树比较合适，hash_map也应该能行。</p><h4 id="10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"><a href="#10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。" class="headerlink" title="10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"></a>10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</h4><p>方案1:<br>    这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p><h4 id="11-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"><a href="#11-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。" class="headerlink" title="11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"></a>11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。</h4><p>方案1: 首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。</p><h4 id="12-100w个数中找出最大的100个数。"><a href="#12-100w个数中找出最大的100个数。" class="headerlink" title="12. 100w个数中找出最大的100个数。"></a>12. 100w个数中找出最大的100个数。</h4><p>方案1: 采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w<em>100)。<br>方案2:采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w</em>100)。<br>方案3: 在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p><h4 id="13-寻找热门查询："><a href="#13-寻找热门查询：" class="headerlink" title="13. 寻找热门查询："></a>13. 寻找热门查询：</h4><p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><ol><li><p>请描述你解决这个问题的思路；</p></li><li><p>请给出主要的处理流程，算法，以及算法的复杂度。</p></li></ol><p>方案1: 采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><p>    关于此问题的详细解答，请参考此文的第3.1节：第三章续、Top K算法问题的实现。</p><h4 id="14-一共有N个机器，每个机器上有N个数。每个机器最多存O-N-个数并对它们操作。如何找到N-2个数中的中数？"><a href="#14-一共有N个机器，每个机器上有N个数。每个机器最多存O-N-个数并对它们操作。如何找到N-2个数中的中数？" class="headerlink" title="14. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数中的中数？"></a>14. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数中的中数？</h4><p>方案1: 先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有2^32个）。我们把0到2^32-1的整数划分为N个范围段，每个段包含（2^32）/N个整数。比如，第一个段位0到2^32/N-1，第二段为（2^32）/N到（2^32）/N-1，…，第N个段为（2^32）（N-1）/N到2^32-1。然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于（N^2）/2，而在第k-1个机器上的累加数小于（N^2）/2，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第（N^2）/2-x位。然后我们对第k个机器的数排序，并找出第（N^2）/2-x个数，即为所求的中位数的复杂度是O（N^2）的。</p><p>方案2: 先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第（N^2）/2个便是所求。复杂度是O（N^2*lgN^2）的。</p><h4 id="15-最大间隙问题"><a href="#15-最大间隙问题" class="headerlink" title="15. 最大间隙问题"></a>15. 最大间隙问题</h4><p>给定n个实数，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。</p><p>方案1:<br>最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：</p><p>找到n个数据中最大和最小数据max和min。<br>用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为，且桶i 的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为：。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为），且认为将min放入第一个桶，将max放入第n-1个桶。<br>将n个数放入n-1个桶中：将每个元素x[i] 分配到某个桶（编号为index），其中（这括号里多了个“+”），并求出分到每个桶的最大最小数据。<br>最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶i的上界和桶j的下界之间产生j&gt;=i+1。一遍扫描即可完成。</p><h4 id="16-将多个集合合并成没有交集的集合"><a href="#16-将多个集合合并成没有交集的集合" class="headerlink" title="16. 将多个集合合并成没有交集的集合"></a>16. 将多个集合合并成没有交集的集合</h4><p>    给定一个字符串的集合，格式如：。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出。</p><p>(1) 请描述你解决这个问题的思路；</p><p>(2) 给出主要的处理流程，算法，以及算法的复杂度；</p><p>(3) 请描述可能的改进。</p><p>方案17:<br>采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于，首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。</p><h4 id="17-最大子序列与最大子矩阵问题"><a href="#17-最大子序列与最大子矩阵问题" class="headerlink" title="17. 最大子序列与最大子矩阵问题"></a>17. 最大子序列与最大子矩阵问题</h4><p>数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。</p><p>方案1:<br>    这个问题可以动态规划的思想解决。设b[i]表示以第i个元素a[i]结尾的最大子序列，那么显然。基于这一点可以很快用代码实现。</p><p>最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。</p><p>方案2: 可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。</p><p> </p><h3 id="第二部分、海量数据处理之Bti-map详解"><a href="#第二部分、海量数据处理之Bti-map详解" class="headerlink" title="第二部分、海量数据处理之Bti-map详解"></a>第二部分、海量数据处理之Bti-map详解</h3><p>    Bloom Filter已在上一篇文章海量数据处理之Bloom Filter详解中予以详细阐述，本文接下来着重阐述Bit-map。有任何问题，欢迎不吝指正。</p><p>什么是Bit-map<br>    所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>    如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：)</p><p>    然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0×01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一（如下图）：</p><p>      </p><p>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：</p><p>然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。下面的代码给出了一个BitMap的用法：排序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义每个Byte中有8个Bit位</span><br><span class="line">#include ＜memory.h＞</span><br><span class="line">#define BYTESIZE 8</span><br><span class="line">void SetBit(char *p, int posi)</span><br><span class="line">&#123;</span><br><span class="line">for(int i&#x3D;0; i ＜ (posi&#x2F;BYTESIZE); i++)</span><br><span class="line">&#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">*p &#x3D; *p|(0x01＜＜(posi%BYTESIZE));&#x2F;&#x2F;将该Bit位赋值1</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void BitMapSortDemo()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;为了简单起见，我们不考虑负数</span><br><span class="line">int num[] &#x3D; &#123;3,5,2,10,6,12,8,14,9&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;BufferLen这个值是根据待排序的数据中最大值确定的</span><br><span class="line">&#x2F;&#x2F;待排序中的最大值是14，因此只需要2个Bytes(16个Bit)</span><br><span class="line">&#x2F;&#x2F;就可以了。</span><br><span class="line">const int BufferLen &#x3D; 2;</span><br><span class="line">char *pBuffer &#x3D; new char[BufferLen];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;要将所有的Bit位置为0，否则结果不可预知。</span><br><span class="line">memset(pBuffer,0,BufferLen);</span><br><span class="line">for(int i&#x3D;0;i＜9;i++)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;首先将相应Bit位上置为1</span><br><span class="line">SetBit(pBuffer,num[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;输出排序结果</span><br><span class="line">for(int i&#x3D;0;i＜BufferLen;i++)&#x2F;&#x2F;每次处理一个字节(Byte)</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;0;j＜BYTESIZE;j++)&#x2F;&#x2F;处理该字节中的每个Bit位</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;判断该位上是否是1，进行输出，这里的判断比较笨。</span><br><span class="line">&#x2F;&#x2F;首先得到该第j位的掩码（0x01＜＜j），将内存区中的</span><br><span class="line">&#x2F;&#x2F;位和此掩码作与操作。最后判断掩码是否和处理后的</span><br><span class="line">&#x2F;&#x2F;结果相同</span><br><span class="line">if((*pBuffer&amp;(0x01＜＜j)) &#x3D;&#x3D; (0x01＜＜j))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,i*BYTESIZE + j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pBuffer++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">BitMapSortDemo();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p><p>基本原理及要点<br>使用bit数组来表示某些元素是否存在，比如8位电话号码</p><p>扩展<br>Bloom filter可以看做是对bit-map的扩展（关于Bloom filter，请参见：海量数据处理之Bloom filter详解）。</p><p>问题实例<br>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</p><p>    8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）</p><p>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p><p>    将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p><p>参考：</p><p><a href="http://www.cnblogs.com/youwang/archive/2010/07/20/1781431.html%E3%80%82">http://www.cnblogs.com/youwang/archive/2010/07/20/1781431.html。</a><br><a href="http://blog.redfox66.com/post/2010/09/26/mass-data-4-bitmap.aspx%E3%80%82">http://blog.redfox66.com/post/2010/09/26/mass-data-4-bitmap.aspx。</a><br>完。</p><p>版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明.<br>原文链接：<a href="https://blog.csdn.net/v_july_v/article/details/6685962">https://blog.csdn.net/v_july_v/article/details/6685962</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>支持亿级io底层基石epoll实战揭秘</title>
    <link href="http://example.com/posts/36817/"/>
    <id>http://example.com/posts/36817/</id>
    <published>2021-03-24T06:19:34.000Z</published>
    <updated>2021-03-24T11:18:47.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>绝大部分linux服务器，基本上会用到epoll.</p><h3 id="epoll是什么"><a href="#epoll是什么" class="headerlink" title="epoll是什么?"></a>epoll是什么?</h3><ol><li>io管理组件.</li><li>高性能.是select/poll的升级版本.</li><li>epoll用在什么地方?</li><li>和ntyco协程框架有什么关联?<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4>只要客户端对服务器进行一次tcp连接，就会产生一次io,如果十万个客户端同时对服务端建立连接，服务端就会产生十万socket，没连接一次就会产生一个io,就会产生十万个io,这时候就需要有个东西来管理它(十万个io)，(比如我怎么知道他来了数据呢?)<br>例子: 比如收快递用的蜂巢，当小哥把快递放到蜂巢，蜂巢就是统一管理快递的组件，所以说每个快递就好比一个io,蜂巢对应的就是管理io的组件,当蜂巢收到一个快递的时候，蜂巢就会通知用户来取这个快递，io的管理跟这个功能相似（io管理用来存fd的）.io多路复用，说明不只是你一个io，而是管理多个io.</li></ol><h4 id="epoll的产生-解决什么问题"><a href="#epoll的产生-解决什么问题" class="headerlink" title="epoll的产生(解决什么问题)"></a>epoll的产生(解决什么问题)</h4><p>如果没有多线程没有io管理，我们如何做一个服务器????</p><p>最初采用信号: 数据到达通过发送一个信号通知我们(这个信号-＞sigio现在还在沿用).性能极低，一两个客户端是没有问题的，一般用udp(因为udp以一个服务器为主)。</p><p>后来产生了线程:(几百个几千个服务端也是可用的，写代码非常简单)<br>    如果有线程没有io管理的情况该怎么做????<br>    一请求一线程: 当每一个accept来的时候(accept出现返回值的时候)就创建一个线程.当客户端退出的时候，这个线程也随之关闭，非常简单。每个线程读一个(是同步的).</p><p>有没有一些web服务器在用呢??<br>Apache服务器在用一请求一线程这种方式.</p><p>这种方式的弊端在哪里???<br>注定做不了很大的用户量，一个线程占用8MB的内存。吃内存.所以是不行的.</p><p>还有一种方式类似，是一请求一进程的方式:(叫做CGI)随着用户量多起来，并不好管理.</p><p>后续出现了select(io统一的管理)<br>select(maxfd. rset, wset, eset, timeout);</p><ol><li>maxfd表示最大的fd比如1,2,3,4,5 表示5, 比如2, 3, 4, 5, 6表示6.</li><li>rset是否可读</li><li>wset是否可写</li><li>eset是否有错误</li><li>timeout多长时间轮循一次.(多长时间检查一次)</li></ol><p>poll跟select类似。</p><p>现在来到了epoll跟蜂巢的概念一模一样的，</p><p>epoll真的能支持亿级并发吗?<br>epoll_creat(EPOLL_SIZE); EPOLL_SIZE只有零和一的区别，写10000也是和一同样的功能.<br>为零，表示什么用都没，不为零就能正常创建epoll.</p><p>epoll_wait(epoll_fd, events, EPOLL_SIZE, -1);<br>相当于蜂巢工作人员收快递，events相当于那个袋子,多长时间去一次，-1不是毫秒也不是啥，就不是一个准确的时间，表示有io才去取，没有io就一直阻塞.等于零表示一直没有，没有就直接过，如果大于零，随便一个数表示等待send.</p><p>水平触发和边沿触发问题????谁在什么时候触发????</p><p>触发: 是由tcp协议栈触发的,</p><ol><li>一次性触发。</li><li>一个事件没处理完一直触发.</li><li>对应的是水平触发: </li><li>对应的是边沿触发:<br>这里和长连接和短连接没有什么关系.</li></ol><p>问题: accept发生在epoll_wait之后吗?</p><p>当epoll_wait阻塞在一个地方的时候，如何解除阻塞的呢?<br>通过回调函数，协议栈通过epoll这个模块，通过调用回调函数来解除epoll_wait,这里tcp通过回调，这个回调叫做colback，回调到哪里呢?回调到epoll里边，来解除epoll_wait的阻塞状态.<br>所以上边的问题，是对的，只有epoll_wait被触发之后，才能进行数据的收取.这样才能判断fd是listen的还是我们程序本身的.</p><p>以下四种对epoll的做法都是不一样的，所以对应的方式也是不一样的.</p><ol><li>单线程可不可以做epoll? -&gt; redis.</li><li>多线程可不可以做epoll? -&gt; nattyserver(服务器的框架).</li><li>多核做epoll? -&gt; ntyco</li><li>多进程做epoll? -&gt; nginx</li></ol><p>redis单线程为何这么快?<br>redis:<br>    1. 纯内存的操作.(没有那些io,本身就很快).<F5><br>    2. 单线程是说的一个线程里边才有epoll,别的线程没有，也就是说没有线程之间的切换，加锁等操作.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++函数对象-sort排序规则</title>
    <link href="http://example.com/posts/53699/"/>
    <id>http://example.com/posts/53699/</id>
    <published>2021-03-23T03:21:48.000Z</published>
    <updated>2021-03-23T12:53:04.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="函数对象类由来"><a href="#函数对象类由来" class="headerlink" title="函数对象类由来"></a>函数对象类由来</h3><p>如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名.</p><p>函数对象的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CAverage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    double operator()(int a1, int a2, int a3)</span><br><span class="line">    &#123;  &#x2F;&#x2F;重载()运算符</span><br><span class="line">        return (double)(a1 + a2 + a3) &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CAverage average;  &#x2F;&#x2F;能够求三个整数平均数的函数对象</span><br><span class="line">    cout &lt;&lt; average(3, 2, 3);  &#x2F;&#x2F;等价于 cout &lt;&lt; average.operator(3, 2, 3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">程序的输出结果是：</span><br><span class="line">2. 66667</span><br><span class="line"></span><br><span class="line">()是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</span><br><span class="line"></span><br><span class="line">average 是一个对象，average(3, 2, 3) 实际上就是 average.operator(3, 2, 3)，这使得 average 看上去像函数的名字，故称其为函数对象。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="函数对象应用实例1-在-accumulate-算法中的应用"><a href="#函数对象应用实例1-在-accumulate-算法中的应用" class="headerlink" title="函数对象应用实例1:在 accumulate 算法中的应用"></a>函数对象应用实例1:在 accumulate 算法中的应用</h3><p>STL 中有以下实现“累加”功能的算法(函数模板):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template &lt;class InIt, class T, class Pred&gt;</span><br><span class="line">T accumulate(InIt first, InIt last, T val, Pred op);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下：该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下:                                                                                                             </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class InIt, class T, class Pred&gt;</span><br><span class="line">T accumulate(InIt first, Init last, T init, Pred op)</span><br><span class="line">&#123;</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此模板被实例化后，op(init, *first)必须要有定义，则 op 只能是函数指针或者函数对象。因此调用该 accmulate 模板时，形参 op 对应的实参只能是函数名、函数指针或者函数对象。</p><p>下面的程序通过 accumulate 模板求一个 vector 中元素的平方和，其中用到了函数对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt; &#x2F;&#x2F;accumulate 在此头文件定义</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintInterval(T first, T last)</span><br><span class="line">&#123; &#x2F;&#x2F;输出区间[first,last)中的元素</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int SumSquares(int total, int value)</span><br><span class="line">&#123;</span><br><span class="line">    return total + value * value;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class SumPowers</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int power;</span><br><span class="line">public:</span><br><span class="line">    SumPowers(int p) :power(p) &#123; &#125;</span><br><span class="line">    const T operator() (const T &amp; total, const T &amp; value)</span><br><span class="line">    &#123; &#x2F;&#x2F;计算 value的power次方，加到total上</span><br><span class="line">        T v &#x3D; value;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; power - 1; ++i)</span><br><span class="line">            v &#x3D; v * value;</span><br><span class="line">        return total + v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int SIZE &#x3D; 10;</span><br><span class="line">    int a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;</span><br><span class="line">    vector&lt;int&gt; v(a1, a1 + SIZE);</span><br><span class="line">    cout &lt;&lt; &quot;1) &quot;; PrintInterval(v.begin(), v.end());</span><br><span class="line">    int result &#x3D; accumulate(v.begin(), v.end(), 0, SumSquares);</span><br><span class="line">    cout &lt;&lt; &quot;2) 平方和：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    result &#x3D; accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(3));</span><br><span class="line">    cout &lt;&lt; &quot;3) 立方和：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    result &#x3D; accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(4));</span><br><span class="line">    cout &lt;&lt; &quot;4) 4次方和：&quot; &lt;&lt; result;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">1)1 2 3 4 5 6 7 8 9 10</span><br><span class="line">2)平方和:385</span><br><span class="line">3)立方和3025</span><br><span class="line">4)4次方和:25333</span><br></pre></td></tr></table></figure><p>上述函数的倒数第八行，第四个参数是 SumSquares 函数的名字。函数名字的类型是函数指针，因此本行将 accumulate 模板实例化后得到的模板函数定义如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int accumulate(vector &lt;int&gt;::iterator first, vector &lt;int&gt;::iterator last, int init, int(*op)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">for (; first !&#x3D; last; ++first)</span><br><span class="line">    init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure><p>形参 op 是一个函数指针，而op(init, *first)就调用了指针 op 指向的函数，在第 37 行的情况下就是函数 SumSquares。</p><p>第 39 行，第四个参数是 SumPowers<int>(3)。SumPowers 是类模板的名字，SumPowers<int> 就是类的名字。类的名字后面跟着构造函数的参数列表，就代表一个临时对象。因此 SumPowers<int>(3) 就是一个 SumPowers<int> 类的临时对象。</p><p>编译器在编译此行时，会将 accumulate 模板实例化成以下函数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int accumulate(vector&lt;int&gt;::iterator first, vector&lt;int&gt;::iterator last, int init, SumPowers&lt;int&gt; op)</span><br><span class="line">&#123;</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参 op 是一个函数对象，而op(init, *first)等价于：<br>op.operator()(init, *first);</p><p>即调用了 SumPowers<int> 类的 operator() 成员函数。</p><p>对比 SumPowers 和 SumSquares 可以发现，函数对象的 operator() 成员函数可以根据对象内部的不同状态执行不同操作，而普通函数就无法做到这一点。因此函数对象的功能比普通函数更强大。</p><h3 id="函数对象应用实例2：在sort算法中的应用"><a href="#函数对象应用实例2：在sort算法中的应用" class="headerlink" title="函数对象应用实例2：在sort算法中的应用"></a>函数对象应用实例2：在sort算法中的应用</h3><p>STL 中的排序模板 sort 能将区间从小到大排序。sort 算法有两个版本。第一个版本的原型如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class_Randlt&gt;</span><br><span class="line">void sort(_Randlt first, _RandIt last);</span><br></pre></td></tr></table></figure><p>该模板可以用来将区间 [first, last) 中的元素从小到大排序，要求 first、last 是随机访问迭代器。元素比较大小是用&lt;进行的。如果表达式a&lt;b的值为 true，则 a 排在 b 前面；如果a&lt;b的值为 false，则 b 未必排在 a 前面，还要看b&lt;a是否成立，成立的话 b 才排在 a 前面。要使用这个版本的 sort 算法，待排序的对象必须能用&lt;运算符进行比较。</p><p>sort 算法第二个版本的原型如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class_Randlt, class Pred&gt;</span><br><span class="line">void sort(_Randlt first, _RandIt last, Pred op);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个版本和第一个版本的差别在于，元素 a、b 比较大小是通过表达式op(a, b)进行的。如果该表达式的值为 true，则 a 比 b 小；如果该表达式的值为 false，也不能认为 b 比 a 小，还要看op(b, a)的值。总之，op 定义了元素比较大小的规则。下面是一个使用 sort 算法的例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;  &#x2F;&#x2F;sort算法在此头文件中定义</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Printlnterva1(T first, T last)</span><br><span class="line">&#123;  &#x2F;&#x2F;用以输出 [first, last) 区间中的元素</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) : v(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool operator &lt; (const A &amp; a1, const A &amp; a2)</span><br><span class="line">&#123;  &#x2F;&#x2F;重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错</span><br><span class="line">    return a1.v &lt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line">bool GreaterA(const A &amp; a1, const A &amp; a2)</span><br><span class="line">&#123;  &#x2F;&#x2F;v值大的元素作为较小的数</span><br><span class="line">    return a1.v &gt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line">struct LessA</span><br><span class="line">&#123;</span><br><span class="line">    bool operator() (const A &amp; a1, const A &amp; a2)</span><br><span class="line">    &#123;  &#x2F;&#x2F;v的个位数小的元素就作为较小的数</span><br><span class="line">        return (a1.v % 10) &lt; (a2.v % 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; operator &lt;&lt; (ostream &amp; o, const A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    o &lt;&lt; a.v;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a1[4] &#x3D; &#123; 5, 2, 4, 1 &#125;;</span><br><span class="line">    A a2[5] &#x3D; &#123; 13, 12, 9, 8, 16 &#125;;</span><br><span class="line">    sort(a1, a1 + 4);</span><br><span class="line">    cout &lt;&lt; &quot;1)&quot;; Printlnterva1(a1, a1 + 4);  &#x2F;&#x2F;输出 1)1 2 4 5</span><br><span class="line">    sort(a2, a2 + 5);  &#x2F;&#x2F;按v的值从小到大排序</span><br><span class="line">    cout &lt;&lt; &quot;2)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 2)8 9 12 13 16</span><br><span class="line">    sort(a2, a2 + 5, GreaterA);  &#x2F;&#x2F;按v的值从大到小排序</span><br><span class="line">    cout &lt;&lt; &quot;3)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 3)16 13 12 9 8</span><br><span class="line">    sort(a2, a2 + 5, LessA());  &#x2F;&#x2F;按v的个位数从小到大排序</span><br><span class="line">    cout &lt;&lt; &quot;4)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 4)12 13 16 8 9</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译至第 45 行时，编译器将 sort 实例化得到的函数原型如下：<br>void sort(A* first, A* last, bool (*op)(const A &amp;, const A &amp;) );</p><p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中 op 指向 GreaterA,因此就用 GreaterA 定义的规则来比较大小。</p><p>编译至第 47 行时，编译器将 sort 实例化得到的函数原型如下：<br>void sort( A* first, A* last, LessA op);</p><p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中，op(a, b) 等价于 op.opeartor(a, b)，因此就用 LessA 定义的规则来比较大小。</p><p>STL 中定义了一些函数对象类模板，都位于头文件 functional 中。例如，greater 模板的源代码如下：<br>template <class T><br>struct greater<br>{<br>    bool operator()(const T&amp; x, const T&amp; y) const{<br>        return x &gt; y;<br>    }<br>};<br>假设有以下数组：<br>int a[4] = {3, 5, 34, 8};</p><p>要将该数组从大到小排序，则只需写：<br>sort( a, a+4, greater<int>() );</p><p>要使用 greater 模板，须确保&gt;运算符本来就有定义，或经过了适当的重载。</p><p>list 容器的 sort 成员能将元素从小到大排序。它也有两个版本：一个是没有参数的函数，比较大小用&lt;运算符；另一个是函数模板，原型如下：<br>template <class Pred><br>void sort(Pred op);</p><p>sort 函数允许自定义比较大小的规则，即 op(x, y) 为真就认为 x 比 y 小。例如，假设有：<br>list<int> lst;</p><p>如果希望将 lst 中的元素按其整数数值从大到小排序，只需写：<br>lst.sort( greater<int>() );</p><p>在使用关联容器和许多算法时，都可以用函数对象来定义比较大小的规则，以及其他一些规则和操作。</p><h3 id="STL-中的函数对象类模板"><a href="#STL-中的函数对象类模板" class="headerlink" title="STL 中的函数对象类模板"></a>STL 中的函数对象类模板</h3><p>函数对象类模板    成员函数 T operator ( const T &amp; x, const T &amp; y) 的功能<br>plus <T>    return x + y;<br>minus &lt; &gt;    return x - y;<br>multiplies <T>    return x * y;<br>divides <T>    return x / y;<br>modulus <T>    return x % y;<br>     成员函数 bool operator( const T &amp; x, const T &amp; y) 的功能<br>equal_to <T>    return x == y;<br>not_equal_to <T>    return x! = y;<br>greater <T>    return x &gt; y;<br>less <T>    return x &lt; y;<br>greater_equal <T>    return x &gt; = y;<br>less_equal <T>    return x &lt;= y;<br>logical_and <T>    return x &amp;&amp; y;<br>logical_or <T>    return x || y;<br>     成员函数 T operator( const T &amp; x) 的功能<br>negate <T>    return - x;<br>     成员函数 bool operator( const T &amp; x) 的功能<br>logical_not <T>    return ! x;<br>例如，如果要求两个 double 型变量 x、y 的乘积，可以写：<br>multiplies<double> () (x, y)</p><p>less 是 STL 中最常用的函数对象类模板，其定义如下：<br>template <class_Tp><br>struct less<br>{<br>    bool operator() (const_Tp &amp; __x, const_Tp &amp; __y) const<br>    { return __x &lt; __y; }<br>};<br>要判断两个 int 变量 x、y 中 x 是否比 y 小，可以写：<br>if( less<int>()(x, y) ) { … }</p><p>引入函数对象后 STL 中的“大”、“小”和“相等”概念<br>前面提到过，默认情况下，STL 中的容器和算法比较元素的大小是通过&lt;运算符进行的。通过 10.3.4 节可知，sort 和 list::sort 都可以通过一个函数对象或函数自定义比较元素大小的规则。例如以下的 sort 版本：<br>template &lt;class_RandIt, class Pred&gt;<br>void sort(_RandIt first, _RandIt last, Pred op);</p><p>实际调用 sort 时，和 op 对应的实参可以是一个函数对象或者函数的名字。sort 在执行过程中用 op(x, y) 比较 x 和 y 的大小，因此可以将 op 称为自定义的“比较器”。</p><p>关联容器中的元素是从小到大排序的。使用关联容器时，也可以用自定义的比较器取代&lt;运算符，以规定元素之间的大小关系。STL 中还有许多算法都可以自定义比较器。在自定义比较器 op 的情况下，以下三种说法是等价的：<br>x 小于 y。<br>op(x, y) 的返回值为 true。<br>y 大于 x。</p><p>重点:<br>经过自己的测试，每两个数要比较两次<br>A 与 B 比较 return true 说明A比B小 A 排在B的前面<br>B 与 A 比较 return true 说明B比A小 B 排在A的前面<br>so 这就是问题 到底是A大还是B大？？</p><p>我以前一直这样记忆：<br>return true ==== 说明第一个参数排在第二个参数前面<br>return false ==== 说明第一个参数排在第二个参数后面<br>其实这样记忆没有错 but<br>sort函数的潜规则就是：<br>如果两个数相等 必须返回false<br>————————————————</p><h3 id="STL-sort-函数实现详解"><a href="#STL-sort-函数实现详解" class="headerlink" title="STL sort 函数实现详解"></a>STL sort 函数实现详解</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>#include <algorithm></p><p>template&lt; class RandomIt &gt;<br>void sort( RandomIt first, RandomIt last );</p><p>template&lt; class RandomIt, class Compare &gt;<br>void sort( RandomIt first, RandomIt last, Compare comp );<br>使用方法非常简单，STL提供了两种调用方式，一种是使用默认的&lt;操作符比较，一种可以自定义比较函数。可是为什么它通常比我们自己写的排序要快那么多呢？</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>原来，STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p><p>普通的快速排序<br>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p><p>如果S中的元素只有0个或1个，结束。<br>取S中的任何一个元素作为枢轴pivot。<br>将S分割为L、R两端，使L内的元素都小于等于pivot，R内的元素都大于等于pivot。<br>对L、R递归执行上述过程。<br>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称为median-of-three，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p><p>分割的方法通常采用两个迭代器head和tail，head从头端往尾端移动，tail从尾端往头端移动，当head遇到大于等于pivot的元素就停下来，tail遇到小于等于pivot的元素也停下来，若head迭代器仍然小于tail迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p><p>看一张来自维基百科上关于快速排序的动态图片，帮助理解。</p><p>内省式排序 Introsort<br>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 O(n2)。David R.Musser于1996年提出一种混合式排序算法：Introspective Sorting（内省式排序），简称IntroSort，其行为大部分与上面所说的median-of-three Quick Sort完全相同，但是当分割行为有恶化为二次方的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 O(nlgn)，又比一开始就使用堆排序来得好。</p><p>代码分析<br>下面是完整的SGI STL sort()源码（使用默认&lt;操作符版）</p><p>template <class _RandomAccessIter><br>inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {<br>  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);<br>  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,<br>                 _LessThanComparable);<br>  if (__first != __last) {<br>    __introsort_loop(__first, __last,<br>                     __VALUE_TYPE(__first),<br>                     __lg(__last - __first) * 2);<br>    __final_insertion_sort(__first, __last);<br>  }<br>}<br>其中，__introsort_loop便是上面介绍的内省式排序，其第三个参数中所调用的函数__lg()便是用来控制分割恶化情况，代码如下：</p><p>template <class Size><br>inline Size __lg(Size n) {<br>    Size k;<br>    for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;<br>    return k;<br>}<br>即求lg(n)（取下整），意味着快速排序的递归调用最多 2*lg(n) 层。</p><p>内省式排序算法如下：</p><p>template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;<br>void __introsort_loop(_RandomAccessIter __first,<br>                      _RandomAccessIter __last, _Tp*,<br>                      _Size __depth_limit)<br>{<br>  while (__last - __first &gt; __stl_threshold) {<br>    if (__depth_limit == 0) {<br>      partial_sort(__first, __last, __last);<br>      return;<br>    }<br>    –__depth_limit;<br>    _RandomAccessIter __cut =<br>      __unguarded_partition(__first, __last,<br>                            _Tp(__median(*__first,<br>                                         <em>(__first + (__last - __first)/2),<br>                                         *(__last - 1))));<br>    __introsort_loop(__cut, __last, (_Tp</em>) 0, __depth_limit);<br>    __last = __cut;<br>  }<br>}</p><ol><li>首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。</li><li>若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。</li><li>若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。__unguarded_partition()函数采用的便是上面所讲的使用两个迭代器的方法，代码如下：<br>template &lt;class _RandomAccessIter, class _Tp&gt;<br>_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, <pre><code>                                 _RandomAccessIter __last,                                  _Tp __pivot) </code></pre>{<br> while (true) {<pre><code> while (*__first &lt; __pivot)     ++__first; --__last; while (__pivot &lt; *__last)     --__last; if (!(__first &lt; __last))     return __first; iter_swap(__first, __last); ++__first;</code></pre> }<br>}</li><li>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。<br>递归上述过程，直到元素规模小于__stl_threshold，然后返回sort函数，对整个元素序列调用一次插入排序，此时序列中的元素已基本有序，所以插入排序也很快。至此，整个sort函数运行结束。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lambda</title>
    <link href="http://example.com/posts/65250/"/>
    <id>http://example.com/posts/65250/</id>
    <published>2021-03-21T06:53:13.000Z</published>
    <updated>2021-03-21T08:03:48.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="由来（要解决什么问题）"><a href="#由来（要解决什么问题）" class="headerlink" title="由来（要解决什么问题）"></a>由来（要解决什么问题）</h3><p>使用STL时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。<br>对于只使用一次的函数对象类，能否直接在使用它的地方定义呢？Lambda表达式能够解决这个问题。使用Lambda表达式可以减少程序中函数对象类的数量，使得程序更加优雅。</p><h3 id="lambda表达式的定义形式如下"><a href="#lambda表达式的定义形式如下" class="headerlink" title="lambda表达式的定义形式如下"></a>lambda表达式的定义形式如下</h3><p>[部变量访问方式说明符] (参数表) -&gt; 返回值类型<br>{<br>   语句块<br>}</p><p>下面是一个合法的Lambda表达式：<br>[=] (int x, int y) -&gt; bool {return x%10 ＜ y%10;}</p><p>Lambda 表达式实际上是一个函数，只是它没有名字。下面的程序段使用了上面的 Lambda 表达式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[4] &#x3D; &#123;11, 2, 33, 4&#125;;</span><br><span class="line">sort(a, a+4, [&#x3D;](int x, int y) -&gt; bool &#123; return x%10 &lt; y%10; &#125; ); &#x2F;&#x2F; 带-&gt;函数返回值的</span><br><span class="line">for_each(a, a+4, [&#x3D;](int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125; ); &#x2F;&#x2F; 省略-&gt;函数返回值的。</span><br><span class="line"></span><br><span class="line">这段程的输出结果是：</span><br><span class="line">11 2 33 4</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ol><li>程序第 2 行使得数组 a 按个位数从小到大排序。具体的原理是：sort 在执行过程中，需要判断两个元素 x、y 的大小时，会以 x、y 作为参数，调用 Lambda 表达式所代表的函数，并根据返回值来判断 x、y 的大小。这样，就不用专门编写一个函数对象类了。这里的外部传入的x， y<br>不能被改变，否则编译报错的.</li><li>for_each 的第 3 个参数是一个 Lambda 表达式。for_each 执行过程中会依次以每个元素作为参数调用它，因此每个元素都被输出。这里的x也不允许被改变的.</li></ol><h4 id="外部变量访问方式说明符"><a href="#外部变量访问方式说明符" class="headerlink" title="[外部变量访问方式说明符]"></a>[外部变量访问方式说明符]</h4><p>外部变量: 一般指定义在{}作用域外边的变量，参数的话跟正常函数一样，传引用和传值的区别.<br>“外部变量访问方式说明符”可以是=或&amp;，表示{}中用到的、定义在{}外面的变量在{}中是否允许被改变。=表示不允许，&amp;表示允许。当然，在{}中也可以不使用定义在外面的变量。</p><p>实际上，“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。例如：</p><ol><li>[=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；</li><li>[&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。</li></ol><h4 id="参数表"><a href="#参数表" class="headerlink" title="(参数表)"></a>(参数表)</h4><p>跟普通的函数参数的形式一样。</p><h4 id="gt-返回值类型"><a href="#gt-返回值类型" class="headerlink" title="-&gt;返回值类型"></a>-&gt;返回值类型</h4><p>“-&gt; 返回值类型”可以省略。</p><h4 id="语句块"><a href="#语句块" class="headerlink" title="{语句块}"></a>{语句块}</h4><p>正常函数书写形式一样。</p><h4 id="用到外部变量-外部变量改变"><a href="#用到外部变量-外部变量改变" class="headerlink" title="用到外部变量(外部变量改变)"></a>用到外部变量(外部变量改变)</h4><p>程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[4] &#x3D; &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">    int total &#x3D; 0;</span><br><span class="line">    for_each(a, a + 4, [&amp;](int &amp; x) &#123; total +&#x3D; x; x *&#x3D; 2; &#125;);</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;  &#x2F;&#x2F;输出 10</span><br><span class="line">    for_each(a, a + 4, [&#x3D;](int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">10</span><br><span class="line">2 4 6 8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[&amp;]表示该 Lambda 表达式中用到的外部变量 total 是传引用的，其值可以在表达式执行过程中被改变（如果使用[=]，编译无法通过）。该 Lambda 表达式每次被 for_each 执行时，都将 a 中的一个元素累加到 total 上，然后将该元素加倍。</p><h4 id="最终程序"><a href="#最终程序" class="headerlink" title="最终程序"></a>最终程序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;   </span><br><span class="line">    int x &#x3D; 100,y&#x3D;200,z&#x3D;300;</span><br><span class="line">    auto ff  &#x3D; [&#x3D;,&amp;y,&amp;z](int n) &#123;</span><br><span class="line">        cout &lt;&lt;x &lt;&lt; endl;</span><br><span class="line">        y++; z++;</span><br><span class="line">        return n*n;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; ff(15) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; &quot;,&quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">100</span><br><span class="line">225</span><br><span class="line">201, 301</span><br></pre></td></tr></table></figure><p>定义了一个变量 ff，ff 的类型是 auto，表示由编译器自动判断其类型（这也是 C++11 的新特性）。本行将一个 Lambda 表达式赋值给 ff，以后就可以通过 ff 来调用该 Lambda 表达式了。<br>通过 ff，以 15 作为参数 n 调用上面的 Lambda 表达式。该 Lambda 表达式指明，对于外部变量 y、z，可以修改其值；对于其他外部变量，例如 x，不能修改其值。因此在该表达式执行时，可以修改外部变量 y、z 的值，但如果出现试图修改 x 值的语句，就会编译出错。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>algorithm-实现</title>
    <link href="http://example.com/posts/4524/"/>
    <id>http://example.com/posts/4524/</id>
    <published>2020-12-31T06:56:51.000Z</published>
    <updated>2021-01-25T12:13:38.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STL库剖析</title>
    <link href="http://example.com/posts/4515/"/>
    <id>http://example.com/posts/4515/</id>
    <published>2020-12-31T05:07:27.000Z</published>
    <updated>2021-01-25T12:13:38.777Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/Rane/p/12635027.html">先参考网站</a></p><h3 id="STL标准模板类库"><a href="#STL标准模板类库" class="headerlink" title="STL标准模板类库"></a>STL标准模板类库</h3><p>分为三部分:<br>    1. 容器: 对数据结构的封装<br>    2. 算法:<br>    3. 迭代器</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="STL库" scheme="http://example.com/categories/STL%E5%BA%93/"/>
    
    
    <category term="STL库" scheme="http://example.com/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>leedcode-链表中等</title>
    <link href="http://example.com/posts/17385/"/>
    <id>http://example.com/posts/17385/</id>
    <published>2020-12-30T02:54:10.000Z</published>
    <updated>2021-01-25T12:13:38.877Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>看题解第二个<br>`<br>递归方法</p><p>tion for singly-linked list.</p><ul><li><p>struct ListNode {</p></li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode *next;</code></pre></li><li><pre><code>ListNode() : val(0), next(nullptr) &#123;&#125;</code></pre></li><li><pre><code>ListNode(int x) : val(x), next(nullptr) &#123;&#125;</code></pre></li><li><pre><code>ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</code></pre></li><li><p>};</p></li><li><p>/<br>class Solution {<br>public:<br>  ListNode* swapPairs(ListNode* head) {</p><pre><code>  if(head == nullptr || head-&gt;next == nullptr) return head;  ListNode *next = head-&gt;next;  head-&gt;next = swapPairs(next-&gt;next);  next-&gt;next = head;  return next;</code></pre><p>  }<br>};</p><pre><code></code></pre></li></ul><p>迭代方法</p><p>class Solution {<br>public:<br>    ListNode* swapPairs(ListNode* head) {<br>        ListNode *pre = new ListNode(0);<br>        pre-&gt;next = head;<br>        ListNode *pre1 = pre;<br>        while(pre1-&gt;next != nullptr &amp;&amp; pre1-&gt;next-&gt;next != nullptr){<br>            ListNode *node1 = pre1-&gt;next;<br>            ListNode *node2 = node1-&gt;next;<br>            pre1-&gt;next = node2;<br>            node1-&gt;next = node2-&gt;next;<br>            node2-&gt;next = node1;<br>            pre1 = node1;<br>        }<br>        return pre-&gt;next;<br>    }<br>};</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>big_data</title>
    <link href="http://example.com/posts/60234/"/>
    <id>http://example.com/posts/60234/</id>
    <published>2020-12-27T13:01:28.000Z</published>
    <updated>2021-01-25T12:13:38.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="十道海量数据处理题"><a href="#十道海量数据处理题" class="headerlink" title="十道海量数据处理题"></a>十道海量数据处理题</h3><h4 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h4><p>　此题，在我之前的一篇文章算法里头有所提到，当时给出的方案是：IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p><p>　　再详细介绍下此方案：首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><h4 id="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。"><a href="#搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。" class="headerlink" title="搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。"></a>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。</h4><p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><p>　　典型的Top K算法，还是在这篇文章里头有所阐述。 文中，给出的最终算法是：第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成排序；然后，第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。 即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。</p><p>　　或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><h4 id="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h4><p>方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。</p><p>　　如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p><h4 id="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h4><p>还是典型的TOP K算法，解决方案如下： 方案1： 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。</p><p>　　对这10个文件进行归并排序（内排序与外排序相结合）。</p><p>　　方案2： 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。</p><p>　　方案3： 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p><h4 id="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"><a href="#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？" class="headerlink" title="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h4><p>　方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p><p>　　遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。</p><p>　　遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p><p>　　求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p><p>　　方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><p>　　Bloom filter日后会在本BLOG内详细阐述。</p><h4 id="在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。"><a href="#在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。" class="headerlink" title="在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。"></a>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h4><p>方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p><p>　　方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h4 id="腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h4><p>与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法： 方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p><p>　　dizengrong： 方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；这里我们把40亿个数中的每一个用32位的二进制来表示假设这40亿个数开始放在一个文件中。</p><p>　　然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找</p><p>再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1</p><p>　　并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ……. 以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。</p><p>　　附：这里，再简单介绍下，位图方法： 使用位图法判断整形数组是否存在重复 判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。</p><p>　　位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。</p><h4 id="怎么在海量数据中找出重复次数最多的一个？"><a href="#怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="怎么在海量数据中找出重复次数最多的一个？"></a>怎么在海量数据中找出重复次数最多的一个？</h4><p>　　 方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h4 id="上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"><a href="#上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。" class="headerlink" title="上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"></a>上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</h4><p>方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。</p><h4 id="一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"><a href="#一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。" class="headerlink" title="一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"></a>一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</h4><p>方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p><p>　　附、100w个数中找出最大的100个数。</p><p>　　方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p><p>　　方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。</p><p>　　方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。</p><h3 id="十个海量数据处理方法大总结"><a href="#十个海量数据处理方法大总结" class="headerlink" title="十个海量数据处理方法大总结"></a>十个海量数据处理方法大总结</h3><p>　　ok，看了上面这么多的面试题，是否有点头晕。是的，需要一个总结。接下来，本文将简单总结下一些处理海量数据问题的常见方法。</p><p>　　下面的方法全部来自<a href="http://hi.baidu.com/yanxionglu/blog/%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%AF%B9%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%B8%80%E4%B8%AA%E4%B8%80%E8%88%AC%E6%80%A7%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%8C%E5%BD%93%E7%84%B6%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E8%83%BD%E5%B9%B6%E4%B8%8D%E8%83%BD%E5%AE%8C%E5%85%A8%E8%A6%86%E7%9B%96%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B9%9F%E5%9F%BA%E6%9C%AC%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%9F%BA%E6%9C%AC%E7%9B%B4%E6%8E%A5%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%85%AC%E5%8F%B8%E7%9A%84%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%9C%80%E4%BC%98%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AC%A2%E8%BF%8E%E8%AE%A8%E8%AE%BA%E3%80%82">http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。</a></p><p>　　一、Bloom filter</p><p>　　适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集</p><p>　　基本原理及要点：</p><p>　　对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p><p>　　还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。</p><p>　　举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p><p>　　注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。</p><p>　　扩展：</p><p>　　Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。</p><p>　　问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</p><p>　　根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p><p>　　二、Hashing</p><p>　　适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存</p><p>　　基本原理及要点：</p><p>　　hash函数选择，针对字符串，整数，排列，具体相应的hash方法。</p><p>　　碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p><p>　　扩展：</p><p>　　d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p><p>　　问题实例：</p><p>　　1).海量日志数据，提取出某日访问百度次数最多的那个IP。</p><p>　　IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p><p>　　三、bit-map</p><p>　　适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p><p>　　基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码</p><p>　　扩展：bloom filter可以看做是对bit-map的扩展</p><p>　　问题实例：</p><p>　　1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</p><p>　　8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。</p><p>　　2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p><p>　　将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。</p><p>　　四、堆</p><p>　　适用范围：海量数据前n大，并且n比较小，堆可以放入内存</p><p>　　基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。</p><p>　　扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p><p>　　问题实例：</p><p>　　1)100w个数中找最大的前100个数。</p><p>　　用一个100个元素大小的最小堆即可。</p><p>　　五、双层桶划分—-其实本质上就是【分而治之】的思想，重在分的技巧上！</p><p>　　适用范围：第k大，中位数，不重复或重复的数字</p><p>　　基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。</p><p>　　扩展：</p><p>　　问题实例：</p><p>　　1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p><p>　　有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p><p>　　2).5亿个int找它们的中位数。</p><p>　　这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p><p>　　实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p><p>　　六、数据库索引</p><p>　　适用范围：大数据量的增删改查</p><p>　　基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。</p><p>　　七、倒排索引(Inverted index)</p><p>　　适用范围：搜索引擎，关键字查询</p><p>　　基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。</p><p>　以英文为例，下面是要被索引的文本： T0 = “it is what it is” T1 = “what is it” T2 = “it is a banana”</p><p>我们就能得到下面的反向文件索引：</p><p>“a”: {2} “banana”: {2} “is”: {0, 1, 2} “it”: {0, 1, 2} “what”: {0, 1}</p><p>　检索的条件”what”,”is”和”it”将对应集合的交集。</p><p>　　正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。</p><p>　　扩展：</p><p>　　问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。</p><p>　　八、外排序</p><p>　　适用范围：大数据的排序，去重</p><p>　　基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树</p><p>　　扩展：</p><p>　　问题实例：</p><p>　　1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。</p><p>　　这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。</p><p>　　九、trie树</p><p>　　适用范围：数据量大，重复多，但是数据种类小可以放入内存</p><p>　　基本原理及要点：实现方式，节点孩子的表示方式</p><p>　　扩展：压缩实现。</p><p>　　问题实例：</p><p>　　1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。</p><p>　　2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？</p><p>　　3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。</p><p>　　十、分布式处理 mapreduce</p><p>　　适用范围：数据量大，但是数据种类小可以放入内存</p><p>　　基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p><p>　　扩展：</p><p>　　问题实例：</p><p>　　1).The canonical example application of MapReduce is a process to count the appearances ofeach different word in a set of documents:</p><pre><code>　　2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。　　3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？　　经典问题分析　　上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。　　可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序　　所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。　　如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。　　当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。　　实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。　 而外排序的方法会消耗大量的IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>ip协议</title>
    <link href="http://example.com/posts/37850/"/>
    <id>http://example.com/posts/37850/</id>
    <published>2020-12-23T07:57:39.000Z</published>
    <updated>2020-12-27T12:59:20.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP是网络控制消息协议,属于网络层协议,ICMP协议用来在网络设备间传递各种差错和控制信息,并对于收集各种网络信息,诊断和排除各种网络故障等方面起着至关重要的作用.使用基于ICMP的应用时,需要对ICMP的工作原理非常熟悉.</p><p>平时用到的ping命令,就是使用的ICMP协议,用来检测网络的连通性(通或者不通问题),<br>通过主机A向主机(服务器),现在想检测主机A与服务器之间的联通性,使用ICMP协议首先从A主机发送一个message消息到服务器,不管到哪里或者断了,都会回复一个消息(return Message),就可以通过回复的消息来判断中间的网络是怎么样的(ip等路由信息都通过return message来判断),大致流程是这样的.</p><p>网关: 用来转发不同网段之间的数据包.<br>如果是主机A想想访问服务器A,就是先判断服务器A的网络ip是不是和服务器的ip属于同一个网段,如果是就直接访问,如果不是就得交给网关进行转发,网关的作用就是转发不同网段之间的数据包.</p><p>ICMP重定向:<br>    例子,图:ICMP重定向<br>    主机A判断和服务器A的是不是属于同一个网段，这里判断显然不是，就会通过默认的网关，RTB进行消息转发，转发给了RTA,RTA再找到服务器A,这里的RTB的操作就是冗余的.这种情况下网关(RTB)会返回一个ICMP重定向的消息，告诉主机A,下次的路径.直接可以访问TRA就可已到达．这里所说的RTB那条路径是次优路径，RTA那条路径是次优路径是最优路径．<br>ICMP重定向的作用: 解决了次优路径.(这里只是控制消息还有我们的差错还有查询)</p><p>ICMP差错检测<br>图：ICMP差错检测<br>主机A会给主机B发送一个ICMP Echo Requst消息,经过传播到达服务器A ,服务器A 会回复ICMP Rcho Reply的消息．这是正常的情况．<br>如果说没有返回这个消息，就说明出现问题了，</p><p>ICMP Echo Requst 和ICANN Echo Reply分别用来查询和响应某些信息，进行差错检测.</p><p>ICMP错误报告<br>图 ICMP错误报告<br>主机会给服务器发送消息，中间经过路由器，如果中间出现问题（IP冲突或者没有路由）路由会回复一个信息（ICMP目的不可达）<br>当网络设备无法访问目标网络时，会自动发送ICMP目的不可达报文到发送端设备.</p><p>ICMP数据包格式:<br>    1. 帧头<br>    2. 网络头<br>    3. ICMP<br>    4. FCS<br>ICMP中包括:<br>    1. type(0-7)<br>    2. code(7-15)<br>    3. checksum(15-31)<br>ICMP的报文内容(不同类型和代码标识不同的内容)．<br>type表示ICMP消息类型，Code表示同一消息类型中的不同信息．<br>返回的ICMP目的不可达就是通过Type类型和Code值．<br>图　ICMP消息类型和编码类型．<br>网络不可达: 没有路由<br>主机不可达: 主机没有IP或者说IP地址配置错误.<br>协议不可达: acl协议（或者中间设备）给他过滤了．<br>端口不可达: 端口不对外开放.</p><p>ICMP应用-ping<br>主动方发送一个ICMP请求，对方发送一个ICMP回应,<br>确认情况下ping一般发送五个请求包，对方会给我们回五个回应．</p><p>ICMP应用-Tracert<br>用来跟踪数据包所经过的路径.<br>原理就是控制TTL值，TTL值是用来防环的，如果TTL值为0的时候这个数据包就会被丢弃，而且每经过一次路由器，TTL就会减一.缺省值为255.</p><p>运行过程:<br>    开始的时候，主机会把ttl设置为1，发送一个TTL为1的报文,首先主机A会把报文交给网关，网关再次发送给路由器，（在网关TTL为1,发送出去就会变成0,到b路由器判断为0,报文丢弃，返回一个信息(ICMP消息不可达)给主机A）,主机A收到了这个消息，就会知道第一个设备经过的是哪里，下次会再次发送一个TTL为2的报文，以此类推.就可以判断经过的路径.<br>图: icmp应用-Tracert</p><p>Tracert: 回复的是ICMP.</p><p>模拟机上用的是Tracertroute<br>Tracertroute: 回复的是UDP.</p><p>抓包真机上能抓到，模拟器上抓不到icmp重定向.</p><h3 id="rqp协议"><a href="#rqp协议" class="headerlink" title="rqp协议"></a>rqp协议</h3><p>在操作系统和网络设备没有或者不需要设置ARP参数.很少用到．<br>有助于故障诊断:<br>    1. 通过ARP包的特征就能判断网络构架是否正确．<br>    2. 有没有发生依赖．<br>    3. 有没有错包<br>    4. 有没有广播分报等信息.</p><p>由于ARP本身的缺陷，使其成为内网的安全隐患(ARP协议攻击前边有说过),</p><h3 id="浅谈协议"><a href="#浅谈协议" class="headerlink" title="浅谈协议"></a>浅谈协议</h3><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>Address Resolution Protocol，地址解析协议，根据IP地址获取物理地址。</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存，由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>Network Address Translation，网络地址转换，一种将私有（保留）地址转化为合法IP地址的转换技术。</p><p>在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但又想和因特网上的主机通信时，可使用NAT方法。这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有专用网内部的想和因特网上的主机通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>Internet Control Message Protocol，Internet控制报文协议，用于在IP主机、路由器之间传递控制消息。</p><p>控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>Dynamic Host Configuration Protocol，动态主机配置协议，是一个局域网的网络协议。</p><p>DHCP使用UDP协议工作，主要有两个用途：一是给内部网络或网络服务供应商自动分配IP地址，二是作为用户或者内部网络管理员对所有计算机作中央管理的手段。</p><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>Routing Information Protocol，路由信息协议，是一个内部网关协议，是一种基于距离矢量的路由协议，以路由跳数作为计数单位的路由协议，适合用于比较小型的网络环境。它选择路由的度量标准是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>Open Shortest Path First，开放式最短路径优先，是一个内部网关协议，是对链路状态路由协议的一种实现，用Dijastra算法实现。它选择路由的度量标准是带宽，延迟。</p><h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>Border Gateway Protocol，边界网关协议，是一个外部网关协议，用来连接因特网上的独立系统，在自治系统之间动态交换路由信息。</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><h4 id="到底该如何理解HTTP长连接"><a href="#到底该如何理解HTTP长连接" class="headerlink" title="到底该如何理解HTTP长连接"></a>到底该如何理解HTTP长连接</h4><p>想要理解HTTP长连接就必须理解socket连接.<br>套接字是什么?<br>Socket是什么?是操作系统提供的tcp协议之上的接口.</p><p>这里就会涉及到TCP协议，该协议处在传输层，那么什么来实现TCP协议呢?<br>TCP协议在linux源码中实现了三次握手等操作.也就是说TCP是在os中进行详细实现的.<br>HTTP协议(请求)就是一个特定格式的数据,</p><p>重申操作系统会实现TCP协议.</p><p>在linux系统内部:<br>建立TCP链接—首先调用tcp_connect()完成三次握手,</p><p>HTTP格式:</p><p>访问<a href="https://www.baidu,com/">https://www.baidu,com/</a><br>会默认的设置一个请求头 Connextion:(http 0.9/http 1.0)默认的是close.(如果是http1.1版本的话　就是keepAlive （这里就是长连接)).构造完成请求头，然后发送给百度的服务器．</p><p>浏览器步骤:<br>    1. 构造数据(构造成指定格式的数据(HTTP格式)).<br>    2. 调用操作系统的API(所提供的功能.–发送数据的功能—TCP连接.)<br>    3. 基于TCP连接再发送数据.</p><p>操作系统是负责传输数据，而数据格式解析等操作都是交给应用程序(浏览器/Tomcat)来完成的．</p><p>HTTP的长连接参数为啥是 keep_alive/close这个参数呢?他有什么特殊的含义吗?<br>注意区分(tcp中有一个keep_alive(这个定义的心跳))我么这里所说的是HTTP中的keep_alive.</p><p>下边的两行构造出来的就是HTTP请求:<br><a href="https://www.baidu.com/">https://www.baidu.com/</a><br>Connextion: keep_alive</p><p>当我们访问百度的时候我们只向百度服务器只发送了一个HTTP的请求吗?</p><p>当我们输入baidu.com的时候，会发出75个HTTP请求,难道会建立75个socket吗?<br>??????<br>如果使用的是HTTP的短连接: 就会建立75个Socket.<br>如果使用的是HTTP长连接:<br>    如果不建立75个Socket,如果建立10个Socket那个这75个HTTP请求如何发呢?</p><p>这里就涉及到了多个HTTP请求共用一个Socket连接,一个socket连接能处理多少个HTTP请求，这个在Tomact中会有配置的.</p><p>我们想要访问一个服务器就需要先建立socket连接,然后再发送HTTP请求(就是通过Socket发送HTTP类型的数据),Tomcat接受这些数据之后就会处理这些数据,Tomact如何处理这些数据这里就涉及到了长连接,当Tomact接收到这个请求后，就会判断这个请求头中connection:是不是close类型的，如果这个参数是close类型的，Tomact就认为是短连接，如果是短连接Tomact就会先处理完这个请求，总而言之先解析头部，再解析请求，把这个请求的结果的响应给浏览器．在响应头里边也有一个connection的参数短连接的话参数也为close，对于Tomcat请求处理完了就会把socket关掉，对于浏览器当他接收到响应之后,就会渲染页面渲染完成之后，也会把socket关掉,这里就是短连接….close的先后顺序在网络中，不能很好的控制的．<br>双方没有谁主动的问题，只要收到connection:close.就会去主动关闭.</p><p>下边说什么是长连接:<br>    如果Connextion参数为keep_alive,当浏览器发送这HTTP请求，Tomact接收到这个请求后，解析出来是keep_alive(保持活跃),<br>    这里的保持活跃说的是，接收到HTTP请求这个socket保持活跃,所以说在Tomcat处理完成之后会给一个反馈信息，这个反馈信息就不会再包含connection:close这个参数了，当前这个socket谁(socket和Tomact)都不会去关，从而使得Socket的(长连接)没有关闭（保持开着的状态),Tomact能同时存在活跃的socket,可以同时有好多个浏览器来连tomcat的8080端口,Tomact会控制有多少个活跃的socket个数，当浏览器在向tomcat建立socket连接的时候，还有一个参数来控制能够来处理多少个HTTP请求，就比如建立了一条长连接的socket(),然后通过这个socket()发送若干次http的请求，参数为maxKeepAliveRequests,就是长连接处理参数的请求,在一次建立socket之后，然后接收HTTP格式(这里都是connection为keep_alive.保持长连接)的请求，假设参数设置为3，就是前两个反馈信息（反馈头部）设置相关闭参数，等收到第三个请求之后，反馈头部就会加上connection:close.这个参数，返回给浏览器，这时Tomcat(服务器)就会调用socket.close()这个方法，然后浏览器收到响应头部这个反馈信息后，也会调用浏览器的socket.close的方法,进而实现套接字的关闭,这个参数的作用到这里解释完毕，注意一下,这个参数的默认参数为100,就是一个Socket连接只能处理100个http请求.</p><pre><code>为什么要加上100这个限制呢?一直处理不好吗?这里涉及到socket中的两个buffer，发送端有sendbuffer, 服务端recvbuffer,这里的buffer是在操作系统里边的，当我们写一个套接字，没有相关的处理数据（写发等）等逻辑，服务端为例，服务端就会把HTTP请求的那些信息暂存于buffer,服务端再进行数据的读取操作，就是从recvbuffer中获取的数据.我们可以实现一个功能模拟(client)网站连接一个服务端一直发送大量的数据，到达一定的时候他就不会再进行发送了，那么问题来了，客户端怎么知道服务端的buffer满了呢?这就跟tcp协议有关，就好比是tcp协议中的窗口，服务端每次接受到一个数据或者一组数据，就会返回有一个信息反馈，如果我这里满了就会告诉服务端不要再发了,这个可以手动更改，serversocket.setReceiveBufferSize()来修改这个缓冲区的大小，tomcat从recvbuffer中获取数据的，</code></pre><p>最大连接数，这里说的就是socket的连接个数，这里通过控制socket的个数来达到控制最大连接数的，代码底层有一个最大线程数，还有一个最大连接数，这两个区别是什么呢?<br>  最大线程数:　就是线程池的大小．<br>  Tomact中用的是bio的方式，在这种方式下,两者的值是一样的,只有用nio的方式他们连个才会不一样．<br>  bio的方式:<br>      就是我能够同时处理的socket的数量，在线程池开一定数量的线程，比如线程数为100,每个线程开一个socket连接,基于这种方式在bio里边最大连接数和最大线程数是一样的.</p><p>Tomact整体读数据的流程:<br>    读取buffer中的数据，字节格式，然后解析http协议,获得请求头部,判断连接方式(connection: keep还是什么)，响应获得一个rquest的对象，然后servle处理这个request的对象，然后会调用socket,output的对象发出响应，然后根据头部解析的结果来判断要不要调用套接字的关闭与否．</p><p>Tomact底层是调用的socket的,</p><p>setsotimeout()来设置套接字的等待时间，就是想从buffer中拿数据，但是buffer中目前又不存在数据，所以说要等多久，这里就是我们设置的这个时间，这就是会阻塞的原因.如果说Tomcat也想设置socket这个参数该怎么办呢，就要设置keepAliveTimeout这个函数了，如果时间到了，还是没有读到，Tomcat就会调用套接字的close方法.</p><p>Tomact长连接就是读完最后一次数据的20秒后关闭socket.<br>图:Tomact请求过程</p><p>如果七个HTTP请求访问jsp页面，会反馈多少个HTTP请求?(Google浏览器)<br>会反会9个HTTP,第一个为index.jsp返回jsp页面，后续七个为servletDemo? = 1直到等于7,最后会默认发送一个图标,favicon.ico．那么一共建立了几个socket连接呢? 这个显示了6个socket连接，问题来了，这个6从哪里来的，是Tomact还是浏览器哪个设置的.<br>这个6是浏览器设置的,浏览器是客户端,就是拿到一个网页，其中有7个请求，一个浏览器也能同时建立多个socket,谷歌里边默认会建立六个，这就是浏览器并发请求的数量,这里有9个HTTP请求，六个socket这里就必然会涉及到共享，哪几个http请求用的是同一个socket,第一个请求必然会建立一个socket连接，发送完反馈信息之后，再发送第二http请求的时候有必要再建立一个socket呢？没有必要，这里就可以看出前两个.js和http1用的是同一个socket连接,第三个(http2)这个请求会建立新的socket，那么第四个会不会新建立一个呢？不一定的,其他几个HTTP就会并发的建立socket来发送http请求．这只是一种情况，第一个和第二个会通过一个socket来发送数据，而下边几个http请求，可能会占用同一个socket也可能自己新创建,并发的执行，谁跟谁用一个socket我们没有办法确定的.</p><p>注意: 如果在频繁的建立连接的过程过程中，也可能会用到同一个socket．<br>学完这个完成:<br>可用在项目中的jvm,mysql,Tomact调优. </p><p>参数: keepAliveTimeout,maxConnections,maxKeepAliveRequests的作用</p><h3 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h3><h3 id="DNS域名解析详细过程"><a href="#DNS域名解析详细过程" class="headerlink" title="DNS域名解析详细过程"></a>DNS域名解析详细过程</h3><h4 id="根域名"><a href="#根域名" class="headerlink" title="根域名"></a>根域名</h4><p>ICANN公司(US)来负责管理顶级域名比如说是(.com).<br>一般的话给这些域名分为两类:<br>    1. 一般的(.com)(.net)(.org)大概700个.<br>    2. 国别(.cn 中国)(.uk)英国,大概200个.</p><p>ICANN不会亲自管理这些域名,每一个域名有一个托管商,由托管商来管理这些域名的具体管理事项.<br>ICANN会将所有事物都委托给管商,(.cn)就是中国互联网网络信息中心(CNNIC),最大的托管商verisign,ICANN是非盈利组织, verisign是商业公司托管有((.com)(.net)(.tv)),</p><p>下面说域名注册费用问题:<br>    比如注册(.com)的费用,10美元.<br>    ICANN : 0.8美元.<br>    verisign: 7.85美元.<br>    注册商: 剩余的.</p><p>verisign几乎的垄断利润,ICANN通过发布新的域名,反垄断.</p><p>根域名:<br>    <a href="http://www.abc.com.注意com后边有一个点,这个就是根域名,因为所有的域名都有根域名,所以这个点(根域名)被隐藏了/">www.abc.com.注意com后边有一个点,这个就是根域名,因为所有的域名都有根域名,所以这个点(根域名)被隐藏了</a>.</p><p>细说一下: <a href="http://www.abc.com.的访问过程/">www.abc.com.的访问过程</a>:<br>    1. 查询根域名得到.com顶级域名的服务器地址.<br>    2. 查询顶级域名得到.abc次级域名的服务器地址.<br>    3. 最后通过查询次级域名,得到了ip地址.<br>INACC: 在这里的作用是维护了一个列表维护了所有的顶级域名服务器地址,这个列表名叫DNS根区,保存这个文件的服务器就是根域名服务器,全世界目前有13台根域名节点,分别是a.root-servers.net…m.root-servers.net(就是a 到 m).为什么是13台,因为早期的DNS解析结果是512字节的数据包,数据包只能容纳13台服务器的地址,现在13台服务器由12家组织独立运营,每家组织为了保持根域名的稳定性,在每个编号下边都会运行很多台机器,现在世界有五百多台机器用于根节点的查询,</p><h4 id="DNS域名解析协议"><a href="#DNS域名解析协议" class="headerlink" title="DNS域名解析协议"></a>DNS域名解析协议</h4><p>图 域名解析图</p><p>我们输入浏览器的是域名,但是电脑是通过IP访问的,这里就需要有一个地址簿(域名IP对应表),电脑能通过域名来查询到对应的IP.电脑拿到IP之后再去访问网站,这里所说的地址簿就是DNS服务器.</p><p>知识储备根域名的知识:</p><p>DNS服务器:<br>    相关设计:<br>        由于需求是人都能上网,并且这些人都分布在世界各地,所以对服务器的要求是高可用,分布式(满足世界各地).在这种要求下DNS服务器就被设计成了树状结构:<br>            根: 用点来表示(.)<br>            跟下边是若干顶级域名,常见的顶级域名:<br>                (.com), (.cn), (.net),<br>            顶级域名解析服务器就是返回权威DNS域名解析服务器.权威域名:<br>                (baidu.com),(163.com)<br>            权威域名解析服务器就能返回具体的域名对应的IP地址.比如<a href="http://www.163.com的ip地址/">www.163.com的ip地址</a>,<br>            网络运营商会就近部署一些缓存域名服务器,如果缓存中有IP就直接返回,就不用到根域名,顶级域名,和权威域名解析服务器上进行逐级解析了,提高解析性能.</p><p>解析的处理流程:<br>    比如<a href="http://www.163.com如何解析的/">www.163.com如何解析的</a>.<br>    1. 电脑会查询相对应的IP,首先看电脑的hosts文件是否有相关的配置,如果存在就直接使用,如果没有电脑就会想本地的DNS域名解析服务器(由服务运营上来提供比如电信,联通等,一般也会部署到他们的机房里边)发出一次请求.<br>    2. 本地的DNS收到请求,会查看本地的缓存中是否存在<a href="http://www.163.com所对应的ip,如果有直接返回,如果没有就会向根域名(根域名是一种高级的域名,全球一共13套)发出一次请求/">www.163.com所对应的ip,如果有直接返回,如果没有就会向根域名(根域名是一种高级的域名,全球一共13套)发出一次请求</a>.<br>    3. 根域名收到请求后不会直接返回<a href="http://www.163.com的ip,而是看他的顶级域名是多少,这里是.com,他只会返回(返回.com)顶级域名的服务器给本地dns,然后本地dns会访问.com的顶级域名dns服务器/">www.163.com的IP,而是看他的顶级域名是多少,这里是.com,他只会返回(返回.com)顶级域名的服务器给本地DNS,然后本地DNS会访问.com的顶级域名DNS服务器</a>.<br>    4. 顶级域名服务器就会返回常规域名,这里的常规域名是163.com,这里就会返回一个权威域名的服务器,本地DNS就会访问权威域名服务器,他这里有<a href="http://www.163.com的ip,就会返回他所对应的ip,本地dns拿到ip后就会返回给电脑,我们电脑拿到ip就会与目标服务器进行链接/">www.163.com的ip,就会返回他所对应的ip,本地DNS拿到ip后就会返回给电脑,我们电脑拿到ip就会与目标服务器进行链接</a>.<br>    5. 这就是一次DNS解析的全过程,<br>    6. 总结:<br>        电脑只是对本地域名解析服务器发起了一次请求,递归解析的过程都是DNS服务器帮忙处理,并且每次DNS服务器在拿到结果后,会把相关信息缓存到本地DNS缓存中,这样等下一次有相同的域名来访问的时候,他就会取到一个对应的ip进行访问,这样也能提高解析性能.</p><p>DNS服务器除了返回对应的IP还有两个作用:<br>    1. 负载均衡<br>    2. 就近访问:<br>        对于我们的应用为了保证他的高可用,我们一般将代码和数据部署在多个机房,每个机房都有自己的IP,并且这些机房托管在不同的运营商和不同的地域,同时对于我们的用户肯定希望北京的用户就近访问北京的数据中心,上海的用户就近访问上海的数据中心,如果是电信宽带就会访问电信数据中心,联通的就是联通数据中心,这样就能尽可能避免跨地域跨运营商之间的网络延迟,提升访问速度,这就是就近访问.</p><pre><code>如何实现就近访问呢?这里就需要我们的全局负载均衡器(简称GSLB).看一看他的执行方式上例子:    假设你有多个应用,这个应用穿过多个机房,并且这些机房托管在不同的运营商,用户的域名为file.abc.com,当一个客户端访问这个域名的时候,首先将这个域名转换成IP,所以客户端会向本地的DNS发起一个域名解析请求,跟上班一样,根域名请求.com等级域名,再从顶级服务器得到abc.com,再访问权威域名服务器,为了支持跨地名跨运营商的就近访问,配置的就不是file.abc.com的ip而是配置的是CNAME(别名),本地域名会通过这个CNAME(别名)访问GSLB服务器,请求查看他本地的运营商和地址,就知道用户的运营商和地址是什么了,这样GSLB就会返回一个和用户相同的运营商,并且返回一个最近机房的IP,给本地DNS,本地的DNS再加上IP返回给电脑,电脑拿着这个ip就能访问就近的机房.这样就通过DNS协议完成了高效的访问.</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>hashtable和hashmap</title>
    <link href="http://example.com/posts/55244/"/>
    <id>http://example.com/posts/55244/</id>
    <published>2020-12-23T01:35:48.000Z</published>
    <updated>2020-12-27T12:59:20.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>剑指offer手撕</title>
    <link href="http://example.com/posts/24772/"/>
    <id>http://example.com/posts/24772/</id>
    <published>2020-12-22T08:02:41.000Z</published>
    <updated>2020-12-27T12:59:20.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problemset/all/?search=%E6%89%BE%E5%88%B0%E5%BA%8F%E5%88%97%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0">跳转网页</a></p><h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50 第一个只出现一次的字符"></a>剑指 Offer 50 第一个只出现一次的字符</h3><p>一个循环<br>for(char c: s) = for(char c; c != ‘\0’; c++); 这里的c是下标index值.</p><p>一次遍历再加上哈希映射O(n) + O(1).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char firstUniqChar(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, bool&gt; dic;</span><br><span class="line">        for(char c : s)&#123;</span><br><span class="line">            dic[c] &#x3D; (dic.find(c) &#x3D;&#x3D; dic.end());</span><br><span class="line">        &#125;</span><br><span class="line">        for(char c : s)&#123;</span><br><span class="line">            if(dic[c]) return c;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43 1～n 整数中 1 出现的次数"></a>剑指 Offer 43 1～n 整数中 1 出现的次数</h3><p>看题解吧!!</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int countDigitOne(int n) &#123;</span><br><span class="line">                long digit &#x3D; 1;</span><br><span class="line">                int high &#x3D; n &#x2F; 10, cur &#x3D; n % 10, low &#x3D; 0;</span><br><span class="line">                int res &#x3D; 0;</span><br><span class="line">        while(high !&#x3D; 0 || cur !&#x3D; 0)&#123;</span><br><span class="line">            if(cur &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                                res +&#x3D; high * digit;</span><br><span class="line">                            </span><br><span class="line">            &#125;</span><br><span class="line">            else if(cur &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                                res +&#x3D; high * digit + low + 1;</span><br><span class="line">                            </span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                                res +&#x3D; (high + 1) * digit;</span><br><span class="line">                            </span><br><span class="line">            &#125;</span><br><span class="line">                        low +&#x3D; cur * digit;</span><br><span class="line">                        cur &#x3D; high % 10;</span><br><span class="line">                        high &#x2F;&#x3D; 10;</span><br><span class="line">                        digit *&#x3D; 10;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return res; </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44 数字序列中某一位的数字"></a>剑指 Offer 44 数字序列中某一位的数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int findNthDigit(int n) &#123;</span><br><span class="line">                if(n &#x3D;&#x3D; 0) &#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">                int digit &#x3D; 1; &#x2F;&#x2F; 数位（个位&#x2F;十位&#x2F;百位&#x2F;...，就是1&#x2F;2&#x2F;3&#x2F;...）</span><br><span class="line">                long start &#x3D; 1; &#x2F;&#x2F; 属于该数位的所有数的起始点数（个位是1，十位是10，百位是100）</span><br><span class="line">                long index_count &#x3D; digit * 9 * start; &#x2F;&#x2F; 该数位的数一共的索引个数（不是数字个数）</span><br><span class="line"></span><br><span class="line">        while(n &gt; index_count ) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 找出 n 属于那个数位里的索引</span><br><span class="line">                        n -&#x3D; index_count; </span><br><span class="line">                        ++ digit;</span><br><span class="line">                        start *&#x3D; 10;</span><br><span class="line">                        index_count &#x3D; digit * 9 * start;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                &#x2F;&#x2F; 上面的循环结束后：</span><br><span class="line">                &#x2F;&#x2F; digit 等于原始的 n 所属的数位；start 等于原始的 n 所属数位的数的起始点</span><br><span class="line">                &#x2F;&#x2F; index_count 等于原始的 n 所属数位的索引总个数（不重要了，下面不用）</span><br><span class="line">                &#x2F;&#x2F; n 等于在当前数位里的第 n - 1 个索引（索引从 0 开始算起）</span><br><span class="line"></span><br><span class="line">                long num &#x3D; start + (n - 1) &#x2F; digit; &#x2F;&#x2F; 算出原始的 n 到底对应哪个数字</span><br><span class="line">                int remainder &#x3D; (n - 1) % digit; &#x2F;&#x2F; 余数就是原始的 n 是这个数字中的第几位</span><br><span class="line"></span><br><span class="line">                string s_num &#x3D; to_string(num); &#x2F;&#x2F; 将该数字转为 string 类型</span><br><span class="line">                return int(s_num[remainder] - &#39;0&#39;); &#x2F;&#x2F; n 对应着第 remainder 位，再转成 int</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39 数组中出现次数超过一半的数字"></a>剑指 Offer 39 数组中出现次数超过一半的数字</h3><h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I 数组中数字出现的次数"></a>剑指 Offer 56 - I 数组中数字出现的次数</h3><h3 id="剑指-Offer-56-II数组中数字出现的次数-II"><a href="#剑指-Offer-56-II数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II数组中数字出现的次数 II"></a>剑指 Offer 56 - II数组中数字出现的次数 II</h3><h3 id="剑指-Offer-57-II和为s的连续正数序列"><a href="#剑指-Offer-57-II和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II和为s的连续正数序列"></a>剑指 Offer 57 - II和为s的连续正数序列</h3><h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52 两个链表的第一个公共节点"></a>剑指 Offer 52 两个链表的第一个公共节点</h3><h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31 栈的压入、弹出序列"></a>剑指 Offer 31 栈的压入、弹出序列</h3><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22 链表中倒数第k个节点"></a>剑指 Offer 22 链表中倒数第k个节点</h3><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04 二维数组中的查找"></a>剑指 Offer 04 二维数组中的查找</h3><h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I 在排序数组中查找数字 I"></a>剑指 Offer 53 - I 在排序数组中查找数字 I</h3><h3 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51  数组中的逆序对"></a>剑指 Offer 51  数组中的逆序对</h3><h3 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15 二进制中1的个数"></a>剑指 Offer 15 二进制中1的个数</h3><h3 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16 数值的整数次方"></a>剑指 Offer 16 数值的整数次方</h3><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09 用两个栈实现队列"></a>剑指 Offer 09 用两个栈实现队列</h3><h3 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41 数据流中的中位数"></a>剑指 Offer 41 数据流中的中位数</h3><h3 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60 n个骰子的点数"></a>剑指 Offer 60 n个骰子的点数</h3><h3 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25 合并两个排序的链表"></a>剑指 Offer 25 合并两个排序的链表</h3><h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03 数组中重复的数字"></a>剑指 Offer 03 数组中重复的数字</h3><h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57 和为s的两个数字"></a>剑指 Offer 57 和为s的两个数字</h3><h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33 二叉搜索树的后序遍历序列"></a>剑指 Offer 33 二叉搜索树的后序遍历序列</h3><h3 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37 序列化二叉树"></a>剑指 Offer 37 序列化二叉树</h3><h3 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62 圆圈中最后剩下的数字"></a>剑指 Offer 62 圆圈中最后剩下的数字</h3><h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40 最小的k个数"></a>剑指 Offer 40 最小的k个数</h3><h3 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34 二叉树中和为某一值的路径"></a>剑指 Offer 34 二叉树中和为某一值的路径</h3><h3 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67 把字符串转换成整数"></a>剑指 Offer 67 把字符串转换成整数</h3><h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21 调整数组顺序使奇数位于偶数前面</h3><h3 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17 打印从1到最大的n位数"></a>剑指 Offer 17 打印从1到最大的n位数</h3><h3 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19 正则表达式匹配"></a>剑指 Offer 19 正则表达式匹配</h3><h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12 矩阵中的路径"></a>剑指 Offer 12 矩阵中的路径</h3><h3 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61 扑克牌中的顺子"></a>剑指 Offer 61 扑克牌中的顺子</h3><h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II  0～n-1中缺失的数字"></a>剑指 Offer 53 - II  0～n-1中缺失的数字</h3><h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38 字符串的排列"></a>剑指 Offer 38 字符串的排列</h3><h3 id="剑指-Offer-59-II队列的最大值"><a href="#剑指-Offer-59-II队列的最大值" class="headerlink" title="剑指 Offer 59 - II队列的最大值"></a>剑指 Offer 59 - II队列的最大值</h3><h3 id="1539-第-k-个缺失的正整数"><a href="#1539-第-k-个缺失的正整数" class="headerlink" title="1539 第 k 个缺失的正整数"></a>1539 第 k 个缺失的正整数</h3><h3 id="LCP-11-期望个数统计"><a href="#LCP-11-期望个数统计" class="headerlink" title="LCP 11 期望个数统计"></a>LCP 11 期望个数统计</h3><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I 斐波那契数列"></a>剑指 Offer 10- I 斐波那契数列</h3><h3 id="38-字符串中的第一个唯一字符-7"><a href="#38-字符串中的第一个唯一字符-7" class="headerlink" title="38 字符串中的第一个唯一字符  7"></a>38 字符串中的第一个唯一字符  7</h3><h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54 二叉搜索树的第k大节点"></a>剑指 Offer 54 二叉搜索树的第k大节点</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leedcode" scheme="http://example.com/categories/leedcode/"/>
    
    
    <category term="leedcode" scheme="http://example.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://example.com/posts/44296/"/>
    <id>http://example.com/posts/44296/</id>
    <published>2020-12-22T01:19:04.000Z</published>
    <updated>2020-12-22T05:21:42.082Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>重点:<br>    1. 缓存穿透, 缓存击穿, 缓存雪崩.<br>    2. redis数据结构各种提问.<br>    3. redis持久化以及集群方案问题.</p><h3 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么?"></a>redis是什么?</h3><p>内存数据库(存储在内存中磁盘中的),数据结构数据库就是KV数据库(key-value).这里能想到memcached这个数据库也是内存数据库也是KV数据库(key-value)唯一不同的就是value只支持string类型,这个不能称为数据结构数据库.</p><h4 id="什么是数据结构数据库"><a href="#什么是数据结构数据库" class="headerlink" title="什么是数据结构数据库?"></a>什么是数据结构数据库?</h4><p>主要是key_value中的，value提供的数据结构,v:(string ,list(链表),hash(类似c/c++中的map&lt;type,type&gt; ), set(存储的值唯一就是去重),zset(实现的一个有序集合，用来实现一个实时的排行榜，比如游戏中的排名,mysql就很得隔一定时间刷新一遍．)，stream(存储的是消息队列，zeromq专门实现消息队列的一种方式，消息队列主要解决服务间通信的问题，能保证消息的缓冲作用，这些消息最终能到达另一个服务．))</p><h4 id="数据库详细理解"><a href="#数据库详细理解" class="headerlink" title="数据库详细理解:"></a>数据库详细理解:</h4><pre><code>什么叫内存式的数据结构呢例子:    client端, 服务器, redis.    服务器对redis进行操作的时候，就是对value中的数据结构进行操作．如何进行操作的呢?</code></pre><p>　　　　客户端通过发送命令的方式(这里是服务端对redis信息写入读取的方式)，比如操作类型为string类型，通过命令set hello word,写入redis中，如果想取出数据就需要get hello.　clent端如果登录会通过服务器取得redis中的个人信息，（这就是操作redis的操作流程）.</p><p>图: redis结构</p><h4 id="为什么使用这个redis-他的特性和功能是什么呢"><a href="#为什么使用这个redis-他的特性和功能是什么呢" class="headerlink" title="为什么使用这个redis?他的特性和功能是什么呢?"></a>为什么使用这个redis?他的特性和功能是什么呢?</h4><p>以前我们通过服务器对mysql进行数据的操作，频繁的访问mysql的话，mysql的(存栈)(这两个字可能存在问题)他是有限的,怎么解决这个问题，就是在中间增加一个缓存数据库(redis),同样的一个登录操作，如果加上了redis是如何的操作: (服务端操作)<br>    1. 首先查询redis.<br>    2. 如果没有,去mysql查询.mysql中的查询的值会保存到redis中，下次查询就会直接从这里读取信息.<br>    3. 如果有，redis返回.<br>    mysql的读写速度比redis的读写速度慢很多的.这样一来客户端登录如果从redis读取数据，会比从mysql中读取数据快很多,<br>    所以说引入redis就是为了解决mysql读写速度慢的问题，因为关系型数据库都是通过操作磁盘的方式，对b/b+树加索引，然后才去查询，redis都在内存中，他的读写速度非常块．<br>    总结redis的优点:<br>        1. 读写速度比关系型数据快.<br>        2. redis(操作数据结构能实现关系型数据库很难完成的功能)，比如zset实时的排行版，set在mysql中可能得设置唯一键问题，list根据插入顺序来完成一个有序性,hash在mysql中需要加入很多的字段，但是我们的hash只需要维护一个key-value．</p><p>多读源码，发现细节，得心应手!!!!</p><h3 id="重点来了"><a href="#重点来了" class="headerlink" title="重点来了"></a>重点来了</h3><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>产生的原因:(数据源(关系型数据库)存在数据，缓存(redis)不存在或者key过期了,如果此时有大量的请求过来，这些数据压力都会涌入mysql)</p><p>详细分析: 在clent端通过服务器对redis进行操作，查询到redis没有这个key值或者key值已经过期，这个时候就会重新进入mysql进行查询，如果这个查询非常多的话，就会产生过多的这样的问题，这种情况下redis就会成为一种负担，每次花费大量的开销来进行redis的查询,这是徒劳的.</p><h5 id="缓存击穿解决方法"><a href="#缓存击穿解决方法" class="headerlink" title="缓存击穿解决方法"></a>缓存击穿解决方法</h5><p>如果大量访问这个key值，<br>加锁:　具体方法用带成功返回值的命令 set(key, 1), 解锁就是　+ok set(key, 0).后面的请求就会知道这里加了锁，就不会将所有的请求加载到mysql.</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>解析问题: 数据源不存在，(缓存)redis也不存在.<br>这样会存在大量的重复的操作进入redis和mysql,这样一直访问redis或者mysql会造成对别的请求不可用的问题.</p><p>解决方案: 布隆过滤器<br>解决思路:<br>    一定不存在的问题用什么数据结构来解决?<br>    用哈希的方式hash<keybool>如果存在的话直接从redis中去取，不存在就去mysql去取,存储的数据比较多占用的内存比较高.<br>    布隆过滤器采用的是一个位图 (bitmap)固定长度的数组，每一位就是0或者1,<br>    图: 前哈希后布隆</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存重启或者大量缓存失效(这里主要是后者),一般是使用expire出现的问题,</p><p>那么问题来了:为什么将数据设置成过期呢(expire)?<br>不设置过期，数据就会越来越多，在redis缓存中一般记录最近查找的值，为了维护查询效率，就会设置这个过期时间，一定时间处理一些数据.<br>如果是重启，可以通过持久化的方式进行解决.</p><p>如果是大量缓存失效的问题?<br>如果大量缓存失效，就会导致大量的请求涌入到mysql中,跟缓存击穿很像，大量请求在mysql中堆积,</p><h5 id="缓存雪崩解决方案"><a href="#缓存雪崩解决方案" class="headerlink" title="缓存雪崩解决方案"></a>缓存雪崩解决方案</h5><p>缓存击穿可以加锁，这里也可以加锁，不同于缓存击穿的就是这里不是一个key引发的问题了，可能涉及到多个key.</p><ol><li>错开失效时间</li><li>加锁: 在服务器等待，直到得到锁再访问，防止大量数据访问mysql.</li><li>加消息队列: 把访问设置为一个队列，依次访问.<br>2, 3两种方式并不能解决根本的问题，如果给key加锁，响应的会有一定的延迟，这样服务器会堆积很多的请求，既没有去请求mysql也没有返回信息,这样没办法从根本解决问题.</li></ol><p>所以说从设计上来解决这个问题，就是1的方法(错开失效时间)(具体设计: 设置key过期的时候，避免同时失效.)</p><p>图: redis数据结构</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>跳表,用来zset有序集合</li><li>字典 hashtable</li></ol><p>相同数量级下，数据存储采用跳表和字典，空间占用怎么样?</p><h4 id="问题来了跳表是啥"><a href="#问题来了跳表是啥" class="headerlink" title="问题来了跳表是啥?"></a>问题来了跳表是啥?</h4><p>图:跳表结构<br>首先是一个有序的单链表（升序）．跳表就是加入了层级的查询的方式，这是一种完美的跳表，但是实际中的跳表会有增删改查等操作，(待续)</p><p>增加节点的值:<br>    zadd hello world 10<br>    zadd hello world 20 就是第一个节点为10,第二个节点为20，这些节点的级别数是随机的，这也是数量大于128的时候才能接近完美的跳边(满足二分查找的效率).对这个推论有一个论文可查!!读它.</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><pre><code>读源码看出它是通过两个hashtable来实现的，数组+hash来确定位置，避免冲的时候会用挂链表的方法解决冲突.为什么是两个数组呢?因为集中大量的插入的时候,短的数组不够用了，就需要rehash的方式，把第一个数组中的数拷贝到第二个数组中（第二个数组长度是第一个长度的2倍），如果数据量很大的时候，就需要通过渐进式rehash的方式，进行拷贝，如果是原来的rehash拷贝，如果这里也用这个原样拷贝的方式，会很浪费cpu的资源，不能够提供及时的服务.渐进式rehash的方式，两种方法:    1. 对dict操作的时是 增删改查　操作的时候rehash 1次    2. while(rehash时间 &lt; 1ms)&#123;        rehash 100个循环.    &#125;</code></pre><p>这里开始解决上边提到的问题:<br>    跳表的数据浪费主要是跳边建立的层级，<br>    图: rehash比较图 这里的rehash看上边对渐进式rehash.</p><h3 id="数据结构存储相关的知识"><a href="#数据结构存储相关的知识" class="headerlink" title="数据结构存储相关的知识"></a>数据结构存储相关的知识</h3><p>时间与空间均衡的过程(模型一直在变化)<br>这里就涉及到zset底层采用什么样存储方式?<br>图: 时间与空间均衡的过程</p><h3 id="redis持久化和集群"><a href="#redis持久化和集群" class="headerlink" title="redis持久化和集群"></a>redis持久化和集群</h3><p>持久化: 就是持久化我们的写操作,读操作没有必要持久化.<br>持久化的两种方式:<br>    1. rdb: 一段时间的写操作．<br>    2. aof: 每一次的写操作.<br>    这两种方式在配置中进行的，一般同时开启两种，采用混用的方式.<br>    有时候会丢掉一段时间的数据，这里就是只打开了rdb这种方式，</p><p>集群方式:<br>    1. 主从: 主要解决单点故障问题(redis突然宕机或者是硬盘损坏数据就会丢失，通过主从数据（数据备份）)来解决．<br>    这里就是redis高可用的基础,<br>    遵循cap原则:<br>        c: 一致性 : 修改密码依然登录．<br>        a: 可用性 : 一个节点宕机了，别的节点依然可以提供服务．<br>        p: 分区容错性 : 比如两个地区不了连同了，依然能支持cap原则.</p><pre><code>高可用: 合理的时间返回合理的结果．2. 哨兵:     解决高可用的问题．    图: 哨兵解释图    需要奇数个节点进行投票选集要替换的节点.    如果哨兵死掉，就会切换哨兵，但是也要保证是奇数个哨兵.3. cluster集群:    对redis横向扩展的问题,    图: cluster点的扩展, 三个节点如果加入新的节点，就需要crc(key) 取莫运算16384,插入节点的位置，别的方法还有一致性哈希.</code></pre><p>为什么单线程那么快呢?</p><h2 id="补充-每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作"><a href="#补充-每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作" class="headerlink" title="补充: 每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作."></a>补充: 每个redis都是单线程提供服务，如果想要更快的服务，需要多线程一起工作.</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Tcp/Ip协议栈</title>
    <link href="http://example.com/posts/40290/"/>
    <id>http://example.com/posts/40290/</id>
    <published>2020-12-19T14:43:48.000Z</published>
    <updated>2020-12-21T14:14:13.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="今天主题，手写协议栈"><a href="#今天主题，手写协议栈" class="headerlink" title="今天主题，手写协议栈"></a>今天主题，手写协议栈</h3><h4 id="什么叫协议栈"><a href="#什么叫协议栈" class="headerlink" title="什么叫协议栈?"></a>什么叫协议栈?</h4><p>简单来说现有来两个端，A端，B端,假设A端向B端发送数据，计算机网络采用的是五层结构(应传网数物)，A端通过send()函数把应用层数据(hello)发送给B端口,中间需要在每一层加上相关的协议(前边有讲)头部或者尾部，因为这些协议的组成类似于栈的结构，详细说就是在A端放封装的协议，在B端是以相反的顺序进行解封的，符合了栈的结构特性，先进后出,所以名字叫协议栈．</p><p>物理层确切的来说就是，双绞线等传输的电信号/光信号.<br>在数据链路层拿到的就是数字信号(010101这样的).</p><p>网卡属于哪一层?<br>网卡起到了A/D转换的功能(A模拟，D数字).网卡他不是协议栈里边的东西，详细说网卡就是把物理层的数据转换为数据链路层的数据．send()刚好相反．所以说他哪一层都不属于!</p><h4 id="实现一个协议栈之前了解"><a href="#实现一个协议栈之前了解" class="headerlink" title="实现一个协议栈之前了解"></a>实现一个协议栈之前了解</h4><p>zero-copy零拷贝.<br>例子: 在一个服务器或者客户端:<br>    A 网卡　B内核协议栈　C应用程序.<br>    AB属于内核态，ｃ属于用户态.<br>    从网络中该服务器收到了一个信息，比如hello, 会通过网卡copy到内核协议栈中，网卡数据到达内核协议栈这个东西用什么来进行储存呢，这里有一个有名的东西叫SK-buffer.第二次拷贝就是调用receive函数（receive_buffer），从协议栈拷贝到引用程序里边(就是说应用程序通过receive_buffer来拷贝得到应用程序)，一般数据的传输就是经过这两次的拷贝，下面特殊的零拷贝来了<br>什么叫做零拷贝?<br>网卡是一个外设，内存之外的就是外存,外设也有存储空间，网卡通过A/D转换把信息放到自己存储空间的时候，由于外设存在存储空间，就通过DMA的方式，映射到内存里边，内存里的数据跟网卡里存储的数据是一样．注意这里不叫复制，复制是通过cpu把源地址的东西拷贝到目的地址，DMA和Cpu没什么特别大的关系，内存被映射的地方称为mmap,在应用程序操作这个内存的时候，不能叫读取，读取是指从外存读入到内存．在内存中不叫读(叫操作).这样数据进入内存之后，我们cpu直接进行数据操作就可以了，所以这就是零拷贝.</p><p>协议栈就是基于DMA的方式，先把裸数据放到内存，再进行内存数据的操作．<br>图协议栈的基础实现．</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>以太网协议头</p><p>目的地址(6字节)　源地址(6字节)　类型(2字节)　数据和填充(46字节-1500字节)　CRC(4字节).</p><p>用户数据的存储不能是一个指针，只能是一个数字首地址(柔性数组也叫零长数组,不占用任何空间)，这样发出去的包能找到所对应的数值．<br>柔性数组应用场景:<br>    1. 数组的内存分配好了．<br>    2. 数组的大小未知（但是可以通过其他方式计算的）．</p><p>数据的操作:<br>    网卡来一段数据，发送给内核协议栈标识为可读（fd指向网卡内存标识可读，我们操作的是内存中的数据，跟文件读取不一样），我们应用程序来操作内存中的数据拷贝的数据.</p><p>ringbuffer:<br>    就是把外存的信息启动mmap映射到内存，构建一个环形队列，就是ringbuffer.直接去next就能到下一个数据.断开前后指针，直接操作，在内存中不用拷贝(没有用到cpu的mv指令).</p><p>弄清楚netmap了之后，下边带你在ubuntu(linux)环境下部署环境.</p><h4 id="netmap环境部署"><a href="#netmap环境部署" class="headerlink" title="netmap环境部署"></a><a href="https://blog.csdn.net/weixin_43326322/article/details/108265924">netmap环境部署</a></h4><h5 id="修改网卡名称"><a href="#修改网卡名称" class="headerlink" title="修改网卡名称"></a>修改网卡名称</h5><p>在我的Ubuntu版本上，网关默认的就是eth类型,如果默认的网卡名称是ens32.这里需要修改为eth类型.</p><p>sudo vim /etc/default/grub<br>修改里面 GRUB_CMDLINE_LINUX=“net.ifnames=0 biosdevname=0”<br>.重新生成grub引导配置文件 ：sudo grub-mkconfig -o /boot/grub/grub.cfg</p><p>安装netmap（抓包工具配合网络小助手发送信息可以查看包的信息）</p><ol><li>git clone <a href="https://gitee.com/mirrors/netmap.git">https://gitee.com/mirrors/netmap.git</a></li><li>./configure</li><li>sudo make</li><li>sudo make install</li><li>insmod netmap.ko</li></ol><p>将ens33修改为eth0<br>sudo vim /etc/network/interfaces进行ifconfig，发现网卡名称并没有变，不知道是不是因为没有重启的原因。所以进行重启。再重启之前，再网上看到了重启后找不到网络的错误，所以进行了下面的设置，但是建议配置完上面的步骤后进行重启.<br>sudo vim /etc/netplan/01-network-manager-all.yaml</p><p>重启查看：ifconfig</p><h4 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;poll.h&gt;</span><br><span class="line">#include&lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#define NETMAP_WITH_LIBS</span><br><span class="line">#include &lt;net&#x2F;netmap_user.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#pragma pack(1) &#x2F;&#x2F;以一个字节对齐，因为以四个字节对齐会有一个空挡.四字节对齐sizeof(odppkt)44字节，一个对齐就是42字节.</span><br><span class="line">#define ETH_ALEN 6</span><br><span class="line">#define PROTO_IP 0x0800</span><br><span class="line">#define PROTO_UDP 17</span><br><span class="line">struct ethhdr&#123;&#x2F;&#x2F;以太网格式 </span><br><span class="line">    unsigned char h_dest[ETH_ALEN];&#x2F;&#x2F;目的地址</span><br><span class="line">    unsigned char h_src[ETH_ALEN];&#x2F;&#x2F;源地址</span><br><span class="line">    unsigned short h_proto;&#x2F;&#x2F;类型</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct iphdr &#123;&#x2F;&#x2F;ip协议格式</span><br><span class="line">              &#x2F;&#x2F;4位版本号，四位首部长度(表示的是字节数不是字节数要*4变成字节: 15 * 4 &#x3D; 60).</span><br><span class="line">    unsigned char version:4,</span><br><span class="line">                  hdrlen:4;</span><br><span class="line">    unsigned char tos;&#x2F;&#x2F;八位服务类型(TOS)实时服务&#x2F;非实时服务等</span><br><span class="line">    unsigned char totlen;&#x2F;&#x2F;十六位总长度</span><br><span class="line">    unsigned short id;&#x2F;&#x2F;十六位标识</span><br><span class="line">    unsigned short flags: 3,&#x2F;&#x2F;三位标志位</span><br><span class="line">                   offset: 13;&#x2F;&#x2F;十三位偏移</span><br><span class="line">    unsigned short ttl; &#x2F;&#x2F;8位生存时间.(生存时间).</span><br><span class="line">    unsigned char proto;&#x2F;&#x2F;8位协议，解析这里判断传输层的协议.</span><br><span class="line">    unsigned char check;&#x2F;&#x2F;16位首部检验和</span><br><span class="line">    unsigned int sip;&#x2F;&#x2F;源地址ip 四个字节</span><br><span class="line">    unsigned int dip;&#x2F;&#x2F;目的地址ip</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;udp的头部.简单</span><br><span class="line">struct udphdr&#123;&#x2F;&#x2F;都是两个字节</span><br><span class="line">    unsigned short sport;</span><br><span class="line">    unsigned short dport;</span><br><span class="line">    unsigned short length;</span><br><span class="line">    unsigned short check; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现一个udp的包</span><br><span class="line">struct udppkt&#123;</span><br><span class="line">    struct ethhdr eh;    &#x2F;&#x2F;14</span><br><span class="line">    struct iphdr ip;     &#x2F;&#x2F;20</span><br><span class="line">    struct udphdr udp;   &#x2F;&#x2F;8</span><br><span class="line">    unsigned char body[];&#x2F;&#x2F;用户数据如何定义？</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F;把网卡的数据映射到内存三种方式1.dpdk kin 2.net map 3.pf_ring</span><br><span class="line">    struct nm_desc *nmr &#x3D; nm_open(&quot;netmap:eth0&quot;, NULL, 0, NULL);&#x2F;&#x2F;映射网卡，就是打开的映射网卡的那块内存.</span><br><span class="line">    if(nmr &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct pollfd pfd &#x3D; &#123;0&#125;;</span><br><span class="line">    pfd.fd &#x3D; nmr-&gt;fd;</span><br><span class="line">    pfd.events &#x3D; POLLIN;</span><br><span class="line">    </span><br><span class="line">    while(1)&#123;</span><br><span class="line">       int ret &#x3D;  poll(&amp;pfd, 1, -1);&#x2F;&#x2F;单独一个IO不用用epoll;</span><br><span class="line">        if(ret &lt; 0) continue;</span><br><span class="line">        if(pfd.revents &amp; POLLIN)&#123;</span><br><span class="line">            struct nm_pkthdr h;</span><br><span class="line">            unsigned char *stream &#x3D; nm_nextpkt(nmr, &amp;h);&#x2F;&#x2F;取下一个包,从环形队列拿出buffer</span><br><span class="line">            struct ethhdr *eh &#x3D; (struct ethhdr*)stream;&#x2F;&#x2F;给他强转为以太网格式，判断是不是我们要的以太网．以此类推各个层的协议是否合适如果不合适直接丢弃.</span><br><span class="line">            if(ntohs(eh-&gt;h_proto) &#x3D;&#x3D; PROTO_IP )&#123;&#x2F;&#x2F;大小端判断转换字节续的问题只要超过两位就转换.</span><br><span class="line">                &#x2F;&#x2F;如果是个ip;</span><br><span class="line">                struct udppkt *udp &#x3D; (struct udppkt*)stream;&#x2F;&#x2F;发送出去的时候网络中有一个统一的字节序，这个不用管.</span><br><span class="line">                if(udp-&gt;ip.proto &#x3D;&#x3D; PROTO_UDP )&#123;</span><br><span class="line">                    int udplen &#x3D; ntohs(udp-&gt;udp.length);&#x2F;&#x2F;整个长度，我们把八个字节后的body部分打印出来.</span><br><span class="line">                    udp-&gt;body[udplen - 8] &#x3D; &#39;\0&#39;;</span><br><span class="line">                    printf(&quot;%s\n&quot;, udp-&gt;body);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>这里需要结合信息的传输逻辑来思考．</p><ol><li>首先网关接受信息，需要进行网关ip的确定．</li><li>编译我们的程序．打开运行工具insmod netmap.ko　</li><li>运行程序查看包的信息.</li></ol><p>两个问题:</p><ol><li>发包之后不能ping通.(因为数据从我们的应用程序走，不通过正常路径走，icmp协议没有实现)</li><li>过一段时间就不能再发送包了.（arp协议没有实现）<br>arp(协议) —&gt;arp(应用)<br>icmp(协议)—&gt;ping(应用)</li></ol><p>用户态协议栈.(网卡优化,比如零拷贝减少了复制的次数)<br>内核协议栈可以通过看端口有没有被占用.</p><p>c10m（千万并发问题）用来解决，用到的是零拷贝.<br>————————————————-第一部分完结—————————————-</p><h3 id="Tcp-Ip协议栈深度解析"><a href="#Tcp-Ip协议栈深度解析" class="headerlink" title="Tcp/Ip协议栈深度解析"></a>Tcp/Ip协议栈深度解析</h3><h4 id="如何实现tcp"><a href="#如何实现tcp" class="headerlink" title="如何实现tcp"></a>如何实现tcp</h4><p>前四块就是协议的实现.</p><ol><li>协议头</li><li>三次握手/四次挥手，11状态迁移</li><li>tcp的顺序,如何保证有序，延迟ack/滑动窗口</li><li>定时器，rtt,满启动与拥塞控制.</li><li>posix send.recv接口的实现,epoll如何实现.(epoll可读可写的事件从哪里触发的到的)</li></ol><h4 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h4><p>客户端: client<br>服务器: server</p><p>第一次: c-&gt;s syn置1,seq =23452 (随机值)<br>第二次: s-&gt;c 回复一个ack置1, acknum = 23453(seq + 1返回,表示前边都已经确认了再加上本身的1,syn置1, seq有一个随机值5436)值为无符号整形，到达上限会重新开始.<br>第三次: c–&gt;s ack置1,acknum = 5437(seq + 1).</p><h5 id="三次握手如何实现"><a href="#三次握手如何实现" class="headerlink" title="三次握手如何实现"></a>三次握手如何实现</h5><p>第一次握手，服务端如何保存客户端的握手信息？<br>创建一个连接队列，（名字叫半连接状态队列）实现的时候叫syn队列.<br>第三次握手，服务端如何保存客户端的握手信息?<br>同样也会创建一个连接队列（名字叫全连接队列），收到第三次握手时服务端会把信息与半链接状态队列中的信息进行比较，如果一致半连接队列中的数据会被直接把节点拿)到全连接状态队列，(accept队列),这些节点会伴随整个连接过程的．这些节点叫tcb(tcp控制块).</p><p>accept函数:<br>    从accept队列里面取出一个节点，并分配一个fd</p><p>listen(fd, backlog);<br>fd : 是服务器listen的fd.<br>backlog : 半连接队列和全连接队列的总长度(两个队列中只是节点的转移，不考虑删除等操作).<br>一般的时候syn队列中节点比较多.accept队列中的节点少，甚至为零.</p><p>如果大量的泛洪攻击服务器的话会产生什么后果?</p><p>如果客户端不给服务端回ack的话会有什么后果?服务器出现什么状态?<br>会出现半连接队列满的情况，服务器会崩溃，内核会爆．</p><p>图: tcp三次握手的五种状态<br>tcp的十一种状态:<br>    1.<br>    2.<br>    3.<br>    4.<br>    5. </p><p>四次挥手</p><p>在三次握手的时候就会区分客户和服务端，在四次挥手的时候就不会区分客户端和服务端．只有一端对应另一端（主动方和被动方）．<br>A方调用了close发送fin给B方,就是关闭了A方对B方的发送通道,被动方会发一个ACK,B(被动方)也会返送一个fin给主动方,主动方也会返回一个ACK,</p><p>第二次和第三次可以合在一起?<br>可以! 在什么时候可以合在一起呢?<br>和延迟ACK有关系,第一次返回ACK的时候，如果出现延迟的时候，恰好被动方也调用了close这个时候就会把连个包放在一起发送,就会变成三次挥手了,如果在第一个返回ACK后，隔一段时间再发fin就是两次,</p><p>十一种状态主要保存在哪里,每一个tcp,每一个socket,每一个连接都会有一个状态，这个状态保存在哪里?<br>tcb中的，绝对是tcb中的(这个就是上边说的那个节点).</p><p>图:四次挥手状态迁移图<br>如果出现很多close_wait状态现象是什么情况?</p><p>在被动方调用close这个函数不正常就会产生close_wait这个状态.</p><p>time_wait: 作用是什么呢?<br>第一个作用:确保最后一个ack能接收到，如果这个ack丢失，处在LAST_ACK状态就会定一个定时器，如果时间到了就会重新发送一个fin.<br>第二个作用: 防止上一次的数据和下一次数据的链接混淆.</p><p>四次挥手除了图中的五个状态，还会有另外的一种closing状态,中间的两条线都是被动方发过去的，一共有三种情况:<br>    1. 先发ack过一段时间发fin,会出现FIN_WAIT2的状态.<br>    2. 先发fin过一段时间发ack这个时候会出现closing状态.(没办法确定第一次的fin有没有到)<br>    3. ack + fin 同时发送这时候就会出现time_wait状态.</p><p>tcp如何保证顺序的?<br>由于包在网络中传输的过程路径选择等原因造成包的变成无序的，在一个包到了之后会儿等待两百毫秒,比如1号包到了等两百毫秒，如果2号包到了之后会重置定时器,再等200毫秒,在超时的时候，会判断那个包之前的包都收到了，就对应的回一个确认消息（这个包的序号），通过延迟ack来确认这个包是有顺序的．</p><p>既然tcp是可靠传输，为什么还会出现udp可靠传输呢?<br>udp有两种应用:<br>    1. 下载，有tcp的拥塞控制.<br>    2. udp的实时性:<br>        延迟ack也是为了增加tcp的传输效率<br>        udp牺牲了这种效率来完成实时性.</p><p>如何确定发送包的多少呢?<br>慢启动与拥塞控制<br>慢启动: 就是成指数增长,就比如说1, 2, 4,…<br>这里涉及到了拥塞控制门限值，第一次初始化他是有一个默认值的，超过这个值的时候就会自然增长（就是加1这样的），总的来说前面是指数增长后边是线性增长,直到这个包收不到的时候（发生拥塞了（默认为是网络带宽的问题）），产生拥塞的那个值除以2, 再正常增长，开始那个指数增长就是慢开始，后边指数增长的时候就是拥塞控制，慢启动计算出来的这个值就是滑动窗口的大小．</p><p>发送窗口:<br>    发送的端会通过两个指针把发送队列分成三部分，已经发送，允许发送，不允许发送．允许发送的窗口的大小就是慢启动计算出来的那个值．<br>    对应允许发送窗口的接收方的就是使用了延迟ack来确定的．</p><p>(ack)定时器的时间如何设置?(ack延时多久回复一个ack呢)<br>第一个挥手收到的ack(这里所确定的确定定时器)，这里的定时器的超时如何设置?<br>从三次握手的时候第一个ack回复的时候就会记录一个这个样的值，称为rtt(从发送到确认这段时间的der塔值),他的公式为rtt = 0.9*old_rtt + 0.1 * new_rtt,采用这个公式完成消抖(上下抖动过高)的过程,这样就能计算出下一次的rtt, new_rtt(上一个rtt),old_rtt表示上上一个，用相关的系数来消除new_rtt过高或者过低引起的抖动问题.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>c++8</title>
    <link href="http://example.com/posts/28273/"/>
    <id>http://example.com/posts/28273/</id>
    <published>2020-12-19T01:47:32.000Z</published>
    <updated>2020-12-21T14:14:13.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ping命令的实现"><a href="#ping命令的实现" class="headerlink" title="ping命令的实现"></a>ping命令的实现</h3><p><a href="https://blog.csdn.net/qq_33724710/article/details/51576444">相关实现</a></p><h3 id="udp实现可靠通信"><a href="#udp实现可靠通信" class="headerlink" title="udp实现可靠通信"></a>udp实现可靠通信</h3><p><a href="https://blog.csdn.net/gettogetto/article/details/76736365">udp可靠性通信</a></p><h3 id="什么情况必须用UDP代替tcp"><a href="#什么情况必须用UDP代替tcp" class="headerlink" title="什么情况必须用UDP代替tcp"></a>什么情况必须用UDP代替tcp</h3><h3 id="DNS服务器解析"><a href="#DNS服务器解析" class="headerlink" title="DNS服务器解析"></a>DNS服务器解析</h3><p><a href="https://www.cnblogs.com/gopark/p/8430916.html">详细解释</a><br><a href="https://www.cnblogs.com/gopark/p/8430936.html">DNS解析过程详解</a></p><h3 id="高并发直接对数据库访问-优化"><a href="#高并发直接对数据库访问-优化" class="headerlink" title="高并发直接对数据库访问,优化"></a>高并发直接对数据库访问,优化</h3><h3 id="数据库底层实现"><a href="#数据库底层实现" class="headerlink" title="数据库底层实现"></a>数据库底层实现</h3><h3 id="最大连续子数组和"><a href="#最大连续子数组和" class="headerlink" title="最大连续子数组和"></a>最大连续子数组和</h3><h3 id="单-cpu-多线程实现"><a href="#单-cpu-多线程实现" class="headerlink" title="单 cpu 多线程实现"></a>单 cpu 多线程实现</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="交换单链表的第-n-个节点和倒数第-m-个节点"><a href="#交换单链表的第-n-个节点和倒数第-m-个节点" class="headerlink" title="交换单链表的第 n 个节点和倒数第 m 个节点"></a>交换单链表的第 n 个节点和倒数第 m 个节点</h3><h3 id="写一个程序判定系统是大端模式还是小端模式"><a href="#写一个程序判定系统是大端模式还是小端模式" class="headerlink" title="写一个程序判定系统是大端模式还是小端模式"></a>写一个程序判定系统是大端模式还是小端模式</h3><h3 id="实现-memmove-函数"><a href="#实现-memmove-函数" class="headerlink" title="实现 memmove()函数"></a>实现 memmove()函数</h3><h3 id="attribute-关键字"><a href="#attribute-关键字" class="headerlink" title="attribute 关键字"></a>attribute 关键字</h3><h3 id="位域的概念"><a href="#位域的概念" class="headerlink" title="位域的概念"></a>位域的概念</h3><h3 id="memory-barry"><a href="#memory-barry" class="headerlink" title="memory barry"></a>memory barry</h3><h3 id="int-foo-5-int-const-char-是什么意思"><a href="#int-foo-5-int-const-char-是什么意思" class="headerlink" title="int * (*foo[5]) (int, const char *) 是什么意思"></a>int * (*foo[5]) (int, const char *) 是什么意思</h3><h3 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h3><h3 id="操作系统从上电到启动的过程"><a href="#操作系统从上电到启动的过程" class="headerlink" title="操作系统从上电到启动的过程"></a>操作系统从上电到启动的过程</h3><h3 id="KVM-和-Xen-的区别"><a href="#KVM-和-Xen-的区别" class="headerlink" title="KVM 和 Xen 的区别"></a>KVM 和 Xen 的区别</h3><h3 id="特权指令和敏感指令的区别"><a href="#特权指令和敏感指令的区别" class="headerlink" title="特权指令和敏感指令的区别"></a>特权指令和敏感指令的区别</h3><h3 id="Linux-从用户态切换到内核态的过程"><a href="#Linux-从用户态切换到内核态的过程" class="headerlink" title="Linux 从用户态切换到内核态的过程"></a>Linux 从用户态切换到内核态的过程</h3><h3 id="操作系统访问-IO-的过程"><a href="#操作系统访问-IO-的过程" class="headerlink" title="操作系统访问 IO 的过程"></a>操作系统访问 IO 的过程</h3><h3 id="软中断和硬中断的区别"><a href="#软中断和硬中断的区别" class="headerlink" title="软中断和硬中断的区别"></a>软中断和硬中断的区别</h3><h3 id="C-语言编译链接的过程"><a href="#C-语言编译链接的过程" class="headerlink" title="C 语言编译链接的过程"></a>C 语言编译链接的过程</h3><h3 id="函数调用压栈的过程"><a href="#函数调用压栈的过程" class="headerlink" title="函数调用压栈的过程"></a>函数调用压栈的过程</h3><h3 id="以及现在操作系统对栈的优化"><a href="#以及现在操作系统对栈的优化" class="headerlink" title="以及现在操作系统对栈的优化"></a>以及现在操作系统对栈的优化</h3><h3 id="进程和线程的区别-进程间通信机制"><a href="#进程和线程的区别-进程间通信机制" class="headerlink" title="进程和线程的区别,进程间通信机制,"></a>进程和线程的区别,进程间通信机制,</h3><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议,"></a>TCP 协议,</h3><h3 id="static-关键字的用法"><a href="#static-关键字的用法" class="headerlink" title="static 关键字的用法,"></a>static 关键字的用法,</h3><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别,"></a>堆和栈的区别,</h3><h3 id="C-语言内存分配"><a href="#C-语言内存分配" class="headerlink" title="C 语言内存分配"></a>C 语言内存分配</h3><h3 id="对高负载有了解么"><a href="#对高负载有了解么" class="headerlink" title="对高负载有了解么"></a>对高负载有了解么</h3><h3 id="对高并发有了解么"><a href="#对高并发有了解么" class="headerlink" title="对高并发有了解么?"></a>对高并发有了解么?</h3><h3 id="Arraylist-的原理"><a href="#Arraylist-的原理" class="headerlink" title="Arraylist 的原理"></a>Arraylist 的原理</h3><h3 id="场景题-设计判断论文抄袭的系统"><a href="#场景题-设计判断论文抄袭的系统" class="headerlink" title="场景题:设计判断论文抄袭的系统"></a>场景题:设计判断论文抄袭的系统</h3><h3 id="堆排序的原理"><a href="#堆排序的原理" class="headerlink" title="堆排序的原理"></a>堆排序的原理</h3><h3 id="抽象工厂和工厂方法模式的区别"><a href="#抽象工厂和工厂方法模式的区别" class="headerlink" title="抽象工厂和工厂方法模式的区别"></a>抽象工厂和工厂方法模式的区别</h3><h3 id="工厂模式的思想"><a href="#工厂模式的思想" class="headerlink" title="工厂模式的思想"></a>工厂模式的思想</h3><h3 id="Forward-和-redirect-的区别"><a href="#Forward-和-redirect-的区别" class="headerlink" title="Forward 和 redirect 的区别"></a>Forward 和 redirect 的区别</h3><h3 id="线程池的使用时的注意事项"><a href="#线程池的使用时的注意事项" class="headerlink" title="线程池的使用时的注意事项"></a>线程池的使用时的注意事项</h3><h3 id="Spring-中-autowire-和-resourse-关键字的区别"><a href="#Spring-中-autowire-和-resourse-关键字的区别" class="headerlink" title="Spring 中 autowire 和 resourse 关键字的区别"></a>Spring 中 autowire 和 resourse 关键字的区别</h3><h3 id="Hashmap-的原理"><a href="#Hashmap-的原理" class="headerlink" title="Hashmap 的原理"></a>Hashmap 的原理</h3><h3 id="Hashmap-的大小为什么指定为-2-的幂次"><a href="#Hashmap-的大小为什么指定为-2-的幂次" class="headerlink" title="Hashmap 的大小为什么指定为 2 的幂次"></a>Hashmap 的大小为什么指定为 2 的幂次</h3><h3 id="讲一下线程状态转移图"><a href="#讲一下线程状态转移图" class="headerlink" title="讲一下线程状态转移图"></a>讲一下线程状态转移图</h3><h3 id="消息队列了解么"><a href="#消息队列了解么" class="headerlink" title="消息队列了解么"></a>消息队列了解么</h3><h3 id="分布式了解么"><a href="#分布式了解么" class="headerlink" title="分布式了解么"></a>分布式了解么</h3><h3 id="来个算法题-一个无序数组-其中一个数字出现的次数大于其他数字之和-求"><a href="#来个算法题-一个无序数组-其中一个数字出现的次数大于其他数字之和-求" class="headerlink" title="来个算法题:一个无序数组,其中一个数字出现的次数大于其他数字之和, 求"></a>来个算法题:一个无序数组,其中一个数字出现的次数大于其他数字之和, 求</h3><h3 id="这个数字-主元素"><a href="#这个数字-主元素" class="headerlink" title="这个数字 (主元素)"></a>这个数字 (主元素)</h3><h3 id="答完再来一个-一个数组-有正有负-不改变顺序的情况下-求和最大的最-长子序列"><a href="#答完再来一个-一个数组-有正有负-不改变顺序的情况下-求和最大的最-长子序列" class="headerlink" title="答完再来一个:一个数组,有正有负,不改变顺序的情况下,求和最大的最 长子序列"></a>答完再来一个:一个数组,有正有负,不改变顺序的情况下,求和最大的最 长子序列</h3><h3 id="项目用到什么数据库-隔离级别-每个隔离级别各做了什么"><a href="#项目用到什么数据库-隔离级别-每个隔离级别各做了什么" class="headerlink" title="项目用到什么数据库?隔离级别?每个隔离级别各做了什么"></a>项目用到什么数据库?隔离级别?每个隔离级别各做了什么</h3><h3 id="数据库的索引-mysql-不同引擎索引的区别"><a href="#数据库的索引-mysql-不同引擎索引的区别" class="headerlink" title="数据库的索引?mysql 不同引擎索引的区别"></a>数据库的索引?mysql 不同引擎索引的区别</h3><h3 id="垃圾回收算法的过程"><a href="#垃圾回收算法的过程" class="headerlink" title="垃圾回收算法的过程"></a>垃圾回收算法的过程</h3><h3 id="数据库的索引"><a href="#数据库的索引" class="headerlink" title="数据库的索引"></a>数据库的索引</h3><h3 id="对算法有什么了解-答主先回答了动态规划-解释了一下-dp-的思想"><a href="#对算法有什么了解-答主先回答了动态规划-解释了一下-dp-的思想" class="headerlink" title="对算法有什么了解?答主先回答了动态规划,解释了一下 dp 的思想"></a>对算法有什么了解?答主先回答了动态规划,解释了一下 dp 的思想</h3><h3 id="快排的思想讲一下"><a href="#快排的思想讲一下" class="headerlink" title="快排的思想讲一下"></a>快排的思想讲一下</h3><h3 id="tcp-怎么保证可靠传输-中间穿插了好多小问题"><a href="#tcp-怎么保证可靠传输-中间穿插了好多小问题" class="headerlink" title="tcp 怎么保证可靠传输(中间穿插了好多小问题)"></a>tcp 怎么保证可靠传输(中间穿插了好多小问题)</h3><h3 id="Tcp-的拥塞控制"><a href="#Tcp-的拥塞控制" class="headerlink" title="Tcp 的拥塞控制"></a>Tcp 的拥塞控制</h3><h3 id="让你设计一个即时聊天的系统"><a href="#让你设计一个即时聊天的系统" class="headerlink" title="让你设计一个即时聊天的系统"></a>让你设计一个即时聊天的系统</h3><h3 id="支付宝转账-是如何实现-几个小时通知转账成功的-面试官想让回答长连接-答主一直没-get-到点"><a href="#支付宝转账-是如何实现-几个小时通知转账成功的-面试官想让回答长连接-答主一直没-get-到点" class="headerlink" title="支付宝转账,是如何实现,几个小时通知转账成功的(面试官想让回答长连接,答主一直没 get 到点)"></a>支付宝转账,是如何实现,几个小时通知转账成功的(面试官想让回答长连接,答主一直没 get 到点)</h3><h3 id="解释一下长连接"><a href="#解释一下长连接" class="headerlink" title="解释一下长连接"></a>解释一下长连接</h3><h3 id="手撕算法-一棵二叉排序树-给定一个数-找到与给定数差值最小的数"><a href="#手撕算法-一棵二叉排序树-给定一个数-找到与给定数差值最小的数" class="headerlink" title="手撕算法:一棵二叉排序树,给定一个数,找到与给定数差值最小的数"></a>手撕算法:一棵二叉排序树,给定一个数,找到与给定数差值最小的数</h3><h3 id="场景题-设计一个系统-解决抢购时所需要的大量的短链接的功能-如何保证高并发-如何设计短链接"><a href="#场景题-设计一个系统-解决抢购时所需要的大量的短链接的功能-如何保证高并发-如何设计短链接" class="headerlink" title="场景题:设计一个系统,解决抢购时所需要的大量的短链接的功能,如何保证高并发,如何设计短链接"></a>场景题:设计一个系统,解决抢购时所需要的大量的短链接的功能,如何保证高并发,如何设计短链接</h3><h3 id="设计题-设计一个系统-记录-qq-用户前一天的登录状态-提供-16g-内存和2tb-的硬盘-要做到查询指定qq号的前一天的登录状态-快速查询-O-1-复杂度"><a href="#设计题-设计一个系统-记录-qq-用户前一天的登录状态-提供-16g-内存和2tb-的硬盘-要做到查询指定qq号的前一天的登录状态-快速查询-O-1-复杂度" class="headerlink" title="设计题:设计一个系统,记录 qq 用户前一天的登录状态,提供 16g 内存和2tb 的硬盘,要做到查询指定qq号的前一天的登录状态,快速查询 O(1)复杂度"></a>设计题:设计一个系统,记录 qq 用户前一天的登录状态,提供 16g 内存和2tb 的硬盘,要做到查询指定qq号的前一天的登录状态,快速查询 O(1)复杂度</h3><h3 id="手撕算法-两个排序的数组-A-和-B-分别含有-m-和-n-个数-找到两个排序数组的中位-数-答主用的二分-时间复杂度为-O-log-m-n-。结果面试官不满意-让用归并的思-想做-时间复杂度其实更高了"><a href="#手撕算法-两个排序的数组-A-和-B-分别含有-m-和-n-个数-找到两个排序数组的中位-数-答主用的二分-时间复杂度为-O-log-m-n-。结果面试官不满意-让用归并的思-想做-时间复杂度其实更高了" class="headerlink" title="手撕算法:两个排序的数组 A 和 B 分别含有 m 和 n 个数,找到两个排序数组的中位 数,答主用的二分,时间复杂度为 O(log (m+n))。结果面试官不满意,让用归并的思 想做,时间复杂度其实更高了"></a>手撕算法:两个排序的数组 A 和 B 分别含有 m 和 n 个数,找到两个排序数组的中位 数,答主用的二分,时间复杂度为 O(log (m+n))。结果面试官不满意,让用归并的思 想做,时间复杂度其实更高了</h3><h3 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h3><h3 id="数据库的引擎"><a href="#数据库的引擎" class="headerlink" title="数据库的引擎"></a>数据库的引擎</h3><h3 id="算法题-给一个整数数组-找到两个数使得他们的和等于一个给定的数"><a href="#算法题-给一个整数数组-找到两个数使得他们的和等于一个给定的数" class="headerlink" title="算法题:给一个整数数组,找到两个数使得他们的和等于一个给定的数"></a>算法题:给一个整数数组,找到两个数使得他们的和等于一个给定的数</h3><h3 id="自己写一个-tomcat-服务器-你会怎么写"><a href="#自己写一个-tomcat-服务器-你会怎么写" class="headerlink" title="自己写一个 tomcat 服务器,你会怎么写"></a>自己写一个 tomcat 服务器,你会怎么写</h3><h3 id="一千万用户并发抢购-怎么设计"><a href="#一千万用户并发抢购-怎么设计" class="headerlink" title="一千万用户并发抢购,怎么设计"></a>一千万用户并发抢购,怎么设计</h3><h3 id="讲一下数据的-acid"><a href="#讲一下数据的-acid" class="headerlink" title="讲一下数据的 acid"></a>讲一下数据的 acid</h3><h3 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h3><h3 id="什么是隔离性"><a href="#什么是隔离性" class="headerlink" title="什么是隔离性"></a>什么是隔离性</h3><h3 id="Mysql-的隔离级别"><a href="#Mysql-的隔离级别" class="headerlink" title="Mysql 的隔离级别"></a>Mysql 的隔离级别</h3><h3 id="每个隔离级别是如何解决"><a href="#每个隔离级别是如何解决" class="headerlink" title="每个隔离级别是如何解决"></a>每个隔离级别是如何解决</h3><h3 id="然后面试官设置了每个参数-给了是个线程-让描述出完整的线程池执行的流程"><a href="#然后面试官设置了每个参数-给了是个线程-让描述出完整的线程池执行的流程" class="headerlink" title="然后面试官设置了每个参数,给了是个线程,让描述出完整的线程池执行的流程"></a>然后面试官设置了每个参数,给了是个线程,让描述出完整的线程池执行的流程</h3><h3 id="Linux-了解么"><a href="#Linux-了解么" class="headerlink" title="Linux 了解么"></a>Linux 了解么</h3><h3 id="怎么查看系统负载"><a href="#怎么查看系统负载" class="headerlink" title="怎么查看系统负载"></a>怎么查看系统负载</h3><h3 id="Cpu-load-的参数如果为-4-描述一下现在系统处于什么情况"><a href="#Cpu-load-的参数如果为-4-描述一下现在系统处于什么情况" class="headerlink" title="Cpu load 的参数如果为 4,描述一下现在系统处于什么情况"></a>Cpu load 的参数如果为 4,描述一下现在系统处于什么情况</h3><h3 id="Linux-查找磁盘上最大的文件的命令"><a href="#Linux-查找磁盘上最大的文件的命令" class="headerlink" title="Linux,查找磁盘上最大的文件的命令"></a>Linux,查找磁盘上最大的文件的命令</h3><h3 id="Linux-如何查看系统日志文件"><a href="#Linux-如何查看系统日志文件" class="headerlink" title="Linux,如何查看系统日志文件"></a>Linux,如何查看系统日志文件</h3><h3 id="手撕算法-leeetcode-原题-22-Generate-Parentheses-给定-n-对括号-请写一个函数-以将其生成新的括号组合-并返回所有组合结果。"><a href="#手撕算法-leeetcode-原题-22-Generate-Parentheses-给定-n-对括号-请写一个函数-以将其生成新的括号组合-并返回所有组合结果。" class="headerlink" title="手撕算法:leeetcode 原题 22,Generate Parentheses,给定 n 对括号,请写一个函数 以将其生成新的括号组合,并返回所有组合结果。"></a>手撕算法:leeetcode 原题 22,Generate Parentheses,给定 n 对括号,请写一个函数 以将其生成新的括号组合,并返回所有组合结果。</h3><h3 id="数据库的索引原理"><a href="#数据库的索引原理" class="headerlink" title="数据库的索引原理"></a>数据库的索引原理</h3><h3 id="非聚簇索引和聚簇索引"><a href="#非聚簇索引和聚簇索引" class="headerlink" title="非聚簇索引和聚簇索引"></a>非聚簇索引和聚簇索引</h3><h3 id="索引的使用注意事项"><a href="#索引的使用注意事项" class="headerlink" title="索引的使用注意事项"></a>索引的使用注意事项</h3><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><h3 id="从底层解释最左匹配原则"><a href="#从底层解释最左匹配原则" class="headerlink" title="从底层解释最左匹配原则"></a>从底层解释最左匹配原则</h3><h3 id="Mysql-对联合索引有优化么-会自动调整顺序么-哪个版本开始优化"><a href="#Mysql-对联合索引有优化么-会自动调整顺序么-哪个版本开始优化" class="headerlink" title="Mysql 对联合索引有优化么?会自动调整顺序么?哪个版本开始优化?"></a>Mysql 对联合索引有优化么?会自动调整顺序么?哪个版本开始优化?</h3><h3 id="手撕一个单例模式"><a href="#手撕一个单例模式" class="headerlink" title="手撕一个单例模式"></a>手撕一个单例模式</h3><h3 id="快速排序的思想讲一下"><a href="#快速排序的思想讲一下" class="headerlink" title="快速排序的思想讲一下"></a>快速排序的思想讲一下</h3><h3 id="给个数组-模拟快排的过程"><a href="#给个数组-模拟快排的过程" class="headerlink" title="给个数组,模拟快排的过程"></a>给个数组,模拟快排的过程</h3><h3 id="手写快排"><a href="#手写快排" class="headerlink" title="手写快排"></a>手写快排</h3><h3 id="反爬虫的机制-有哪些方式"><a href="#反爬虫的机制-有哪些方式" class="headerlink" title="反爬虫的机制,有哪些方式"></a>反爬虫的机制,有哪些方式</h3><h3 id="手撕算法-反转单链表"><a href="#手撕算法-反转单链表" class="headerlink" title="手撕算法:反转单链表"></a>手撕算法:反转单链表</h3><h3 id="手撕算法-实现类似微博子结构的数据结构-输入一系列父子关系-输出一"><a href="#手撕算法-实现类似微博子结构的数据结构-输入一系列父子关系-输出一" class="headerlink" title="手撕算法:实现类似微博子结构的数据结构,输入一系列父子关系,输出一"></a>手撕算法:实现类似微博子结构的数据结构,输入一系列父子关系,输出一</h3><h3 id="个类似微博-评论的父子结构图设计题-一个图书馆管理系统-数据库怎么设计-需求自己定"><a href="#个类似微博-评论的父子结构图设计题-一个图书馆管理系统-数据库怎么设计-需求自己定" class="headerlink" title="个类似微博 评论的父子结构图设计题,一个图书馆管理系统,数据库怎么设计,需求自己定"></a>个类似微博 评论的父子结构图设计题,一个图书馆管理系统,数据库怎么设计,需求自己定</h3><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><h3 id="手撕算法-爬楼梯-写出状态转移方程"><a href="#手撕算法-爬楼梯-写出状态转移方程" class="headerlink" title="手撕算法: 爬楼梯,写出状态转移方程"></a>手撕算法: 爬楼梯,写出状态转移方程</h3><h3 id="智力题-时针分针什么时候重合"><a href="#智力题-时针分针什么时候重合" class="headerlink" title="智力题:时针分针什么时候重合"></a>智力题:时针分针什么时候重合</h3><h3 id="多线程条件变量为什么要在-while-体里"><a href="#多线程条件变量为什么要在-while-体里" class="headerlink" title="多线程条件变量为什么要在 while 体里"></a>多线程条件变量为什么要在 while 体里</h3><h3 id="会不会滥用设计模式"><a href="#会不会滥用设计模式" class="headerlink" title="会不会滥用设计模式"></a>会不会滥用设计模式</h3><h3 id="多线程的理解-如何保证线程安全"><a href="#多线程的理解-如何保证线程安全" class="headerlink" title="多线程的理解,如何保证线程安全"></a>多线程的理解,如何保证线程安全</h3><h3 id="场景题-千万用户抢购-如何处理高并发-并且有一个链接-指向前一天抢"><a href="#场景题-千万用户抢购-如何处理高并发-并且有一个链接-指向前一天抢" class="headerlink" title="场景题:千万用户抢购,如何处理高并发,并且有一个链接,指向前一天抢"></a>场景题:千万用户抢购,如何处理高并发,并且有一个链接,指向前一天抢</h3><h3 id="购成功的用-户-如何设计这个系统和数据库"><a href="#购成功的用-户-如何设计这个系统和数据库" class="headerlink" title="购成功的用 户,如何设计这个系统和数据库"></a>购成功的用 户,如何设计这个系统和数据库</h3><h3 id="如果后台处理抢购请求的服务器-每次最多承受-200-的负载-系统该怎么设计"><a href="#如果后台处理抢购请求的服务器-每次最多承受-200-的负载-系统该怎么设计" class="headerlink" title="如果后台处理抢购请求的服务器,每次最多承受 200 的负载,系统该怎么设计"></a>如果后台处理抢购请求的服务器,每次最多承受 200 的负载,系统该怎么设计</h3><h3 id="最小公倍数和最大公约数"><a href="#最小公倍数和最大公约数" class="headerlink" title=":最小公倍数和最大公约数"></a>:最小公倍数和最大公约数</h3><h3 id="个完整请求的流程"><a href="#个完整请求的流程" class="headerlink" title="个完整请求的流程"></a>个完整请求的流程</h3><h3 id="Mysql-的容灾备份"><a href="#Mysql-的容灾备份" class="headerlink" title="Mysql 的容灾备份"></a>Mysql 的容灾备份</h3><h3 id="写一个两个有序链表合并成一个有序链表"><a href="#写一个两个有序链表合并成一个有序链表" class="headerlink" title="写一个两个有序链表合并成一个有序链表"></a>写一个两个有序链表合并成一个有序链表</h3><h3 id="死锁是什么呢"><a href="#死锁是什么呢" class="headerlink" title="死锁是什么呢"></a>死锁是什么呢</h3><h3 id="怎么解决死锁"><a href="#怎么解决死锁" class="headerlink" title="怎么解决死锁"></a>怎么解决死锁</h3><h3 id="http-请求流程"><a href="#http-请求流程" class="headerlink" title="http 请求流程"></a>http 请求流程</h3><h3 id="为什么负载均衡"><a href="#为什么负载均衡" class="headerlink" title="为什么负载均衡"></a>为什么负载均衡</h3><h3 id="怎么实现负载均衡"><a href="#怎么实现负载均衡" class="headerlink" title="怎么实现负载均衡"></a>怎么实现负载均衡</h3><h3 id="数据库挂了怎么办-除了热备份还有什么方法"><a href="#数据库挂了怎么办-除了热备份还有什么方法" class="headerlink" title="数据库挂了怎么办?除了热备份还有什么方法"></a>数据库挂了怎么办?除了热备份还有什么方法</h3><h3 id="算法-找出两个数组相等的数-不能用其他数据结构"><a href="#算法-找出两个数组相等的数-不能用其他数据结构" class="headerlink" title="算法:找出两个数组相等的数,不能用其他数据结构"></a>算法:找出两个数组相等的数,不能用其他数据结构</h3><h3 id="算法-给定一个数字-一个数组-找出数组中相加等于这两个数的和-不能用数据结构"><a href="#算法-给定一个数字-一个数组-找出数组中相加等于这两个数的和-不能用数据结构" class="headerlink" title="算法:给定一个数字,一个数组,找出数组中相加等于这两个数的和,不能用数据结构"></a>算法:给定一个数字,一个数组,找出数组中相加等于这两个数的和,不能用数据结构</h3><h3 id="算法-如何判断一个树是不是另一颗树的子树"><a href="#算法-如何判断一个树是不是另一颗树的子树" class="headerlink" title="算法:如何判断一个树是不是另一颗树的子树"></a>算法:如何判断一个树是不是另一颗树的子树</h3><h3 id="如何解决并发访问的错误I-操作怎么保证线程安全"><a href="#如何解决并发访问的错误I-操作怎么保证线程安全" class="headerlink" title="如何解决并发访问的错误I++操作怎么保证线程安全"></a>如何解决并发访问的错误I++操作怎么保证线程安全</h3><h3 id="场景题-设计一个下单系统-下单成功后可以给用户发优惠券"><a href="#场景题-设计一个下单系统-下单成功后可以给用户发优惠券" class="headerlink" title="场景题:设计一个下单系统,下单成功后可以给用户发优惠券"></a>场景题:设计一个下单系统,下单成功后可以给用户发优惠券</h3><h3 id="接上面场景题-服务器挂了-优惠券还没发怎么办"><a href="#接上面场景题-服务器挂了-优惠券还没发怎么办" class="headerlink" title="接上面场景题:服务器挂了,优惠券还没发怎么办"></a>接上面场景题:服务器挂了,优惠券还没发怎么办</h3><h3 id="数据库挂了怎么怎么办"><a href="#数据库挂了怎么怎么办" class="headerlink" title="数据库挂了怎么怎么办"></a>数据库挂了怎么怎么办</h3><h3 id="怎么保证一致性"><a href="#怎么保证一致性" class="headerlink" title="怎么保证一致性"></a>怎么保证一致性</h3><h3 id="分布式事务知道么"><a href="#分布式事务知道么" class="headerlink" title="分布式事务知道么"></a>分布式事务知道么</h3><h3 id="介绍分布式事务"><a href="#介绍分布式事务" class="headerlink" title="介绍分布式事务"></a>介绍分布式事务</h3><h3 id="锁的实现原理"><a href="#锁的实现原理" class="headerlink" title="锁的实现原理"></a>锁的实现原理</h3><h3 id="怎么解决缓存和主存的一致性问题"><a href="#怎么解决缓存和主存的一致性问题" class="headerlink" title="怎么解决缓存和主存的一致性问题"></a>怎么解决缓存和主存的一致性问题</h3><h3 id="缓存还没更新到主存-服务器挂了怎么办"><a href="#缓存还没更新到主存-服务器挂了怎么办" class="headerlink" title="缓存还没更新到主存,服务器挂了怎么办"></a>缓存还没更新到主存,服务器挂了怎么办</h3><h3 id="数据库挂了怎么办"><a href="#数据库挂了怎么办" class="headerlink" title="数据库挂了怎么办"></a>数据库挂了怎么办</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h3 id="什么时候用读锁"><a href="#什么时候用读锁" class="headerlink" title="什么时候用读锁"></a>什么时候用读锁</h3><h3 id="什么时候用写锁"><a href="#什么时候用写锁" class="headerlink" title="什么时候用写锁"></a>什么时候用写锁</h3><h3 id="数据库的瓶颈"><a href="#数据库的瓶颈" class="headerlink" title="数据库的瓶颈"></a>数据库的瓶颈</h3><h3 id="常见的内存泄漏-内存溢出-怎么解决"><a href="#常见的内存泄漏-内存溢出-怎么解决" class="headerlink" title="常见的内存泄漏/内存溢出?怎么解决"></a>常见的内存泄漏/内存溢出?怎么解决</h3><h3 id="手写一个有序数组的合并"><a href="#手写一个有序数组的合并" class="headerlink" title="手写一个有序数组的合并?"></a>手写一个有序数组的合并?</h3><h3 id="用最小的时间复杂度判断单链表是否有交点。"><a href="#用最小的时间复杂度判断单链表是否有交点。" class="headerlink" title="用最小的时间复杂度判断单链表是否有交点。"></a>用最小的时间复杂度判断单链表是否有交点。</h3><h3 id="手写二叉树的按层级进行遍历"><a href="#手写二叉树的按层级进行遍历" class="headerlink" title="手写二叉树的按层级进行遍历"></a>手写二叉树的按层级进行遍历</h3><h3 id="算法-翻转一个-int-型的大数-Linux-管道的作用。"><a href="#算法-翻转一个-int-型的大数-Linux-管道的作用。" class="headerlink" title="算法:翻转一个 int 型的大数,Linux 管道的作用。"></a>算法:翻转一个 int 型的大数,Linux 管道的作用。</h3><h3 id="手撕代码-版本号-每次加一-到-99-变成进位"><a href="#手撕代码-版本号-每次加一-到-99-变成进位" class="headerlink" title="手撕代码: 版本号,每次加一,到 99 变成进位"></a>手撕代码: 版本号,每次加一,到 99 变成进位</h3><h3 id="udp-和-tcp-区别"><a href="#udp-和-tcp-区别" class="headerlink" title="udp 和 tcp 区别"></a>udp 和 tcp 区别</h3><h3 id="linux-基本命令-给个-ip-地址-char"><a href="#linux-基本命令-给个-ip-地址-char" class="headerlink" title="linux 基本命令 给个 ip 地址(char*)"></a>linux 基本命令 给个 ip 地址(char*)</h3><h3 id="写个程序判断是否合法"><a href="#写个程序判断是否合法" class="headerlink" title="写个程序判断是否合法"></a>写个程序判断是否合法</h3><h3 id="日志中有用户名-上线、下线时间-如何统计每秒的用户在线数"><a href="#日志中有用户名-上线、下线时间-如何统计每秒的用户在线数" class="headerlink" title="日志中有用户名,上线、下线时间,如何统计每秒的用户在线数"></a>日志中有用户名,上线、下线时间,如何统计每秒的用户在线数</h3><h3 id="智力题-8-个球球-找不一样的"><a href="#智力题-8-个球球-找不一样的" class="headerlink" title="智力题,8 个球球,找不一样的"></a>智力题,8 个球球,找不一样的</h3><h3 id="怎么定位移动端的元素"><a href="#怎么定位移动端的元素" class="headerlink" title="怎么定位移动端的元素"></a>怎么定位移动端的元素</h3><h3 id="代码-是-kmp-算法的那个题目-楼主一看就知道自己写不出来-就说能不能写"><a href="#代码-是-kmp-算法的那个题目-楼主一看就知道自己写不出来-就说能不能写" class="headerlink" title="代码: 是 kmp 算法的那个题目,楼主一看就知道自己写不出来,就说能不能写"></a>代码: 是 kmp 算法的那个题目,楼主一看就知道自己写不出来,就说能不能写</h3><h3 id="两个-for-循环-面试官愉快的同意了-写完程序-面试官让写测试用例-测试这"><a href="#两个-for-循环-面试官愉快的同意了-写完程序-面试官让写测试用例-测试这" class="headerlink" title="两个 for 循环,面试官愉快的同意了 写完程序,面试官让写测试用例,测试这"></a>两个 for 循环,面试官愉快的同意了 写完程序,面试官让写测试用例,测试这</h3><h3 id="个程序-说出程序的问题-指导我改正-人超级-nice"><a href="#个程序-说出程序的问题-指导我改正-人超级-nice" class="headerlink" title="个程序 说出程序的问题,指导我改正,人超级 nice"></a>个程序 说出程序的问题,指导我改正,人超级 nice</h3><h3 id="链表逆转"><a href="#链表逆转" class="headerlink" title="链表逆转"></a>链表逆转</h3><h3 id="自己建立个链表测试一下那个程序"><a href="#自己建立个链表测试一下那个程序" class="headerlink" title="自己建立个链表测试一下那个程序"></a>自己建立个链表测试一下那个程序</h3><h3 id="链表的冒泡-不可以换数据-交换节点的那种"><a href="#链表的冒泡-不可以换数据-交换节点的那种" class="headerlink" title="链表的冒泡(不可以换数据,交换节点的那种)"></a>链表的冒泡(不可以换数据,交换节点的那种)</h3><h3 id="手写代码-手写冒泡排序"><a href="#手写代码-手写冒泡排序" class="headerlink" title="手写代码:手写冒泡排序"></a>手写代码:手写冒泡排序</h3><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><h3 id="死锁原因及解决方法"><a href="#死锁原因及解决方法" class="headerlink" title="死锁原因及解决方法"></a>死锁原因及解决方法</h3><h3 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h3><h3 id="手写代码-寻找二维数组的鞍点"><a href="#手写代码-寻找二维数组的鞍点" class="headerlink" title="手写代码:寻找二维数组的鞍点"></a>手写代码:寻找二维数组的鞍点</h3><h3 id="c-语言各种变量所在的节"><a href="#c-语言各种变量所在的节" class="headerlink" title="c 语言各种变量所在的节"></a>c 语言各种变量所在的节</h3><h3 id="C-虚函数的实现"><a href="#C-虚函数的实现" class="headerlink" title="C++虚函数的实现"></a>C++虚函数的实现</h3><h3 id="有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。"><a href="#有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。" class="headerlink" title="有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。"></a>有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。</h3><h3 id="两个单向链表-有公共节点-有多少种结构。-考虑有环和无环的各种情况"><a href="#两个单向链表-有公共节点-有多少种结构。-考虑有环和无环的各种情况" class="headerlink" title="两个单向链表,有公共节点,有多少种结构。(考虑有环和无环的各种情况)"></a>两个单向链表,有公共节点,有多少种结构。(考虑有环和无环的各种情况)</h3><h3 id="epoll-的工作模式。"><a href="#epoll-的工作模式。" class="headerlink" title="epoll 的工作模式。"></a>epoll 的工作模式。</h3><h3 id="100G-的文件-分发的-100-个机器上-机器之间互相联通-带宽千兆。最少数据是多少。-这一题答的稀烂-想挂电话"><a href="#100G-的文件-分发的-100-个机器上-机器之间互相联通-带宽千兆。最少数据是多少。-这一题答的稀烂-想挂电话" class="headerlink" title="100G 的文件,分发的 100 个机器上,机器之间互相联通,带宽千兆。最少数据是多少。(这一题答的稀烂,想挂电话)"></a>100G 的文件,分发的 100 个机器上,机器之间互相联通,带宽千兆。最少数据是多少。(这一题答的稀烂,想挂电话)</h3><h3 id="二叉树查找最近"><a href="#二叉树查找最近" class="headerlink" title="二叉树查找最近"></a>二叉树查找最近</h3><h3 id="公共祖先、求平方根"><a href="#公共祖先、求平方根" class="headerlink" title="公共祖先、求平方根"></a>公共祖先、求平方根</h3><h3 id="翻转二叉树-写代码"><a href="#翻转二叉树-写代码" class="headerlink" title="翻转二叉树 写代码"></a>翻转二叉树 写代码</h3><h3 id="tcp-关闭连接的过程-为什么要四次"><a href="#tcp-关闭连接的过程-为什么要四次" class="headerlink" title="tcp 关闭连接的过程, 为什么要四次?"></a>tcp 关闭连接的过程, 为什么要四次?</h3><h3 id="问了操作系统的内存管理-分页和分段的区别"><a href="#问了操作系统的内存管理-分页和分段的区别" class="headerlink" title="问了操作系统的内存管理, 分页和分段的区别"></a>问了操作系统的内存管理, 分页和分段的区别</h3><h3 id="银行家算法原理"><a href="#银行家算法原理" class="headerlink" title="银行家算法原理"></a>银行家算法原理</h3><h3 id="写程序-翻转链表"><a href="#写程序-翻转链表" class="headerlink" title="写程序 翻转链表"></a>写程序 翻转链表</h3><h3 id="算法题-atoi-实现-主要看代码细节"><a href="#算法题-atoi-实现-主要看代码细节" class="headerlink" title="算法题:atoi 实现,主要看代码细节"></a>算法题:atoi 实现,主要看代码细节</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>

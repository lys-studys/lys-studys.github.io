<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌上花开缓缓归</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-16T07:29:24.711Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lys-studys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leedcode-tree</title>
    <link href="http://example.com/posts/31131/"/>
    <id>http://example.com/posts/31131/</id>
    <published>2020-11-16T01:00:18.000Z</published>
    <updated>2020-11-16T07:29:24.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h4><p>代码写了四种遍历方式下的不同代码．<br>递归步骤</p><ol><li>确认边界:</li><li>递归部分:</li><li>递归处理:<br>类似后序遍历,判断两个子孩子的值来返回父节点的值．进行公共父节点查询.</li></ol><p>`</p><p>tion for a binary tree node.</p><ul><li><p>struct TreeNode {</p><ul><li><pre><code>int val;</code></pre></li><li><pre><code>TreeNode *left;</code></pre></li><li><pre><code>TreeNode *right;</code></pre></li><li><pre><code>TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</code></pre></li><li><p>};<br><em>/<br>class Solution {<br>public:<br>TreeNode</em> invertTree(TreeNode* root) {</p><pre><code>     //先序遍历     /*      if(root == NULL) return root;      TreeNode *rightTree = root-&gt;right;          // 交换左右子树的位置      root-&gt;right = invertTree(root-&gt;left);      root-&gt;left = invertTree(rightTree);      return root;      */     //中序遍历     /*      if (root == NULL) return root;      invertTree(root-&gt;left); // 递归找到左节点      TreeNode *rightNode= root-&gt;right; // 保存右节点      root-&gt;right = root-&gt;left;      root-&gt;left = rightNode;          // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left      invertTree(root-&gt;left);      return root;     */     //后续遍历      /*      if(root == NULL) return root;      TreeNode *left = invertTree(root-&gt;left);      TreeNode *right =  invertTree(root-&gt;right);      root-&gt;right = left;      root-&gt;left = right;      return root;      */      //层次遍历      if(root == NULL) return NULL;      queue&lt;TreeNode *&gt; q;      q.push(root);</code></pre><p>  while(!q.empty()){</p><pre><code>              TreeNode *node = q.front();              q.pop();              TreeNode *rightTree = node-&gt;right;              node-&gt;right = node-&gt;left;              node-&gt;left = rightTree;              if(node-&gt;left != NULL) q.push(node-&gt;left);              if(node-&gt;right != NULL) q.push(node-&gt;right);</code></pre><p>  }</p><pre><code>      return root;</code></pre></li></ul></li></ul><pre><code> &#125;</code></pre><p> };```</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="tree联系" scheme="http://example.com/categories/tree%E8%81%94%E7%B3%BB/"/>
    
    
    <category term="tree练习" scheme="http://example.com/tags/tree%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++5</title>
    <link href="http://example.com/posts/43952/"/>
    <id>http://example.com/posts/43952/</id>
    <published>2020-11-14T01:19:42.000Z</published>
    <updated>2020-11-15T15:43:11.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-里面的同步和互斥怎么实现的"><a href="#c-里面的同步和互斥怎么实现的" class="headerlink" title="c++里面的同步和互斥怎么实现的"></a>c++里面的同步和互斥怎么实现的</h3><h3 id="c-里面的常量怎么定义"><a href="#c-里面的常量怎么定义" class="headerlink" title="c++里面的常量怎么定义"></a>c++里面的常量怎么定义</h3><p>c++中定义常量有两种方法：</p><ol><li>使用#define预处理器</li><li>使用const关键字</li></ol><p>就定义常量说的话： const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。</p><p>就起作用的阶段而言： define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。</p><p>就起作用的方式而言： define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。</p><p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。<br>对于局部对象，常量存放在栈区；<br>对于全局对象，常量存放在全局/静态存储区。<br>对于字面值常量，比如字符串，常量存放在常量存储区。</p><h3 id="c-的智能指针"><a href="#c-的智能指针" class="headerlink" title="c++的智能指针"></a>c++的智能指针</h3><h4 id="智能指针的原理"><a href="#智能指针的原理" class="headerlink" title="智能指针的原理"></a>智能指针的原理</h4><ol><li><p>你知道智能指针吗？智能指针的原理。<br>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放，</p></li><li><p>常用的智能指针。</p></li><li><p>智能指针的实现。</p><h4 id="常用的智能指针"><a href="#常用的智能指针" class="headerlink" title="常用的智能指针"></a>常用的智能指针</h4></li><li><p>td::auto_ptr，有很多问题。不支持复制（拷贝构造函数）和赋值（operator =），但复制或赋值的时候不会提示出错。因为不能被复制，所以不能被放入容器中。</p></li><li><p>C++11引入的unique_ptr， 也不支持复制和赋值，但比auto_ptr好，直接赋值会编译出错。实在想赋值的话，需要使用：std::move。<br>例如：</p><p> std::unique_ptr<int> p1(new int(5));<br> std::unique_ptr<int> p2 = p1; // 编译会出错<br> std::unique_ptr<int> p3 = std::move(p1); // 转移所有权, 现在那块内存归p3所有, p1成为无效的指针.</p></li><li><p>C++11或boost的shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。</p></li></ol><p>创建与赋值:<br>    shared_ptr<int> sp(new int(10));//不推荐，避免使用new,应该采用下面的方法创建与赋值.<br>    shared_ptr<int> sp2 = make_shared<int>(10);//应该用make_shared代替new,这一个shared_ptr的工厂函数.使用new会破坏delete在函数中的对称性．<br>    不要把一个裸指针给多个shared_ptr对象管理，避免多次释放同一个裸指针，第一个shared_ptr参数为裸指针外，其他的都是shared_ptr对象.作为参数.<br>    可以通过加{}来控制析构的位置．</p><ol start="4"><li>C++11或boost的weak_ptr，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。</li></ol><h4 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h4><p>下面是一个基于引用计数的智能指针的实现，需要实现构造，析构，拷贝构造，=操作符重载，重载*-和&gt;操作符。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    SmartPointer(T* p&#x3D;0): _ptr(p), _reference_count(new size_t)&#123;</span><br><span class="line">        if(p)</span><br><span class="line">            *_reference_count &#x3D; 1;</span><br><span class="line">        else</span><br><span class="line">            *_reference_count &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">    SmartPointer(const SmartPointer&amp; src) &#123;</span><br><span class="line">        if(this!&#x3D;&amp;src) &#123;</span><br><span class="line">            _ptr &#x3D; src._ptr;</span><br><span class="line">            _reference_count &#x3D; src._reference_count;</span><br><span class="line">            (*_reference_count)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重载赋值操作符</span><br><span class="line">    SmartPointer&amp; operator&#x3D;(const SmartPointer&amp; src) &#123;</span><br><span class="line">        if(_ptr&#x3D;&#x3D;src._ptr) &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        releaseCount();</span><br><span class="line">        _ptr &#x3D; src._ptr;</span><br><span class="line">        _reference_count &#x3D; src._reference_count;</span><br><span class="line">        (*_reference_count)++;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重载操作符</span><br><span class="line">    T&amp; operator*() &#123;</span><br><span class="line">        if(ptr) &#123;</span><br><span class="line">            return *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;throw exception</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重载操作符</span><br><span class="line">    T* operator-&gt;() &#123;</span><br><span class="line">        if(ptr) &#123;</span><br><span class="line">            return _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;throw exception</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;析构函数</span><br><span class="line">    ~SmartPointer() &#123;</span><br><span class="line">        if (--(*_reference_count) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            delete _ptr;</span><br><span class="line">            delete _reference_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T *_ptr;</span><br><span class="line">        size_t *_reference_count;</span><br><span class="line">        void releaseCount() &#123;</span><br><span class="line">        if(_ptr) &#123;</span><br><span class="line">            (*_reference_count)--;</span><br><span class="line">                if((*_reference_count)&#x3D;&#x3D;0) &#123;</span><br><span class="line">                    delete _ptr;</span><br><span class="line">                    delete _reference_count;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SmartPointer&lt;char&gt; cp1(new char(&#39;a&#39;));</span><br><span class="line">    SmartPointer&lt;char&gt; cp2(cp1);</span><br><span class="line">    SmartPointer&lt;char&gt; cp3;</span><br><span class="line">    cp3 &#x3D; cp2;</span><br><span class="line">    cp3 &#x3D; cp1;</span><br><span class="line">    cp3 &#x3D; cp3;</span><br><span class="line">    SmartPointer&lt;char&gt; cp4(new char(&#39;b&#39;));</span><br><span class="line">    cp3 &#x3D; cp4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C-虚函数的实现"><a href="#C-虚函数的实现" class="headerlink" title="C++虚函数的实现"></a>C++虚函数的实现</h3><ol><li>虚函数是通过一张虚函数表实现的，有多少个虚函数，就有多少个指针；</li><li>在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题；</li><li>实际上在编译的时候，编译器会自动加上虚表</li><li>虚函数的作用实现动态联编，也就是说在程序运行阶段动态的选择合适的成员函数，在定义了虚函数之后，可以在基类的派生类中对虚函数重新定义。</li><li>虚表的使用方法是如果派生类在自己定义中没有修改基类的虚函数，我们就指向基类的虚函数；如果派生类改写了基类的虚函数，这时续表则将原来指向基类的虚函数的地址替换为指向自身虚函数的指针。注意续表!!!每个类都会有一个自己的表</li><li>必须通过基类类型的引用或指针进行函数调用才会发生多态</li></ol><h3 id="有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。"><a href="#有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。" class="headerlink" title="有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。"></a>有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。</h3><p>值为15</p><p>int sum = 0;<br>void Func ()<br>{<br>    for (int i = 0; i &lt; 10; ++i)<br>    sum += 2;</p><p>}<br>这个和一个接一个执行没有区别，并发性只是可能会导致同一时间sum+4，加出来还是40，不会说少加了，也不会说两个线程 分开，一个线程加5次，哪怕减也一样。平时我们遇到的并发性所导致的问题如，写日志的时候，多个线程同时往一个日志文件写数据（很常见），如果不加互斥锁，写出来的数据可能会杂乱无章，失去了数据原应该代表的信息，或者多个线程对一块资源请求的时候，如果每个线程在请求完之后都会改变请求的资源，并发性会导致一系列严重问题.</p><h3 id="epoll-的工作模式。-区分工作机制"><a href="#epoll-的工作模式。-区分工作机制" class="headerlink" title="epoll 的工作模式。(区分工作机制)"></a>epoll 的工作模式。(区分工作机制)</h3><p>LT（level triggered）<br>LT模式，也叫做水平触发模式。在该模式下，当有事件发生并调用epoll_wait后，若未及时处理，下一次调用epoll_wait仍会继续通知。<br>内部实现方法：将从rdlist上取出的事件重新放回去，再次调用epoll_wait仍会继续通知，直到用户处理完成主动关闭fd。<br>在该模式下有两种工作方式：阻塞和非阻塞。<br>自认为这两种工作方式并没有很明显的区别，因为只要被唤醒就一定有事件可读或者可写，阻塞模式下，一般情况并不会进入阻塞状态。在非阻塞模式下，会使用循环的方式进行读/写，直到完成或出现异常循环退出。</p><p>ET(edge trigger)<br>ET模式，也叫边缘触发模式，其与水平模式的区别就是，调用epoll_wait通知过的事件，不论是否经过处理，再次调用epoll_wait不会再次通知了，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此ET模式效率比LT模式高。<br>内部实现方法：调用epoll_wait从rdlist取出事件后就不会再放回。<br>ET模式下推荐使用非阻塞，我在这件事情上面纠结了很久，为什么阻塞就不行呢？网上给出的答案也都模棱两可，说阻塞模式下可能会造成永久阻塞，但是又不说明情况。思考后我的理解是这样的：</p><p>非阻塞模式：在ET模式下，因为事件只会被通知一次，为了保证数据成功被读取或写入，在非阻塞模式下，采用循环的方式进行读写，直到完成或出现异常时退出。<br>阻塞模式：如果不采用循环的方式进行读写，就会造成数据读/写不完的情况，因为下一次再调用epoll_wait就不会再通知了，如果尝试采用循环的方式进行读写，则会造成永久阻塞。<br>造成阻塞的原因只有没有数据可读/可写，在非阻塞模式下出现没有数据可读/可写可以返回相应的错误信息，但是阻塞模式就会进入阻塞状态，而处理的该fd永远也不可能再有可读数据了，所以就被永久阻塞了。</p><h3 id="c-语言各种变量所在的节"><a href="#c-语言各种变量所在的节" class="headerlink" title="c 语言各种变量所在的节"></a>c 语言各种变量所在的节</h3><h3 id="c-怎么实现一个函数先于main函数运行"><a href="#c-怎么实现一个函数先于main函数运行" class="headerlink" title="c++怎么实现一个函数先于main函数运行"></a>c++怎么实现一个函数先于main函数运行</h3><h3 id="c-的static的变量的初始化顺序怎么样的-如果一个类里面呢？"><a href="#c-的static的变量的初始化顺序怎么样的-如果一个类里面呢？" class="headerlink" title="c++的static的变量的初始化顺序怎么样的,如果一个类里面呢？"></a>c++的static的变量的初始化顺序怎么样的,如果一个类里面呢？</h3><h3 id="两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？"><a href="#两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？" class="headerlink" title="两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？"></a>两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？</h3><h3 id="来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜"><a href="#来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜" class="headerlink" title="来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜"></a>来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜</h3><h3 id="STL说一下"><a href="#STL说一下" class="headerlink" title="STL说一下."></a>STL说一下.</h3><p>在整理:</p><h3 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析:"></a>系统分析:</h3><pre><code>维护在线人数的瓶颈分析。【除了内存,想不到】</code></pre><h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题:"></a>计算题:</h3><pre><code>100G 的文件,分发的 100 个机器上,机器之间互相联通,带宽千兆。最少数据是多少。(这一题答的稀烂,想挂电话)。</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++基础实战" scheme="http://example.com/categories/c-%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="c++基础实战" scheme="http://example.com/tags/c-%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>network-of-computer3</title>
    <link href="http://example.com/posts/19628/"/>
    <id>http://example.com/posts/19628/</id>
    <published>2020-11-14T00:55:40.000Z</published>
    <updated>2020-11-15T15:43:11.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="输入-www-baidu-com在浏览器的完整过程，越详细越好"><a href="#输入-www-baidu-com在浏览器的完整过程，越详细越好" class="headerlink" title="输入 www.baidu.com在浏览器的完整过程，越详细越好."></a>输入 <a href="http://www.baidu.com在浏览器的完整过程,越详细越好/">www.baidu.com在浏览器的完整过程，越详细越好</a>.</h3><ol><li>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></li><li>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li><li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。（IP地址转为MAC）</li></ol><p>事件顺序:<br>    (1) 浏览器获取输入的域名<a href="http://www.baidu.com/">www.baidu.com</a><br>    (2) 浏览器向DNS请求解析<a href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a><br>    (3) 域名系统DNS解析出百度服务器的IP地址<br>    (4) 浏览器发出HTTP请求，请求百度首页<br>    (5) 浏览器与该服务器建立TCP连接(默认端口号80)<br>    (6) IP的重要功能是寻址和路由<br>   （7）定义了通过物理网络输出数据所需的协议与硬件要求</p><p>   服务器通过HTTP响应把首页文件发送给浏览器<br>    (7) TCP连接释放<br>    (8) 浏览器将首页文件进行解析，并将Web页显示给用户。</p><p>涉及到的协议:<br>    (1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务)   DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输<br>    (2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)<br>    HTTP会话会被分成报文段，添加源、目的端口；TCP协议进行主要工作 　　(3)网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)<br>    为数据包选择路由，IP协议进行主要工作，相邻结点的可靠传输，ARP协议将IP地址转成MAC地址。<br>    点击网址后，应用层的DNS协议会将网址解析为IP地址；</p><pre><code>DNS查找过程： 1. 浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。 2. 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存（hosts文件）中是否有这个域名对应的DNS解析结果。 3. 若还没有，此时会发送一个数据包给DNS服务器，DNS服务器找到后将解析所得IP地址返回给用户。  在应用层，浏览器会给web服务器发送一个HTTP请求:   请求头为：GET http://www.baidu.com/HTTP/1.1  在传输层，（上层的传输数据流分段）HTTP数据包会嵌入在TCP报文段中:   TCP报文段需要设置端口，接收方（百度）的HTTP端口默认是80，本机的端口是一个1024-65535之间的随机整数，这里假设为1025，这样TCP报文段由TCP首部（包含发送方和接收方的端口信息）+ HTTP数据包组成。  在网络层中，TCP报文段再嵌入IP数据包中:   IP数据包需要知道双方的IP地址，本机IP地址假定为192.168.1.5，接受方IP地址为220.181.111.147（百度），这样IP数据包由IP头部（IP地址信息）+TCP报文段组成。  在网络接口层，IP数据包嵌入到数据帧（以太网数据包）中在网络上传送:    数据帧中包含源MAC地址和目的MAC地址（通过ARP地址解析协议得到的）。这样数据帧由头部（MAC地址）+IP数据包组成。   数据包经过多个网关的转发到达百度服务器，请求对应端口的服务: I    I     服务接收到发送过来的以太网数据包开始解析请求信息，从以太网数据包中提取IP数据包—&gt;TCP报文段—&gt;HTTP数据包，并组装为有效数据交与对应线程池中分配的线程进行处理，在这个过程中，生成相应request、response对象。   请求处理完成之后，服务器发回一个HTTP响应:       请求处理程序会阅读请求及它的参数和cookies。它会读取也可能更新一些数据，并将数据存储在服务器上。处理完毕后，数据通过response对象给客户输出信息，输出信息也需要拼接HTTP协议头部分，关闭后断开连接。断开后，服务器端自动注销request、response对象，并将释放对应线程的使用标识（一般一个请求单独由一个线程处理，部分特殊情况有一个线程处理多个请求的情况）。      响应头为：HTTP/1.1200 OK浏览器以同样的过程读取到HTTP响应的内容（HTTP响应数据包），然后浏览器对接收到的HTML页面进行解析，把网页显示出来呈现给用户。客户端接收到返回数据，去掉对应头信息，形成也可以被浏览器认识的页面HTML字符串信息，交与浏览器翻译为对应页面规则信息展示为页面内容。         1. 由域名→IP 地址         寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。         2. 建立 TCP/IP 连接（三次握手具体过程）         3. 由浏览器发送一个 HTTP 请求         4. 经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器         5. 服务器处理该 HTTP 请求，返回一个 HTML 文件         6. 浏览器解析该 HTML 文件，并且显示在浏览器端         7. 这里需要注意：         o  HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接         o  可以这样理解：HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。         o  两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络实战总结" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux系统</title>
    <link href="http://example.com/posts/63613/"/>
    <id>http://example.com/posts/63613/</id>
    <published>2020-11-12T11:05:40.000Z</published>
    <updated>2020-11-13T13:24:57.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>linux系统的开机过程是比较复杂的一个过程，但整体上可以分成四大步骤或四大块:<br>    1. 按电源按钮后BIOS开始工作,然后进行加电自检<br>    BOIS是英文”Basic input output system”的缩写词，就是进本的输入输出系统，BOIS是电脑启动时加载的第一个软件，其实,他是一组固化到计算机内主板上一个ROM(只读存储器)芯片上的程序.<br>    2. MBR引导(Boot Loader)(0磁盘的0柱面的第一个扇区)<br>     主引导记录(MBR,Main Boot Record)是位于磁盘最前边的一段引导(Loader)代码.它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判断,分区引导信息的定位，它由磁盘操作系统(DOS)对磁盘对象初始化时产生的．<br>    3. 启动内核<br>    4. 启动第一个进程init<br>    进程pid为1的进程,然后进行各个脚本的调用，脚本运行，</p><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><h3 id="BIOS-开机自检"><a href="#BIOS-开机自检" class="headerlink" title="BIOS/开机自检"></a>BIOS/开机自检</h3><h4 id="微控制器"><a href="#微控制器" class="headerlink" title="微控制器"></a>微控制器</h4><p>开机键-&gt;硬件工作(寄存器复位)-&gt;BIOS(执行BIOS里边的程序,作用是找到主引导记录MBR)-&gt;(MBR)-&gt;(MBR程序加载到内存)-&gt;接下来执行MBR的程序.</p><p>系统想要启动必须先加载BOIS,按下电源键时,给微控制器下达一条复位指令,个寄存器复位,最后下达一条跳转指令,跳转到BOIS的ROM,使得硬件去读取主板上的BOIS程序,在这之前都是由硬件来完成，之后硬件就会把控制权交给BOIS.</p><h4 id="BOIS-gt-POST"><a href="#BOIS-gt-POST" class="headerlink" title="BOIS-&gt;POST"></a>BOIS-&gt;POST</h4><p>  随后BOIS程序如果加载CMOS(可读写的RAM芯片(断电数据丢失),保存BIOS设置的硬件参数的数据)的信息,借CMOS取得主机的各项硬件配置:<br>  取得硬件配置的信息之后,BOIS进行加电自检(Power-on self Test, POST)过程检测计算机各种硬件信息,如果发现硬件错误则会报错(发出声音警告);<br>  之后BOIS对硬件进行初始化(检测硬件信息无误)．<br>  BOIS将自己复制到物理内存中继续执行,开始按顺序搜寻可引导存储设备,判断的标准就是判断每个磁盘前512个字节结尾是否存在55AA,有就是可引导，没有就继续检查下一个磁盘.一般第一张磁盘就是可引导磁盘,接下来就会读取磁盘的内容，但是要读取磁盘文件必须要有文件系统，这对BOIS挂载文件系统来说是不可能(BOIS非常小的),因此需要一个不依赖文件系统的方法使得BOIS读取磁盘内容,这种方法就是引入MBR.最后BOIS读取第一个可导的存储设备的MBR(0柱面0磁道第一扇区)中的boot Loader(根引导程序).将MBR加载到物理内存中执行．<br>  MBR载入内存后,BIOS将控制权转交给MBR(准确的说应该是MBR中的boot loader),然后MBR接管任务开始执行．</p><p>  小例子:<br>       如果开机密码忘记了，打开主板扣电池，BIOS断电,然后RAM芯片会全部还原为默认值,BIOS密码会消失.</p><h3 id="MBR引导-Boot-Loader"><a href="#MBR引导-Boot-Loader" class="headerlink" title="MBR引导(Boot Loader)"></a>MBR引导(Boot Loader)</h3><p>  载入了第一个可引导的存储设备的MBR后,MBR中的boot Loader就要读取所在磁盘的操作系统核心文件(即后面所说的内核)了.</p><h4 id="boot-Loader"><a href="#boot-Loader" class="headerlink" title="boot Loader"></a>boot Loader</h4><p>  但是呢还存在一些问题，不同操作系统的文件格式不同?还有我们知道一个磁盘可以安装多个操作系统，boot Loader怎么能够做到引导的就是我们想要的操作系统呢?这么多不同的功能单靠一个446字节的boot Loader是远远不够的．因此必须弄一个相对应的程序来处理各自对应的操作系统核心文件，这个程序就是操作系统的loader(注意不是MBR中的boot Loader,而是没个操作系统本身有一个自己的boot Loader),这样一来boot Loader只需要将控制权限交给对应操作系统的loader,让他负责去启动操作系统就行了．</p><p>第一个扇区512个字节<br>MBR　　　446字节<br>分区表　　64字节　16个字节一个分区<br>55AA标记　2字节</p><p>这里有张图更好的解释boot loader的作用:</p><p>图跳转.<br>扇区的0-2048就是存放这些东西的所以我们用不了</p><p>解读上图内容，我们知道一个硬盘的每个分区的第一个扇区叫做boot sector,这个扇区存放的就是操作系统的loader,所以我们常说一个分区只能安装一个操作系统，如上图，第一个分区的Boot sector存放这windowde的loader,第二个分区放着linux的loader,第三个第四个由于没有安装操作系统所以空着．至于MBR的boot Loader是干嘛呢,Boot Loader有三个功能:<br>    1. 提供选单<br>    2. 读取内存文件<br>    3. 转交给其他loader<br>    提供选单就是给用户提供一张选项单，让用户选择进入那个系统；<br>    读取内核文件，我们知道系统会有一个默认启动的操作系统，这个系统的loader在所有分区的boot sector有一份，除此之外也会将这个迷人启动的操作系统的loader复制一份到MBR的boot Loader中,这样一来MBR就会直接读取Boot Loader总的loader了，然后就是启动默认的操作系统．<br>    转交给其他的Loader,当用户选择其他操作系统启动的时候，Boot Loader会将控制权限转交给对应的loader,让他负责去启动操作系统的启动．<br>    另外，安装window操作系统的时候,window会主动复制一份自己的loader到MBR中的Boot Loader中,这种操作在linux下不会.所以我们安装多重操作系统的时候要求先安装window,然后在安装linux;我们假设先安装linux再安装windows的时候就会把windows的loader复制到MBR中的boot Loader,这样依赖就会默认优先启动windows.然后先安装windows,自动回复Windows的loader到boot Loader,再安装linux的时候,我们可以设置把linux的loader复制到boot Loader中,把原先windows的覆盖掉,这样才能设置linux默认启动.</p><h4 id="Linux的GRUB"><a href="#Linux的GRUB" class="headerlink" title="Linux的GRUB"></a>Linux的GRUB</h4><p>linux操作系统层面的loader使用的是grub.(loader包含在grub)<br>linux的Boot Loader和grub到底是什么关系呢?<br>图片跳转:<br>    我们可以看到很多文件，其实linux的Loader为stage1那个文件，linux所在分区的boot sector(一个扇区是512个字节)就是存放在stage1文件的内容，同时默认linux启动的话,也需要把stage1中的引导代码安装到MBR中的boot Loader中.该文件太小，能完成的功能有限，因此linux的Loader只是简单的引导作用．<br>    stage1完成了主程序的引导后，主引导程序开始加载配置文件了，但是加载这些配置文件之前需要有文件系统的支持，可是现在还没有文件系统呢,gurb在不依赖linux内核的情况下具有读取配置文件与内核映像的能力，gurb的内置文件系统其实是依赖stage1_5这些文件定义的,而且有不同文件系统对应不同的stage1_5文件.<br>    而后开始读取stage2开始真正的读取配置文件grub,conf.解析/boot/grub/grub.conf文件;<br>    (linux操作系统多个系统核心并存,linux内核更新没有覆盖原来的内核，而是增加了一个新的内核)．<br>    文件参数<br>    1. default = 0 第几个操作系统<br>    2. timeout = 5 系统选择页面显示时间．<br>    3. splashimage = (hd0, 0)/grud/splash.xpm.gz: (hd0, 0)磁盘分区的意思，grub表示磁盘是磁盘+坐标形式.<br>    大多数用的是SATA这种接口的硬盘，文件设备名字为sd, 第一块硬盘为Sda,第二块硬盘为 sdb….<br>　　grub中是以hd + 坐标的形式来展现的<br>　　　具体对应关系实现:<br>      　sda -&gt;1.-&gt;(hd0,0)<br>      　　　-&gt;2.-&gt;(hd0,1)<br>      　　　-&gt;3.-&gt;(hd0,2)<br>    4. haddenmenu 隐藏菜单<br>    5. (对应图片)启动系统名字<br> 　　　boot引导分区的根对应的/boot/这个地方．<br>　　　启动linux的内核，初始化一个虚拟的伪文件系统(,img),用来加载linux系统的核心模块，加载完成后，就把这个伪文件系统给删除掉，转而加载真正的linux系统所支持的真正的内核文件系统．</p><h3 id="gurb把内核文件加载到内存"><a href="#gurb把内核文件加载到内存" class="headerlink" title="gurb把内核文件加载到内存"></a>gurb把内核文件加载到内存</h3><h4 id="加载内核文件"><a href="#加载内核文件" class="headerlink" title="加载内核文件."></a>加载内核文件.</h4><p>MBR将内核文件(代码)载入物理内存中执行，内核就是/boot/vmlinuz-2.6.32-696.el6.x86_64.观察该文件，发现是一个压缩镜像文件．<br>看图．<br>控制权转交给内核后，内核重新检测各种硬件信息,(第一次为POST自检)我们前边说了，一个完整的linux包括内核和内核之上的程序需要使用硬件，还需要加载提供这些程序功能的模块（硬件驱动程序），然而这些模块都在根目录的/lib/modules/2.6.32-696.el.x86_64下(和/lib/modules/不能挂载不同的分区)，这时候内核还没有文件系统的概念，没有文件系统就没办法挂载到根目录，想要挂载根目录就需要相应的模块支持，而我们原本的问题就是如何加载模块，先有鸡后有蛋．</p><h4 id="加载initrd初始化ramfs文件系统"><a href="#加载initrd初始化ramfs文件系统" class="headerlink" title="加载initrd初始化ramfs文件系统"></a>加载initrd初始化ramfs文件系统</h4><p>看图<br>我们发现解压之后的内容类似于真正/目录下内容，这是因为这是一个最小化的linux根文件系统，内核就是先把这个文件展开，形成一个虚拟文件系统,内核接虚拟文件系统装在必要的模块，完成后释放该虚拟文件系统并挂载真正的根目录．</p><p>运行起来后真正的根会和fstable挂载在一起，并且会把根目录放在第一个硬盘挂载在一起sda1(?),然后在调用linux系统中的系统程序,第一个就是调用init,进程ID就是1,其他进程都是他的子进程.</p><h3 id="启动第一个进程init"><a href="#启动第一个进程init" class="headerlink" title="启动第一个进程init"></a>启动第一个进程init</h3><h4 id="init进程-主要功能是准备软件执行的环境"><a href="#init进程-主要功能是准备软件执行的环境" class="headerlink" title="init进程:主要功能是准备软件执行的环境"></a>init进程:主要功能是准备软件执行的环境</h4><p>内核完成硬件检测和加载模块后，内核会呼吁第一进程，就是/sbin/init,至此内核把控制权限交给init进程读取初始化配置文件/etc/inittab,决定操作系统的runlevel,/etc/inittab内有这样一句:<br>    id:runlevel:action:process,这里我的实验机器的值:id:3:initdefault:<br>    看图:</p><h4 id="etc-rc-d-rc-sysinit"><a href="#etc-rc-d-rc-sysinit" class="headerlink" title="/etc/rc.d/rc.sysinit"></a>/etc/rc.d/rc.sysinit</h4><p>读取/ect/rc.d/sinit系统初始化脚本，设置主机名，挂载/etc/fstab中的文件系统，修改/etc/systl.conf的内核参数等各项系统环境．<br>查看脚本内容，大致功能如下图:</p><pre><code>k开头的文件杀死，ｓ开头的文件启动．linux默认的号为３,就会扫描rc.d中的rc3.d文件．文件中一部分ｋ开头，一部分ｓ开头．</code></pre><p>根据运行级别(123456)进入相应的etc/rc.d/rcN,d目录，启动和关闭相关的系统服务．里边存放着一堆以k,S开头的软连接文件，分别是代表相应的服务.K开头表示运行级别下需要把该服务杀死，S开头表示该运行级别下需要把服务开启．上述操作都是有/etc/rc.d/rc脚本来完成的.另外我们还注意都S和K后边的数字，他们的数字代表了读取的顺序，因为有一些服务是具有一定的关联性．<br>　　而且每个rcN.d目录内最后都有一个S99local文件，该文件指向../rc.local脚本．</p><h4 id="etc-rc-d-rc-local"><a href="#etc-rc-d-rc-local" class="headerlink" title="/etc/rc,d/rc.local"></a>/etc/rc,d/rc.local</h4><p>　　系统根据runlevel执行完成/etc/rc.d/rcN.d中的脚本后，调用/etc/rc.d/rc.local脚本<br>　　这时候系统已经完成了各种必要系统服务的启动，假如我们想定自定义一些指令要在开机的时候启动，我们就可以把他们放到/etc/rc.d/rc.local内,该文件默认为空.</p><h4 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h4><p>　　接下来会由/sbin/mingetty指令启动终端，会启动6个命令行终端,最终呈现给我们的就是这样画面<br>看图启动过程<br>　<a href="https://blog.csdn.net/abc_ii/article/details/8740008">全面图解</a><br><a href="https://blog.51cto.com/itchentao/1912451">进阶图解强烈推荐</a><br><a href="https://s1.51cto.com/wyfs02/M00/8F/7A/wKiom1jfbn-zLndXAAJfq4gKqGA617.png">直接显示图</a></p><h3 id="Centos7-x的启动过程和相关配置文件"><a href="#Centos7-x的启动过程和相关配置文件" class="headerlink" title="Centos7.x的启动过程和相关配置文件"></a>Centos7.x的启动过程和相关配置文件</h3><p>Cenos7和Centos6启动流程差不多，只不过到init程序时候，改为了systemd,因此详细解释一下systemd后的启动流程，</p><ol><li>uefi或BIOS初始化,开始POST开机自检(uefi是BIOS发展的阶段)</li><li>加载mbr到内存</li><li>GRUB阶段，Centos6加载的是/boot/grub.grub.conf,而Centos7加载的是/boot/grub2/grub.conf</li><li>加载内核和initramfs模块</li><li>内核开始初始化，使用system来代替centos6以前的init程序,systemd使用”target”来处理引导和服务管理过程，这些system里的”target”文件被用于分组不同的引导单元以及自启动同步进程．</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>leedcode_动态规划</title>
    <link href="http://example.com/posts/34955/"/>
    <id>http://example.com/posts/34955/</id>
    <published>2020-11-11T03:23:11.000Z</published>
    <updated>2020-11-15T15:41:45.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h3><p>状态表示: sum表示当前位置的最大子序列和<br>状态划分: 子序列结尾位置<br>转移方程: max(sums ,sum + sums[i+1] )<br>边界:sum = sums[0]<br>目标: sum中最大值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            int length &#x3D; sizeof(nums)&#x2F;sizeof(nums[0]); </span><br><span class="line">            int sum &#x3D; 0; </span><br><span class="line">            if(length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">            int last &#x3D; nums[0];</span><br><span class="line">            sum &#x3D; nums[0];</span><br><span class="line">        for(auto it &#x3D; nums.begin()+1; it !&#x3D; nums.end() ; it++)&#123;</span><br><span class="line">                    sum &#x3D; max(*it, sum + *it);</span><br><span class="line">                    last &#x3D; max(sum, last);                </span><br><span class="line">        &#125;</span><br><span class="line">            return last;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a>面试题 17.16. 按摩师</h3><p>分两种情况的dp.<br>状态表示: dp[i][0]和dp[i][1]表示第i个位置选和不许的两种状态<br>状态划分: dp[i][0/1]表示i位结尾的状态<br>转移方程:<br>    不选: dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);<br>    选: dp[i][1] = dp[i - 1][0] + nums[i]; 这次选上次为不选．<br>边界: (1 &lt;= i &lt;= n),<br>目标: max(dp[n][0], dp[n][1]);</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int massage(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">                int n &#x3D; nums.size();</span><br><span class="line">                if(!n) return 0;</span><br><span class="line">                int dp0 &#x3D; 0, dp1 &#x3D; nums[0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; n; i++)&#123;</span><br><span class="line">                        int tdp0 &#x3D; max(dp0, dp1);</span><br><span class="line">                        int tdp1 &#x3D; dp0 + nums[i];</span><br><span class="line">                        dp0 &#x3D; tdp0;</span><br><span class="line">                        dp1 &#x3D; tdp1;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return max(dp0, dp1);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a>1025. 除数博弈</h3><p>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标:<br>博弈论找规律: 奇数必败偶数必赢.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool divisorGame(int N) &#123;</span><br><span class="line">           return N % 2 &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a>面试题 08.01. 三步问题</h3><p>状态表示: dp[i] 表示i级台阶的状态步数种数.<br>状态划分: dp[i]以i结尾的状态种数和.<br>转移方程: </p><ol><li>转移条件为走1,2,3步到达目标状态.</li><li>dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];<br>就是走到i位置，需要走1,2,3三种情况能到i位置的不同情况.<br>边界:dp[1] = 1, dp[2] = 2, dp[3] = 4;<br>目标: dp[n];<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int waysToStep(int n) &#123;</span><br><span class="line">                int dp[1000005];</span><br><span class="line">                dp[1] &#x3D; 1, dp[2] &#x3D; 2, dp[3] &#x3D; 4;</span><br><span class="line">                if(n &lt; 4) return dp[n];</span><br><span class="line">        for(int i &#x3D; 4; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; (((dp[i - 1] % 1000000007+ dp[i - 2])%1000000007 + dp[i - 3])%1000000007) %1000000007;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return dp[n] % 1000000007;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h3><p>状态表示:<br>    temp记录i节点前dp中的最小值.<br>    sum 记录最大利润.<br>状态划分:<br>    加入一个新节点加入通过比较加入新状态</p><p>转移方程:<br>    sum = max(sum ,prices[i] - temp);<br>    temp = min(temp, prices[i]);<br>边界: sim = -1, temp = prices[0].<br>目标: sum值</p><p>总统思想: 当前节点减去前边最小节点，维护一个最大的利润.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">                if(prices.size()&#x3D;&#x3D; 0) return 0;</span><br><span class="line">                int temp &#x3D; prices[0], sum &#x3D; -1;</span><br><span class="line">        for(auto it &#x3D; prices.begin(); it !&#x3D; prices.end(); it++)&#123;</span><br><span class="line">                        sum &#x3D; max(sum, *it - temp);</span><br><span class="line">                        temp &#x3D; min(temp, *it);</span><br><span class="line">        &#125;</span><br><span class="line">                if(sum &lt;&#x3D; 0) return 0;</span><br><span class="line">                return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h3><p>状态表示: dp[i] 表示当前状态最大的获益<br>状态划分:　抢n, 和不抢n两种状态<br>转移方程: dp[n + 1] = max(dp[n], dp[n - 1] + nums[i - 1]);<br>边界: 左后遍历的时候数组往后移动三位．<br>目标: dp[nums.size() + 1];</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">             &#x2F;&#x2F;   if(nums.size() &#x3D;&#x3D; 0 ) return 0;</span><br><span class="line">             &#x2F;&#x2F;   if(nums.size() &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">                int dp[200] &#x3D; &#123;0&#125;;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; nums.size(); i++)&#123;</span><br><span class="line">                        dp[i + 1] &#x3D; max(dp[i], dp[i - 1] + nums[i - 1]);</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return dp[nums.size() + 1];</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a>剑指 Offer 42. 连续子数组的最大和</h3><p>状态表示: dp[i] 表示到目前的最大值<br>状态划分: dp[i - 1] 加与不加 nums[i - 1]　两种状态<br>转移方程: dp[i] = max(nums[i], dp[i - 1] + nums[i]);<br>边界: dp[0] = nums[0]<br>目标: temp 最大值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">                int dp[100005] &#x3D; &#123;0&#125;;</span><br><span class="line">                if(nums.size() &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">                dp[0] &#x3D; nums[0];</span><br><span class="line">                int temp &#x3D; nums[0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; max(nums[i],dp[i - 1] + nums[i]);</span><br><span class="line">                        temp &#x3D; max(temp, dp[i]);           </span><br><span class="line">        &#125;</span><br><span class="line">                return temp;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>状态表示:  dp[i] 走到当前状态最小步数<br>状态划分:　当前楼梯是上一步还是上两步走到的，<br>转移方程:　dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);<br>边界: dp[0]和dp[1];<br>目标: dp[cost.size()];</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">                int dp[1005] &#x3D; &#123;0&#125;;</span><br><span class="line">                if(cost.size() &#x3D;&#x3D; 0) return 0;</span><br><span class="line">                if(cost.size() &#x3D;&#x3D; 1) return cost[0];</span><br><span class="line">        for(int i &#x3D; 2; i &lt;&#x3D; cost.size(); i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return dp[cost.size()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h3><p>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标:<br>思想: 维护前ｎ项和，取差值就是区间和．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class NumArray &#123;</span><br><span class="line">    public:</span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">                res.push_back(0);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                        res.push_back(res.back() + nums[i]);</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    int sumRange(int i, int j) &#123;</span><br><span class="line">                return res[j+1] - res[i];</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    private:</span><br><span class="line">         vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your NumArray object will be instantiated and called as such:</span><br><span class="line">      * NumArray* obj &#x3D; new NumArray(nums);</span><br><span class="line">       * int param_1 &#x3D; obj-&gt;sumRange(i,j);</span><br><span class="line">        *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>状态表示: dp[i] 当前位置的种数<br>状态划分: 一步和两步到达当前状态.<br>转移方程: dp[i] = dp[i - 1] + dp[i - 2];<br>边界: dp[0],dp[2]<br>目标: dp[n]<br>思想: 依据斐波那契数列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int climbStairs(int n)&#123;</span><br><span class="line">                int dp[10005] &#x3D; &#123;0&#125;;</span><br><span class="line">                dp[0] &#x3D; 1,dp[1] &#x3D; 1;</span><br><span class="line">        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">                    </span><br><span class="line">        &#125; </span><br><span class="line">                return dp[n];</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-16-17-连续数列"><a href="#面试题-16-17-连续数列" class="headerlink" title="面试题 16.17. 连续数列"></a>面试题 16.17. 连续数列</h3><p>dp前边有原题<br>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标:<br>    思路：分治算法就是加判断</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            int max1 &#x3D; nums[0], i &#x3D; 1, sum &#x3D; max1;</span><br><span class="line">        while(i &lt; nums.size())&#123;</span><br><span class="line">            if(sum + nums[i] &lt; nums[i])&#123;</span><br><span class="line">                            sum &#x3D; 0;</span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">                    sum +&#x3D; nums[i];</span><br><span class="line">            if(sum &gt; max1)&#123;</span><br><span class="line">                            max1 &#x3D; sum;</span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            return max1;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h3><p>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标: </p><p>暴力求解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">            int s1 &#x3D; 0, t1 &#x3D; 0;</span><br><span class="line">        while (s[s1] &amp;&amp; t[t1]) &#123;</span><br><span class="line">            if (s[s1] &#x3D;&#x3D; t[t1]) &#123;</span><br><span class="line">                            s1++;     </span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">                     t1++;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        if (s[s1] &#x3D;&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux_system</title>
    <link href="http://example.com/posts/47607/"/>
    <id>http://example.com/posts/47607/</id>
    <published>2020-11-10T06:09:26.000Z</published>
    <updated>2020-11-27T15:37:51.201Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>###　操作系统　<br>包括三部分:</p><ol><li>cpu</li><li>i/o</li><li>memory(内存)</li></ol><p>(硬盘)DISK : 存放OS,还有一个bootloader小程序也在上边<br>bootloader:主要功能用来加载OS的,能够让OS从硬盘加载到内存中去，然后让cpu执行操作系统．<br>BIOS : 基本I/O处理系统</p><h4 id="BIOS准备"><a href="#BIOS准备" class="headerlink" title="BIOS准备"></a>BIOS准备</h4><p>BOIS在内存中的分布</p><p>空闲内存<br>BOIS<br>空闲内存</p><p>BIOS会从一个确定的地址开始执行</p><ol><li>POST(加电自检)</li><li>寻找显卡和执行BIOS.</li></ol><h4 id="加载bootloader"><a href="#加载bootloader" class="headerlink" title="加载bootloader"></a>加载bootloader</h4><p>开启时　DISK(硬盘)包括 bootloader程序, os两部分.<br>bootloader程序一般为位于硬盘第一个主引导扇区．512个字节.<br>bootloader程序目的是为了把os放到内存中去．（OS为操作系统）</p><p>以X386为例:</p><p>BOIS:<br>    1. 将bootloader从磁盘的引导扇区(512字节)加载到0x7c00<br>    2. 跳转到　CS:IP = 0000:7c00 (这个地址是确定的)<br>bootloader:<br>    1. 将操作系统的代码和数据从鹰牌加载到内存中．<br>    2. 跳转到操作系统起始位置执行．（把操作系统的权限交给了OS）<br>到此硬件设备检测完毕,有操作系统来执行程序分配资源等操作.</p><h4 id="操作系统与设备和程序交互"><a href="#操作系统与设备和程序交互" class="headerlink" title="操作系统与设备和程序交互"></a>操作系统与设备和程序交互</h4><p>interface(接口):包括三部分<br>面向应用程序：</p><ol><li>系统调用: 应用程序主动向操作系统发出服务请求.</li><li>异常: 非法指令或者其他坏的处理状态(如:内存出错)(不良的应用程序产生的)</li></ol><p>面向硬件(外设):<br>3. 中断: 来自不同的硬件设备的计时器和网络中断.</p><p>为什么应用程序不能直接访问外设呢？</p><p>操作系统跟其他软件不同的地方在于，OS对操作系统有一定的控制权，能执行特权指令，是一个可信任的软件．<br>安全方面: 如果程序可以直接访问外设，可造成整个计算机系统的直接崩溃．<br>简单方面：操作系统为上层应用提供一个通用接口，可以是程序不用关注底层的运行，使得程序变得通用，可移植．</p><p>基于这两个方面设计了　system core, exception,interupt;</p><p>操作系统如何设计和实现中断，异常，和系统调用？</p><p>他们三者有什么区别和特点?<br>源头：</p><ol><li>中断： 外设</li><li>异常:　应用程序意想不到的行为</li><li>系统调用:　应用程序请求操作提供服务．<br>处理时间:　异步和同步指的是时间点.<ol><li>中断: 异步(事件),当这个中断产生的时候，应用程序并不知道会产生．</li><li>异常: 同步.（执行到某个指令或者别的一定会产生的事件）</li><li>系统调用: 异常或同步.<br>操作系统同步：就是发送一个请求，等待反馈（同步是可预测的）<br>操作系统异步：就是发送一个请求，就去做别的事情去了．返回一个消息这个事情做完了．（异步是不可预测的）<br>响应：<br>　　1. 中断: 持续，对用户应用程序是透明的．(应用程序感觉不到中断产生)</li><li>异常:杀死或者重新执行意想不到的应用程序指令.(严重的将杀死进程，其他的程序未响应等会重新执行．)</li><li>系统调用:等待和持续．(等待服务完成之后继续执行，不会重复执行产生系统调用的指令)．</li></ol></li></ol><h4 id="计算机体系结构-内存分层体系"><a href="#计算机体系结构-内存分层体系" class="headerlink" title="计算机体系结构/内存分层体系"></a>计算机体系结构/内存分层体系</h4><p>OS对操作系统首先控制的就是内存<br>操作系统如何管理物理内存:</p><h5 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h5><p>图：计算机体系结构<br>图: 内存的层次结构<br>缓存为cache包含l1和l2,<br>主存(物理内存)中放置：操作系统本身以及要运行的代码.掉电数据消失.<br>所以说需要永久保存的数据需要放在硬盘中．加电之后可以把数据从硬盘读到内存中来．</p><p>图: 操作系统对内存管理</p><ol><li>抽象:<br> 逻辑地址空间(底层提供的供程序用的连续的物理空间，不用考虑物理空间什么地方)</li><li>保护:<br> 独立地址空间(保护进程间的内存是独立的)</li><li>共享<br> 访问相同内存（进程间的交互）</li><li>虚拟化<br> 更多的地址空间（解决内存不够的情况，把最需要访问的数据放入内存，不太需要的放到硬盘上去）</li></ol><p>图中表示p1,p2,p3,p4四个应用程序续，p4可能处于等待状态，所以放入磁盘中，其他的在主存中排队.</p><h5 id="在操作系统中管理内存的不同方法"><a href="#在操作系统中管理内存的不同方法" class="headerlink" title="在操作系统中管理内存的不同方法"></a>在操作系统中管理内存的不同方法</h5><ol><li>程序重定位</li><li>分段</li><li>分页</li><li>虚拟内存</li><li>按需分页虚拟内存</li></ol><p>除了OS对内存管理还要对硬件管理,如下:</p><h5 id="实现高度依赖与硬件"><a href="#实现高度依赖与硬件" class="headerlink" title="实现高度依赖与硬件"></a>实现高度依赖与硬件</h5><ol><li>必须知道内存架构</li><li>MMU(内存管理单元):硬件组件负责处理CPU的内存访问请求.<h4 id="地址空间-amp-地址生成"><a href="#地址空间-amp-地址生成" class="headerlink" title="地址空间&amp;地址生成"></a>地址空间&amp;地址生成</h4>图:地址空间<br>物理地址空间:<br> 硬件支持的地址空间(主存和硬盘表示物理空间)<br> 主要靠硬件控制管理．<br>逻辑地址空间:<br> 一个运行的程序所拥有的内存范围</li></ol><p>逻辑地址空间是一个一维度的，它对应着一个物理空间（可能在主存也可能在硬盘），映射关系靠操作系统管理．</p><h5 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h5><p>图:逻辑地址生成<br>变量的名字就是一种逻辑地址．人为的实现的．<br>一个大程序可能有好多个小程序组成的，小程序组成的过程中，会使得不同程序间的地址相互访问，形成一个非常复杂的依赖关系？<br>通过link应用程序，把他们连在一起，构成一个统一的程序，比如图中的.exe file,他是一个可以在内存中执行，目前存在硬盘上的程序．不同的.io程序，在一个程序中访问的地址，有自己相关的定义．这个定义还不在内存中，还需要lowder应用程序硬盘中的程序，放到内存中执行．这样完成一个逻辑地址在内存中的分配，使程序可以正常的跑．看到这里基本不需要操作系统，只需要通过应用程序就可以完成这些操作．虽然放到了内存中但是他还是逻辑地址，不是物理地址，只是程序能看到这个地址．</p><h5 id="物理地址生成"><a href="#物理地址生成" class="headerlink" title="物理地址生成"></a>物理地址生成</h5><p>图: 物理地址生成</p><p>逻辑地址如何对应到对应的物理空间中去.</p><p>执行一条指令<br> cpu需要把指令从内存中取出来，cpu中有一个能查询逻辑地址和物理地址对应关系的MMU. MMU在内存中有一个相对应的位置，如图蓝色位置所示.查表可以知道逻辑地址对应物理地址在的位置，就可以让硬件把数据在物理内存中把数据取过来．</p><p>执行过程:</p><ol><li>当cpu执行某条指令的时候，他的ALU部件会需要这个指令的内容请求，带的参数是逻辑地址．</li><li>cpu中的MMU会查询这个逻辑地址的映射表，如果有ok，如果没有会产生一个处理过程，去内存中的map去找．如果找到了cpu的控制器会给主存发送一个请求我需要某一个物理地址的内容，（就是那条指令的内容）</li><li>主存会通过总线把内容传给CPU,cpu拿到这条指令后，cpu就开始对这条指令执行了．\</li></ol><p>操作系统起的作用：在完成这三步之前把这个映射关系建立好(逻辑地址到物理地址的映射关系)，这个关系可以放到内存中由cpu进行缓存，加快访问的过程，</p><h5 id="线程安全内存的约束"><a href="#线程安全内存的约束" class="headerlink" title="线程安全内存的约束"></a>线程安全内存的约束</h5><p>图:线程安全内存的约束<br>操作系统会保证每个程序有效访问的地址空间，主要包括起始地址,和长度.可以来确定在这块内存中程序访问是合理，一旦超出这个区域，访问变成不合法的访问，这个表也是操作系统建立和维护的，一旦cpu要执行某条指令的时候，他就会查这个map,来判断程序访问的逻辑地址是否满足该区域的限制，如果满足，就会根据映射关系把数据或者指令取回来，一旦不满足cpu就会产生一个memory异常，就是内存访问异常,从而让操作系统进一步处理．这就是地址的安全检查安全检测的过程，</p><h5 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h5><h6 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h6><p>图:内存碎片问题<br>内存空间不能被利用．<br>外部碎片:在分配单元间的未使用的内存<br>内部碎片:在分配单元中的为使用内存.</p><h6 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h6><p>图：分区的动态分配．<br>简单的内存管理方法:<br>    1. 当一个程序准许运行在内存中时，分配一个连续的分区．<br>    2. 分配一个连续的内存区间给运行的程序以访问数据．</p><p>分配策略:</p><ol><li>第一适配<br>图:第一匹配分配<br>为了分配n字节,使用第一个可用空闲块以致块的尺寸比n大．<br>简单实现:<br>需求:<ol><li>按地址排序的空闲块列表</li><li>分配需要一个合适的分区</li><li>重分配需要检查，看是否自由分区能合并于相邻的空闲分区．<br>优点:</li><li>简单</li><li>易于产生更大空闲块，向着地址空间的结尾．<br>劣势：</li><li>容易产生外碎片</li><li>不确定性</li></ol></li><li>最佳适配<br>图：最佳匹配分配<br>为了分配n字节,使用最小的可用空闲块，以致快的尺寸比n大．<br>基本原理＆实现<br>为了避免分割大空闲块.<br>为了最小化外部碎片产生的尺寸.<br>需求:<ol><li>按尺寸排列到空闲块列表</li><li>分配需要寻找一个合适的分区</li><li>重分配需要搜索及合并于相邻的空闲分区，若有<br>优势:<ol><li>当大部分分配是小尺寸时非常有效．</li><li>比较简单<br>劣势:</li><li>外部碎片</li><li>重分配慢</li><li>易产生很多没用的微笑碎片(不怎么好).</li></ol></li></ol></li><li>最差适配<br>图：最差匹配分配<br>为了分配n字节,使用最大可用空闲块,以致块的尺寸比n大.<br>基本原理&amp;实现<br>为了避免有太多微小的碎片<br>需求:<ol><li>按尺寸排列的空闲块列表</li><li>分配很快（获得最大的分区）</li><li>重分陪需要合并于相邻的空闲分区，若有，然后调整空闲块列表．<br>优势: 假如分配是中等尺寸效果最好<br>劣势: </li><li>重分配慢</li><li>外部碎片</li><li>易于破碎打的空闲块以致大分区无法被分配．</li></ol></li></ol><h6 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h6><p>紧致算法:</p><ol><li>重置程序以合并孔洞(就是把程序位置尽可能先上移动，然后省出够用的内存).</li><li>要求所有程序是动态可重置的<br>一提:<ol><li>何时重置?(程序运行是不能挪动)．</li><li>开销（内存拷贝用于挪动，考虑频繁挪动开销大不大问题）</li></ol></li></ol><p>交换式碎片整理<br>图:交换式碎片整理</p><ol><li>运行程序需要更多的内存</li><li>抢占等待的程序&amp;回收他们的内存<br>把硬盘当做内存的备份.<br>比如内存有p1,p2,p3,p4四个程序，p3在运行需要更大的内存，就会把p4这个程序换到硬盘中．不用了之后在缓存到内存中．<br>换入换出的大小为程序的大小，开销也是看的是程序的大小．内存开销问题就是改善的方向．或者改善的更为灵活（块变得小一些）．</li></ol><h4 id="非连续内存的分配-分段"><a href="#非连续内存的分配-分段" class="headerlink" title="非连续内存的分配-分段"></a>非连续内存的分配-分段</h4><p>连续内存分配的缺点就是非连续内存分配出现的缘由．<br>缺点:<br>    1. 分配给一个程序的物理内存是连续的<br>    2. 内存利用率较低<br>    3. 有外碎片,内碎片问题．</p><p>非连续分配的优点:<br>    1. 一个程序的物理地mZ动态链接.</p><p>非连续内存: 缺点<br>如何建立虚拟地址和物理地址之间的转换.</p><ol><li>软件方案</li><li>硬件方案<br>两种硬件方案:<ol><li>分段机制</li><li>分页机制<br>分段考虑两点:</li><li>程序的分段地址空间（如何分段）</li><li>分段寻址方案(如何寻址)．<br>分段机制的作用：就是为了根据程序的特点，把内存得到一个有效的分离和管理，<br>图:分散到多个物理地址空间（方便管理）<br>左边是连续的逻辑地址，右边是一个不连续的物理地址，这是就需要一个对应的关联.</li></ol></li></ol><p>图:分段的逻辑视图<br>逻辑地址映射到物理空间中，不一定是连续的大小也不一定一样．<br>这个映射如果是软件支持的话，就需要非常大的开销．<br>这时需要硬件的支持，</p><p>硬件支持寻址</p><ol><li>分段寻址方案<br>图:段访问机制<br>一个段:一个内存”块”<br>　一个逻辑地址空间<br>程序访问内存地址需要:<br> 一个2维的二元组(s,addr)<ol><li>s-段号</li><li>addr-段内偏移<br>X86是段寄存和地址寄存器分开的．<br>还有一种就是段和地址连在一起，不用分开的这种管理方式.就没有专门的段寄存器这样的概念.</li></ol></li></ol><p>图：硬件实现方案<br>运行程序，cpu执行命令，寻址，逻辑地址分成两部分,一部分是段号，另一部分是段内偏移，（这里有硬件机制称为段表）段表中存在映射关系，逻辑地址段号和物理地址段号对应关系，段表中还有储存一个段的长度的信息．（一共两个信息），所以说段号是一个段的索引．cpu会根据查询到的物理段，和限制大小比对，是否合法，如果不合法有一个中断异常机制.交给操作系统处理，如果有问题会Kill掉．如果合法，就把起始地址加上偏移量形成起始地址，<br>段表是操作系统在寻址前建立的.</p><h4 id="非连续内存的分配-分页"><a href="#非连续内存的分配-分页" class="headerlink" title="非连续内存的分配-分页"></a>非连续内存的分配-分页</h4><p>分页:<br>    1. 分页地址空间<br>    2. 页寻址方案<br>分段段的大小可变，分页页的大小不可变．</p><p>划分物理内存至固定大小的帧（物理页的大小）<br>大小是2的幂，512,4096,8192.</p><p>划分逻辑地址空间至相同大小的页，（逻辑页的大小）<br>大小是2的幂,512,4096,8192.</p><p>所以我们需要建立逻辑页和物理页之间的对应关系．</p><p>这些会涉及到<br>建立方案转逻辑地址为物理地址(pages to frames)</p><ol><li>页表</li><li>MMU/TLB(内存管理单元，cpu中的组成单元)．/（TBL快表完成对页表的缓存）</li></ol><p>帧(物理帧)<br>图: 物理帧<br>物理内存被分割为大小相等的帧．<br>一个内存物理地址是一个二元组(f,o)<br>f—-帧号(F位,共有2^F个帧)<br>o—-帧内偏移(S位,每帧有2^s字节)<br>物理地址 = 2^s*f + o;</p><p>地址计算的实例<br>16-bit的地址空间，9-bit(512 byte) 大小的页帧，</p><ol><li>物理地址 = (3, 6);</li><li>物理地址 = 1542<br>图:地址计算的实例</li></ol><p>逻辑的寻址方式(页)<br>一个程序的逻辑地址空间被划分为大小相等的页</p><ol><li>页内偏移的大小 = 帧内偏移的大小</li><li>叶号大小&lt;&gt;帧号大小.(可能不一样)<br>图:逻辑页<br>虚拟地址 = 2^s * p + o</li></ol><p>图：页寻址机制<br>页表保存了逻辑地址—物理地址之间的映射关系．<br>cpu通过页号和页表基址找到帧号，也表中的帧后边有一个offset,通过公式找到真实的物理地址．<br>page table 页表是操作系统在初始化的过程中就要建立好.(分页之前).</p><p>可以得到页的大小是固定的，在硬件管理方面也可以用更加简洁的方式来实现．不需要像分段那部分需要考虑段的大小不同的这样的问题．</p><p>图:页寻址机制<br>一般来说逻辑的空间大于物理的地址空间</p><ol><li>页映射到帧</li><li>页是连续的虚拟内存</li><li>帧是非连续的物理内存</li><li>不是所有的页都有对应的帧<br>页映射页帧，页帧是不连续的，这样减少了磁盘碎片．</li></ol><h4 id="非连续内存的分配-页表概述"><a href="#非连续内存的分配-页表概述" class="headerlink" title="非连续内存的分配-页表概述"></a>非连续内存的分配-页表概述</h4><p>页表（怎样实现）</p><ol><li>页表概述</li><li>页表后备缓冲区</li><li>二级/多级 页表　</li><li>反向页表</li></ol><p>图:页表结构<br>图:页表地址转换实例<br>(4, 0) 向从表的下往上数，第四位发现标记位(红色)为零，表示没有相关的物理内存映射，返回一个异常．<br>(3,1023)<br>向表的从下往上数，第三位发现标记位(红色)为零，表示有相关的物理内存映射，frame num是00100表示对应的物理页帧的号，物理页帧后边有一个偏移号o,进行计算找到对应的物理地址．</p><p>分页机制的性能问题<br>问题: 访问一个内存单元需要2次内存访问</p><ol><li>一次用于获取页表项</li><li>一次用于访问数据<br>在操作系统内需要实现考虑两个问题</li><li>内存占用越少越好</li><li>效率越高越好</li></ol><p>实例：页表可能非常大<br>64位机器如果每项1024字节,那么一个页表大大小会是多少?<br>(2^64)/(2^10) = 2^(54)这会导致页表也很大，就不能放到我们的cpu里面，这个开销很大</p><p>为了使应用程序的隔离，每个程序都有一份自己的页表，ｎ个程序ｎ份页表．<br>第一个问题页表可能导致占得空间很大．<br>第二个问题返回效率问题．<br>因为表很大，所以不能放到cpu中，页表得放到存中，页表放到内存中，需要在cpu和内存中两次寻址.(自己想的)<br>解决方法:<br>    1. 缓存(cache)<br>    2. 间接访问（比如多级索引）．</p><p>解决浪费时间问题：<br>图: TLB<br>cpu里边有一个MMU(内存管理单元),MMU里边有一个(TLB)(我们所说的cache缓冲)他缓冲的就是页表里边的内容．</p><p>TLB(Translation Look-aside Buffer)<br>缓存近期访问的页帧转换表项:<br>    1. TLB使用associative memory(关联内存)实现．具备快速访问性能．<br>    2. 如果TLB命中，物理页号可以很快被获取．<br>    3. 如果TLB未命中,对应的表项被更新到TLB中.<br>TBL内部有一个p和f值，Key和Value值最为列明对应的是p和f,这一对key和value构成了一个表项，是由相关的存储器实现的，速度很快可以并发的进行查找，但是他实现的代价和容量都是有限的，所以把经常用到的页表项把他放到我们的TLB中去，这样就能提升访问速度，就不需要查询页表了，当CPU的到逻辑地址，献给局p来查询TLB,如果有就很容易得到value值(f值)，有f之后直接加上offset直接得到物理地址对应的内容了．如果出现TLB访问不到的情况（TLB表项中不存在）就是TLB缺失(miss),cpu不得不查询页表．xB6系统中由于cpu的特性，硬件就完成了TLB缺失后查询存取的操作，会放到TLB表中．（有的系统需要os实现，就是软件来实现的）</p><p>TLB确实情况会不会很大呢?<br>32位系统里边，一个页是4k,一次访问，要访问4k次，才会引起TLB的缺失．</p><p>!!!!!! 疑问，一个TLB是不是占一个页的大小.<br>注意:TLB本身不是一种存储设备，是存储在存储设备中的一种数据结构．<br>在写程序的过程中</p><h4 id="非连续内存的分配-页表－二级多级页表"><a href="#非连续内存的分配-页表－二级多级页表" class="headerlink" title="非连续内存的分配-页表－二级多级页表"></a>非连续内存的分配-页表－二级多级页表</h4><p>为了让页表所占的空间足够小，就产生了二级或者多级页表来缓解这个问题．<br>以二级页表为例:<br>图:二级页表<br>就只是把page number 分成了两个,offset没有分开,把一个较大的page table,换成了两个较小的page table来进行寻址.<br>寻址过程:<br>    1. 把大的page number分成两部分，p1,p2.<br>    2. p1的起始地址cpu是知道的，把p1的起始地址作为index,查找p1中的页表项，p1中存的值是p2（二级页表的起始值）中的起始值，<br>    3. 找到p2的index,加上p1中存的起始地址，就找到了p2中的页表项．<br>    4. p2里边存的是frome number.(就是对应的f,然后招到逻辑和物理地址映射表，取出f,o进行公式运算得到物理地址.)</p><p>这样一来，多级页表都存到内存中，开销会很大，所以会把那些没有映射关系的页表项，就没必要占用内存了，<br>有一个驻存位来表示当前映射关系的可用与否，如果为零就说明可以把第二级页表移出内存．<br>图：多级页表<br>多级页表导致每次访问的时间越来越大，用时间换取了空间．时间可以通过TLB来缓解.</p><h4 id="非连续内存的分配-页表反向页表"><a href="#非连续内存的分配-页表反向页表" class="headerlink" title="非连续内存的分配-页表反向页表"></a>非连续内存的分配-页表反向页表</h4><p>非连续内存分配</p><ol><li>为什么需要非连续内存分配</li><li>分段</li><li>分页</li><li>页表:<ol><li>页表概览</li><li>快表(TLB)</li><li>二级/多级页表</li><li>反向页表</li></ol></li></ol><p>由于空间越大页表越多，从而想到有没有一种方法，是页表大小与逻辑地址空间大小没那么大的关系．和物理地址的大小建立对应关系．</p><p>大地址空间问题:<br>    有大地址空间(64-bit),前向映射页表变得繁琐．比如:5级页表<br>    不是让页表与逻辑地址空间的大小相对应，而是让页表与物理地址空间的大小相对应:<br>        1. 逻辑（虚拟地址空间增长速度快于物理地址空间）．</p><p>图:基于页寄存器的方案.<br>index 变了由逻辑页号变为了物理页号(页帧号)．根据物理页帧号查询他所对应的页号．反向查询.<br>这使得寄存器的容量只与物理地址的大小相关，与逻辑地址的大小无关．这样就限制了寄存器的数量．<br>还有一个很大的问题，就是我们根据page number来查找frome number的．这样一来怎么找到page　number所在的位置．我们的到的是以frame　number为index的数组.<br>难题：如何建立页号和页帧号的对应关系的建立?</p><p>解决方案 图:基于关联内存的方案（关联存储器）<br>这个问题可以解决，但是寄存器设计复杂，开销太大，由于复杂导致他的容量不可能做的太大．<br>key -&gt;页号<br>Value-&gt;页帧号<br>放到cpu里边，由于内存开销过大，没法避免．<br>如果放到cpu外边就会产生一个内存访问问题．<br>图：使用页寄存器.<br>有例题．</p><p>图：在反向页表中搜索一个页对应的帧号<br>如果帧数较少，页寄存器可以被放置在关联内存中．<br>在关联内存中查找逻辑页号</p><ol><li>成功: 帧号被提取</li><li>失败: 页错误异常(page fault)<br>限制因素:<br> 大量的关联内存非常昂贵:<pre><code> 1. 难以在单个时钟周期完成 2. 耗电．</code></pre></li></ol><p>图:基于哈希查找的方案.<br>  输入page number 输出　frome number.(就一个底层的计算)<br>  可以用软件使用也可以用硬件加速.<br>  为了更快地效率，加一个PID(当前运行程序的ID),PID加上page number就可以很好通过哈希函数设计出对应的frame  number.很好的缓解了完成映射的开销．</p><p>把反向列表存到没存中去说白了内存的开销还是很大，还需要一个TLB的机制给他缓存起来，来降低访问列表的时间开销，（目前反向列表只有在高级的cpu中存在.<br>  再反向页表中通过哈希算法来搜索一个页对应的帧号．</p><ol><li>对页号做哈希计算，为了在”帧表”(每帧拥有一个表项)中获取对应的帧号．</li><li>页i被放置在表中f(i)位置，其中f是设定的哈希函数<br>　为了查找页i,执行下列操作:<ol><li>获取对应的页寄存器</li><li>检查寄存器标签是否包含i,如果包含，则代表成功，否则失败．</li></ol></li></ol><p>好处:不受限与逻辑内存大小的影响．只和我们物理的内存有关，<br>对于单级列表来说，每个程序都有一份自己的页表（page table)，对多级页表来说整个系统只要一个．因为他是用物理页帧号作为(index)来建立的表．需要高速的硬件计算，高速的处理函数．还需要一个解决冲突的机制，来保证高效的执行，</p><h4 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h4><p>起因:<br>虚拟内存之前用</p><ol><li>覆盖技术</li><li>交换技术<br>然后发展虚存技术</li><li>目标</li><li>程序局部性原理</li><li>基本概念</li><li>基本特征</li><li>虚拟页式内存管理</li></ol><p>理想中的存储器<br>更大，更快，更便宜的非易失性存储器．（就是断电能够保存数据）<br>图:os支持的存储器<br>基本实现了更大，更快，更便宜，但是非易失性基于现在的硬件设备没能实现，</p><p>通过操作系统的管理把不常用的数据放到硬盘上去，把常用的数据放入内存，这样让有限的内存放经常访问的数据，通过这种方式实现一种大内存的感觉，这种方式需要cpu,mmu硬件和操作系统内核协同在一起才能完成，</p><p>在早期遇到这种情况怎么办？</p><ol><li>如果是程序太大,超过了内存的容量，可以采用手动的覆盖技术，只把需要的指令和数据保存的内存中． </li><li>如果是程序太多，超过了内存的容量，可以采用自动的交换技术，把暂时不能执行的程序送到外存中．</li><li>如果想要在有限容量的内存中，以更小的页粒度为单位装入更多更大的程序，可以采用自动的虚拟存储技术．</li></ol><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>目标:<br>    是在较小的可用内存中运行较大的程序．常用于多道程序系统，与分区存储管理配合使用．<br>原理:<br>把程序按照期自身逻辑结构，划分为若干个功能功能上相对独立的程序模块,那些不会同时执行的模块共享同一块内存区域，按时间先后来运行．</p><ol><li>必要部分(常用功能)的代码和数据常驻内存</li><li>可选部分(不常用功能)在其他程序模块中实现，平时存放在外存中，需要时才装如内存<br>3, 不存在调用关系的模块不必同时装入到内存，从而可以交互覆盖，即这些模块共用一个分区．<br>图:覆盖技术例子<br>程序A需要常驻内存，因为他要常驻内存，来调用BCDEF的执行．BC不会相互调用，DEF也不会相互调用，因此分成了两个共享区．（注意图中共享内存大小和原来程序的大小），在调用的过程中，比如A调用C,ｃ的内存会被调入都一个覆盖区，再调入之前需要把B的内容导回到硬盘中，注意代码是只读的不需要导只需要释放就可以了，把调入的内存和数据调用完，A就可以调用C了，<br>缺点:开销问题<ol><li>(设计开销)由程序来吧一个大的程序划分成为若干个小的功能块，并确定各个模块之间的覆盖关系，费时费力，增加了编程的复杂度．</li><li>(引入了时间开销)覆盖模块从外村装入内存，实际上是以时间延长来换区空间节省．</li></ol></li></ol><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>目标:<br>    多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源．<br>方法:<br>    1. 可将暂时不能运行的程序送到外存，从而获得空闲内存空间，<br>    2. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出swap out),而将外存中的某个进程的地址空间读入到内存中(换入swap in).换入换出内容的大小为整个程序的地址空间．<br>    换入换出这一部分是操作系统的一个重要部分，导入导出的粒度是一个程序，这跟程序的大小有关，如果程序比较大那么导入导出的开销就比较大，否则就比较小，相对来说粒度会大于一个页几十几百页，所以说导入导出的开销是比较大的．</p><p>图:交换技术</p><p>交换技术实现中的几个问题</p><ol><li>交换机的确定:何时需要发生交换?（如果频繁的交换会产生很大的开销）只当内存空间不够或又不够的危险时换出；（尽量减少换入换出的次数）</li><li>交换区的大小:必须足够大以存放所有用户进程的所有内存映像的拷贝；必须能够对这些内存映像进行直接存取；</li><li>程序换入时的重定位:换出后再换入的内存位置一定要在原来的位置上吗?最好才赢动态地址映射的方法．（换入换出的位置可能发生变化，寻址就会出现问题，怎么能让换入新地方的程序正常执行，值得思考．如果是换入位置是换出前的位置一样，那能正常执行，没问题，所以需要建立页表虚地址一样物理地址不一样，页表建立完成就可以了，也是动态地址映射的方法）</li></ol><h5 id="覆盖和交换技术的比较"><a href="#覆盖和交换技术的比较" class="headerlink" title="覆盖和交换技术的比较"></a>覆盖和交换技术的比较</h5><p>覆盖技术一个程序的模块，交换技术是一整个程序，所以说粒度有差别．</p><ol><li>覆盖只能发生在那些相互之间没有调度关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构．</li><li>交换技术是以在内存中的程序大小为单位来进行的，他不需要程序员给出各个模块之间的逻辑覆盖结构．换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部（某个函数为覆盖对象，不好的地方是需要程序员手动的指定他们之间的逻辑关系，便于覆盖处理单元完成相应的功能）．</li></ol><h4 id="虚拟技术-上"><a href="#虚拟技术-上" class="headerlink" title="虚拟技术(上)"></a>虚拟技术(上)</h4><p>虚拟技术–目标<br>在内存不够用的情形下，可以采用覆盖技术和交换技术，但是:<br>    1. 覆盖技术:需要程序员自己把整个程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，增加了程序员的负担；<br>    2. 交换技术:以进程作为交换单位，需要把进程的整个地址空间都换进换出，增加了处理器的开销．<br>更好的解决办法（四海之内的）解决之道:虚拟内存管理技术—虚拟技术</p><p>虚拟技术–目标</p><ol><li>像覆盖技术那样，不是把程序的所有内容都放在内存中，因而能够运行比当前的空闲内存空间还要大的程序．但做的更好，由操作系统自动来完成，无需程序员的干涉:</li><li>像交换技术那样，能够实现进程在内存和外村之间的交换，因而获得更多的空闲空间，但做的更好，只对进程的部分内容在内存和外存之间进行交换．（不用交换整个程序或者程序块，只需要动态调用所需要用到的页就好了，没有运行到的就放到外村就可以了）由操作系统和MMU合作完成的．</li></ol><p>由于这个过程是自动做的，就会要求程序有一定的局部性.<br>虚拟技术—程序的局部性原理<br>程序的局部性原理:指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域．这可以表现为:<br>    1. 时间局部性:一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；<br>    2. 空间局部性:当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内．<br>    程序的局部性原理表明，从理论上来说，虚拟存储技术是能够实现的，而且在实现了以后应该是能够取得一个满意的效果的．<br>图:虚拟技术–程序的局部性原理 例题<br>图:虚拟技术–程序的局部性原理2 题解<br>缺页中断，就是4k的物理内存，每次能存1024字节(图中的消息得出)，如果访问没有数据了，就会产生缺页中断．<br>第二中就不具备两种局部性．注意32位系统下一个整形占4比特，1024*4 = 4k.</p><p>根据时间局部性来判断需要把哪些内容放到内存中去．</p><p>图:虚存技术–基本概念<br>可以在页式或段式内存管理的基础上实现．</p><ol><li>在装入程序时，不必将其全部装入内存，而是需将当前需要执行的部分页面或段装入到内存，就可以让程序开始执行；</li><li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内容（称为缺页或缺段）,则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序．</li><li>另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段．</li></ol><p>虚存技术-基本特征</p><ol><li>大的用户空间:通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离．如32位的虚拟地址理论上可以访问4GB,而可能计算机上仅有256M的物理内存,但硬盘容量大于4GB.</li><li>部分交换: 与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的．</li><li>不连续性: 物理内存分配的不连续，虚拟地址空间使用的不连续．（某些代码换出去，导致不连续）</li></ol><p>虚拟内存 = 物理内存 + 硬盘</p><p>虚拟内存的实现．<br>图：虚拟技术-虚拟页式内存管理<br>虚拟技术-虚拟页式内存管理　<br>大部分虚拟存储系统都采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加请求调页和页面置换功能．<br>基本思路:<br>    1. 当一个用户程序要调入内存运行时,不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可以启动程序运行．<br>    2. 在运行过程中，如果发现要运行的程序或要访问数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行．<br>    换入换出过程中有效的置换算法，起着关键因素．</p><p>图:虚拟技术-虚拟页式内存管理–页表项<br>页表项中有4个bity比较重要．<br>逻辑页号—访问位-修改位-保护位-驻留位-物理页帧号</p><ol><li>驻留位:表示该页是在内存还是在外存．如果该位等于1,表示该页位于内存当中，即该页表项是有效的，可以使用；如果该位等于0,表示该页当前还在外存当中，如果访问该页表项，将导致缺页中断；</li><li>保护位: 表示允许对该页坐何种类型的访问，如只读，可读写，可执行等．</li><li>修改位: 表明此页在内存中是否被修改过．当系统回收该物理页面是，根据此位来决定是否把它的内存写回外存；（如果数据没有被修改，就不需写回，直接释放即可，有数据更新则就写回）．</li><li>访问位: 如果该页面被访问过,(包括读操作或写操作),则设置此位用于页面置换算法．</li></ol><p>图:虚拟技术–虚拟页式内存管理bity图</p><p>如果是X就说明驻留位为零，否则就是一个数字表示驻留位为1，表示该位是有效的。</p><p>如果把虚拟的零地址赋值给一个寄存器，命令如MOV REG, 0</p><p>查询0的页号对应的是2，代表驻留位为1，对应关系是有效的，页帧号为2，一个页的大小为4k，表示4096，用4096*2 = 8192，实际访问的物理地址就是8192.操作正常没有问题。</p><p>现在要把   MOV REG, 32780</p><p>就是要把虚拟得知32780读到寄存器中去，页表项就是第八个，32k-36k区间，驻留位的设置为零，没有所对应的页帧号，就会产生缺页异常（缺页中断）。</p><p>图：虚拟技术–虚拟页式内存管理-缺页中断</p><p>一旦缺页，程序就会把控制权交给操作系统，然后执行图中流程。</p><p>后备存储</p><p>在何处保存未被映射的页？</p><ol><li><p>能够简单的识别在二级存储器中的页</p></li><li><p>交换空间（磁盘或者文件）:特殊格式，用于存储未被映射的页面。</p></li></ol><p>概念后备存储</p><ol><li>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置</li></ol><p>例如：访问一个数组，他是一个大的数据可能是一个数据文件，方在了我们的硬盘上，当需要访问到某个地方的时候呢，如果内存中没有就需要从数据文件中读取出来，（这是一种后援存储 ）</p><ol start="2"><li>代码段:映射到可执行二进制文件   </li></ol><p>操作系统在执行代码过程中，会执行每一条指令，这个指令也是一种数据，这个数据放到我们的执行程序里边.放在我们的硬盘中，我们的硬盘存了好多执行程序。会把这些代码当做数据，放到内存中去。然后让我们cpu去执行一条条指令，如果遇到某条指令不存在的情况，会进一步从执行程序中，把信息读取到内存中来进一步执行，这属于代码的一种后备存储。</p><ol start="3"><li>动态加载的共享库程序段:映射到动态调用的库文件</li></ol><p>软件运行需要很多库，这些库也是放到硬盘中的，需要的时候才会把库的代码和数据从硬盘中读进内存中。</p><ol start="4"><li>其他段:可能被映射到交换文件（swap file）</li></ol><p>程序在运行的过程中，会产生很多的数据，这些数据没有对应到具体文件（数据文件，执行文件，库文件等），这些数据可能占了很大空间，需要被换出到硬盘上去，操作系统会在硬盘开辟一个区（swap换入换出分区）放置那些没有与文件直接对应的那些内容。</p><p>这四部分构成了我们说的后备存储或者二级存储，充分保证空间的有效性。</p><p>图:虚拟内存性能</p><p>p:代表残缺的概率</p><p>q:代表对页进行写操作的概率</p><p>5000，000表示ms到ns的换算</p><p>（1+q）写完后需要换出操作，写入硬盘，也需要5ms的时间。</p><p>p足够小使得公式后边的数最小，这样接近10ns</p><p>我们有办法保证p的最小就是程序的局部性特点，就是缺页的概率很小，</p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>功能与目标</p><ol><li>功能:当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中那个物理页面被置换</li><li>目标:尽可能地减少页面的换进换出次数(即缺页中断的次数).具体来说，把未来不再使用或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数据来进行预测:</li><li>页面锁定:用于描述必须常驻内存的操作系统的关键部分或时间关键的应用程序．实现的方法是：在页表中添加锁定标志位（lock bit）,使得这些页不在页面处理算法之内．确保操作系统随时能正常工作．<br>实验设置与评估方法<br>局部页面置换算法</li><li>最优页面置换算大(opt)</li><li>先进先出算法(FIFO)</li><li>最久未使用算法(LRU)</li><li>时钟页面置换算法(clock)</li><li>最不常用算法(LFU)</li><li>Belady现象</li><li>LRU,FIFO和Clock的比较．<br>全局页面置换算法</li><li>工作集模型</li><li>工作集页置换算法</li><li>缺页率置换算法</li></ol><h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><p>图:1最优页面置换算法–性能分析<br>(3,0) (1, 9)表示页号和偏移(f, o);<br>只有页不存在的情况，才会产生缺页中断，所以只看页就可以了，offset忽略掉就可以．<br>更少的缺失，更好的性能．</p><p>基本思路:当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多久时间，从中选择等待时间最长的那个，作为被置换的页面．</p><p>这是一种理想情况，在实际系统中是无法实现的，因为操作系统无从知道每一个页面要等待多久时间以后才会再次被访问．<br>这个算法涉及到了未来，所以无法实现，这个算法只是作为一个评价算法好坏的标准．</p><p>可以作其他算法的性能评价的依据(在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二次运行时即可使用最优算法．</p><p>图:置换页面算法的例题<br>前a,b,c,d四个页已经存到了物理页里．所以说前四个不弄页面置换，后边才涉及到页面转换，换出的时间最长不用的．<br>第四步中<br>步数为a = 7, b = 6, c = 9, d = 10,需要把d替换出去，e替换进来．</p><h4 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h4><p>基本思路:选择在内存中驻留时间最长的页面并淘汰之，具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面．从链表的排列顺序来看，链首页面的驻留时间最长，链表页面的驻留时间最短．当发生一个缺页中断时，把链首页面淘汰出局，并把新的页面添加到链表的末尾．</p><p>性能较差，调出的页面有可能是经常要访问的页面，并且有Belady现象．<br>FIFO算法很少单独使用．<br>图:FIFO</p><h4 id="最近最久未使用算法"><a href="#最近最久未使用算法" class="headerlink" title="最近最久未使用算法"></a>最近最久未使用算法</h4><p>图:最久未使用算法.<br>图:页面置换算法应用<br>图:LRU算法数据维护</p><ol><li>头插链表，头部为最近时期用的，尾部没用的</li><li>用栈维护，栈顶为最近用的，栈尾为最久未用的．<br>图LRU算法基于栈的样例<br>lRU算法，系统开销过于大．不利于你系统和程序的运行平衡．</li></ol><h4 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h4><p>图:时钟页面置换算法(由cpu访问页，就会把xsexbit(时钟位)位置一，此过程不需要软件参与，由硬件完成)<br>这个算法依据的就是x-sexbit位.<br>图:时钟置换算法原理<br>page 7,4,0,3,1五个虚拟页放在物理内存中的<br>第一位表示页的存在位，页的存在1,不存在0.(resident bit)<br>第二位表示x-sexbit（access bit）<br>第三位表示页帧号(frame number)<br>通俗来说当前位如果为1,就替换成0,指针下移动一位，找到零就会把虚拟页为6(举例子)的内容存到物理页为5的页中，然后置为1.</p><p>图:时钟置换原理算法题<br>最下边一行每一列表示一个环形列表．</p><p>在实际过程中clock和LRU置换算法的置换页面次数相近（产生缺页中断的次数），因为clock只用了一个bit为来表示置换的信息，达不到LRU那么精确.达不到最好的效果，但是接近，</p><h4 id="二次-机会-进位法"><a href="#二次-机会-进位法" class="headerlink" title="二次(机会)进位法"></a>二次(机会)进位法</h4><p>clock算法用了页表项的access bit位，标记了访问信息，但是访问信息是读和写，两种都是访问，并没有区分．页表项中还有一个叫dity bit脏位标记，如果进行了写操作，dity bit 会置为1,如果只是读操作没有写，dity bit 置位为零．（有硬件完成的）</p><p>如果把页内容从硬盘中读入内存，如果只有读操作，那么把该页替换出去的话，就不会把该页重新写回到硬盘中去，只把该页内容释放掉就好了，因为他们的内容是一样的．如果程序在访问这一页的过程中对该页进行了写操作．这个页如果被替换出去的话，就需要把页重新写回到硬盘中去．通过dity bit 这一位就可以改善clock这个算法的执行效率，就更名为”二次进位法”</p><p>图：二次进位法<br>查看图的　从左往右数，第二位(used)access bit, 第三位dity bit.<br>　　　　　　　　　　　　　　　　　　after clock sweep<br>used bit　　　　　dity bit 　　　　used bit　　　dity bit　　　　<br>0　　　　　　　　　0　　　　　　　　replace page<br>0　　　　　　　　　1　　　　　　　　0　　　　　　0<br>1　　　　　　　　　0　　　　　　　　0　　　　　　0<br>1　　　　　　　　　1　　　　　　　　0　　　　　　1<br>二次机会由来是因为两个标记位都是1,就要就行指针两次循环指，才能把该页换出去．从而使被写过的页被换出去的概率减少．由于dit bit位进行了修改，所以要标记一下是否进行了写操作．比如图中a^w ｗ标记为写过．<br>图:二次进位法例题</p><h4 id="最不常用法-Least-Frequently-Used-LFU"><a href="#最不常用法-Least-Frequently-Used-LFU" class="headerlink" title="最不常用法(Least Frequently Used LFU)"></a>最不常用法(Least Frequently Used LFU)</h4><p>基本思路: 当一个缺页中断发生时，选择访问次数最少的那个页，并淘汰之．<br>实现方法: 对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加1,在发生缺页中断时，淘汰计数值最小的那个页．（用计数器来存，很明显硬件开销很大，如果也很大，链表查找时间按也必然很长）</p><p>LRU和LFU区别:LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问次数和频度，访问次数越多越好．</p><p>问题：一个页面在进程开始使用得很多，但以后就不使用了．实现也费时费力．<br>解决方法: 定期把次数寄存器右移一位．</p><h4 id="Belady现象，LRU-FIFO"><a href="#Belady现象，LRU-FIFO" class="headerlink" title="Belady现象，LRU,FIFO"></a>Belady现象，LRU,FIFO</h4><p>Belady现象:在采用FIFO算法时,有时会出现分配的物理页面增加,缺页率反而提高的异常现象;注意Belady是科学家名字．<br>Relady现象的原因:FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的(即替换较少使用的页面),因此，被置换出去的页面并不一定是进程不会访问的．<br>图:Belady-FIFO（分三个物理页的情况）<br>最后一行X表示产生缺页中断，带框的就是不产生缺页中断．<br>图:Belady-FIFO-page-4(分四个物理页的情况)<br>给三行物理页缺页次数为9,给四行物理页缺页次数变为10.期望的是少结果变多了．<br>图中不是最坏的，最坏情况就是每次都会产生缺页中断．</p><p>图: Belady-LRU实例<br>Belay-FIFO ：物理页为3缺页中断次数为10</p><p>LRU: 物理页为4缺页中断次数为8,更符合我们的理想情况，</p><p>时钟/第二次机会页面置换是怎样的?</p><p>为什么LRU页面置换算法没有Belay的现象？（再此鼓励查找Belady现象的论文查找读）<br>LRU算法符合一类栈算法的特点，符合这一特点就有一种属性，给的物理页越多产生的缺页次数越少．FIFO不满足栈算法这一特点．</p><p>LRU,FIFO和Clock的比较(如果程序没有良好的局部性这些区别也就不会很大，都会成为最差的算法)<br>LRU算法和FIFO本质上都是先进先出的思路，只不过LRU是针对页面的最近访问时间来进行排序，所以需要在每一次页面访问的时候动态调整各个页面的先后顺序（有一个页面的最近访问时间变了）；而FIFO是针对页面进入内存的时间来进行排序，这个时间是固定不变的，所以各页面之间的先后顺序是固定的，．如果一个页面在进入内存后没有被访问，那么它的最近访问时间就是进入内存的时间．换句话说，如果内存当中的所有页面都未曾访问过，那么LRU算法就退化为FIFO算法．</p><p>例如进程分配3个物理页面，逻辑页面的访问顺序为1,2,3,4,5,6,1,2,3…</p><p>如果程序有更好的局部特点，LRU更能适应，也能产生更能好的效果．<br>所以说如果程序没有很好的局部性，LRU和FIFO算法就会有一样的不太好的效果．<br>clock算法是对LRU算法的一种类似，只是clock用access bit和dity bit两个位进行了标记（硬件标记）,不能精确的表示使用的频率信息，最差效果也是FIFO算法．开销比LRU算法小的很多.因为LUR在某种情况下会退化为FIFO,所以clock在最坏的情况下也会退化为FIFO算法．</p><p>LRU算法性能较好，但系统开销较大；FIFO算法系统开销较小，但可能会发生Belady现象，因此，折中的办法就是Clock算法，每一次页面访问时，它不必去动态调用该页面在链表中的顺序，而仅仅是做一个标记，然后等到发生却也中的时候，再把它移动到链表末尾．对于内存当中那些未被访问的页面，Clock算法的表现和LRU算法一样好；而对于那些曾经被访问过得页面，它不能像LRU算法那样，记住他们的精准位置，</p><h4 id="局部页替换算法的问题"><a href="#局部页替换算法的问题" class="headerlink" title="局部页替换算法的问题"></a>局部页替换算法的问题</h4><p>以上算法针对的是一个进程或者是一个程序来写的．如果操作系统只是采取固定的局部的页面置换算法，其实会带来一些问题，这就是全局置换算法产生的原因．<br>图:FIFO页面置换算法不同物理页区别</p><p>可以看出物理页数的不同会影响到不同页面置换算法的效果．（效果评判看置换页面的多少，少的为优），如果分配一个固定的页帧，和一个固定的算法没给一个程序，其实在某种程度上就限制了程序产生缺页的特点．因为程序在运行过程中他有一个阶段性特点．可能开始需要内存多中间少最后内存多，此时程序对物理页的需求是动态变换的过程．操作系统可同时跑多个程序，如果这时分配固定的物理页帧，就限制了物理灵活性．所以可不可以动态调整不同时期对程序分配的物理页帧，这是全局页面置换算法要考虑的问题．</p><p>实现全局置换算法的前提(工作集模型)<br>前面介绍的各种页面置换算法，都是基于一个前提．<br>即程序的局部性原理，但是此原理是否成立?</p><ol><li>如果局部性原理不成立，那么各种页面置换算法就没有什么区别，也没有什么意义．例如;假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,7,8,9…,即单调递增，那么在物理页面数有限的前提下你，不管采用何种置换算法，每次的页面访问必然导致缺页中断．</li><li>如果局部性原理是成立的（时间和空间访问的局部性），那么如何来证明他的存在，如何来对它进行定量的分析?这就是工作集模型．</li></ol><p>工作集定义:<br>工作集: 一个进程当前正在使用的逻辑页面集合．（当前正在使用表示一个时间段，起始时间，时间长度）（逻辑页面的集合这是一个集合）<br>可以用一个二元函数W(t,△ )来表示:<br>t :是当前的执行时刻；<br>△ : 称为工作集窗口(working-set window),即一个定长的页面访问的时间窗口；（t + △ 形成的时间段）<br>W(t, △ ) = 在当前时刻t之前的△ 时间窗口当中的所有页面所组成的集合（随着t的变化，该集合也在不断的变化）;（t在变△ 不变，移动定长窗口）<br>| W(t, △ )|指定工作集的大小，即页面数目．（在der ta（△ ）时间内访问到的页面的集合）</p><p>图：工作集实例</p><p>△ :当前和过去的大小．（注意是过去）<br>分析：t1中7出现了四次，但是t2中多个数多次出现，从工作集中看出，t1比t2的程序局限性比差．</p><p>图：工作集大小的变化图<br>可以看出工作集动态变化的特征．</p><p>另一个概念：常驻集<br>常驻集是指在当前时刻，进程实际驻留在内存当中的页面集合．<br>图:常驻集（笔记中符号有缺陷可看图）<br>对比解释：</p><ol><li>工作集是进程在运行过程中固有的性质，而常驻集取决于系统分配给进程的物理页面的数目，以及所采用的页面置换算法；（常驻集就是当前程序需要访问的页哪些在内存中，工作集是在运行过程中需要访问的页是那些，也得有一个上限，不是越多越好，超出一定限制，程序会把多余的页分给其他程序，使得所有程序总的缺页次数比较小）</li><li>如果一个进程的整个工作集都在内存中，即常驻（－）工作集，那么进程将很顺利的运行，而不会造成太多的缺页中断(直到工作集发生剧烈变动，从而过渡到另一状态);<br>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，</li></ol><h4 id="两个全局置换算法"><a href="#两个全局置换算法" class="headerlink" title="两个全局置换算法"></a>两个全局置换算法</h4><h5 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h5><p>工作集页置换算法的思想:<br>随着工作窗口的移动，页不属于工作集窗口或者缺页了都会进行替换（或者说丢掉）．<br>性质：每次窗口中都有一定的物理页，来进行页面的替换或者丢弃（来确保整个系统的缺页置换次数降低）</p><p>图：工作集页置换算法实例.<br>图片讲解：开始分配了五个物理页帧其中ade三个窗口被访问了．剩下两个页是空页还可以再用．<br>第几次访问等同于第几个时刻访问．<br>第一次访问: 工作集a,c,d,e（缺页中断大红点）<br>第二次访问: 工作集a,c,d（e不属于工作集窗口的元素，如果只读直接free,如果可写就得写回硬盘）<br>第三次访问: 工作集a,c,d（工作集不变）<br>第四次访问: 工作集b,c,d,(把a换出去，把b换进来产生缺页中断，为什么换a,因为a的t= 0,超出了工作级窗口．)<br>第五次访问: 工作集b,c,d(工作集不变)<br>第六次访问: 工作集b,c,d,e（工作集加入e）<br>第七次访问: 工作集b,c,e(工作集由于ｄ的时间到了剔除，别的不变)<br>第八次访问: 工作集c,e(b到时间了，可以看出即使没有中断由于工作集往前走，所以也会把到时见的页踢出工作集)</p><p>根据窗口从不变到改变得到了以下的算法．</p><h5 id="缺页率页面置换算法"><a href="#缺页率页面置换算法" class="headerlink" title="缺页率页面置换算法"></a>缺页率页面置换算法</h5><p>可变分配策略: 常驻集大小可变．例如: 每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，在动态的调整常驻集的大小．</p><ol><li>可采用页面置换的方式，法身一个缺页中断时，被置换的页面可以是在其他进程当中，各个并发进程竞争地使用物理页面．</li><li>优缺点:性能较好，但增加了系统开销．</li><li>具体实现: 可以使用缺页率算法(PFF, page fualt frequenvy)来动态调整常驻集的大小．</li></ol><p>缺页率：<br>缺页率表示＂缺页次数/内存访问次数＂(比率)或＂缺页的平均时间间隔的倒数＂.影响缺页率的因素:</p><ol><li>页面置换算法</li><li>分配给进程的物理页面数目（一般情况下物理页越多产生的缺页次数越少）</li><li>页面本身的大小（页面越大差生的缺页次数也会减少）</li><li>程序的编写方法（程序是否拥有局部性）</li></ol><p>图:缺页率算法<br>若运行程序的缺页率过高，则通过增加工作集来分配更多的物理页面；若运行的程序的缺页率过低，则通过减少工作集来减少他的物理页面数．力图使运行的每个程序的缺页率保持在一个合理的范围内．</p><p>一个交替的工作集计算明确的试图最小化页缺失</p><ol><li>当缺页率高的时候-增加工作集</li><li>当缺页率低的时候-减少工作集</li></ol><p>图:缺页率页面置换算法<br>算法:<br>注意T 为一个时间阈值．<br>保持追踪缺失发生概率:<br>    当缺失发生时,从上次页缺失起计算这个时间记录这个时间，t(last)是上次的页缺失的时间．<br>    如果发生页缺失之间的时间是”大”的，之后减少工作集如果．<br>    如果t(current) - t(last) &gt; T,之后从内存中移除所有在[t(last), t(current)]时间内没有被引用的页．<br>    没有被引用的页．<br>    如果这个发生页缺失的时间是”小”的，之后增加工作集．<br>    如果t(current) - t(last) &lt;= T，之后增加缺失页到工作集中． </p><p>图:页面置换算法实例</p><p>前三个不用管，因为就产生一次中断，到第二次页面中断才能应用该算法，<br>第四个时刻；4 - 1 &gt; 2,page(e)就是第五个页不在工作集内，被清理出去，缩小窗口．a在该时间段内没有被访问也被剔除．b添加进来．工作集变为（b,c,d）.<br>第五个时刻:没有变化<br>第六个时刻:有缺页变化, 6-4 &lt;= 2,符合算法的第二点，直接把e重新加入到工作集中来．新工作集（b,c,d,e）.<br>第七,八时刻: 没有变化<br>第九时刻: 有缺页中断，9 - 6 = 3 &gt; 2, b, d 没有被访问，剔除，a,c,e放在里边<br>第十时刻: 10 - 9 = 1,直接把缺的页面放到工作集中就行了．<br>工作集需要在每一个时刻调整工作集中的内容，而缺页率置换算法，只是在中断发生时，才会产生工作集调整．<br>这两个算法根据工作集和工作频度的大小来动态调整内存页的放入踢出情况．使得一些经常访问的页驻留在内存中．就全局运行的程序而言．全局置换算法优于局部页置换算法．</p><h4 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h4><p>其实就是对工作集和常驻集进行进一步讲解<br>工作集：程序在执行过程中对内存访问的固有属性，<br>常驻集: 指的是要把我们当前运行的程序要访问的那些页面放到内存里边来．</p><p>如果分配给一个进程的物理页面太少，不能包含整个的工作集，即常驻集是工作集的子集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为”抖动”<br>抖动产生的原因: 随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升．所以OS要选择一个适当的进程数目和进程需要的帧数，以便在并发水平和缺页率之间达到一个平衡．</p><p>如何量化页面抖动现象:<br>抖动问题可能会被本地的页面置换改善<br>更好的规则为加载控制:调整MPL所以:Better criteria for load cintrol:<br>Adjust MPL sot that :</p><ol><li>平均页缺失时间mean time between page faults(MTBF) = 缺页服务时间 page fault service time(PFST)</li><li>M(右旋转45度累加)WSi = 内存大小．<br>图：抖动问题的改动</li></ol><p>图横轴表示程序的多少，纵轴表示CPU的利用率．紫线图．<br>(MTBF)/(PFST) 蓝色表示，当蓝色线为1的点，就是最佳的时候．（尽可能改善了内存抖动现象）</p><p>如果一个程序耗费了很大的内存，也可能产生内存抖动现象．<br>内存抖动的主要原因就是需要的内存在硬盘，需要频繁的产生缺页中断，从而使得整个系统处于一个利用率很低的状态．<br>所以说系统需要全局页面置换算法的实现，来有效的缓解内存不够这种现象．同时来缓解内存不够这种现象．这是设计高效置换算法的原因．<br>实际过程中使用的算法更为复杂，这些只是一些简单的置换思路．<br>能力要求：　学完之后看到别的算法，能看出底层和置换顺序，给出一定的评价（评估，置换次数少者一般是优越的）</p><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>进程的组成<br>一个进程应该包括:<br>    程序的代码:<br>    程序处理的数据；<br>    程序计数器数器中的值，指示下一条将运行的指令；<br>    一组通用的寄存器的当前值，堆栈；<br>    一组系统资源(如打开的文件)<br>总之，进程包含了正在运行的一个程序的所有状态信息．</p><p>进程和程序的联系（多对多的映射关系）<br>1, 程序是产生进程的基础<br>2. 程序的每次运行构成不同的进程（资源数据不同，所得到的结果也是不同的）<br>3. 进程是程序功能的体现<br>4. 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序．（后半句是如果多个程序合在一起完成一个更大功能体现）</p><p>进程与程序的区别</p><ol><li><p>进程是动态的，程序是静态的；程序是有序代码的集合；进程是程序的执行，进程有核心态/用户态．（读取文件信息，操作系统代表地进程在内核中执行就是处于核心态）</p></li><li><p>进程是暂时的，程序是永久的；进程是一个状态变化的过程，程序可长久保存．</p></li><li><p>进程与程序的组成不同:　进程的组成包括程序，数据和进程控制块（即进程状态信息）（进程使用了程序的代码段，数据段，但是数据的处理不同比如输入和输出，以及为了管理进程信息建立的进程控制块等等．）<br>总的来说进程包括程序的部分也有自己独有的部分</p></li></ol><p>进程和程序的联系:类比<br>科学家做蛋糕问题<br>食谱= 程序,科学家 = CPU, 原料 =数据, 做蛋糕 = 进程.<br>科学家做蛋糕的过程就叫进程．<br>在坐蛋糕的过过程中会按照食谱（一条一条指令去做），蛋糕做完之后程序和进程都结束了，这就是程序和进程的对应关系．<br>做蛋糕途中儿子被狗咬了，给儿子处理伤口后，再回到做蛋糕．<br>体现了cpu的动态这一特性，也是第二件事优先级高于第一件事．（这是进程和程序没有的特性）</p><p>进程的特点</p><ol><li><p>动态性: 可动态的创建,结束进程;</p></li><li><p>并发性: 进程可以被独立调度并占用处理机运行；并发并行:</p><ol><li>并发: 指的是一段时间内有多进程在执行．如果时间很短，感觉是在一起执行一样．</li><li>并行:一个时刻多个进程能过同时执行．（所以说一个cpu只能执行一个进程，不能实现并发）．<br>如果需要执行别的进程就需要进行切换，所以说一个CPU在一段时内只能实现并发.<br>现在的机器存在多核（多个cpu）就能实现并行．</li></ol></li><li><p>独立性:不同进程的工作不相互影响．两个层面来看</p><ol><li>同过CPU调度，可能会受到第一个线程的影响，但是安全性（正确性）不受影响．就是一个进程的数据不会受到其他进程所破坏．怎么实现独立性呢？<br>这里提到了前边的页表，可以使不同的程序访问不同的地址空间，不可能越过这个地址空间，如果越过就会产生缺页异常（页错误）所以说页表是保证进程独立性的重要机制．cpu通过给不同的进程分配不同的页表，达到进程的独立性，这需要操作系统在内存管理上有一定的支持．</li></ol></li><li><p>制约性:因访问共享内存数据/资源或进程同步而产生制约．<br>　　进程进不可能完全独立，有可能还会有交互，或者说一个进程等另一个进程执行到一定阶段后才能执行另一个进程，两个进程间有一个时序的关系．这样进程间就会产生制约．也需要操作系统根据进程的特点来协调这些过程．那个时间执行进程ａ，那些时候执行进程ｂ，这涉及到进程间同步互斥的特点．</p></li></ol><p>图：进程的特点<br>ａ图：进程间的相互切换(动态性)<br>ｂ图: 地址空间相互独立<br>ｃ图: 不同时间的调度关系．需要操作系统去调度．执行那个进程．</p><p>问题:如果你要设计一个OS,怎么样来实现其中的进程管理机制?(思考！！！！！)</p><p>程序 =　算法　+ 数据结构<br>描述进程的数据结构:进程控制块(Process Control Block,PCB).<br>操作系统为每个进程都维护了一个PCB,用来保存与该进程有关的各种状态信息．</p><h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h4><h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><h4 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h4><p>如果进程存在PCB存在，如果进程消失PCB消失．（PCB是唯一的东西，是进程存在的唯一标识）．<br>进程控制块: 操作系统管理控制进程运行所用的信息集合．<br>操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志．</p><p>使用进程控制块<br>进程的创建: 为该进程生成一个PCB;<br>进程的终止: 回收它的PCB;<br>进程的组织管理: 通过对PCB的组织管理来实现;</p><p>PCB具体包含什么信息?如何组织的?进程的状态转换….?</p><p>PCB包含以下三大类信息:<br>进程标识信息．如本进程的标识，本进程的产生者标识(父进程标识)；用户标识．<br>处理机状态信息保护区．保护进程的运行现场信息:<br>    1. 用户可见寄存器，用户程序可以使用的数据，地址等寄存器．<br>    2. 控制和状态寄存器，如程序寄存器(PC),程序状态字(PSW).<br>    3. 栈指针，过程调用/系统调用/中断处理和返回时需要用到它．</p><p>进程控制信息</p><ol><li>调度和状态信息，用于操作系统调度进程并占用处理机使用．(描绘出进程当前执行现状)</li><li>进程间通信信息，为支持进程间的与通信相关的各种标识，信号，信件等．这些信息存在接收方的进程控制块中．</li><li>存储管理信息，包含有指向本进程映像存储空间的数据结构．</li><li>进程所用资源，说明由进程打开，使用的系统资源，如打开的文件等．</li><li>有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB.</li></ol><p>PCB的组织方式<br>链表: 同一状态的进程其PCB成一链表，多个状态对应多个不同的链表．<br>　　　个状态的进程形成不同的链表:就绪链表，阻塞链表．</p><p>用链表的主要原因，因为进程的创建和删除是一个动态的过程，一会创建，一会删除，在组织里可以动态加入，动态删除的．</p><p>索引表: 同一状态的进程归入一个index表(由index指向PCB),多个状态对应多个不同的index表<br>      各状态的进行形成不同的索引表: 就绪索引表，阻塞索引表<br>      索引如果是数组的话动态的加入删除开销会大很多．所以更多来说大多数系统使用链表．如果进程确定，没有过多的删除生成操作，索引也不失为一种更快捷的方法．</p><p>进程状态．</p><ol><li>进程的生命期管理</li><li>进程状态变化模型</li><li>进程挂起模型</li></ol><h4 id="进程的生命期原理"><a href="#进程的生命期原理" class="headerlink" title="进程的生命期原理"></a>进程的生命期原理</h4><ol><li>进程创建</li><li>进程运行</li><li>进程等待</li><li>进程唤醒</li><li>进程结束</li></ol><p>进程创建<br>引起进程创建的三个主要事件:<br>    1. 系统初始化时；(init进程)<br>    2. 用户请求创建一个新进程:(init 来创建别的进程)<br>    3. 正在运行的进程执行了创建进程的系统调用；</p><p>进程运行<br>内核选择一个就绪的进程，让它占用处理机并执行<br>(下边两个问题涉及系统调度的问题)</p><ol><li>为何选择?</li><li>如何选择?</li></ol><p>进程等待<br>在以下情况下，进程等待(阻塞):<br>    1. 请求并等待系统服务，无法马上完成<br>    2. 启动某种操作，无法马上完成<br>    3. 需要的数据没有到达．</p><pre><code>进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生．</code></pre><p>进程唤醒　<br>进程唤醒的原因:<br>    1. 被阻塞进程需要的资源可被满足<br>    2. 被阻塞进程等待的事件到达<br>    3. 将该进程的PCB插入到就绪队列．</p><pre><code>进程只能被别的进程或操作系统唤醒．</code></pre><p>进程结束<br>在以下四种情形下，进程结束:<br>    1. 正常退出(自愿的)<br>    2. 错误退出(自愿的)<br>    3. 致命错误(强制性的)(抢占了其他进程的空间死的形式3/4两种方式)<br>    4. 被其他进程所杀(强制性的)</p><p>图:进程的运行过程.</p><h4 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h4><p>进程的三种基本状态:<br>    进程在生命结束前处于且仅处于三种基本状态之一不同系统设置的进程状态数目不同．<br>    1. 运行状态(Running): 当一个进程正在处理机上运行时．<br>    2. 就绪状态(Ready):一个进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行．<br>    3. 等待状态(又称为阻塞状态Blocked):一个进程正在等待某一事件而暂停运行时．如等待某资源，等待输入/输出完成．</p><p>图：进程运行状态模型</p><p>进程其他的进程状态:<br>    1. 创建状态(new):一个进程正在被创建，还没被转到就绪状态之前的状态．<br>    2. 一个进程正在从系统中消失时的状态，这是因为进程结束或由于其他原因所导致．</p><p>图:进程五状态图<br>为什么运行的好好地就从运行态转变成就绪态?<br>由于每个就绪进程，操作系统都希望他得到执行，所以会给每个进程分配一个时间片(小的时间段)，然后CPU会执行，等到时间片运行完之后，就会变回到就绪态．让其他处于就绪态的进程能被执行．可以使的每个就绪态的进程可以公平的获得CPU的资源去执行．</p><p>可能的状态变化如下:<br>    NULL-&gt;new: 一个新进程被产生出来执行一个程序．(创建PCB,进行PCB的初始化（数据结构的定义）初始化为零)<br>    new-&gt;Ready: 当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态．是否会持续很久?（PCB的初始化，所需资源准备完毕，就是初始化完毕）（初始化为一定的数据）．<br>    他不会持续很久，因为只是一个初始化，而且初始化会很快．<br>    以下两个步骤取决于时间调度算法．<br>　　Read-&gt;Running: 处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行.<br>　　Running-&gt;Exit:当进程表示它已经完成或者因出错，当前运行进程会由操作系统作结束处理．<br>　　Running-&gt;Ready:处于运行状态的程序在其运行过程中，由于分配给他的处理机时间片用完而让出处理机.谁完成?<br>　　(因为同时存在多个就绪态进程，都得执行，所以划分时间片，所以会出现运行态到就绪态)<br>　　这里是操作系统来完成的，应用进程不是说能让出来就能让出来的．因为操作系统有会管理一个时钟．<br>　　Running-&gt;Block:　当进程请求某样东西且必须等待时.例如?<br>　　等待定时器，或者读写文件就比较慢．就会到阻塞态．<br>    Blocked-&gt;Ready:　当进程要等待某事件到来时，他从阻塞状态变到就绪状态，例如?<br>    当这个事件阻塞到某一件事件上边，当这个事件到来，就会从阻塞态变到就绪态．有操作系统完成．</p><h4 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h4><p>Why? 合理且充分的利用系统资源．<br>进程在挂起状态时，意味着进程没有占用内存空间．处在挂起状态的进程映像在磁盘上．这个时候进程是挂起的进程．<br>进程挂起：通俗来说进程没有占用内存空间，就是进程挂起．<br>前边说进程在内存中运行，怎么能不占用内存呢?<br>虚拟内存部分说到了，会把运行的一部分不用的空间，移到外存中去．腾出更多的空间给需要的进程去使用（以前说的运行的程序就叫进程）．<br>图：进程挂起</p><p>挂起状态两种</p><ol><li>阻塞挂起状态(Block-suspend): 进程在外存并等待某事件的出现，</li><li>就绪挂起状态(Ready-suspend):　进程在外存，但只要进入内存，即可运行．</li></ol><p>与挂起相关的状态转换<br>挂起: 把一个进程从内存转到外存:可能有一下几种情况:<br>    1. 阻塞到阻塞挂起: 没有进程处于就绪状态或就绪进程要求更多内存资源时，会进行这种装换，以提交新进程或运行就绪进程；<br>    2. 就绪到就绪挂起:当有优先级阻塞(系统一位会有很快就绪的)进程和低优先级先就绪进程时，系统会选择挂起低优先级就绪进程；<br>    3. 运行到就绪挂起: 对抢先式分时系统，当有高优先级阻塞挂进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态．<br>    4. 阻塞挂起到就绪挂起（在外存中的状况）:当有阻塞挂起进程因相关事件出现时，系统会把阻塞挂起进程转换为就绪挂起进程．（但是进程所需要的资源，还是都存储在硬盘中的）．</p><p>与挂起相关的状态转换（续）<br>解挂/激活(Activate):把一个进程从外存转到内存；可能有一下几种情况：</p><ol><li>就绪挂起到就绪: 没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换．</li><li>阻塞挂起到阻塞: 当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起（系统认为会很快出现所等待的事件）进程转换为阻塞进程；</li></ol><p>OS怎么通过PCB和定义的进程状态来管理PCB,帮助完成进程的调度过程?</p><p>用进程的观点来看待OS:用户进程，磁盘管理进程，中断进程…….<br>以进程为基本结构的OS:<br>    最底层为CPU调度程序(包括中断处理等)；<br>    上面一层为一组各式各样的进程；</p><p>状态队列</p><ol><li>由操作系统来维护一组队列，用来表示系统当中所有进程的当前状态；</li><li>不同的状态分别用不同的队列来表示(就绪队列，各种类型的阻塞队列)；</li><li>每个进程的PCB都根据它的状态加入相对应的队列当中，当一个进程的状态发生变化时，它的PCB从一个状态队列中脱离出来，加入到另外一个队列．</li></ol><p>图；状态表示方法</p><p>小结:<br>　　进程描述<br>    1. 进程定义<br>    2. 进程的定义和组成<br>    3. 进程控制结构</p><pre><code>进程状态1. 进程的生命期管理2. 进程状态变化模型3. 进程挂起模型</code></pre><h4 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程</h4><p>线程管理<br>自提出进程概念以来，在操作系统中一直都是以进程为独立运行的基本单位，直到，<br>人们又提出了更小的能独立运行的基本单位—-线程．</p><ol><li><p>为什么使用线程?<br>案例　编写一个MP3播放软件．<br>核心功能模块有三个:</p><ol><li><p>从MP3音频文件中读取数据;</p></li><li><p>对数据进行解压缩;</p></li><li><p>把解压缩后的音频数据播放出来.<br>图:单进程的实现方法while循环实现三个函数．<br>问题来了:<br> 播放出来的声音是否连贯?<br> 各个函数之间不是并发执行，影响资源的使用效率;</p><p>图:多进程的实现方法<br>　　每个函数都写一个进程．形成三者之间有序的执行，像流水一样．（行云流水）实现高效的音频播放．<br>　　问题来了:<br>进程之间如何通信，共享数据?另外，维护进程的系统开销较大；创建进程时，分配资源，建立PCB;撤销进程时，回收资源，撤销PCB;进程切换时，保存当前进程的状态信息．</p><p>怎么来解决这些问题?<br>提出一种新的实体,满足以下特征:（这种实体不是进程，就是我们所说的线程）</p><ol><li>实体之间可以并发的执行；</li><li>实体之间共享相同的地址空间；</li></ol></li></ol></li></ol><ol start="2"><li>什么是线程？<br>Thread: 进程当中的一条执行流程．<br>从两个方面重新理解进程前边是整合在一起的现在进程拆分成两部分．前边讲的进程中线程只有一个.<br>　　1. 从资源组合的角度;进程把一组相关的资源组合起来，构成了一个资源平台(环境），包括地址空间(代码段，数据段)，打开的文件等各种资源；<br>　　2. 从运行的角度:代码段在这个资源平台上的一条执行流程(线程)<br>线程共享该进程的资源，可以直接访问该进程提供的代码数据内存等等．<br>（TCB为线程控制块，不是进程控制块）只负责管理跟时间相关的一系列的流程信息，包含pc(程序计数器)sp(堆栈)一些不同的寄存器的信息，因为他有不同的执行流控制流，控制流需要一些列的寄存器来表示执行状态．堆代码段数据段是所有线程所共享的．有各自独立的部分和共同拥有的部分．</li></ol><p>线程　＝　进程　－　共享资源<br>线程的优点:</p><ol><li>一个进程中可以同时存在多个线程．</li><li>各个线程之间可以并发的执行．</li><li>各个线程之间可以共享地址空间和文件等资源．<br>线程的缺点:一个进程在处理资源时出现错误，就会导致别的线程的资源也会出现错误．（安全可靠性没有保障）<br>一个线程崩溃，会导致其所属进程所有线程崩溃．整个进程也就结束了．</li></ol><p>应用场景:<br>比如高性能计算，水利天气预报计算，这里用的是线程．不容易出现错误，<br>另一方面像intnet 的服务，比如打开一个网页就可以用一个线程去实现很快，一个线程崩溃之后，就会导致所有页面崩溃，就会导致这个浏览器崩溃．（早期浏览器采用线程机制实现，现在浏览器采用进程机制实现）<br>性能不是瓶颈安全性成为瓶颈，在这种情况下采用进程方式实现，例子chrome浏览器，就是一个进程打开一个网页，意味这一个网页崩溃后不会影响到其他进程访问的网页，（这就是进程和线程的区别他们各自有各自的特点，依据特点选取所需）</p><p>图：不同操作系统对线程的支持<br>早期的MS-DOS 就是单进程单线程的模式，<br>早期的Unix是多进程单线程的模式．<br>现在的Windows_NT, linux 等就是支持一个进程以及一个进程里边多线程的模式．</p><p>图:线程所需的资源(续) (重要)（线程区别进程，就是两种资源一种独占的一种共享的，所有独占的资源都跟他的控制执行相关的．需要把这些信息单独的保护起来，避免线程之间状态的破坏）<br>基于几个进程（小框是进程的资源）（寄存器和堆栈是每个线程独有的）共享的是数据段代码段文件网络资源等<br>左图为单线程流<br>右图为多线程流</p><p>进程和线程的比较:</p><ol><li><p>进程是资源(内存，文件，网络)分配的单位，线程是CPU调度单位（cpu执行控制流相关的信息）;</p></li><li><p>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，<br>　　如寄存器和栈；</p></li><li><p>线程同样具有就绪，阻塞和执行三种基本状态，同样具有状态之间的转换关系．（和进程是一样的）</p></li><li><p>线程能减少并发执行的时间和空间开销；<br>　　1. 线程的创建时间币进程短；（进位进程在创建进程时还要去创建一些其他的信息去管理，比如内存的管理，大的文件怎么去管理，线程直接重用了进程创建好的资源．）<br>　　2. 线程的终止时间比进程短；（同理他不需要考虑那些资源的释放问题，终止的时间也会短）<br>　　3. 同一进城内的线程切换时间比进程短；(在同一进程中的线程，切换也会很快，同一个进程的线程拥有一样的页表，早切换过程中不需要切换内存管理所需要的页表，而进程切换需要把页表也要进行切换掉，切换页表的开销很大，因为涉及到他们访问也表的物理地址空间是不一样的，很多catch和TLB 那些信息都会无效，需要重新加载，这里的开销很大，线程由于共享一个页表信息可以重用，不需要切换页表)<br>　　4. 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信．（不通过内核，直接物理地址读取，效率会很高．）<br>综上说是，线程实行的时间效率空间开销比进程要高．</p></li><li><p>线程的实现．</p></li><li><p>多线程编程接口举例．</p></li></ol><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>各个进程之间是共享cpu资源的，在不同时候，进行cpu切换，让不同的进程占用cpu执行．切换的过程称为进程的上下文切换．<br>停止当前运行进程(从运行状态改变成其他状态)并且调度其他进程(转变成运行状态)（各种信息存放在进程控制块中，在切换过程中，需要把要换的进程的控制块中的信息，恢复到cpu中执行．）<br>图:进程切换图(这部分的信息，主要是硬件完成的，这部分代码有的是汇编语言)</p><ol><li>必须在切换之前存储许多部分的进程上下文</li><li>必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过．</li><li>必须快速(上下文切换时非常频繁的)．</li></ol><p>需要存储什么上下文?</p><ol><li>寄存器(PC,SP,…),cpu状态,…</li><li>一些时候可能会费时，所以我们应该尽可能避免．</li></ol><p>上下文切换的开销越小越好，这样我们就能让进程有更多的时间做必须要做的事情去了．</p><p>操作系统为活跃进程准备了进程控制块(PCB)<br>操作系统将进程控制块(PCB)放置在一个合适的队列里．</p><ol><li>就绪队列</li><li>等待i/o队列(每个设备的队列)</li><li>僵尸队列</li></ol><p>图:操作系统控制块队列</p><h4 id="进程控制-创建进程"><a href="#进程控制-创建进程" class="headerlink" title="进程控制-创建进程"></a>进程控制-创建进程</h4><p>和上一个重复了</p><h4 id="进程控制-加载和执行进程"><a href="#进程控制-加载和执行进程" class="headerlink" title="进程控制-加载和执行进程"></a>进程控制-加载和执行进程</h4><p>系统调用exec()加载程序取代当前运行的进程．<br>图:系统调用exex()加载程序取代当前运行的进程<br>pid 三种情况 </p><ol><li>pid== 0　代表子进程</li><li>pid&gt;0　</li><li>pid&lt;0 失败的进程调用</li></ol><p>图:exrc()复制过程<br>执行fork()代码和数据都复制了一份,执行完exec()的时候，pid 有了变化，用户态的进程空间中的代码段被新的程序所替换和执行的数据都变了．整个程序的控制流都发生了变化．<br>图:exec在内存中的布局图.</p><ol><li>Exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上_start)</li><li>它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv).</li><li>如果调用成功<br>　　1. 他是相同的进程…<br>　　2. 但是它运行了一个不同的程序!!</li><li>代码,stack(栈)&amp;heap(堆)重写.</li></ol><p>fork()的简单实现;</p><ol><li>对子进程分配内存</li><li>复制父进程的内存和CPU寄存器到子进程里</li><li>开销昂贵</li></ol><p>在99%的情况里，我们在调用fork()之后调用exec()</p><ol><li>在fork()操作中内存复制是没有作用的 </li><li>子进程将可能关闭打开的文件和连接</li><li>开销因此是高的</li><li>为什么不能结合他们在一个调用中(os/2, windows)?<br>由于fork(),重复拷贝了一个空间，exec()进行了数据可代码的初始化所以内存空间进行了fork()时是一个无用的copy操作．如何优化呢.<br>Uxix系统中的优化手段，vfork()创建一个虚拟空间．</li></ol><p>vfork();(早起Unix系统改进手段)</p><ol><li>一个创建进程的系统调用，不需要创建一个同样的内存映像．</li><li>一些时候称为轻量级fork()</li><li>子进程应该几乎立即调用exex()</li><li>现在不再使用如果我们使用Copy on Write (cow)技术．<br>cow技术: 写的时候进行复制．<br>运用cow技术：只复制父进程的源数据，页表，指向的是同一块地址空间，当父进程或者子进程进行写操作的时候，会触发异常，无论是父进程还是子进程，把触发异常那个页制为两份，这样使得父进程和子进程用于两个不同的地址了．可以实现不同情况按需写的情况的复制，如果都是读数据确实没必要复制，因为指向的同一块内存，只有在进行写的时候才需要复制．<br>这样的话不管有没有exec(),执行fork()都产生一个子进程，而且这样效率还很块，因为他只复制了源数据页表等等．然后根据是否进行写操作，来决定是否需要复制，这就是cow技术．是进程和内存之间相互支撑的一种技术．</li></ol><p>问题：<br>有没有什么方法，只用一个fork()系统调用，不用考虑exec(）执行还是不执行．<br>结合之前的内存管理考虑，操作系统各个子系统是相互支持相互帮助的，通过虚存管理就能实现一个高效的fork()机制．</p><h4 id="进程控制-等待和终止进程"><a href="#进程控制-等待和终止进程" class="headerlink" title="进程控制-等待和终止进程"></a>进程控制-等待和终止进程</h4><p>wait()系统调用是被父进程用来等待子进程的结束</p><ol><li>一个子进程向父进程返回一个值，所以父进程必须接受这个值来处理</li><li>wait()系统调用担任这个要求<br>　　1. 他使父进程去休眠来等待子进程的结果<ol start="2"><li>当一个子进程调用exit()的时候，操作系统解锁父进程，并且将通过exit()传递得到的返回值作为wait调用的一个结果（连同子进程的pid一起）如果这里没有子进程存活，wait()立刻返回.</li><li>当然，如果这里有为父进程的僵尸等待，wait()立即返回其中一个值(并解除僵尸状态)．</li></ol></li></ol><p>问题直接让子进程结束exit()就可以了，为什么还要父进程来等待呢（为什么要有wait()）？<br>一个进程exit()，结束之后，进程的资源会不会被系统回收掉，缺失操作系统会把当前进程所占用的资源打开的文件进行关闭和释放．这确实可以做完，但是有一个很难去掉，比如操作系统内代表进程存在那个东西，就是进程控制块，进程控制块是代表进程存在的唯一标识．释放了这些空间后，只能说明这个进程回不到用户空间继续执行了．但是操作系统内核里边还在帮你完成回收操作，在这个时刻，把所有资源释放后，虽然用户空间不能执行了，但是内核态还有进程的相关资源．比如说PCB它本身回收就比较困难，就好像自己把自己拎起来一样．自身完成不了的事情，就让父进程来帮忙完成．所以子进程在执行完成后，会返回，通过操作系统通知父进程，如果父进程正在执行一个wait()操作的话，就会知道子进程执行了exit()这个操作，子进程退出了系统调用，父进程还收到了子进程执行完毕的信号，wait会有一个返回值，这时父进程就可以帮助子进程完成最后一步帮助子进程把它在内存中的资源释放掉．主要即使我们所说的子进程的PCB,这个就是靠父进程的wait()完成．<br>wait()和exit()两个一起完成子进程的所有资源的回收．<br>wait(pid),参数等待的进程．</p><p>进程结束之后，它调用exit()<br>这个系统调用:</p><ol><li>将整个程序的”结果”作为一个参数</li><li>关闭所有打开的文件，连接等</li><li>释放内容</li><li>释放大部分支持进程的操作系统结构</li><li>检查是否父进程是否存活着的；<br>　　1. 如果是的话，他保留结果的值直到父进程需要它；在这种情况里，进程没有真正死亡，但是他进入了僵尸状态．<br>　　2. 如果没有，他释放所有数据结构，这个进程死亡．</li><li>清理所有等待僵尸进程　<br>进程终止是最终的垃圾收集(资源回收)</li></ol><p>在子进程执行完exit()后，父进程还没执行网wait(),这是他不属于任何状态(就绪态等状态．因为他已经没法回到用户态执行了)这个就是僵尸状态．要死没死的状态叫僵尸状态．</p><p>问题来了：如果父进程先于子进程死了，是不是没法回收资源了,PCB一直留在内存中?<br>如果是这样的操作系统中处于僵尸态的进程越来越多，操作系统的设计思路: 进程都有父子关系，第一个进程称为祖宗进程(root进程)，他会定期的扫描进程控制块的链表，是否有进程处于僵尸状态，如果有进程处于僵尸状态，他会代替父进程完成资源回收过程（wait操作），这样就会使得操作系统中不会以后更多的僵尸进程存在．这也是让操作系统更好的管理系统采取的更有效的办法．</p><p>图:加上僵尸进程的六状态图<br>注意running 后边的两个状态，资源不够blocked态，资源程序条件都到位了就执行exit()函数.</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>上下文切换</p><ol><li>切换CPU当前任务,从一个进程/线程到另一个</li><li>保存当前进程/线程在PCB/TCP中的执行上下文(CPL状态)</li><li>读取下一个进程/线程的上下文<br>CPU调度</li><li>从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程</li><li>调度程序:挑选进程/线程的内核函数(通过一些调度策略)</li><li>是么时候进行调度?<br>在进程/线程的生命周期中的什么时候进行调度?<br>状态转变的时候，尤其是就绪态到运行态，从运行态到等待状态，或者是从运行态到结束态等．这些状态这是就应该考虑是否让新的进程让CPU执行，或者让当前进程从CPU撤下来，这就是调度的时机或者是调度点，涉及调度，就要考虑调度的这些位置．<br>对应用程序而言它是以用户态的应用程序存在的两种情况（对应下边的可抢占和不可抢占）</li><li>　不可抢占 一个程序启动后，从开始到结束不允许被打断（早期操作系统实行的非抢占式的调度策略）这种策略确保了这个进程一旦启动别的进程不能打断它了．这就不得不让下一个进程等着这个进程执行完毕才能执行，<br>如果有急需使用的进程还得等第一个进程结束，所以效率不高．</li><li>可抢占<br>操作系统来根据需求进行进程的切换，会根据操作系统来觉定该时刻是否要进行进程的换入换出．</li></ol><p>内核里存在一个状态是否可以抢占？<br>分析两种1.用户态是否能抢占 2.内核态是否能抢占<br>当一个用户进程，执行系统调用，如果这个系统调用在内核中不会导致这个进程处于等待状态，就是他还是处于运行状态的时候，当这个进程在正常返回的时候，他一定返回到发起这个进程的进程继续执行．也就意味着内核中不会出现抢占现象．（不会在内核中发生切换，切换到另一个进程去执行了．）只要从系统调用到内核态，自身不会出现从运行态到阻塞态的变化，操作系统就可以确保，回去之后一定是发起进程的那个进程去执行．（这就是内核的不可抢占）</p><p>如果在内核当中也允许去抢占，在内核中执行系统调用，由一个进程发起的，由一种特殊事件的产生，需要当前内核进行切换，切到另一个优先级更高的进程，一旦进程返回的时候，就可能返回到另一个程序，这样的就是抢占式内核．</p><p>内核运行调度程序的条件(满足一条即可)</p><ol><li>一个进程从运行转台切换到等待状态</li><li>一个进程被终结了</li></ol><p>不可抢占<br>调度程序必须等待事件结束</p><p>可以抢占</p><ol><li>调度程序在中断被响应后执行</li><li>当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪</li><li>当前运行的进程可以被换出．</li></ol><h4 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h4><p>原则是: 基于什么去选择合适的进程去执行</p><ol><li>调度策略</li><li>程序执行模型<br>执行模型:程序在CPU突变和I/O中交替<br> 图:执行模型:程序在CPU突变和io交替(突增的原因，可能进程在读文件，io较多，读完io就自然降低了)<br>　　1. 每个调度决定都是关于下一个CPU突变将哪个工作交给CPU<br>　　2. 在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU.<br>CPU繁忙或者IO繁忙，如何协调进程才能更充分的利用CPU.</li><li>比较调度算法的准则<br>设计算法的指标　<br>　　1. CPU利用率吧:<br>　　　　CPU处于忙状态所占时间的百分比<br>　　2. 吞吐量:<br>　　　　在单位时间内完成的进程数量<br>　　3. 周转时间:等待时间越少越好<br>　　　　包括两部分：等待时间和运行时间<br>　　　　启动之后要等待一段时间才能被CPU执行称为等待时间<br>　　　　服务时间：进程执行程序的时间<br>　　　　一个进程从初始化到结束，包括所有等待时间所花费的时间　　<br>　　4. 等待时间:和上边的不一样．<br>　　　　进程在就绪队列中的总时间　<br>　　5. 响应时间:<br>　　　　从一个请求被提交到产生第一次相应所花费的总时间．</li></ol><p>人们通常都需要”更快”的服务<br>什么是更快：响应时间快<br>　　1. 传输文件是的高宽带<br>　　2. 玩游戏时的低延迟<br>　　3. 这两个因素都是独立的<br>和水管类比；响应时间快和时间吞吐量大都是对快的一种体现．<br>　　1. 低延迟:喝水的时候想要一打开水龙头水就流出来<br>　　2. 高宽带:给游泳池冲水时希望从水龙头里同时流出大量的水，并且不介意是否存在延迟<br>所以说对快的不同需求，就会对快有不同的指标．</p><p>我们的目标<br>　　1. 减少响应时间<br>　　　及时处理用户的输出并且尽快将输出提供给用户<br>　　2. 减少平均相应时间的波动<br>　　　在交互系统中，可预测性比高差异低平均更重要　　　<br>　　3. 增加吞吐量－两个方面（这两个指标是有矛盾的，在实际中只能实现其中一个）<br>　　　减少开销(操作系统开销，上下文切换)<br>　　4. 减少等待时间<br>　　　减少每个进程的等待时间<br>　　<br>根据不同需求设计不同算法：<br>低延迟调度增加了交互式表现<br>　　如果移动鼠标，但是屏幕中的光标却没动，我可能重启计算机<br>但是操作系统需要保证吞吐量不受影响<br>    我想结束长时间的编程，多以操作系统必须不时进行调度，即使存在许多交互任务<br>吞吐量是操作系统的计算带宽<br>响应时间是操作系统的计算延迟．</p><ol start="4"><li>吞吐量vs延迟</li><li>公平的目标<br>公平的定义<br>举例</li><li>保证每个进程占用相同的CPU时间</li><li>这公平么?如果一个用户比其他用户运行更多的进程怎么办．</li></ol><p>举例<br>保证每个进程都等待相同的时间</p><p>公平通常会增加平均响应时间</p><h4 id="调度算法1"><a href="#调度算法1" class="headerlink" title="调度算法1"></a>调度算法1</h4><p>三部分入手</p><ol><li>最基本(一般的)的调度算法<br>　1. FCPS(先来先服务)<br>　　　图：FIFO队列的规定(注：average response time 是平均响应时间，而不是周转时间)<br>　　　图中1,2对比，如果第一个进来的进程时间特别长后边的进程时间越来越短，会造成平均相响应时间变长，图二进行一下调整短的在前长的在后，是的平均响应时间变短，响应更快．（后边的短进程优先的调度算法）<br>　　　优点:<br> 　　简单<br> 　缺点:<br>　　　　1. 平均等待时间波动较大<br>　　　　2. 花费时间少的任务可能排在花费时间唱的任务后面<br>　　　　3. 可能导致i/o和CPU之间的叠加处理.(没有考虑抢占)<br>　　　　　　CPU密集型进程会导致I/O设备闲置时，i/O密集型进程也在等待．<br>　　　　<br>　2. SPN(SJF) SRT(短进程优先（短作业优先）短剩余时间优先)<br>　　　　图:短任务优先<br>　　　　总的来说执行时间决定了它的优先级，执行时间越短，优先级越高．<br>　　　　问题来了：在Running运行过程中，wait()中来了一个比running运行的进程优先级更高，怎么办．两种策略.<br>　　　　1. 放到就绪队列最前边，我还执行原来的进程，不会被打断．（非抢占方式）（SJF,SPN）<br>　　　　2. 比如图中的pw,时间片是9,在完成一个时间片后变成8,这时候来了一个pa,执行时间为5,比较一下，pa执行时间更小，这是就要完成抢占，当前运行的进程，从运行态到就绪态，重新挂回到就绪队列里边去，让新来的pa占用cpu执行．（最短调度时间优先的策略Shortest-Remaining-Time(SRT)）最短剩余时间<br>第二种是第一个的变种，只是考虑了抢占．</li></ol><p>　　优点：最优平均等待时间（和前一个算法比较标准）<br>　　　图:最优平均等待时间　<br>　　　图：中SJF是有序的　XYZ是无序的时时间对比<br>　　　c[i]表示进程执行时间(两个R中间的时间)．<br>　　问题:<br>    　　可导致饥饿<br>    　　　　1. 连续的短任务流会使长任务饥饿<br>　　　　　　2. 短任务可用时的任何任务的CPU时间都会增加平均等待时间．<br>　　　　需要预知未来（无法知道进程的结束时间）<br>　　　　　　1. 怎么预估下一个CPU突发的持续时间<br>　　　　　　　2. 简单解决办法:询问用户<br>　　　　　　3. 如何用户欺骗就杀死进程<br>　　　　　　4. 如果用户不知道怎么办．<br>　　　　无法预估进程的结束时间，解决办法．<br>　　　　根据这个进程的历史情况，来预估接下来的执行．比如上一分钟这个进程执行了10秒，上上一分钟执行了2秒这样的历史．通过公式来预估下一个时间段执行的时长．<br>　　　　图:未来预算公式 τ：这次的预算，ｔ这次的时间，ａ一个概率维护这个准确性．黄框中的局部推导，下边是展开．<br>　　　　图:估计情况<br>　　　<br>　　　<br>　3. HRRN(最高相应比优先)<br>最短任务优先考虑了执行时间，没有考虑进程的等待时间，如果等待时间考虑进去就会的到新的算法，依据是下边的R公式．Ｒ越大意味着等待时间越长，就优先调度R.(就是最高响应比的意思)就可以设计一种交互性响应性更好的一种调度算法．目前不考虑抢占，我们完全可以设计一种可以抢占的算法！！！！！和SPN一样，进程的结束时间很难预估，只能去预估．这是它存在的两个问题．<br>对于前面两个算法充分考虑的进程的等待时间．前边的饥饿现象得到了有效的缓解．<br>　　1. 在SPN调度的基础上改进<br>　　2. 不可抢占<br>　　3. 关注进程等待了多长时间<br>　　4. 防止无限期推迟<br>　　　　R = (W + S)/S　　W：waiting time 等待时间，S:service time 执行时间<br>　　　　选择R值最高的进程，　　　　</p><p>　4. Round Robin(轮循)<br>　　轮循算法让各个进程轮流占用cpu去执行．这是他的特点．<br>　　图轮循图<br>　　图：轮循算法例子<br>　　时间片设置为20 ，超过20的执行完换出，不够20的实行进程所需时间换出．<br>　　甘特图就是　时间片执行不同线程的例子．体现的特点是公平，<br>　　衡量算法重要的指标:<br>    1. 等待时间，图中以p1等待时间为例，第一次没等待，到执行完成一共的等待时间，<br>    2. 平均等待时间，总的时间除以进程数量是每个进程的等待时间，他是很大的．<br>    该算法总结:<br>        时间片的大小设置很重要．设置的太大，就会退化成FIFO先来先服务．设置时间片是一个很讲究的事情，一般根据经验，比如linux早起unix设置为1%秒．随着性能提高，现在的linux设置为千分一秒，实现片很小才能让进程得到充分的调度．这是他的一个特点．总体而言我们想要做好一个ＲＲ调度算法，我们尽可能把上下文切换尽量控制在一个小的范围之内．1%以内这是可以接受的范围,99%的时间用在执行上，这个开销还是值得的．<br>        1. RR花销:额外的上下文切换(对比FIFO算法)<br>        2. 时间量子太大:<br>            1. 等待时间过长<br>            2. 极限情况退化成FCFS<br>        3. 时间量子太小:<br>            1. 反应迅速，但是…<br>            2. 吞吐量由于大量的上下文切换开销受到影响<br>        4. 目标:<br>            1. 选择一个合适的时间量子<br>            2. 经验规则:维持上下文切换开销处于1%以内．<br>　　　图RR的不同窗口实例<br>　　　　从图中可以看出有的时候FIFO比RR的新能还好，只要是因为FIFO没有上下文切换的消耗．但是FIFO不能像RR算法那样对每个进程得到及时的响应．公平性上有一定的代价，牺牲了公平性，如果把时间长的服务放到前边，平均等待时间更长了．所以说FIFO更大的去取决于任务的顺序，如果是短任务先来就类似短任务优先的算法，</p><p>有没有兼顾前面这些的算法呢？多级队列．<br>　5. Multilevel Feedback Queues (多级反馈队列)<br>　　由于一开始就会把进程优先级划好，但是执行过程中会导致优先级变化（比如该阶段会要求交互性比较高，后一个阶段会要求做大量的计算处理，所以说在不同阶段他的特点是不一样的，）有没有一种可以动态调整不同队里中的进程优先级的算法．就是我们所说的多级反馈队列．<br>　　1. 就绪队列被划分成独立的队列<br>　　　　E.g 前台(交互)，后台(批处理)<br>　　2. 每个队列拥有自己的调度策略<br>　　　　E.g 前台,—RR后台–FCFS<br>　　3. 调度必须在队列间进行<br>　　　　固定优先级<br>　　　　　1. 先处理前台，然后处理后台<br>　　　　　2. 可能导致饥饿．<br>　　　　时间切片<br>　　　　　1. 每个队列都得得到一个确定的能够调度其进程的CPU总时间<br>　　　　　2. E.g 80%给使用RR的前台，20%给使用FCFS的后台．</p><p>　　图：一个进程可以在不同的队列中移动（重点必看）<br>　执行时间越长优先级越低．特征是:在进程执行过程中，动态调整进程的优先级．从而使得io密集型的任务，可以很快得到执行．CPU密集型优先级逐渐逐渐的降低，这样符合通常我们在计算机系统中执行程序的特点．我们希望交互性好的进程，优先得到执行，特别消耗计算机资源的程序，优先级低，跑的慢一些没有关系．可以让它在交互性任务执行完毕的情况下，执行消耗资源的任务．</p><p>前边的算法或多或少的考虑到了公平的问题．<br>下边的算法重点强调了公平　<br>　　<br>　6. Fair Share Schediling(公平共享调度)<br>每个用户拥有的进程资源是不同的怎么在用户这个层面实现一个进程的公平．（公平共享算法需要重点考虑的内容）最新的linux采取的公平调度策略，设计上也是考虑到了不同级别设计上实现公平调度的机制（CFS调度）<br>图:三种评测方法.<br>最后加到真实的计算机中进行检测（细节可能被忽略在前边三种测评方法中）也受到计算机硬件本身的影响．<br>　<br>2. 嵌入式实时的调度算法<br>3. 多核处理器的调度算法</p><p>总结:<br>    1. FCFS先来先服务：不公平，平均等待时间较差<br>    2. SPN/SRT短进程优先:<br>        1. 不公平，但是平均等待时间最小<br>        2. 需要精确预测计算时间<br>        3. 可能导致饥饿<br>    3. HRRN最高响应比优先: 等待时间考虑进去<br>        1. 基于SPN调度改进<br>        2. 不可抢占<br>    4. Round Robin 轮循:<br>        公平但是平均等待时间较差（上下文切换多度）<br>    5. MLFQ多级反馈队列:（可以进程的优先级动态调用，操作系统可以根据这个特点动态调度）<br>        和SPN类似<br>    6. Fair-share Schediling 公平共享调度:　更多考虑用户的请求在不同级别(用户级别，进程级别，还是用户主的级别等)公平的占用CPU的调度．<br>        公平是第一要素</p><h4 id="调度算法2"><a href="#调度算法2" class="headerlink" title="调度算法2"></a>调度算法2</h4><h4 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h4><p>实时调度系统主要用: 火车，机床或者是嵌入式的工厂的控制环境，他需要确保某些任务在规定时间完成．规定时间指的是在未来的某段时间必须完成某个事情．这个就是如约态，时间是确定的，在操作系统中某个任务或事物在以进程的形式在执行过程中，能够满足实时的特征，确定性和可预测性是实时系统最大的特点，</p><p>实时系统分为两类:<br>    1. 硬实时(强实时系统):如果某个任务在规定时间不完成会引起灾难性后果<br>        需要在保证的时间内完成重要的任务，必须完成<br>        比如控制水坝，如果不能在规定时间内把水放掉，水就会把水坝淹过去了，产生灾难性后果．<br>    2. 软实时(弱实时系统):尽量完成，比如看视频，规定每秒60帧，如果不能完成可能会掉帧．可鞥你会引起观看者不太满意的后果．但是不会产生严重的后果．<br>        要求重要的进程的优先级更高，尽量完成，并非必须．</p><p>定义:<br>    正确依赖于其时间和功能两方面的一种操作系统．<br>性能指标:<br>    1. 时间约束的及时性<br>    2. 速度和平均性能相对不重要<br>主要特性:<br>    时间约束的可预测性．</p><p>如何衡量一个进程是否完成实时的需求？<br>图:进程衡量<br>Released:发起一个任务．对应进程的就绪．就绪之后不能马上执行，等一段时间之后才能执行．<br>图中的蓝色部分表示执行任务部分．<br>结束时间就是蓝色条结束位置．<br>最后一部分还有一个deadline,就是期限．执行时间不能超过这个期限，超过了实时性就不能得到满足．<br>relative deadline 相对的期限．<br>absolute deadline　绝对期限．</p><p>图:一系列相似的任务<br>执行时间为　蓝色区域，执行周期为5.<br>执行时间e,在(0,p),不能超过P.<br>利用率用:e/p表示．<br>对应前边的事情产生的:<br>    1. 硬时限:<br>        1. 如果错过了最后期限，可能会发生灾难性或非常严重的后果．<br>        2. 必须验证: 在最坏的情况下也能够满足时限吗?<br>        3. 保证正确性．<br>    2. 软时限:<br>        1. 理想情况下，时限应该被最大满足．如果有时限没有被满足，那么就相应地降低要求．<br>        2. 尽最大努力去保证．</p><p>基于硬时限和软时限的算法设计时限:<br>    表示一个实时系统是否能够满足deadline要求<br>    1. 决定实时任务执行的顺序,以下为两种不同的实时系统调度算法．（对应前边的FCFS静态调度算法，RR动态调度算法）.<br>    2. 静态优先级调度:<br>        在执行前就得把优先级确定．根据优先级来选择任务在规定时间完成．<br>    3. 动态优先级调度:<br>        任务的优先级会根据任务的动态变化，这就会影响任务在不同时刻他的优先级有所区别，所以会优先调度，也可能会延迟调度．</p><pre><code>图:两种实时调度算法.(了解)</code></pre><h4 id="多处理器调度与优先级反转"><a href="#多处理器调度与优先级反转" class="headerlink" title="多处理器调度与优先级反转"></a>多处理器调度与优先级反转</h4><p>如何确保把处理器均匀的分配给每个任务．不会存在一个特别忙别的特别闲这种情况，这样就浪费了我们计算机系统资源．这是就需要追求一种负载平衡．<br>多核处理器调度考虑的两个问题:<br>    1. 放到哪个CPU上去．<br>    2. 如何让整个系统处于负载平衡的状态．<br>    其实在一个CPU内跟前边的调度是一样的，只是调度算法本身还需要动态的探测其他CPU忙和闲的情况．来完成负载均衡这种情况，这是多处理器调度需要考虑的问题．</p><p>多处理器的CPU调度更加复杂:<br>    1. 多个相同的单处理器组成一个多处理器<br>    2. 优点: 负载共享<br>对称多处理器(SMP):<br>    1. 每个处理器运行自己的调度程序<br>    2. 需要在调度程序中同步．</p><p>优先级反转问题:<br>    1. 可以发生在任何基于优先级的可抢占的调度机制中．<br>    2, 当系统内的环境强制使高优先级任务等待低优先级任务时，发生．</p><pre><code>图:NASA火星车重启问题简化的；当前火星车上有三个进程执行，T1,T2,T3三个进程．T1优先级最高，T2优先级居中，T3优先级最低．正长情况下通过操作系统调度，执行就完成了．但是如果T1不能按时完成，他就会重启这个系统，一般不会出现这种情况，那么为什么出现这种情况，分析图:    横轴是时间轴，纵轴是三个进程．    先是T3开始执行t1-t2,到t2会访问一个共享资源，执行到t3时候，T1出现了，说T1准备好了可以执行了，因为T1的执行优先级比T3高．所以就开始执行T1中的第一个块，执行完灰块（涉及到那块共享资源前），就返回到T3那块已经被T3占有的共享资源，因为共享资源被T3占用，T1没办法访问，就会切换到T3.T3 继续从t4开始执行到t5,这个时候T2来了，T2优先级比T3更高．执行T2,T2抢占cpu执行．执行时间长短取决于T2的任务长短，这个时候会出现，T1的优先级高，但是得等待T2的执行．因为T2抢占了T3的CPU去执行，T1等待T3,导致T3的执行时间被T2的执行延长了．使得不能使T1不能在规定时间完成任务，使系统觉得系统处于不稳定状态．会导致系统重启．这就出现了低优先级任务影响高优先级任务．    基于上述问题提出的解决办法:    其一:    低优先级任务继承高优先级任务的优先级依赖于他们共享的资源．        由于T3在访问一个共享内存，等到T1准备就绪执行，这时共享资源还没被T3用完，所以动态的把T3的优先级提升到和T2一样，这时T2就不能抢占T3了，T3就能尽快把占用共享资源的操作尽快执行完毕．从而可以使得T1继续执行．    图:低优先级继承高优先级    其二:运行开始就会进行一下共享资源的统计，给共享资源确定一个优先级，资源的优先级等于最高进程的优先级，当一个进程占用共享资源去执行，一旦执行之后我的优先级就会和共享资源的优先级一样（或者说提升），这样就能确保他的优先级很高，在执行过程中，除非他的优先级超过共享资源的优先级才只能继续执行，否则就要进行等待．这一部分我们就能保证一旦访问了共享资源，就能保证能完成对这个共享资源的操作．然后离开，不会让别的进程等待更多的时间．        1. 优先级天花板: &quot;资源&quot;的优先级和&quot;所有可以锁定该资源的任务中优先级最高的那个任务&quot;的优先级相同．        2. 除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞．        3. 持有最高优先级上限信号量锁的任务，会继承被该锁所阻塞的任务的优先级．</code></pre><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><p>到目前为止:<br>    还没讲到的多个进程的交互，交互会引起他们对共享资源的访问，如果这些资源处理不当的话，就会出现我们意想不到的情况．比如饥饿死锁等一些列的问题．为什么出现这些问题，还跟我们上节课说的调度相关，如果进程独立（1.没有访问共享资源，没有去使用同一个资源 2.他们之间不需要交互（通知你干什么事情，或者给你发某些数据））．<br>    1. 多道程序(multi-programming):现代化系统的重要特性．<br>    2. 并行很有用(为什么?)提示:多个并发实体:CPU(s),I/O,…,用户,…<br>    3. 进程/线程:操作系统抽象出来用于支持多道程序设计<br>    4. CPU调度:实现多道程序设计的机制<br>    5. 调度算法-不同的策略<br>本周和下周:<br>    协同多道程序设计和并发问题．</p><p>独立的线程:<br>    1. 不和其他线程共享资源和状态<br>    2. 确定性-&gt;输入状态决定结果<br>    3. 可重现-&gt;能够重现起始条件,I/O<br>    4. 调度顺序不重要．(调用顺序是不确定的)<br>合作线程:<br>    1. 在多个线程中共享状态<br>    2. 不确定性<br>    3. 不可重现<br>不确定性和不可重现意味着bug可能是间歇性发作的．</p><p>进程间的合作有这么多风险，我们还需要合作吗？合作也是必须要做到的，因为首先资源是共享的，有可能多进程访问一块内存，访问同一个文件，这跟我们日常生活中一样，很多人在一个银行里边存钱取钱，也是一个道理，第二个可以通过系统的并行或并发的操作，可以提高系统的效率，实现更有效的资源的利用，前边讲过，把一个大的任务拆分成若干小的任务，通过流水或者并行的执行来提升整个系统的性能，提高系统的效率．第三可以把大的工作设置成小的工作，这样具有一定的模块化，这个是软件工程设计过程中必须要考虑的问题，模块化后，不同的模块之间需要完成相应的共享的，交互的，这点使得这种现象在别的地方也是经常存在的．所以说合作的进程是普遍存在的．既然有不可确定很难重现的问题，就有办法来避免这些问题．</p><p>进程/线程，计算机/设备需要合作<br>优点1: 共享资源:<br>    1. 一台电脑，多个用户<br>    2. 一个银行存款余额，多台ATM机<br>    3. 嵌入式系统(机器人控制:手臂和手的协调)<br>优点2: 加速:<br>    1. I/O操作和计算可以重叠<br>    2. 多处理器–将程序分成多个部分并行执行．</p><p>优点3: 模块化:<br>    1. 将大程序分解成小程序<br>    　　以编译为例，gcc会调用cpp, cc1, cc2, as, 1d.</p><pre><code>2. 使系统易于扩展</code></pre><p>有这么多不确定的现象吗？来个例子:<br>  程序可以调用函数fork()来创建一个新的进程:<br>      1. 操作系统需要分配一个新的并且唯一的进程ID<br>      2. 因此在内核中，这个系统调用会运行<br>      操作系统维护了一个全局变量，等有新的进程把这个值付给进程就ｏｋ了．<br>     　　new_pid = next_pid++; 共享全局变量，原子操作?<br>      3. 翻译成机器指令:<br>          1. LOAD next_pid Reg1  把new_pid赋值给寄存器1<br>          2. STORE Reg1 new_pid  把寄存器1的值加载（存）到new_pid中去．<br>          3. INC Reg1　寄存器进行加1操作.<br>          4. STORE Reg1 next_pid 把值赋值给next_pid<br>    假设两个进程并发执行:<br>        1. 如果next_pid等于100,那么其中一个进程得到的ID应该是100,另一个进程的ID应该是101,next_pid应该增加到102.</p><pre><code>    图:多进程并行    图中执行完两句汇编语句后，就进行了上下文切换，进程从进程1到进程2的切换．进程2执行完他所需要的四句汇编指令后，再完成一次调度，从进程2切换到进程1,完成剩下部分语句的执行．两个进程中得到的PID都是100, next_pid 变为101.    总的流程来看:先把new_pid赋值给寄存器1,把寄存器1的值赋值给new_pid,new_pid这时是100,进入进程2中的操作，会把new_pid赋值为100,next_pid变为101,到这里没有异常，一旦从进程2切换到进程1,需要注意进程1,会给寄存器1进行加1操作，这个时候寄存器1还是等于100,按道理说进程2的pid被赋值为100,进程1 会变成101了，可是他却是100,为什么呢?? 更奇怪的现象，next_pid都变成了101了.并没有变成102.因为寄存的值依然保存着100,因为切换会进程1,寄存器的值保存了进程2中的值，使得new_pid不可改变．这是一种典型的异常现象．调度点可以在四条语句中任何一部分切换，产生不同的结果．    综上我们希望线程1得到pid 为100，线程2等到pid 为101;最后的next_pid是102.这是理想情况．    无论多个线程的指令程序怎样交替执行，程序都必须正常工作:        1. 多线程程序具有不确定性和不可重新的特点        2. 不经过专门设计，调度难度很高．    不确定性要求并行程序的正确性:        1. 先考虑清楚问题，把程序的行为设计清楚        2. 切忌急于着手编写代码，碰到问题再调试．</code></pre><p>为了解决这些不确定性原因，引入了同步和互斥．<br>上边的现象我们称为(竞态条件)</p><p>系统缺陷: 结果依赖于并发执行或者事件的顺序/时间:<br>    1. 不确定性<br>    2. 不可重现</p><p>怎样避免竞态?<br>让指令不被打断．</p><p>原子操作(对于刚才那个例子就是四条汇编指令执行完不被打断，就是原子性,不可被打断就是排除不确定性因素的方法，但是在实际的操作系统中，那四条指令是可以被打断的，必须通过某种软硬件结合的方式，使得这四条指令按照一种原子操作的方式来执行，而不是说随时可以被打断的方式来执行)<br>图:A和B两个线程相互竞争小栗子<br>如果说ｃ语言一条语句就确定为一个原子操作，不会像上边那样，一个ｃ指令变为四个汇编指令．是不是就可以避免掉了？这个例子说明即使在c语言保证了原子操作，也不能避免出现别的情况．<br>图中谁赢呢? 如果先调度a,就a赢，调度b,就b赢．还有可能两种结果都不能输出来．这种奇怪的现象如何产生的呢？就是比如在线程A做到i = i + 1的过程，产生线程切换B线程执行的是i = i - 1，这样就相当于i的值没有变化，就有可能线程A和线程B都在while循环里边出不来.都无法取得最后的胜利，取决于调度的序列，在某一种调度算法下就可能出现这种情况．</p><p>下边介绍相应的同步互斥方法:<br>    1. （Critical section）临界区:  临界区是进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域（相当于前边说的进程A和进程B共同访问的共同资源是全局变量i，访问共享资源的代码被称为临界区）．<br>    2. (Mutual exclusion)互斥:当多个进程同时访问一个临界区的时候就会产生不确定性的结果．<br>         当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源．<br>　　3. (Dead lock) 死锁:(两个进程拥有自己的资源，同时还需要其他资源的时候，比如进程A等待进程B的资源，进程B等待进程A的资源，就会出现相互等待，这样锁在一起了，称为死锁，谁也执行不了．)<br>    两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去.<br>    4. (Strvation)饥饿:<br>        一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行．</p><p>原子操作是指一次不存在任何中断或者失败的执行:<br>    1. 该执行成功结束<br>    2. 或者根本没有执行<br>    3. 并且不应该发现任何部分执行的状态．</p><p>实际上操作往往不是原子的:<br>    1. 有些看上去是原子操作，实际上不是<br>    2. 连x++这样的简单语句，实际上是由三条指令构成的．<br>    3. 有时候甚至连单条机器指令都不是原子的:<br>        Pipeline, super-scalar,out-of-order, page fault.</p><p>引入了同步和互斥重要的原因就是解决不确定性．</p><h5 id="一些概念part1"><a href="#一些概念part1" class="headerlink" title="一些概念part1"></a>一些概念part1</h5><p>操作系统中的问题和显示生活中的问题的类比:<br>    1. 更好的帮助你理解现实生活的问题<br>    2. 但是,计算机比人更蠢．</p><p>例如: 人需要协调:<br>栗子:两个人一起住，共享一个面包，两个人相当于两个进程．<br>图:买面包的栗子<br>不同人不同时刻做了同样的事情，导致面包买多了．</p><p>什么是”面包太多”问题的正确性质?以下两个问题如何解决?<br>　1. 最多有一个人去买面包<br>　2. 如果需要，有人回去买面包．<br>　<br>例如,在冰箱上设置一个锁和钥匙:<br>    1. 去买面包之前锁住冰箱并且拿走钥匙<br>    2. 修复了”太多”的问题: 要是有人想要果汁怎么办?<br>    3. 可以改变”锁(lock)”的含义.<br>    4. “锁(lock)”包含”等待(waiting)”</p><p>lock(锁): 在们，抽屉等物体上加上保护性装置，使得外人无法访问物体内的东西，只能等待解锁后才能访问．<br>Unlock(解锁):打开保护性装置，使得可以访问之前被锁保护的物体类的东西．<br>Deadlock(死锁):</p><p>如果把冰箱全都锁住锁的粒度太大．因为整个冰箱还有其他的东西，这就需要一种轻量级的锁．轻量锁的诞生．</p><p>使用便签来避免购买太多面包:<br>    1. 购买之前留下一张便签(一种”锁(lock)”);<br>    2. 买完后移除该便签(一种”解锁”);<br>    3. 如果存在便签就不要购买面包(在便签被移除之前一直等待).</p><p>仔细思考，如果两个进程同时执行这一条逻辑的话，还是会出现多买面包的情况．进程之间会发生上下文切换，也就意味着进程A正在执行，就可能被调度切换到另一个进程去执行．这种情况下是不是存在某种调度策略，调度两个进程出现奇怪的现象．</p><p>图: 某种进程调度:<br>    1. 判断没面包<br>    2. 判断标签<br>    3. 上下文切换到进程2,判断没面包，<br>    4. 判断没标签.<br>    5. 上下文切换到进程1,去买面包放标签.<br>    6. 切换到进程2,然后进程2去买面包，方标签<br>这样产生了一个不太友好的结果，就是又买了两份面包.<br>并没有满足只让一个人(进程)去买面包的操作.就让控制逻辑失效了.<br>下一次再被调度时，可能不按这个顺序调度了</p><p>结果:<br>    1. 偶尔情况下还是会购买太多面包!<br>    2. 线程可以得到检查面包和标签之后，购买面包之前切换的上下文．</p><p>该解决方案由于间歇性的失败，使得问题更糟了:<br>    1. 使问题更加难以调试<br>    2. 必须做调度器所做的事情．</p><p>简单来说采用note的机制不能满足要求.</p><p>修改标签行数，快速修复:将便签(note)放在第一位<br>图: 将留便签放在第一位<br>进程1,先贴标签，然后进程上下文切换到进程2,再进行贴标签，然后两个进程都能判断有标签，所以都不会往下边执行．<br>会发生:不会有人买面包.<br>也不是我们想产生的．</p><h5 id="一些概念part2"><a href="#一些概念part2" class="headerlink" title="一些概念part2"></a>一些概念part2</h5><p>上一部分是part2.</p><h5 id="一些概念part3"><a href="#一些概念part3" class="headerlink" title="一些概念part3"></a>一些概念part3</h5><p>是不是因为note没有一个标识，标明是哪个进程的标签．<br>标签细化看谁标记的标签．<br>图:为便标签增加标签<br>考虑能否满足要求:<br>    1. 需要买面包一定能买到?<br>    2. 不会出现买到多余面包这种情况.</p><p>还是不行，进程1，贴上标签1，进程上下文切换，切换到进程2然后再贴上标签2，都无法满足两个进程中的if()中的判断，最后使得两个进程都无法执行的情况．</p><p>可能导致没有线程去买面包:<br>    错误时间的上下文切换可能会导致每个线程都认为另外一个线程会去买面包</p><p>最难处理的:<br>    1. 极其不可能发生的事情也会发生在糟糕的时间<br>    2. 就像UNIX中的一些事情.</p><p>这种锁定状态叫做”饥饿”．</p><p>进程1就是循环判断标签2是否存在,如果存在，进程1就会进入忙等状态，进程2就是判断标签1的存在与否，如果存在就会把标签2去掉,<br>if 换成了while语句实现mZ两种逻辑.<br>图:更加复杂的两种便签方案<br>可以解决我们的两个问题:<br>    1. 需要买面包一定能买.<br>    2. 不会出现买到多余面包这种情况.<br>可以看出进程A能购买面包的概率会大一些，或者说进程A和进程B同时贴标签，共同竞争资源时，A获胜的概率大一些.<br>产生的问题:<br>    1. 这只是两种进程，多个进程如何应用．<br>    2. 从我们的调度，或者从我们进程的设计来说，我们希望设计一种方法让他们是均等的，让A和B均等获取买面包的事情.刚才设计让A获得概率更大一些，B获得的概率更小一些．这种不对称性，不是我们所期待的．我们期待的是同等概率，同等竞争.</p><p>解决方案3为每个线程保护了一段”临界区”<br>代码 :<br>    if(nobread){<br>        buy bread;<br>    }<br>Critical section(临界区<br>    只能一个进程执行，如果一个进程在执行时，其他的进程只能等待．不能同时进来．<br>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域.</p><p>Mutual exclusion(互斥)<br>    确保一个进程在临界区，就成为互斥．这样就会出现不确定性那种情况．<br>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源.</p><p>总的来说：为了让代码在临界区互斥的进行.</p><p>抽象来说:<br>  1.即使在买面包前后加上，进入临界区，和退出临界区代码．<br>图: 临界区代码<br>退出临界区后，就会把等待队列的进程唤醒执行．<br>这个时候就需要我们设计一个进入和退出临界区的时限.</p><p>接下来设置进入和退出临界区的时限.</p><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区特征:</p><ol><li>互斥:同一时间临界区中最多存在一个线程. </li><li>Progress: 如果一个线程想要进入临界区，那么他最终会成功．</li><li>有限等待:　如果一个线程i处于入口区，那么在i的请求被接受之前,其他进程进入临界区的时间是有限制的．（如果是无线的等待就是饥饿现象．）对第二条的补充．</li><li>无忙等待(可选): 如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起．（如果能确保临界区能很快相应，就进行忙等，如果不能确保临界区及时相应(或执行之间比较长)，忙等效率会很低，导致系统利用率不够．以前就是while死循环忙等）.</li></ol><p>下边是三种方法，对临界区代码的一种保护．</p><h5 id="方法1-禁用硬件中断"><a href="#方法1-禁用硬件中断" class="headerlink" title="方法1: 禁用硬件中断"></a>方法1: 禁用硬件中断</h5><p>进入和离开临界区的代码:</p><ol><li>ENTER_CRITICAL_SECTION</li><li>EXIT_CRITICAL_SECTION</li></ol><p>基本的机制:</p><ol><li>禁用中断</li><li>软件方法(例如, Peterson算法)</li><li>更高级的抽象</li></ol><p>比较不同的机制<br>  性能: 并发级别</p><p>第一种方法开始讲解:<br>当进程进行调度的时候，很重要一个中断就是时钟中断，有了这个中断，即使这个进程正在被执行，也能被打断，切换到我们操作系统来，操作系统可以完成一个调度切换到其他进程去执行,这个中断让我们操作系统有了强制打断进程正常执行完成进程切换的能力，这个能力本来用在操作系统做进程调度很重要的一个机制，但是这也是导致前面不确定结果的很重要的一个原因，因为他随时可以切换，如果执行临界区的一段代码，执行的过程中不予许它切换，就没有问题了，这段代码就会得到一个确定的结果．所以说我们在进入临界区之前把这个中断屏蔽了，退出临界区后再重新恢复这个中断．<br>禁止硬件中断,这些中断都是响应外设或者是网络包磁盘块读写等的内容来的，如果屏蔽了中断系统对这些事件没有办法及时的响应，第二个呢，临界区整个的执行长短是不确定的如果很长就会对系统的影响很大，所以说用屏蔽中断的方法有一定的局限性，仅限于临界区非常小的这种情况是有效的．还要注意一点，如果两个线程由两个cpu并行的执行的话，中断机制只屏蔽其中一个cpu的中断机制是不行的．所以说中断机制对多cpu的情况是有限制的．如过只有一个cou屏蔽了中断，另一个cou继续相应中断，就没有办法解决这个互斥问题．</p><p>一旦中断被禁用,线程(进程)就无法被停止:</p><ol><li>整个系统都会为你停下来 </li><li>可能导致其他线程处于饥饿状态．</li></ol><p>要是临界区可以任意长怎么办:</p><ol><li>无法限制响应中断所需的时间(可能存在硬件影响)<br>要小心使用.</li></ol><p>没有中断，没有上下文切换，因此没有并发</p><ol><li>硬件将中断处理延迟到中断被启用之后． </li><li>大多数现代计算机体系结构都提供指令来完成．<br>进入临界区:</li><li>禁止中断.</li></ol><p>离开临界区:</p><ol><li>开启中断</li></ol><h5 id="方法2-基于软件的解决方案"><a href="#方法2-基于软件的解决方案" class="headerlink" title="方法2:　基于软件的解决方案"></a>方法2:　基于软件的解决方案</h5><p>图:两个线程的代码逻辑<br>设计思想: 如果满足有进程想进入临界区就能让该线程在一定的时间内进入临界区，满足这些特性就说明这个设计是可行的．</p><p>图:皮特森算法:<br>进程进入临界区有一定的顺序，根据次序来确谁进入临界去，比如有两个进程，图中turn 就能取值0和1.<br>能满足互斥但是有时不满足progress.<br>举个例子:比如进程0,在进入临界区之后，就干其他事去了．他就不再访问临界区了，进程1在完成一次临界区操作后，想再次进入临界区，这时候发现，他在离开临界区的时候，turn就被复制成0,导致它再次执行while 循环，turn不为1,就会一直循环.而进程0就不想在进入临界区，就不会执行那段临界区代码了，使得我们进程1无法继续前进．看一看满足的性质满足互斥，但是不满足（一定可以往前走属性）原因就是我们上边所说的，0进程撤出做别的事情，1进程无法进行再次执行临界区的资源.完成这两个属性就必须让两个线程交替执行，每一个都不能离开，一旦一个离开另一个也不能执行了．这是一种不很理想的情况．</p><p>改进思路: 用一个flag[i] = 1表示进程i是否准备好进入临界区别.</p><p>图:临界区改进不可前进部分<br>如果flag[j] = 0的话，就会跳出while循环，表示j进程不想进入临界区，就把当前i进程赋值为1进行执行．执行完成后flag就会赋值为0,表示进程1<br>不需要进入临界区了，就把临界区资源让给别的进程．退出临界区．这里考虑一下是否满足临界区的属性．<br>满足不了互斥的条件．因为在刚开始每个flag[] 都被初始化0,只有在执行到第二步的时候，才会被赋值为1,也就意味着当两个进程同时执行，都会跳过while循环,被赋值为1,(f[0]不为1，就去执行f[1],否则同理)，就会使得两个进程同时得到执行，就会同时执行临界区代码,不存在互斥，都会出现都买面包的问题，这样就无法保证互斥．如果flag[i] 的赋值语句和while(flag[j])互换顺序，会产生什么问题,由于刚开始就被赋值了1,所以产生互斥的问题解决了，但是可能会出现两个进程都在while循环里边谁都进不去的情况（死锁情况），实例是第一个进程被被赋值为1,之后然后调度到进程2，导致这两个进程都变为了1，所以都不会进入下边来执行．谁都跳不出while循环,这样就变成了死锁.所以说简单的代码换位置来实现并不可行．软件实现并不是想象中的那么容易．<br>正确解法皮特森的解法:把刚才的几种方法综合起来解决问题.<br>图:皮特森解法<br>加入了turn 指示谁该进入临界区<br>boolean flag[] 指示进程是否准备好进入临界区</p><p>进入临界区，flag[i] = TRUE, turn = j(另一个进程)(这里边如果i = 0, j就是1,否则反过来), while(flag[j] &amp;&amp; turn == j)表示轮到j进入临界区也该到j进入临界区.只能让给j去执行.只要一种不满足就会跳出循环，退出临界区flagp[i] = false就可以了（表示我不需要进入临界区了）<br>图: 皮特森算法代码<br>反证法证明　互斥，有限等待和前进三个属性，</p><p>戴克斯算法也能解决:<br>图: 戴克斯算法(了解)</p><p>皮特森算法以上研究的是针对两个进程，下一步进行算法扩展,能对n个进程.<br>思路:对于进程i而言，他前边有进程要进入临界区或等待进入临界区，i就会等待，i进程后边的进程也需要等待i进程执行完成后，才能进入临界区，前提是i想进入临界区,实现n个进程循环进入临界区的大致的思路.</p><p>第二个 Bakery算法<br>图:Bakery算法<br>比如去银行取钱，首先拿一个票号，然后根据票的大小来安排取钱的顺序，如果有两个发票号的地方，如果不同人领到相同的票号，就会比较身份正好安排先后顺序.<br>拿号进临界区.先比较拿到的号，如果拿到的号一样就比较进程号的大小．</p><p>图:临界区部分总结</p><h5 id="方法3-更高级的抽象（基于原子操作的指令）"><a href="#方法3-更高级的抽象（基于原子操作的指令）" class="headerlink" title="方法3:　更高级的抽象（基于原子操作的指令）"></a>方法3:　更高级的抽象（基于原子操作的指令）</h5><p>大多数现代体系结构都提供特殊的原子操作指令:<br>    1. 通过特殊的内存访问电路<br>    2. 针对单处理器和多处理器</p><p>Test-and-Set 测试和置位:(第一个特殊指令)<br>    1. 从内存中读取值<br>    2. 测试该值是否为1（然后返回真或假）<br>    3. 内存值设置为1.</p><p>交换:(第二个特殊指令)<br>    1. 交换内存中的两个值.<br>这两个特殊指令实现了，就很容易实现临界区的进入和退出操作．</p><p>图:两个命令的实现<br>既然封装成命令了，也就意味着执行这三条指令时不可以被打断.就是所说的原子操作.(三条指令之间不会产生中断或者上下文切换，只有执行完毕后才可以)<br>设计步骤:<br>    图:test-and-set代码<br>    1. 把内存单元设置为一个lock中的Value．初始值为零代表谁还没用这个lock.<br>    2. 接下来某一个进程想进入临界区，就先获得这个lock,Lock::Acquire().做完test-and-set(Value)之后，返回值为零跳出while循环,从而进入临界区执行，如果Value被赋值为1,那么返回也是1,就会在while里边等待(忙等)<br>    3. 对于退出临界区而言就是lock的release()操作,就简单的把value的内存单元赋值为0就ok了．<br>    4. Value为零，就会跳出Acquire()中的while 循环了.下一个就会执行.从这里可以看出了，除了可以支持两个进程之外还可以支持多个进程的互斥操作.进入临界区和退出临界区很简洁.<br>当一个进程在进行忙等状态时，就可以让他进入睡眠,把忙等的进程，挂到等待队列中去，让他进行睡眠，如果为0,就会退出临界区，然后唤醒wait队列里的进程．</p><p>图:无忙等待.<br>如果临界区很短的时候，我们更喜欢忙等待（因为他不需要像刚才那种方式那样完成上下文切换，因为上下文切换会是一种开销比较大的操作，如果临界区很长，远远大于上下文切换的开销，我们更希望基于上下文切换非忙等的方式，来实现同步互斥的机制，针对某种应用来选择用合适的方式来实现．）<br>以上部分都是基于 test-and-set()实现的，我们还讲了echange指令，我们能不能实现这种功能呢?<br>也是可以的<br>while(test-and-set(Value))如果临界区过长，忙等消耗的cpu比较多，用什么办法让他不忙等呢?思考!!!<br>使用忙等待的锁:<br>    1. 就像上面使用test-and-set实现的锁一样.<br>    2. 线程在等待的时候消耗cpu周期.</p><p>echange 完成进入临界区和退出临界区的概念:<br>    有一个lock和key的两个值,初始化key为1, 当k为1,就会执行exchange(),把lock和key进行转换,key 变成0了，一旦Key为零了就会跳出第一个while循环,就会进入临界区去执行了，进入临界区lock值就会从0变成1,当另一个进程进入临界区的时候lock是1,Key也是1,就不会跳出循环，进入不了临界，直到处于临界区的进程完成后，把lock赋值为0,下一个进程才可以去执行（处于忙等状态的进程，第一个执行exchange的进程就能得到进入临界区的机会）．</p><pre><code>优点:    1. 适用于单处理器或者共享主存的多处理器中任意数量的进程.    2. 简单并且容易证明.    3. 可以用于支持多临界区.</code></pre><p>　　缺点:<br>    　　1. 忙等待消耗处理器时间<br>    　　2. 当进程离开临界区并且多个进程在等待的时候可能导致饥饿(多进程抢占Block,可能存在多个进程抢不到的情况)<br>    　　3. 死锁:<br>        　　如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并等待临界区.(如果高优先级进程获得处理器，低优先级进程就没有机会拿到处理器去释放锁)．（这里就可以通过前边讲到的优先级反转的方法，解决死锁的问题）.</p><p>锁是更高级的编程抽象:<br>    1. 互斥可以使用锁来实现<br>    2. 通常需要一定等级的硬件支持<br>常用的三种实现方法:<br>    1. 禁用中断(仅限于单处理器)<br>    2. 软件方法(复杂)<br>    3. 原子操作指令(单处理器或多处理器均可)<br>可选的实现内容:<br>    1. 有忙等待<br>    2. 无忙等待</p><h4 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h4><p>知识回顾总结:<br>    1. 并发问题:竞争条件(镜态条件):<br>        1. 多程序并发存在大的问题<br>    2. 同步:<br>        1. 多进程共享公共数据的协调执行<br>        2. 包括互斥与条件同步<br>        3. 互斥:在同一时间只有一个线程可以执行临界区<br>    3. 确保同步正确很难?:<br>        1. 需要高层次的编程抽象(如:锁)<br>        2. 从底层硬件支持编译.</p><p>图:临界区概念模型.</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>进入临界区后并不只是进行写操作，在进行读操作的时候就没有必要限制一个进程或者线程的必要了，这个时候就需要更高级的手段来应对这种情况．可以通过信号来实现这种机制.</p><p>抽象数据类型:<br>    1. 一个整形(sem),两个原子操作.sem就是信号量,下是对信号量的操作.通常所说的P,V操作.<br>    2. p():sem减1, 如果sem &lt; 0, 等待，　否则继续.<br>    3. v():sem减1, 如果sem &lt;= 0,唤醒一个等待的P.</p><p>图:信号量(sem)和PV操作<br>举例子：图下的小火车.<br>信号量为2,就是两个线程(资源)，一个进程来进行p()操作，两个线程占用，执行完一个调用一次V()操作，一个线程的小火车就走了，唤醒另一个小火车，再执行P()操作，小火车进来．</p><p>图：信号量PV的含义(ｐｖ来自荷兰语，加减的意思).</p><h5 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h5><p>信号量是整数<br>信号量是被保护的变量:<br>    1. 初始化完成后,唯一改变一个信号量的值的办法是通过P()和V()<br>    2. 操作必须是原子<br>P()能够阻塞,V()不会阻塞(因为P()操作需要进行减操作，减少为零后，就得等待(就是阻塞))<br>我们假定信号量是”公平的”:<br>    1. 没有线程被阻塞在P()仍然堵塞如果V()被无线频繁调用(在同一个信号量)<br>    2. 在实践中，FIFO经常被使用.(后来的放到尾部，从头部开始取)</p><p>锁有没有先等先被唤醒的机制呢?思考!!!</p><p>两种类型信号量:<br>    1. 二进制信号量: 可以使0或1(模拟clock为0或者1)<br>    2. 一般/计数信号量:可取任何非负值．(如果是正整数就可以让多个执行p操作的进程，进入后续操作)主要体现在lock中只有一个进程执行，而在信号量中允许多个进程执行．所以说信号量除了可以用在互斥同步中还能用在条件同步的情况．<br>    3. 两者相互表现(给定一个可以实现另一个)<br>信号量可以用在2个方面:<br>    1. 互斥<br>    2. 条件同步(调度约束—-一个线程等待另一个线程的事情发生).</p><p>用二进制信号量实现的互斥:<br>    模拟lock的话，就要把初始值设置为1, 在临界区前设置P操作，在临界区之后设置V操作.(这是二进制信号量的常用法完全可以代替前边的lock用法．)<br>    除了完成互斥操作，还需要完成同步的操作．这个时候就得把初值设置为0.<br>    举例子:现在有两个线程A 和B,线程A要等到线程B执行到某个语句之后才能执行,怎么确定这一点，我们可以用信号量来完成,在线程A的前边加上p()操作，使信号量变成-1,线程挂起，然后等到B线程执行到V()操作，使得信号量变为0,才能唤醒进程A来执行.总的来说想先执行的代码写再V()的前边．<br>    互斥操作: 目标进程进入临界区时seg = 1 -1 = 0,如果其他进程进入临界区是，seg = 0 - 1 = -1,需要等待.</p><p>一个线程等待另一个线程处理事情:<br>    1. 比如生产东西或消费东西．<br>    2. 互斥(锁机制)是不够的．</p><p>例如:有界缓冲区的生产者—消费者问题:<br>    1. 一个或多个生产者产生数据将数据放在一个缓冲区<br>    2. 单个消费者每次从缓冲区取出数据<br>    3. 在任何一个时间只能一个生产者或消费之可以访问该缓冲区.</p><p>例子: 有一个Buffer,要有生产者和消费者，生产者要向里边写数据，消费者要读数据，生产者写数据的时候，消费者不能做相应的操作，但是可以多个生产者都往里边写数据，这里跟我们的clock是不一样的，clock只能是一个生产者或者一个消费者在做操作．但是这个不一样，我们有多个生产者往里边写东西．也可以有多个消费者从里边读数据.到底有几个主要是设置信号量的初值来完成.这里还有同步的地方,Buffer为空的时候，消费者再从里边读取数据就不行了，只能进行睡眠，只能等有一个生产者往里边写了数据之后，才会唤醒睡眠的进程，同理buffer满了，就会生产者等待消费者了．</p><p>正确性要求:<br>    1. 在任何一个时间只能一个线程操作该缓冲区(互斥)<br>    2. 当缓冲区为空，消费者必须等待生产者(调度/同步约束)<br>    3. 当缓存区满，生产者必须等待消费者(调度/同步约束)</p><p>每个约束用一个单独的信号量:<br>    1. 二进制信号量互斥<br>    2. 一般信号量fullBuffers<br>    3. 一般信号量emptyBuffers</p><p>那么多对buffer的影响,我们可以用信号量来完成对添加或者取出这样的互斥的保障.<br>如果Buffer还有空间,就需要唤醒等待消费者,还需要唤醒生产者让他产生更多的数据,需要两个信号量完成同步的操作.<br>就是上边的1, 2, 3,表示的,<br>图:互斥量完成图<br>mutex 互斥信号量<br>fullBuffers 初值是0,<br>emptyBuffers 设置为Buffer的大小n,<br>Deposit(c) 生产者函数(中添加队列不为空的条件,互斥量,添加信息完,互斥量更新,emptyBuffers加1通知缓冲区有数据了)<br>Remove(c) 消费者从缓冲区移除(消费者和生产者刚好相反.开始fullBuffer值为零,进入睡眠,然后等待fullBuffers-&gt;V操作后,就变为1了,才能继续执行,如果生产者一下把buffer塞满了,就需要消费者进行emptyBuffer-&gt;V操作完成后,通知其才可继续运行)<br>如何保证生产者和消费者的互斥,想一想如何保证?<br>就想用信号量的P()和V()操作来完成.在写入数据和读出数据代码前后都加上P()和V()操作,保证只有一个进程或线程在一个时间内进行内存的读取操作.</p><p>问题来了,P()和V()操作能不能换顺序??<br>基于生产者:<br>V()对信号量加1,然后把等待进程进行唤醒.v()操作交换顺序没有影响,没有阻塞部分.但是交换P()紧紧是生产值,就是如果Buffer快速慢了,再进入函数后,首先执行的mutex-&gt;P()操作,得到锁,这时emptyBuffers-&gt;p()为-1,进行睡眠,换到消费者模式, fullBuffers被初始化为n,可以进入,但是mutex被生产者所占有,得不到锁,执行不到emptyBuffers-V没办法唤醒生产者睡眠的进程.由于p()操作能产生阻塞,所以一旦交换顺序就可能产生死锁更严重的同时进入临界区等等.</p><h5 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h5><p>信号量怎么来做,首先我们来确定信号量是一个整形,我们需要一个整形来记录P(),V()对信号量加和减具体的值.做P()操作会有进程等待,这里的等待是如何实现的.可以把信号量看做虚拟的资源,类似进程的sleep,所以说在这个值变为-1或者小于0,在这种情况下我们会让进程睡在信号量这个资源上,我们需要一个等待队列,要记录这个被执行v()操作之后需要被唤醒的进程,(等待队列最适合用FIFO来实现.)选择把等待时间最久的进程唤醒,然后p()中的Block就可以继续往下执行.<br>图:信号量的实现</p><p>信号量的基本实现原理还是比较容易理解的,但是在使用中除了要用在互斥操作,还可以用在同步操作中,和lock的区别<br>lock两种机制:1. 忙等. 2.等待队列(可以做sleep操作)(lock用在p()的实现过程中),如果P()的操作的顺序安排问题,如果安排的不合适就会产生各种问题.所以如何改进呢?(跳转管程)<br>虽然比较复杂但是生活中我们大量应用来解决同步互斥问题.<br>信号量的双用途:<br>    1. 互斥和条件同步<br>    2. 但等待条件是独立的互斥<br>读/开发代码比较困难:<br>    1. 程序员必须非常精通信号量<br>容易出错:<br>    1. 使用的信号量已经被另一个线程占用<br>    2. 忘记释放信号量<br>不能够处理死锁问题:</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>抽象程度比信号量还要高.抽象程度越高,相对更加容易的完成同步互斥的一些问题<br>信号量的提出:就是为了同步互斥机制的实现.<br>管程提出的时候:是用在语言这个level,不是用在操作系统中的,而是用在了编程语言(java等),这些语言通过管程机制简化语言来完成同步互斥的操作.并不是一开始就用在操作系统中的设计里面的,管程的整个机制实现,很大程度上根据语言的并发机制来完成的,<br>目的: 分离互斥和条件同步的关注<br>什么是管程:包含了一系列的共享变量,以及针对这些变量的函数的一个组合.<br>    1. 一个锁:指定临界区(访问管程管理的区域只能有一个线程,所以有一个lock机制来确保互斥性)<br>    2. 0或者多个条件变量:等待/通知信号量用于管理并发访问共享数据.(如果访问条件(得不到资源)不足了,这个时候就得把进程(线程)挂起这时候就需要把进程或者线程挂起,挂到条件变量中去.)根据条件的个数,来确定你需要多少个条件变量,<br>    通过这两个机制组合就能实现管程.!!</p><p>一般方法:<br>    1. 收集在对象/模块中的相关贡献数据<br>    2. 定义方法来访问共享数据</p><p>图: 管城操作顺序图<br>进入管程时要加入进入队列(entry Queues),先获得一个锁(就是conditions)进入临界区,进入lock管理的管程之后,就可以执行管程维护的一系列的函数(操作或者是函数)就是图中间那一段(operation),在函数中可能有很多共享变量操作,有可能针对某一种共享变量对资源的操作得不到满足了,就需要等待,因为他是互斥的占用了这个管程,他需要把自身挂到某个地方去,然后把lock释放掉,才可以让其他的等待这个lock的线程去执行,等到什么地方,就是条件变量上边,图中x,y就是两个条件变量他有两个队列就是等待队列,这里边挂着所有需要等待的线程,条件变量有两个一个signal 和wait操作,wait就是挂载条件变量里边,signal就是把挂起的线程唤醒,去执行,</p><p>lock:以下两个函数确保执行的函数是互斥的,可以把这两个操作放到函数里边也可以通过语言优先级的保障,不写也行语言能帮你嵌入到函数里边.<br>    1. lock()::Acquire() - 等待知道锁可用,然后抢占锁<br>    2. lock()::Release() - 释放锁,唤醒等待者如果有.<br>conditions variable:<br>    1. 允许等待状态进入临界区:<br>        1. 允许处于等待(睡眠)的线程进入临界区<br>        2. 某个时刻原子释放锁进入睡眠<br>    2. Wait() operation:<br>        释放锁,睡眠,重新获得返回后,</p><pre><code>3. signal() operation(or broadcast() operation):    唤醒等待者(或者所有等待者),如果有</code></pre><p>条件变量的实现:图:管城条件变量的实现<br>    1. 需要维护每一个条件队列<br>    2. 线程等待的条件等待signal()<br>    wait():<br>        num Waiting ++ 表明我要去睡眠了,多了一个要睡的线程,<br>        线程挂到等待队列里边去<br>        还没Acquire lock就要Released lock这里比较特别为什么?<br>        schedule()选择下一个线程去执行.本来的线程处于睡眠状态了,<br>        再做require(lock),这里又是为什么?<br>    signal():和wait()操作相反:<br>        如果大于零就说明有线程在等待.<br>        把等待队列中的线程取出来,FIFO(来等待这个线程)<br>        取出来之后就要唤醒这个线程,(把sleep线程置成ready状态).再次被调用后,处于运行态就可以继续往下走了.<br>        num–;<br>        如果等待队列没有等待的操作,说明这个啥也不做,这里和信号量的整形变量和这里的num wait他们的含义是很不一样的,num wait表示当前等待的数量,signalfull代表信号量的个数,在处理上也不一样,在signal中的实现,一定要执行PV操作(加减操作),着这里wait中有加操作,但是这里的signal中不一定做减操作,</p><p>图: 管程实现消费生产值<br>管程来解决生产者和消费者问题如何解决?<br>就是类似于其那边信号量的定义,来实现管程操作,实现一个锁lock和满和不满的两个条件变量.<br>count记录了当前buffer的空闲情况,count 为零为空,为n为满的.<br>生产者用Deposit(),消费者Remove()两个函数实现.跟前边不一样的就是count++ 和count–操作,和ingal不一样的,sigal是紧紧地放在加入buffer前后的,但是我们这里实现的是放在函数开头结尾,不用紧挨着Buffer.!!这是由我们的管程的定义决定的,就是只能由一个线程能进入管程,才能执行管城所管理的所有的函数,这两个是属于管程所管理的两个函数,访问共享变量的函数,所以得有互斥性,和唯一性,所以要确保一旦进入这个函数就必须是互斥的,所以lock放到了头尾部分,还缺少同步的通知机制buffer空了就得让消费者去睡眠,Buffer满了生产者去睡眠,(while notfull.wait())操作,注意notfull是条件变量不是信号量,不需要有初始值.<br>条件变量中wait(在实现Acquir之前先实现了一个rlease(clock)操作),就是为了让当前生产者释放当前锁,这使得其他的线程才有机会进入管程去执行,因为当前线程要睡眠了,所以要把当前的锁释放.这是因为执行这个函数之前有个lock-Acquire!!!,他获得了这个锁,所以在wait操作里边一定要把锁释放掉,<br>有了notfull.wait就一定会有他的唤醒机制,放在了消费者末尾lock-&gt;Released(),Buffer不满了,notfull里边有等待生产者的线程就会被唤醒,<br>当Buffer空的时候也可以有一个while操作,再消费者这边会判断,count是不是为零,如果等于零,这时候已经空了,会做一一个notemoty的一个wait,直到生产者有一个noemoty.signal之后才会被唤醒继续执行,这几个结合在一起就完成了生产者和消费者问题的实现,<br>总的看来实现的总体是一样的但是实现的细节是不一样的.</p><p>还需要注意一点是: 当线程在管程里边执行的时候,如果某个线程要执行某个条件变量的signal操作(唤醒操作),当执行完这个操作后,去执行等待在这个条件变量上的线程呢还是说让发出唤醒操作这个线程执行完毕之后再去让那个等待的线程去执行这两者是不一样的,因为一旦发出signal操作也就意味这当前管城里边有两个线程都可以执行,一个是发出可执行操作的线程,signal之后就意味着要把等待的线程唤醒,唤醒的线程本身他也应该执行,这样就有两个线程执行,到底选那个线程先执行这是一个问题,<br>图: 两种解决办法<br>两种解决办法:<br>    1. hansen:实现起来容易,在很多操作系统(语言)里都是这样来实现的.<br>        提出另一种方法,当他发出signal操作之后呢,并不意味者我要马上放弃cpu,马上把控制权交给等待的线程,而是等我正在执行的线程执行完release操作之后,才把控制权交给wait中所唤醒的线程,让他去执行,</p><pre><code>2. hoare:实现起来难,需要很复杂的机制保证hoare的有效性,    一旦发出signal操作之后,就应该让等待的线程继续执行,他自身去睡眠,比较急切的让等待线程去执行,等待的线程relaese之后这个线程才能继续执行,</code></pre><p>这两种方式在我们管程中的使用也会产生一定的影响,</p><p>图:两种实现方式不同</p><p>在hoare中Deposit中可以用while中换成if语句主要是由于唤醒机制实现不同造成的.他做完signal操作之后,并没有马上的让那个被唤醒的等待的进程执行,他必须要继续往下执行,知道执行relase才能释放,这种情况下,有可能多个等在条件变量上的线程,也被唤醒,就有可能存在多个被唤醒的进程,大家都可能回去抢共同执行的那个acquire(),cpu只有一个,也就是只有一个抢中,所以说那些被唤醒的那些线程,当他能够被选中占用cpu去执行的时候,count已经不为n了,所以说必须用while来做一下确认,是否count=n,这是hansen实现方式造成的一种结果,<br>但是用hoare这种机制来实现,就相对来说简单一点,只有一个等待线程被唤醒,不会有多个,signal操作条件是count &lt; n,而又只有一个线程,不发生抢占,条件满足,依然认为count &lt; n,继续执行,导致我们设置函数的时候也会有所不一样,</p><p>图: 临界区管城总结</p><p>总结一下:<br>    信号量和管程(Monitor)引入,比lock更进一步,层次高了一层,<br>    不足:<br>        1. 开发/调试并行程序很难:<br>            1. 非确定性的交叉指令<br>        2. 同步结构:<br>            1. 锁:互斥<br>            2. 条件变量:有条件的同步<br>            3. 其他原语:信号量</p><pre><code>    3. 怎样有效的使用这些结构:        制定并遵循严格的程序设计风格/策略</code></pre><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><h5 id="经典同步问题1"><a href="#经典同步问题1" class="headerlink" title="经典同步问题1"></a>经典同步问题1</h5><p>读者-写者问题:<br>动机:<br>    1.<br>两类类型使用者:<br>    读者: 不需要修改数据<br>    写着: 读数据和修改数据<br>问题的约束:<br>    1. 允许同一时间有多个读者,但在任何时候只有一个写着.<br>    2. 当没有写者是读者才能访问数据<br>    3. 当没有读者和写者时写者才能访问数据<br>    4. 在任何时候只能有一个线程可以操作共享变量.</p><p>多个并发进程的数据集共享:<br>    1. 读者-只读数据集;他们不执行任何更新.<br>    2. 写着-可以读取和写入.</p><p>共享数据:<br>    1. 数据集<br>    2. 信号量 CountMutex初始化为1.<br>    3. 信号量 WriteMutex初始化为1.<br>    4. 整数 Rcount 初始化为0.</p><p>有一个细节,读者优先,一开始有读者对这个数据开始读了,这时候来了一个写着,他一看有数据就必须进行等待,之后又来了一个读者,读者会跳过这个写者进行数据的读取操作,并没有按照时间顺序谁先来谁就进去,因为读操作对数据不做更改,所以读数据就会跳过写者完成对数据的操作,这就是读者优先的一个特征.</p><p>了解特性,那么该如何去设计呢?</p><p>首先一个共享变量data,我们会对这个共享变量,进行读取和写入的操作,我们需要知道有几个读者rcount,写者只有一个没什么好说多,我们对Rcount有一个修改,这里的修改的时候需要一个信号量来进行互斥操作,这里用CountMutex来实现的互斥操作,写也需要互斥,因为写者本身也需要互斥,只能有一个写者进入临界区去执行,进入到数据集里边进行相应的写操作,我们还需要一个WriteMutex完成对写者的互斥保护,设置完信号量和共享变量之后就能完成相应的读者和写着的操作流程.</p><p>看一看如何完成:<br>    可以有n个读者线程或者有n个写者线程,<br>    writer 和reader.对共享数据进行操作.<br>    先看writer这一部分:<br>    有一个write操作,<br>    为保持互斥操作,在write操作前后加上锁,只允许一个写者进入临界区执行.sem_wait(WriteMutex) 相当于p()操作,对WriteMutex进行一个P()操作,sem_post(WriteMutex)是对于WriteMutex的V()操作.为二级信号量这种方式更加简洁一点,包起来之后就能保证只能有一个写者的线程对数据进行写操作,就是写方面只能保证一个线程访问临界区资源,完成的是只要有一个写着写了,就能保证读者都不能进去只能在外边等.一旦有读者读这个数据,写着也一样在外边等着,但是没有体现允许多个读者进去,下面介绍如何完成这一步:<br>    什么情况下才允许有多个读者进去,首先前边有一个Rcount变量,来记录读者的数量,如果Rcount等于0,就表示现在没有一个读者,先执行一下WriteMutex,可能没有读者有写着,所以要执行一下writeMutex,p()操作,来确定在对这个临界区操作的时候没有写操作存在, 因为Rcount为0了,就没有读者了,这是第一个读者,只要确保没有写者就能继续执行,如果这个时候Rcount不等于0,意味着当前已经有读者线程读数据,也就意味着当前的操作写者一定进不来了的,然后Rcount++进行读操作,进行–操作,如果为0的话,表示已经读完了,当Rcount为0就表示当前没有读者了我是最后一个读者,所以得等待锁者,就需要sem_post(WriteMutex)操作,来使得等待进程的锁者被唤醒,Rcount是一个共享变量,要确保当多个读者来进行操作的时候他有一个互斥性,所以说在对Rcount进行加或者减操作的时候,要把它包起来,就需要使用sem_wait(CountMutex) 和sem_post(CountMutex)把if和_++Rcount包起来起来,对Rcount进行了互斥的保护,不会存在多个读者线程对这个rcount进行同时的操作,保证数据的互斥性,这里就是读者优先的读者写者问题,<br>图:读者优先的读者写者问题</p><p>基于读者优先策略的方法,只要有一个读者处于活动状态,后来的读者都会被接纳,如果读者源源不断的出现的话,那么写着就始终处于阻塞状态,<br>基于写者优先策略的方法: 一旦写者就绪,那么写者尽可能快地执行写操作.如果写者源源不断地出现的话,那么读者就始终处于阻塞状态(如何实现?)</p><p>读者今次完成读操作</p><p>哲学家就餐问题:</p><h5 id="经典同步问题2"><a href="#经典同步问题2" class="headerlink" title="经典同步问题2"></a>经典同步问题2</h5><p>图:经典同步问题2</p><p>写着优先的角度:<br>    读者要等待的写者有两类:<br>        1. 当前正在做写操作的写者<br>        2. 当前正在等待做写操作的写者.<br>    这两个只有有一个存在,就必须等待.<br>    只有两个写者都不存在,才可以读者进行读数据的操作,在读完数据后,考虑是不是有写者处于等待状态,如果有就把他唤醒,为什么没有写者在等呢?</p><p>这里靠写者完成相应的操作,</p><p>写者:<br>    1. 如果有读者或者写者在进行读操作或者写操作的话就必去等待,(这里的读者指的是正在读的读者,不是处于等待状态的读者)如果处于等待状态的读者就不需要读了,其他的都不需要等待,这就保证了写者优先.<br>    2. 确保了我们的临界区没有读者或者写者,就可以做写操作了,因为这时候临界区已经空出来,我们就可以做写操作,完成操作之后,唤醒readers和writes(读写操作)<br>    3. 如果用管程,就需要先定义好相关的变量,等待的读者写者的表示</p><p>后续补上</p><h5 id="经典同步问题3"><a href="#经典同步问题3" class="headerlink" title="经典同步问题3"></a>经典同步问题3</h5><h5 id="经典同步问题4"><a href="#经典同步问题4" class="headerlink" title="经典同步问题4"></a>经典同步问题4</h5><h5 id="经典同步问题5"><a href="#经典同步问题5" class="headerlink" title="经典同步问题5"></a>经典同步问题5</h5><h5 id="经典同步问题6"><a href="#经典同步问题6" class="headerlink" title="经典同步问题6"></a>经典同步问题6</h5><h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><p>图:车辆过桥模型<br>两个车堵在中桥,才会死锁,谁都不让路,换一种说法是发生饥饿.<br>车辆退出表示释放资源<br>一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源.<br>例子:<br>    1. 系统有2个磁带驱动器<br>    2. P1和P2各有一个,都需要另外一个.</p><h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><p>图: 资源类型</p><p>每个进程使用资源如下:<br>    request/get  —free resource (有空闲的资源)<br>    use/hold —–requested/used resource (得到资源变为拥有状态,其他进程不得拥有这个资源,资源有互斥性,如果没有互斥性就不会出现死锁.)<br>    Release ——free resource(进程使用资源的时间是有限的不能无限的使用资源,确保用完释放,如果得不到释放,系统会出现资源耗尽的情况)(释放资源)</p><p>图: 资源和资源的使用定义</p><p>v表示两个点,中间建立一条边,pi-&gt;Rj 表是pi和rj之间有一条边,表示pi要Rj的资源.<br>Rj-&gt;Pi 表示资源被使用.边的指向与第一个相反,<br>图 : 资源分配表示<br>图: 资源分配表示图.(资源对应的图标表示)<br>图: 资源分配图的例子<br>讲解: p1,p2,p3三个进程,R1,R2,R3,R4四种资源,R2资源有两个实例,R4资源有三个实例.R2中一个资源分配给了P1,另一个分配给了P2,p1需要R1的资源,请求发出去之后并没有得到满足,因为R1这种资源正在被R2占用,p2拥有R1,和R2两个资源,但是对R3的资源发出请求,P3占用R3的资源,正在使用,这个图会不会有死锁呢 ?<br>不会产生死锁,P3用完资源给p2,p2用完资源给p1.都会得到满足.</p><p>图:资源分配图有死锁<br>加一条边p3需要R2的资源.<br>这里有两个环:<br>    1. p1-R1-p2-r3-p3-r2-p1.<br>    2. p2-r3-p3-r2-p2<br>R3需要r2的资源,这时一旦p1,p2,p3都sleep的时候,都没办法执行了.<br>分析: 死锁产生的最典型的特征形成有向的环,<br>链表有无环如何判断???思考 数据结构在做解析,这里不展开讲解</p><p>图: 有循环的资源分配图没有死锁</p><p>环: P1-R1-P3-R3-p1.如果只是这个环就会发生死锁<br>但是还有p2和p4有两份资源,一旦使用结束资源就会得到满足,一但p2或p4释放资源,就会解除P1,和P3的sleep状态,就不会发生死锁.</p><p>总结:(基本情况)<br>     产生死锁代表一定有环,但是有环不一定就代表死锁了.<br>    1. 如果图中不包含循环==&gt;没有死锁<br>    2. 如果图中包括循环==&gt;:<br>        1. 如果每个资源类只有一个实例,那么死锁.<br>        2. 如果每个资源类有几个实例,可能死锁.</p><h4 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h4><p>死锁出现后一定出现四个条件,四个条件出现不一定出现死锁.<br>死锁可能出现如果四个条件同时成立:<br>    1. 互斥:在一个时间只能有一个进程使用资源.<br>    2. 持有并等待;进程保持至少一个资源正在等待获取其他进程持有的额外资源.<br>    3. 无抢占:一个资源只能被进程自愿释放,进程已经完成了他的任务之后.<br>    4. 循环等待:存在等待进程集合{p0,p1,….,pn},p0正在等待p1所占用的资源,P1正在等待p2占用的资源,…,pn-1在等待pn所占用资源,pN正在等待p0所占用的资源.</p><p>出现死锁是因,产生四种现象是果.</p><h4 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h4><p>约束条件从强到弱.</p><ol><li>deadline prevention (死锁预防)</li><li>deadline avoidance (死锁避免)</li><li>deadline Detection(死锁检测)</li><li>Recovery from deadline(死锁恢复)</li></ol><p>处理的办法:<br>确保系统永远不会进入死锁状态<br>运行系统进入死锁状态,然后恢复.<br>忽略这个问题,假装系统中从来没有发生死锁;用于大多数操作系统,包括unix.(判断死锁并且恢复它消耗是很大的,如果用前边四个约束条件,会约束应用程序或者是操作系统,不能充分的占用cpu去执行)操作系统有一些手段,会在调试状态下完成这些操作,(对应c++编程理念,错误尽可能放在编译器查出)</p><h4 id="死锁预防和死锁避免"><a href="#死锁预防和死锁避免" class="headerlink" title="死锁预防和死锁避免"></a>死锁预防和死锁避免</h4><p>死锁预防手段:<br>四个死锁产生的条件我们打破其中一个就可以预防死锁或者避免.<br>下面打破死锁的四种情况<br>限制申请方式.</p><ol><li><p>互斥-共享资源不是必须的,必须占有非共享资源,(如果改成非互斥的就会使程序不稳定所以这个办法不太好)</p></li><li><p>占用并等待-必须保证当一个进程请求的资源,他不持有任何其他资源:(可以解决死锁,一次得到全部所需的资源才会执行,不会拿一部分资源,由于占有的资源过多,使得别的线程无法得到他们所需的资源结果是系统的利用率很低,系统的饥饿现象,)</p><ol><li>需要进程请求并分配其所有资源,它开始执行之前或允许进程请求资源仅当进程没有资源</li><li>资源利用率低,可能发生饥饿.</li></ol></li><li><p>无抢占:(前边说资源互斥,现在如果抢占,就需要把原来的进程kill掉,)</p><ol><li>如果进程占有某些资源,并请求其它不能被立即分配的资源,则释放当前正占有的资源</li><li>被抢占资源添加到资源列表中</li><li>只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行</li></ol></li><li><p>循环等待 - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请,(在传统的操作系统中用的不多,但是在嵌入式操作系统中用的多)</p></li></ol><p>死锁避免手段:在申请资源的阶段进行判断,申请的资源会不会出现死锁,如果会出现死锁我就不会答应你的请求(他知道你在申请资源中最大需要的资源是多少,也能限制分配资源的数量,你提供的数量一定不会大于进程需要的最大需求,如进程说我最大需要十个资源,在运行中第一次申请两个资源,第二次申请了四个资源,一共六个了,第三次申请五个,就不行了,与预先约定不符合)<br>    需要系统具有一些额外的先验信息提供.<br>    1. 最简单和最有效的模式是要求每个进程生命它可能需要的每个类型资源的最大数目<br>    2. 资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求.<br>    3. 死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态.(环形等待不一定死锁,但是很可能死锁,是不安全状态,不安全状态包含死锁状态)我们需要找出一种安全的状态.</p><p>图: 个状态包含图<br>    安全状态: 包含了死锁状态的,针对系统的所有进程存在一个执行序列,按照这个序列执行下来,不会出现某个进程等在那执行不下去的情况,重点是如何去找这个安全序列.<br>    图 :安全状态定义解释<br>    死锁状态:<br>    不安全状态:<br>如何找到安全状态?<br>图: 解决方案图</p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>图:银行家算法由来和背景<br>资金相当于资源,客户相当于进程,客户贷款怎么能确保收回这个点受到得到启发,<br>怎么实现的死锁避免:<br>    前提条件:<br>        1. 多个实例<br>        2. 每个进程都必须能最大限度的利用资源<br>        3. 当一个进程请求一个资源,就不得不等待.<br>        4. 当一个进程获得所有的资源就必须在一段有限的时间释放它们.<br>   基于上述描述我们就能来寻找一个安全序列,让所有进程都能正常的结束,正常运行就说明所有资源都能得到.如果没有这个序列,就说明出入unslfe状态,(unsalf状态包含unlock状态,如果要判断unlock开销会更发,所以判断unsalf状态就可以了)判断unsalf之后,就不能让这个进程获得资源. 基于上述前提条件银行家算法通过尝试寻找允许每个进程获得的最大资源并结束(把资源返还给系统)的进程请求的一个理想执行时序,来决定一个状态是否是安全的.<br>    不存在满足要求的执行时序的状态都是不安全的.</p><p>银行家算法数据结构:<br>    n = 进程数量, m = 资源类型数量.(每一行有多个类型,如a,b,c类型)<br>    Max(总需求) : n x m矩阵.如果Max {i,j] = k,表示进程Pi最多请求资源类型Rj的k个实例.<br>    Available剩余空闲量: 长度为m的向量,如果Available{j] = k, 有k个类型Rj的资源实例可用.<br>    Allocation(已分配量): n x m矩阵.如果Allocation{i,j] = k,则p{i] 分配了k个Rj的实例.<br>    Need(未来需要量): n x m矩阵,如果 Need{i, j] = k, 则pi可能需要k个Rj实例来完成任务.<br>    三者关系:<br>            Need{i,j] = Max{i,j] - Allocation{i, j];</p><p>银行家算法设计:<br>安全序列的生成<br>     work 表示当前资源剩余空闲量,</p><ol><li><pre><code>finish&#123;i]为true表示已经拿到了所有的资源,运行一段时间并结束,为false就得去申请资源,申请到资源才能结束,一开始都为false,怎么判断他能否申请到这是一关键,</code></pre></li><li>找到这样的i: 接下来找出Need比Work小的进程i.<br> a. Finish{i] = false<br> b. Needi ＜= work<br> 没有这样i,就转到4,表示处于不安全序列了.否者就是处于安全序列</li><li>Work = work + Allocation{i] 进程i的资源需求量小于当前剩余空闲资源.<br>Finish{i] = true 所以配置给它在回收.<br>转到2. </li><li>if Finish{i] = ture for all i. 不予分配, 所有进程的Finish为Ture,表明系统处于安全状态.<br>then the system is in a safe state.<br> 一开始进程会提出资源请求,我需要多少资源,资源A多少,资源B多少,就会有一个Request向量如果当前资源狗就会分配给你<br>就是如果 Requesr{i] ＜= need{i] ,转到步骤2,否则,提出错误条件,因为进程已经超过了其最大要求.</li></ol><p>Banker’s Algorithm :<br>图:银行家算法大致的设计思路</p><p>安全状态算法例子(安全序列生成):</p><p>15:18<br>!!! 掌握不太明确定，需要复习.</p><p>Max :所有进程需要资源的情况.<br>need: 当前进程需要资源的情况.<br>Available vector V:表示系统还剩多少资源的情况.<br>allocation matrix A:表示当前进程已经拥有的资源.<br>Resource vectoe R: 表示当前系统中所有资源的个数.</p><h4 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h4><p>死锁检测条件放宽了，前边说死锁避免：就是没有没有死锁，即使我检测出有可能出现不安全状态，就不会让你继续申请资源了，而死锁检测为什么说条件放宽了，因为他允许系统进入死锁状态，就继续运行吧没关系，一旦说到了某个阶段就会判断一下，当前系统是否死锁了，如果是死锁了，就启动恢复机制，如果判断没死锁，那就继续运行，这里他把死锁的检测挪到了更靠后的一个阶段，系统运行中，不是在每次发出请求就去判断．</p><p>死锁检测:<br>跟安全状态检测算法类似.<br>图: 简化资源分配图<br>图: 资源类型的数据结构</p><ol><li>把资源分配的图，变换为等待进程图，把每个资源节点去掉，如果说某一个进程需要一个资源且这个资源被另一个进程所拥有的话，就会在发出请求的线程和拥有资源的线程之间建立一条连线，这是有向图，判断是否有环，如果有环就说明死锁了</li></ol><p>图: 死锁检测算法<br>在检测操作系统的时候能用到，别的就很少用到．</p><ol><li>开销比较大，这就是操作系统很少使用检测算法的原因.</li><li>他还需要提前知道每个进程所需要的最大资源个数，一般程序来说这个信息很难获得，（每次都检测，开销很大）</li></ol><p>Allocation :以得到的资源.<br>Request : 当前需要申请的资源<br>Available: 现在系统中还剩余的资源<br>成功没有死锁<br>图: 例子１死锁检测算法<br>失败就是死锁了<br>图:　例子２死锁检测算法</p><p>图：检测算法使用（使用情况，使用频率）</p><p>已经产生死锁了<br>图: 死锁恢复办法<br>图; 进程恢复的手段（和上边一样）<br>第一条kill所有死锁进程，可以杀死一个进程，但是问题来了应该杀死哪个进程，大家都一样为啥要kill他呢，规则如何定.可以基于进程优先级，进程的运行时间，进程占用的资源一般来说优先级低的kill掉，进程运行时间久了也kill掉也说得过去，进程占用资源多的kill，让还没运行的进程去执行，好像也说得过去，无论那种方法都不能让进程正常执行，所以说这些方法都讯在一些强制性不合理性，实际过程确实这样做的，</p><p>死锁恢复总结三大类:</p><ol><li>选择一个受害者－最小的成本</li><li>回滚—返回到一些安全状态，重启进程到安全状态．(打破死锁的四个条件，这个就是把分配的资源抢回来，迫使不成环)</li><li>饥饿—统一进程可能一直被选作受害者，包括回滚的数量.</li></ol><p>操作系统更多用的是鸵鸟算法：忽略脑袋插土里．真出现了死锁恢复．不是一个很好的方法，还有待研究解决．（聪明的你论文题目来了，啊哈哈哈哈哈哈哈！关注操作系统研究的进展！！！！）</p><h4 id="IPC概述"><a href="#IPC概述" class="headerlink" title="IPC概述"></a>IPC概述</h4><p>进程间通信简称叫IPC:<br>    1. 概述:<br>        1. 通信模型<br>        2. 直接及间接通信<br>        3. 阻塞和非阻塞<br>        4. 通信链路缓冲<br>    2. 信号：<br>    3. 管道:<br>    4. 消息队列:<br>    5. 共享内存: </p><p>IPC的概述:<br>    1. 进程通信的机制及同步<br>    2. 不适用共享变量的进程通信<br>    3. IPC facility 提供2个操作:<br>        1. send(message) - 消息大小固定或者可变<br>        2. recelve(message)<br>    4. 如果P和Q想通信，需要:<br>        1. 在它们之间建立通信链路<br>        2. 通过send/receive交换消息<br>    5. 通信链路的实现:<br>        1. 物理（例如，共享内存，硬件总线）<br>        2. 逻辑（例如，逻辑属性）</p><p>为什么要进程间通信呢?<br>以前我们说过进程之间还要相对保持独立，一个进程不能访问另一个进程的地址空间．这是一个很重要的因素，就是进程地址空间不会随便被不相干的其他进程访问，这样可以确保整的进程正确的运行，另一方面我们知道进程和进程之间需要协作在一起完成一个大的任务，这时候需要一定的沟通，消息的通知，信息的传递，在保证进程相互独立的同时还要保证进程间的相互沟通，这就是为什么有进程间通信这个原因，进程间的机制，最常想到的机制就是send和receive两种，如果两个进程之间通信需要建立一个管道，跟打电话和电子邮件类似，通信管道有很多种情况，比如说基于内存，基于某个特殊的硬件，基于逻辑的资源等等，都可以建立通信链路或者通信管道，看具体实现:<br>    上例子:<br>图:进程间的通信模型<br>        图中ａ部分进程ａ和进程ｂ是一种间接的通信，为什么这么说，可以看到进程ａ把消息发送到内核，由内核再转发给进程ｂ．<br>图中ｂ部分进程ａ和进程ｂ直接可以通信，避免了通过内核倒一次<br>直接通信类似与打电话，间接通信就是写信．（转邮局再发送）</p><p>图: 直接通信<br>进程必须正确的命名对方:<br>    1. send(P,message) —发送信息到进程P（发送ID）<br>    2. receive(Q, message)–从进程Q接受消息．(接受ID)</p><p>在发送和接收数据之前，需要对链路有一个提前的建立，可以是单向也可以是双向的，取决于实现．<br>通信链路的属性:<br>    1. 自动建立链路（一般来说需要操作系统的支持，才能建立好，因为它打破了不同进程的隔离，没有操作系统的支持很难做到的操作系统可以访问到各种资源）<br>    2. 一条链路恰好对应一对通信进程<br>    3. 每对进程之间只有一个链路存在<br>    4. 链接可以是单向的．但是通常是双向的．</p><p>图: 间接通信:发送方:消息得放到某个地方去，这个地方是操作系统指定的一个共享的区域，在内核中的区域,接受方：指定我要从操作系统的那个地方接受数据就ｏｋ了，至于发送方的数据从哪里来的接收方不用管，对于发送方而言对于谁收到他的数据也不用关注，只要关注从某个地方发送或者从某个地方收数据就ｏｋ了，中间节点一般是内核中的一些共享的资源，这是一种间接通信的方式，两种通信手段，可以根据具体的通信需求来判断需要什么通信的手段．<br>    定向从消息队列接受消息:<br>        1. 每个消息队列都有一个唯一的ID,<br>        2. 只有他们共享了一个消息队列，进程才能够通信．<br>    通信链路的属性:<br>        1. 只有进程共享一个共用的消息队列，才建立链路<br>        2. 链接可以与许多进程相关联<br>        3. 没对进程可以共享多个通信链路<br>        4. 链接可以是单向或双向</p><p>间接通信:<br>    操作:这是他的一个操作过程<br>        1. 创建一个新的消息队列<br>        2. 通过消息队列发送和接收消息<br>        3. 销毁消息队列（没有用的缓存队列，及时销毁）<br>    原语的定义如下:发送到消息队列或者从消息队列接收．<br>        1. send(A, message) – 发送消息到队列A<br>        2. receive(A, message) – 从队列A接受消息.</p><p>从发送的方式来看直接和间接<br>另一个：消息传递可以是阻塞或非阻塞:<br>    阻断被认为是同步的：比如我要发送一个消息，如果没发送完成，就要阻塞在那，只有发送完成才能正常的返回去干下边的事情．<br>    1.<br>    2.<br>    非阻塞被认为是异步的:非阻塞发送send就完了，至于send成功与否还不知道，就是send这个操作会很快的返回，是异步的因为成功和结束的时间和（return ）返回时间有一段比较大的间距．间距是异步性的体现，<br>    1.<br>    2.<br>两种方式他们有各自适合的场景，根据具体应用需求来选择合适的应用手段，到底采取阻塞和非阻塞的方式或者同步的方式还是异步的方式，来完成消息的发送和接收．</p><h4 id="信号管道消息队列和共享内存"><a href="#信号管道消息队列和共享内存" class="headerlink" title="信号管道消息队列和共享内存"></a>信号管道消息队列和共享内存</h4><p>如果消息通过某种队列，把消息缓存起来，为什么要缓存，以前我们说过缓存的最主要目的就是提高效率，来避免发送方和接收方的不匹配，因为可能发的很快，收的很慢，或者在同时刻收的很快，发的很慢，因为有缓存，会把临时不能处理的信息，无论发送方还是接收方的数据，放到一个地方可以极大的提高效率，这样缓存就存在一个缓存多少，容量问题，下列三种方式．<br>队列的消息被附加到链路；可以时以下三种方式之一；</p><ol><li>0容量-0message:<br> 发送方必须等待接收方(renfezvous)</li><li>有限容量–n message的有限长度:<br> 发送方必须等待，如果队列满，接收方在队列空了，就得等待，有数据才能接收．</li><li>无限容量–无限长度:作分析模拟的时候才会用到，无限长度．<br> 发送方不需要等待.接受方不一样，如果没有数据，接收方不得不等待，或者返回一个错误信息，这是接受方的处理过程，</li></ol><p>概述讲完了，这些机制使得通信更加的灵活，适应各种不同的计算机通信情况．<br>接下来说计算机系统里边通用的通信手段！！！</p><h5 id="信号-轻量机制"><a href="#信号-轻量机制" class="headerlink" title="信号(轻量机制)"></a>信号(轻量机制)</h5><p>类比一下，最开始讲操作系统提到了，硬件，外设或者让ｃｐｕ知道现在该做些什么事或者我产生什么状态让ｃｐｕ注意一下，需要ｃｐｕ去处理一下，会产生一个硬件中断（interrupt）,这里的signal可以理解为软件level的interrupt,打断了当前的应用程序，说我当前有更紧急的事情要处理，这是signal大致的目标．<br>一旦操作系统由于某种原因，给某一个程序发出了signal信号，那应用程序会怎么处理呢，一般的缺省（catch）（就直接缺省运行，就退出正常执行）</p><p>signal(信号):只是一个很小的bit,来表明是哪种信号，不是传很多数据交换，起了一种通知的作用，这是他的特点也是他的不足．效率很高类似于异步打断的机制，如果说采用专门的中断处理函数处理，处理完之后怎么办，是执行呢，退出呢还是怎么样呢，根据操作系统的约定，一般会回到被打断的程序重新执行，这里说是信号的大致处理过程，了解完处理过程后，还要了解如何实现呢．<br>    1. 软件中断通知事件处理<br>    2. Example: SIGFPE,SIGKILL,SIGUSRI,SIGSTOP.SIGCONT</p><p>接收到信号时会发生什么:<br>    1. catch:指定信号处理函数被调用：信号来了，信号的处理函数就会被调用，来完成信号的响应，这种方式很灵活，为了某种响应某种信号就在程序里编写相对应的处理函数，来指定它是产生某个信号之后做哪些响应，这个是可实现的．<br>    2. Ignore:依靠操作系统的默认操作:<br>        Example:Abort.memory dump, suspend or resume process.<br>    3. Mask:闭塞信号因此不会传送:<br>        可能是暂时的(当处理同样类型的信号)<br>不足:<br>    1. 不能传输要交换的任何数据.</p><p>刚才那些功能，和那些表现形式，操作系统如何实现的（信号机制是操作系统完成的），想一想操作系统提供一种什么样的手段，就能完成刚才那种功能呢，上图:信号量机制图<br>解释图:<br>    第一步：如果针对某个信号单独处理的时候，首先在程序执行开始的时候，注册一个针对某个信号的handles，把这个作为系统调用，发给我们的操作系统，操作系统看这个信息之后，我可以当产生某个信号的时候，针对这个进程的信号的时候，我们会让应用程序写的专门的信号处理函数来执行，把这个信息注册好之后，操作系统就好，ｏｋ．<br>第二步：一旦产生了这个信号，操作系统怎么能让那个当前正在运行的进程把当前的工作停下来，跳到中断处理函数去执行，应该是信号处理函数，软中断，让中断处理函数去执行的，怎么来完成想一想？正在跑的好好一个程序怎么会被打断去执行另外一个函数去了，没错这个靠操作系统完成的，单靠应用程序很难完成，操作系统怎么做？首先想一想，操作系统接受信号的时候运行在内核态，当他从内核态返回用户态去执行那个要去响应信号的那个程序的时候，提前做好准备返回的那个点，调用信号处理函数的入口，这一步怎么实现呢？结合之前写操作系统system call系统调用的实现，他需要把系统调用的返回的用户空间的堆栈进行修改，返回本来应该返回到调用系统调用的后一条语句去执行呢变成信号处理函数入口，改了这一步，同时还需要把信号处理函数之后要执行的那个地址作为后边那个栈的返回地址，这样就没问题了，这样一旦从操作系统内核返回到应用程序去执行的时候会根据你留的栈信息跳到信号执行函数的入口去执行，这时候就回到了用户态，当这个函数执行完毕后，就会继续返回调它的那个函数，构造成那个被打断的点，使他可以被继续执行，怎么组合这是一个问题？<br>70年代，没图形界面，只有键盘还没鼠标，想一想如何把一个函数的输出作为一个函数的输入，一步一步的往前走完成一个更复杂的功能，这个就通过一个|(竖线)就完成了，意思就是一个命令ａ产生的输出会通过｜来作为命令ｂ的输入这样就形成了管道机制，写的时候我知道从键盘或者说文件读到数据，输出到键盘或文件，只知道这么编写就ｏｋ了，中间会有某种机制进行完成，从一个地方到另一个地方的重定向，这就是我们的管道机制．<br>％ｓ　｜　ｍｏｒｅ　使文件分页显示．<br>图:管道分析图</p><p>图中：shell进程，shell收到一条命令，创建两个子进程ls和more(共享文件)，ls的输出(stdout)做一个特殊的处理不是输出到屏幕上而是重定向一个管道，管道实际是内存中的一个buffer，这是ls就没在屏幕写了，而是在管道在写，more以为要从键盘或者屏幕来接收信息，stdin也重定向到了管道，more从缓冲区读入，管道有双重身份，一部分是接收部分，一部分是输出部分.buffer也是有限的，如果ls输出把buffer填满，就会阻塞（sleep）,more发现buffer没数据也会阻塞(sleep)等待被唤醒．ls和more之所以能协同起来是因为他们共同的父进程，就能继承父进程的资源，管道是一种文件的形式存在的．</p><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>也是一种消息传递的机制,跟管道的区别是我们所关注的．<br>管道是通过父进程帮助子进程建立好的通道，如果进程之间没有父子关系就不能建立管道，这是第一个缺陷，第二个呢管道里的数据是一种字节流没有一种结构化的表示形式，把里边的数据按照结构化的形式显示出来，可以实现但是比较复杂，这两个原因呢在消息队列里边都可以克服，消息队列可以实现多个不相干的进程通过消息队列来传递数据这么一个功能，一端send有多个receive只有一个，他们之间没关系也可以传数据，第二个呢send和receive传的是结构化的数据使得编写比较复杂的程序更加灵活方便，因为你传递的不是一个没有意义的字节流，传递完还需要解析，而是传递完成就是一个有意义的数据结构，这是消息队列的通信方式，但是和消息队列有一个类似的方式，是由buffer size限制，如果满了或者空了，发送或者接收方也会睡眠，<br>图:消息对垒（列）<br>消息队列是一种间接通信的方式</p><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><p>共享内存是一种直接通信的方式，因为两个进程有一段特殊的内存空间是两个进程都能访问到的．一个进程写另一个进程就能访问到，不需要send和receive操作，相对于前边的通信方式是最快的，传输数据量是最大最快的方式，只需要操作系统在开始的时候创建好这样一块共享的区域，让多个进程共享这个区域，这是他的好处，方便高效没有多余的拷贝，不好的地方就是怎么保证我写了之后别人不能写到同一个地方去，这就需要一些同步互斥的机制来保证我们写的数据是对的，不会出现前边所说的同步互斥的情况．需要考虑．<br>进程:<br>    1. 每个进程都有私有地址空间<br>    2. 在每个地址空间内，明确的设置了共享内存段<br>优点:<br>    1. 快速，方便地共享数据<br>不足:<br>    1. 必须同步数据访问</p><p>操作系统如何进行共享内存的实现?<br>就是前面说的内存管理,你可以把同一块物理内存,映射到相同或者不同的地址空间中去,这样映射好之后就能通过不同进程的虚地址的时候,访问的就是同一块物理地址的物理空间,实现起来并不复杂,但是需要内存管理的充分支持,页表等相应的支持,第二个需要更好的同步互斥机制,确保不会重复写的等问题的出现,</p><p>根据不同的需求完成机制的选取.</p><h5 id="还有一种通信机制-socket"><a href="#还有一种通信机制-socket" class="headerlink" title="还有一种通信机制 socket()"></a>还有一种通信机制 socket()</h5><p>虽然tcp协议栈都实现在内核里边但是是计算机网络的内容就不进一步赘述了,有发布类似内容.</p><h4 id="文件系统．"><a href="#文件系统．" class="headerlink" title="文件系统．"></a>文件系统．</h4><p>文件系统是操作系统的子进程,完成文件的存储,读取,信息的恢复等操作,</p><h5 id="基本概念-文件系统和文件"><a href="#基本概念-文件系统和文件" class="headerlink" title="基本概念-文件系统和文件"></a>基本概念-文件系统和文件</h5><ol><li>文件描述符</li><li>目录</li><li>文件别名</li><li>文件系统种类</li></ol><p>文件系统: 一种用于持久性存储的系统抽象:硬盘(掉电存储在里边的数据不会丢失)<br>    1. 在存储器上:组织,控制,导航,访问和检索数据.<br>    2. 大多数计算机系统包含文件系统<br>    3. 个人电脑,服务器,笔记本电脑<br>    4. ipod,Tivo/机顶盒,手机/掌上电脑<br>    5. Google可能是由一个文件系统构成的<br>文件:文件系统中一个单元的相关数据在操作系统中的抽象,</p><p>考虑怎样查询,访问,处置放在持久化存储介质上的数据,这是文件系统需要去关心的.</p><h5 id="基本概念-文件系统的功能"><a href="#基本概念-文件系统的功能" class="headerlink" title="基本概念-文件系统的功能"></a>基本概念-文件系统的功能</h5><p>分配文件磁盘空间:<br>    1. 管理文件块(哪一块属于哪一个文件)<br>    2. 管理空闲空间(哪一块是空闲的)<br>    3. 分配算法(策略)</p><p>管理文件集合:<br>    1. 定位文件及其内容<br>    2. 命名: 通过名字找到文件的接口<br>    3. 最常见:分层文件系统<br>    4. 文件系统类型(组织文件的不同方式)</p><p>提供的边里及特征:<br>    1. 保护:分层来保护数据安全<br>    2. 可靠性/持久性: 保持文件的持久即使发生崩溃,媒体错误,攻击等.</p><h5 id="基本概念-文件和块"><a href="#基本概念-文件和块" class="headerlink" title="基本概念-文件和块"></a>基本概念-文件和块</h5><p>文件属性:<br>    名称,类型,位置,大小,保护,创建者,创建时间,最近修改时间,…<br>文件头:<br>    1. 在存储元数据中保存了每个文件的信息<br>    2. 保存文件的属性<br>    3. 跟踪哪一块存储块属于逻辑上文件结构的哪个偏移.</p><h5 id="基本概念-文件描述符"><a href="#基本概念-文件描述符" class="headerlink" title="基本概念-文件描述符"></a>基本概念-文件描述符</h5><p>图: 文件使用模式</p><p>需要元数据数据来管理打开文件:<br>    1. 文件指针: 指向最近的一次读写位置,每个打开了这个文件的进程都这个指针.<br>    2. 文件打开计数:记录文件打开的次数,—当最后一个进程关闭了文件时,允许将其从打开文件表中移除.<br>    3. 文件磁盘位置: 缓存数据访问信息<br>    4. 访问权限: 每个程序访问模式信息.</p><p>用户视图:<br>    持久的数据结构</p><p>系统访问接口:<br>    1. 字节的集合(UNIX)<br>    2. 系统不会关心你想存储在磁盘上的任何的数据结构</p><p>操作系统内部视角:<br>    1. 快的集合(块是逻辑转换单元,而扇区是物理转换单元)<br>    2. 块大小＜＞扇区大小；在UNIX中，块的大小是4KB.</p><p>当用户说: 给我2-12字节空间时会发生什么:<br>    1. 获取字节所在的块（磁盘块）<br>    2. 返回块内对应部分<br>如果说要写2-12字节呢:<br>    1. 获取块<br>    2. 修改块内对应部分<br>早文件系统中的所有操作都是在整个块空间上进行的:<br>    举个例子，getc(),和putc();即使每次只访问1字节的数据，也会缓存目标数据4096字节，</p><p>访问模式上：<br>用户怎么访问文件:<br>    1. 在系统层面需要知道用户的访问模式</p><p>顺序访问:按字节依次读取:<br>    1. 几乎所有的访问都是这种方式</p><p>随机访问: 从中间读写:<br>    1. 不常用,但是仍然重要,例如,虚拟内存支持文件:内存页存储在文件中.<br>    2. 更加快速—不希望获取文件中间的内容也必须获取块内所有字节.</p><p>基于内容访问:通过特征:<br>    许多系统不提供此种访问方式,相反,数据库是建立在索引内容的磁盘访问上(需要高效的随机访问)</p><p>文件内部的结构:<br>    无结构:<br>        单词,比特的对列<br>    简单记录结构:<br>        1. 列<br>        2. 固定长度<br>        3. 可变长度<br>    复杂结构:上边和操作系统有关,操作系统无关和应用有关<br>        1. 格式化的文档(如,MS Word,PDF)<br>        2. 可执行文件<br>        3. …</p><p>多用户系统中的文件共享是很必要的.<br>访问权限:<br>    1. 谁能够获得哪些文件的哪些访问权限.<br>    2. 访问模式:读,写,执行,删除,列举等.</p><p>文件访问控制列表(ACL):<br>    1. ＜文件实体,权限＞</p><p>UNIX模式:<br>    1. ＜用户|组|所有人, 读|写|可执行＞<br>    2. 用户ID识别用户,表明每个用户所允许的权限及保护模式<br>    3. 组ID允许用户组成组,并指定了组访问权限.</p><p>指定多用户/客户如何同时访问共享文件:<br>    1. 和过程同步算法相似<br>    2. 因磁盘I/O和网络延迟而设计简单.</p><p>Unix文件系统(UFS)语义:<br>    1. 对于打开的写入内容立即对其他打开同一文件的其他用户可见<br>    2. 共享文件指针允许多用户同时读取和写入文件</p><p>会话语义:<br>    1. 写入内容只有当文件关闭时可见</p><p>锁:<br>    1. 一些操作系统和文件系统提供该功能.</p><h5 id="基本概念-目录"><a href="#基本概念-目录" class="headerlink" title="基本概念-目录"></a>基本概念-目录</h5><p>图: 文件目录<br>图: 文件目录组织<br>图: 典型操作<br>图: 存目录中的文件<br>图: 路径的遍历<br>图: 文件挂载</p><h5 id="基本目录-文件别名"><a href="#基本目录-文件别名" class="headerlink" title="基本目录-文件别名"></a>基本目录-文件别名</h5><p>图: 两个或多个文件名关联同一个文件<br>快捷方式: 内容是原来文件的路径,查看内容根据路径访问.<br>图: 文件删除方案 图中有两个解决方式<br>如果是软连接的方式,把原来文件删了,会怎么样.指向一个空的地方,成为悬空指针,<br>图: 别名机制出现的问题</p><h5 id="基本目录-文件系统种类"><a href="#基本目录-文件系统种类" class="headerlink" title="基本目录-文件系统种类"></a>基本目录-文件系统种类</h5><p>图: 文件系统的种类<br>日志文件系统: 要么完成要么不完成,突然断电记住修改部分对数据的恢复操作<br>图 :分布式系统补充<br>网络使得分布式或者文件系统他的特征和单机上的特征很不一样,网络意味着延迟大不可靠访问时间不可控这些都是网络系统拥有的特点,但是单机中基于pci总线是一种稳固的快速的完成内存和地址之间的访问,中间有一个网络存在,这使得得考虑,一致性,安全性,访问延迟等问题,使得再设计网络或者分布式系统的时候更加复杂,需要更多的因素,也是我们研究的热点(论文题目又来了!!!!)</p><h5 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h5><p>如何组织设置管理运行<br>图 分层结构<br>图 虚拟文件系统目的和功能<br>图 控制块<br>图 抽象文件图<br>卷控制块,在卷控制块的控制下,会有一堆目录,这个目录可以管理子目录也可以管理文件,根节点会指向文件的内容(数据块)数据块放到磁盘里边,<br>图 文件系统数据结构讲解<br>文件系统数据结构: 这些都会映射到磁盘里的一个或多个扇区.有些专门的数据块存放数据的.<br>图: 再来文件抽象图 注意下边一行图</p><h5 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h5><p>为了提高速度需要在内存中放一个缓存,buffer数据缓存技术,<br>图 缓冲技术图.<br>图 数据缓冲的机制<br>图 缓存粒度<br>图 文件数据块的页缓存<br>效率高的体现,减少对硬盘的读取次数.</p><h5 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h5><p>图 打开文件描述<br>图 打开文件系统<br>下面是流程:<br>    当一个进程做了一个打开操作后,会返回一个index,index会指出在进程的打开文件表的哪个位置,基于这个项找到,系统层面打开的文件表,有可能是不同进程打开了同一个文件,在系统打开文件表里边只记录一项就ok了,基于这一项他会找到如果他是一个目录或者是一个文件他有不同处理简单点,如果是一个文件的话,我们可以知道文件的node信息,文件的节点信息会包含到底这个文件在什么地方,你在做read或write操作的时候会有一个偏移量offset来指出那个文件的哪个位置起的哪个数据或者读或者写,offset会经过文件控制块的转换,转换成一个disk(扇区的编号),要访问的那块数据对应着要访问的扇区,然后呢操作系统会把这些扇区的内容或者读或者写,以读为例就是读到内存中来,这样就可以读到内存的buffer里边取出这个应用程序所需要的数据,传回给应用程序,这就是打开文件之后做的读和写的操作,<br>    在打开文件之前要注意,文件是一个共享的资源,可能存在一个锁的保护机制,锁的设置请况:<br>        1. 强制–根据锁保持情况和需求拒绝访问<br>        2. 劝告–进程可以查找锁的状态来决定怎么做.</p><h5 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h5><h5 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h5><h5 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理-RAID"></a>多磁盘管理-RAID</h5><h5 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h5><h5 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h5><p>####</p><h5 id="内存分层体系"><a href="#内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h5><h5 id="在操作系统的内存管理范例"><a href="#在操作系统的内存管理范例" class="headerlink" title="在操作系统的内存管理范例"></a>在操作系统的内存管理范例</h5><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h3 id="操作系统的内存管理-分页和分段的区别"><a href="#操作系统的内存管理-分页和分段的区别" class="headerlink" title="操作系统的内存管理, 分页和分段的区别"></a>操作系统的内存管理, 分页和分段的区别</h3><p>1、页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。</p><p>段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。</p><p>2、页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。</p><p>段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。</p><p>3、分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。</p><p>分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。<br>4.页内位移溢出时，会传给下一页。段内位移溢出时，就会出现越界中断。</p><p>银行家算法原理</p><hr><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linxu" scheme="http://example.com/tags/linxu/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://example.com/posts/1/"/>
    <id>http://example.com/posts/1/</id>
    <published>2020-11-10T00:38:59.000Z</published>
    <updated>2020-11-13T13:29:15.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>heap_sort()<br>o(nlogn)</p><p>堆的一般性操作(底层是一个完全二叉树)．</p><ol><li>插入元素: 插入元素时根据堆自下而上进行调整，层数越高（越接近根节点）调整的次数越多．<br>实例：第零层(根节点位置)插入的时候进行零次调整，第一层元素最多调整1次依次类推.根据推导单个个元素需要调整的次数:<br> 调整次数 = 树高 - 1<br> 推导得到: 调整次数 = (nlogn + 1) - 1;<br> 调整次数 = nlogn;<br>整体的调整次数:（背景为一个满二叉树）<br>　　　　该层节点最多调整次数　节点个数<br>第一层:　　　　　０　　　　　　　2^0<br>第二层:　　　　　１　　　　　　　2^1<br>第三层:　　　　　２　　　　　　　2^2<br>第N层:　　 　　　Ｎ-1　　　　　　2^n<br>（背景满二叉树）<br>度为零的节点比度为二的节点多一个,<br>上边规律可得最后一层节点有2^n个，那么度为2的节点2^n - 1个.<br>这两个的和就是整个要维护的节点个数，之和就是N = 2^(n + 1) - 1个．</li></ol><p>叶子节点处理:<br>最后一层的节点调整之和就是(n - 1) * 2^n<br>转换为(log(2^n) - 1) * (2 ^ n)</p><p>把N代替了n,求全部节点调整次数：<br>(log2N - 2) * (N/2): 注释由于叶子节点和全部节点近似2倍的关系，所以简化为(N/2).</p><p>化简取其最大量级<br>整体的时间复杂度约为 O(NlogN).</p><h4 id="建堆的优化"><a href="#建堆的优化" class="headerlink" title="建堆的优化"></a>建堆的优化</h4><p>为了让建堆的时间复杂度变为O(n).使其层数越高的元素（层数越小），操作的次数越多，就需要自上而下的进行维护一个堆．<br>所以依据传统思路，找到了一个完全优于前者思路，前者思路就会淘汰．<br>得到公式：<br>n<em>2^1 + (n-1)*2^2 + (n-2)*2^3 +……+ 1</em>2^n (n依据上表分析)<br>注意第一项为第二次到顶层调整次数．<br>就比如最后一项: 最后一层节点数2^n个，需要调整的次数为1次.</p><p>这个公式的计算(等差乘等比)</p><p>当前项成公比，然后错位相减（纸上计算）</p><p>过程中需要加上2^0,2^1再整个减去3.可以得到<br>2^1 + 2^2 +…… 2^n -2<em>n - 3<br>等比序列求结果．Sn = a1(1 - q^n)/(1-q) <a href="https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97/1129457?fr=aladdin">公式跳转</a><br>结果为　2^(n+2) - 2</em>n -4 = 2^(n + 1) - 4.</p><p>对于这个结果分析一下:<br>    把n带入求得n+1层节点个数2^n,从下层调整个数2^(n+1).<br>    2^n变化为2^(n + 1)表明了让N = 2^n（表示节点的数量）可以得到等式N = 2N．趋于一种平衡状态．<br>    进一步推导可得O(2N) = O(N)的时间复杂度. </p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>k-归并排序</title>
    <link href="http://example.com/posts/32473/"/>
    <id>http://example.com/posts/32473/</id>
    <published>2020-11-10T00:27:16.000Z</published>
    <updated>2020-11-13T13:24:57.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>system_develop</title>
    <link href="http://example.com/posts/48539/"/>
    <id>http://example.com/posts/48539/</id>
    <published>2020-11-09T15:43:24.000Z</published>
    <updated>2020-11-13T13:24:57.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统开发" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="操作系统开发" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>programming_language</title>
    <link href="http://example.com/posts/21911/"/>
    <id>http://example.com/posts/21911/</id>
    <published>2020-11-09T15:42:36.000Z</published>
    <updated>2020-11-13T13:24:57.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程语言开发" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="编程语言开发" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>leedcode</title>
    <link href="http://example.com/posts/62607/"/>
    <id>http://example.com/posts/62607/</id>
    <published>2020-11-09T15:39:53.000Z</published>
    <updated>2020-11-16T07:22:44.891Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单组"><a href="#简单组" class="headerlink" title="简单组"></a>简单组</h2><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>快慢指针:<br>    时间复杂度O(n),空间复杂度O(1);</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      bool hasCycle(ListNode *head) &#123;</span><br><span class="line">                  ListNode *p ,*q;</span><br><span class="line">                  p &#x3D; q &#x3D; head;</span><br><span class="line">          while(q &amp;&amp; q-&gt;next)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                          if(p &#x3D;&#x3D; q) return true;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return false;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="160-相交链表-剑指-Offer-52"><a href="#160-相交链表-剑指-Offer-52" class="headerlink" title="160. 相交链表 剑指 Offer 52"></a>160. 相交链表 剑指 Offer 52</h3><p>变为两个等长链表求第一个交点,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tion for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int getNode(ListNode *head, ListNode **p)&#123;</span><br><span class="line">        *p &#x3D; NULL;</span><br><span class="line">        if(head &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt &#x3D; 1;</span><br><span class="line">        *p &#x3D; head;</span><br><span class="line">        while((*p)-&gt;next !&#x3D; NULL)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            (*p) &#x3D; (*p)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        ListNode *p[2];</span><br><span class="line">        int cnt[2], sub;</span><br><span class="line">        p[0] &#x3D; headA;</span><br><span class="line">        p[1] &#x3D; headB;</span><br><span class="line">        cnt[0] &#x3D; getNode(headA, &amp;p[0]);</span><br><span class="line">        cnt[1] &#x3D; getNode(headB, &amp;p[1]);</span><br><span class="line">        if(p[0] !&#x3D; p[1]) return NULL;</span><br><span class="line">        p[0] &#x3D; cnt[0] &lt;&#x3D; cnt[1] ? headA : headB;</span><br><span class="line">        p[1] &#x3D; cnt[0] &gt; cnt[1] ? headA : headB;</span><br><span class="line">        sub &#x3D; abs(cnt[1] - cnt[0]);</span><br><span class="line">        while(sub--)&#123;</span><br><span class="line">            p[1] &#x3D; p[1]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p[0] !&#x3D; p[1])&#123;</span><br><span class="line">            p[0] &#x3D; p[0]-&gt;next;</span><br><span class="line">            p[1] &#x3D; p[1]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p[0];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h3><p>双指针问题</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">                  ListNode *p, *q;</span><br><span class="line">                  p &#x3D; q &#x3D; head;</span><br><span class="line"></span><br><span class="line">          while(k--)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">          while(p !&#x3D; NULL)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return q;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h3><p>和上一题类似，快慢指针.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthToLast(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode *p, *q;</span><br><span class="line">        p &#x3D; q &#x3D; head;</span><br><span class="line">        while(k--)&#123;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            q &#x3D; q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return q-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除中间节点"><a href="#删除中间节点" class="headerlink" title="删除中间节点"></a>删除中间节点</h3><p>把删除当前节点转换为删除下一个节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      void deleteNode(ListNode* node) &#123;</span><br><span class="line">                  node-&gt;val &#x3D; node-&gt;next-&gt;val;</span><br><span class="line">                  node-&gt;next &#x3D; node-&gt;next-&gt;next;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h3><p>设置虚拟头结点两个前后指针进行删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* deleteNode(ListNode* head, int val) &#123;</span><br><span class="line">                  ListNode *p &#x3D; new ListNode(NULL), *q &#x3D; head,*r;</span><br><span class="line">                  r &#x3D; p,p-&gt;next &#x3D; q;</span><br><span class="line">          while(q)&#123;</span><br><span class="line">              if(q-&gt;val &#x3D;&#x3D; val)&#123;</span><br><span class="line">                                  p-&gt;next &#x3D; q-&gt;next;</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return r-&gt;next;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h3><p>快慢指针,一个指针走一步，一个指针走两不，快指针结束，慢指针输出．<br>注意:快指针两个节点判断.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* middleNode(ListNode* head) &#123;</span><br><span class="line">                  ListNode *p &#x3D; head, *q &#x3D; head;</span><br><span class="line">                  if(head &#x3D;&#x3D; NULL) return head;</span><br><span class="line">          while(( q !&#x3D; NULL ) &amp;&amp; (q-&gt;next !&#x3D; NULL))&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return p;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a>1290. 二进制链表转整数</h3><p>首先看到二进制就想到位运算.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      int getDecimalValue(ListNode* head) &#123;</span><br><span class="line">                  int result &#x3D; 0;</span><br><span class="line">          while(head)&#123;</span><br><span class="line">                          result &lt;&lt;&#x3D; 1;</span><br><span class="line">                          result |&#x3D; head-&gt;val;</span><br><span class="line">                          head &#x3D; head-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return result;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>链表长度等长<br>快慢指针</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      int getNode(ListNode *head, ListNode **p)&#123;</span><br><span class="line">                  *p &#x3D; NULL;</span><br><span class="line">                  if(head &#x3D;&#x3D; NULL) return 0;</span><br><span class="line">                  *p &#x3D; head;</span><br><span class="line">                  int cnt &#x3D; 1;</span><br><span class="line">          while((*p)-&gt;next)&#123;</span><br><span class="line">                          (*p) &#x3D; (*p)-&gt;next;</span><br><span class="line">                          cnt++;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return cnt;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">                  ListNode *p[2];</span><br><span class="line">                  int cnt[2], sub;</span><br><span class="line">                  p[0] &#x3D; headA,p[1] &#x3D; headB;</span><br><span class="line">                  cnt[0] &#x3D; getNode(headA, &amp;p[0]);</span><br><span class="line">                  cnt[1] &#x3D; getNode(headB, &amp;p[1]);</span><br><span class="line">                  p[0] &#x3D; cnt[0] &gt;&#x3D; cnt[1] ? headA : headB;</span><br><span class="line">                  p[1] &#x3D; cnt[0] &lt; cnt[1] ? headA : headB;</span><br><span class="line">                  sub &#x3D; abs(cnt[0] - cnt[1]);</span><br><span class="line">          while(sub--)&#123;</span><br><span class="line">                          p[0] &#x3D; p[0]-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">          while(p[0])&#123;</span><br><span class="line">              if(p[0] &#x3D;&#x3D; p[1])&#123;</span><br><span class="line">                                  return p[0];</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          p[0] &#x3D; p[0]-&gt;next;</span><br><span class="line">                          p[1] &#x3D; p[1]-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return NULL;</span><br><span class="line">                   </span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h3><p>快慢指针找中间位置，链表后半部分翻转，首尾往中间移动比较．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* turnlist(ListNode *head)&#123;</span><br><span class="line">                  ListNode *p &#x3D; head, *q &#x3D; head, *temp &#x3D; NULL;</span><br><span class="line">                  if((p &#x3D;&#x3D; NULL) || (p-&gt;next&#x3D;&#x3D;NULL)) return head;</span><br><span class="line">                  q &#x3D; p-&gt;next,  p-&gt;next &#x3D; NULL;</span><br><span class="line">          while(q)&#123;</span><br><span class="line">                          temp &#x3D; q-&gt;next;</span><br><span class="line">                          q-&gt;next &#x3D; p;</span><br><span class="line">                          p &#x3D; q;</span><br><span class="line">                          q &#x3D; temp;</span><br><span class="line">                      </span><br><span class="line">          &#125; </span><br><span class="line">                  return p;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">      bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">                  ListNode *p &#x3D; head, *q &#x3D; head, *temp;</span><br><span class="line">                  if(p &#x3D;&#x3D; NULL  ||p-&gt;next &#x3D;&#x3D; NULL) return true;</span><br><span class="line">          while(q!&#x3D;NULL &amp;&amp; q-&gt;next!&#x3D;NULL)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  temp &#x3D; p;</span><br><span class="line">                  ListNode *k &#x3D; NULL;</span><br><span class="line">                  k &#x3D; turnlist(p);</span><br><span class="line">                  p &#x3D; head;</span><br><span class="line">          while(k)&#123;</span><br><span class="line">              if(p-&gt;val &#x3D;&#x3D; k-&gt;val)&#123;</span><br><span class="line">                                  p &#x3D; p-&gt;next;</span><br><span class="line">                                  k &#x3D; k-&gt;next;</span><br><span class="line">                              continue;</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          else return false;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return true;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h3><p>链表变换虚拟头节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode *p &#x3D; new ListNode();</span><br><span class="line">        p &#x3D; NULL;</span><br><span class="line">        if(head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;</span><br><span class="line">        ListNode *q &#x3D; head, *k;</span><br><span class="line">        while(q)&#123;</span><br><span class="line">            k &#x3D; q-&gt;next;</span><br><span class="line">            q-&gt;next &#x3D; p;</span><br><span class="line">            p &#x3D; q;</span><br><span class="line">            q &#x3D; k;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h3><p>一般思维就是开一个20001的数组进行hash.<br>无额外内存开销，三个指针完成.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode * deleteNode(ListNode*head, ListNode *low,ListNode *fast)&#123;</span><br><span class="line">                  if(fast-&gt;next &#x3D;&#x3D; NULL) </span><br><span class="line">                  low-&gt;next &#x3D; NULL;</span><br><span class="line">                  if(fast-&gt;next)</span><br><span class="line">                  low-&gt;next &#x3D; fast-&gt;next;</span><br><span class="line">                  return head;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">      ListNode* removeDuplicateNodes(ListNode* head) &#123;</span><br><span class="line">                  ListNode *p, *q, *k;</span><br><span class="line">                  if(head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;</span><br><span class="line">                  p &#x3D; head, q &#x3D; head-&gt;next, k &#x3D; p;</span><br><span class="line">          while(p)&#123;</span><br><span class="line">              while(q)&#123;</span><br><span class="line">                  if(p-&gt;val &#x3D;&#x3D; q-&gt;val)&#123;</span><br><span class="line">                                          head &#x3D; deleteNode(head, k, q);</span><br><span class="line">                                          q &#x3D; k-&gt;next;</span><br><span class="line">                                          continue;</span><br><span class="line">                                      </span><br><span class="line">                  &#125;</span><br><span class="line">                                  k &#x3D; k-&gt;next, q &#x3D; q-&gt;next;</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          if(p &#x3D;&#x3D; NULL|| p-&gt;next &#x3D;&#x3D; NULL) return head;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          k &#x3D; p;</span><br><span class="line">                          q &#x3D; p-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return  head;</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>###　剑指 Offer 06. 从尾到头打印链表<br>栈列和数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">              vector&lt;int&gt;res;</span><br><span class="line">              stack&lt;ListNode*&gt;node;</span><br><span class="line">              ListNode *p &#x3D; head;</span><br><span class="line">          while(p !&#x3D; NULL)&#123;</span><br><span class="line">                      node.push(p);</span><br><span class="line">                      p &#x3D; p-&gt;next;</span><br><span class="line">                  </span><br><span class="line">          &#125;</span><br><span class="line">          while(!node.empty())&#123;</span><br><span class="line">                      p &#x3D; node.top();</span><br><span class="line">                      node.pop();</span><br><span class="line">                      res.push_back(p-&gt;val);</span><br><span class="line">                  </span><br><span class="line">          &#125;</span><br><span class="line">              return res;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><p>单段链表循环头插.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* reverseBetween(ListNode* head, int m, int n) &#123;</span><br><span class="line">                ListNode *q &#x3D; new ListNode(0), *fast &#x3D; q;</span><br><span class="line">                q-&gt;next &#x3D; head;</span><br><span class="line">          for(int i &#x3D; 1; i &lt; m; i++)&#123;</span><br><span class="line">                        q &#x3D; q-&gt;next;</span><br><span class="line">                    </span><br><span class="line">          &#125;</span><br><span class="line">                head &#x3D; q-&gt;next;</span><br><span class="line">          for(int i &#x3D; m; i &lt; n; i++)&#123;</span><br><span class="line">                        ListNode *temp &#x3D; head-&gt;next;</span><br><span class="line">                        head-&gt;next &#x3D; temp-&gt;next;</span><br><span class="line">                        temp-&gt;next &#x3D; q-&gt;next;</span><br><span class="line">                        q-&gt;next &#x3D; temp;</span><br><span class="line">                    </span><br><span class="line">          &#125;</span><br><span class="line">                return fast-&gt;next;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>###<br>###<br>###<br>###<br>###</p><p>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###</p><p>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leedcode-链表" scheme="http://example.com/categories/leedcode-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leedcode" scheme="http://example.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>socket+tcp</title>
    <link href="http://example.com/posts/14686/"/>
    <id>http://example.com/posts/14686/</id>
    <published>2020-11-09T13:22:27.000Z</published>
    <updated>2020-11-13T13:24:57.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>socket和tcp/udp以及计算机网络传输结合总结．<br>非常详细的博客</p><p><a href="https://blog.csdn.net/m0_37925202/article/details/80286946#commentBox">socket和tcp/udp网络中传输详解</a></p><p><a href="https://www.cnblogs.com/zgq0/p/8780893.html">进程间通信非常详细的博客</a></p><p><a href="https://blog.csdn.net/qq_38182963/article/list/2">tomcat详细解释-socket通信重点看三</a></p><p><a href="https://www.cnblogs.com/runtimeexception/p/10415821.html">nosql中的redis学习笔记</a></p><h3 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h3><ol><li><p>P地址、端口号……</p></li><li><p>socket API</p></li><li><p>实现UDP客户端/服务器</p></li><li><p>套接字<br>套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p></li></ol><h3 id="进程间通信（IPC）有很多种方式"><a href="#进程间通信（IPC）有很多种方式" class="headerlink" title="进程间通信（IPC）有很多种方式"></a>进程间通信（IPC）有很多种方式</h3><ol><li>管道（包括无名管道和命名管道）；</li><li>消息队列；</li><li>信号量；</li><li>共享存储。</li><li>……（ Socket和Streams支持不同主机上的两个进程IPC）。</li></ol><h3 id="认识网络层通信过程："><a href="#认识网络层通信过程：" class="headerlink" title="认识网络层通信过程："></a>认识网络层通信过程：</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>system</title>
    <link href="http://example.com/posts/59942/"/>
    <id>http://example.com/posts/59942/</id>
    <published>2020-11-09T05:47:41.000Z</published>
    <updated>2020-11-23T01:49:27.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="请简述进程，线程及程序三者有什么区别"><a href="#请简述进程，线程及程序三者有什么区别" class="headerlink" title="请简述进程，线程及程序三者有什么区别?"></a>请简述进程，线程及程序三者有什么区别?</h4><p>程序: 是编译好的可执行的二进制文件．<br>程序运行起来后，进入内存中就变成了进程.</p><p>进程: 进程是程序在内存中的镜像，他是一个实例</p><p>包括：加载的二进制程序，虚拟内存，内核资源（打开的文件,关联的用户,<br>关联用户：再分配权限过程，会把程序和用户进行关联，就是哪个用户来把这个程序运行起来的．</p><p>线程: 是进程内的执行单元，<br>如果只有一个线程，就是一个主线程，也就是进程自己.<br>如果有多个线程的话每个线程都是一个执行单元．<br>线程也是操作系统调度器调度的最小单元.</p><p>进程和线程的异同之处?<br>相同: 都是为了增加程序的并发度.为了使功能更为丰富．而实现的.<br>不同:<br>阶段一 进程中有一个虚拟内存，线程中有一个虚拟处理器的东西．得到的结论，进程是独享存，线程是独享CPU.<br>阶段二<br>进程在运行的过程中独占内存，不会感觉到有内存的争抢．<br>线程在运行的时候就会感觉我独占cpu的核心.没有被挣抢．<br>阶段三<br>进程独占内存：所以进程通信是较为复杂的东西．<br>线程没有虚拟内存，所以说线程会共享整个进程空间的内容，或者说整个进程空间．这样产生的后果就是，线程间的通信会变得很方便．<br>阶段四<br>线程调度的代价是相对较小的,因为在进程空间上的内容是共享的，所以在切换线程的时候，内存空间的消耗比较小的．<br>cpu的消耗，比如两个线程都在用cpu的时候,在线程调度和上下文切换消耗也是很小的．</p><p>第五阶段<br>进程和线程的优势:<br>    多进程程序：他运行起来比较稳定，某个进程退出，不会导致其他进程退出．<br>    多进程编程适合并发度比较小的情况，比如就启动程序后就需要两个进程就可以，并且他们做自己独立的无相关活动的情况．<br>    与我们生活息息相关的进程就是守护进程，守护进程就得用多进程去实现，而不能用多线程，<br>    多线程：让编程变得跟简单，就比如把某个模块抽象化出来，就规定一个线程去实现．相互之间的通信比较简单的．</p><p>弊端：<br>多进程：比较复杂，调度的代价比较大．<br>多线程：</p><ol><li>调试及其不容易</li><li>线程安全问题：主要涉及到资源的竞争，（就是三个进程同时访问一个空间上的资源，如果不加上锁，就会产生资源竞争<br>就是即使加了锁，也会产生死锁问题）</li></ol><h4 id="请简述你所知道的fork-函数，以及再多进程编程中需要注意的事项"><a href="#请简述你所知道的fork-函数，以及再多进程编程中需要注意的事项" class="headerlink" title="请简述你所知道的fork()函数，以及再多进程编程中需要注意的事项"></a>请简述你所知道的fork()函数，以及再多进程编程中需要注意的事项</h4><p>函数问题三个考虑方向</p><ol><li><p>用途 : 克隆了一个父进程产生了一个子进程，基本上拷贝了父进程的进程空间，只进行了一个写拷贝（不会进行马上拷贝，而是发生了写操作的时候，才进行拷贝）．</p></li><li><p>函数原型：　无参数</p></li><li><p>函数返回值：是我们遇到的有多个返回值的函数，可能的三个返回值<br>(1): 在子进程中返回的是零<br>(2): 在父进程中返回的是子进程的pid;<br>在子进程中获得父进程的pid 就是getppid(),获得自己的pid就是getpid();<br>在父进程没办法获取子进程的pid只能通过返回值的形式给他．<br>为什么会不能返回呢？<br>因为fork()之后，子进程就是一个独立的内存空间了，父进程失去了对它的控制．<br>(3): 在系统编程或者io操作上，返回-1有明显的含义的，表示出错了，fork()函数不能出现参数出错的情况，只能是</p></li><li><p>存在问题</p></li></ol><p>第一个问题：<br>比如 简单举个例子<br>for(int i = 0; i != 10; i++){<br>    fork();<br>}<br>这样是产生不了10个子进程的．或者说fork第一次就会产生一个子进程，再执行到for循环的时候，就会是父子进程都执行到了下次变成了四个子进程以此类推．所以说产生不了我们想要的十个子进程，只有判断进程的pid</p><p>第二个问题：<br>比如fork()函数前边有一个printf(),函数没有输出回车(\n),fork就可能会把缓冲区的数据进行一下复制，这个子进程这时就会输出两次．</p><p>第三个问题：</p><p>会引起孤儿进程或者是僵尸进程，<br>僵尸进程：　子进程先于父进程死了，父进程不给他收尸，就会产生僵尸进程．<br>孤儿进程：　子进程活着父进程死了，就会产生孤儿进程．孤儿进程会被一号进程收养．<br>僵尸进程不会被一号进程收养是因为他的父进程还存在，所以不会归到一号进程．<br>僵尸进程的危害: 占用pid,进程控制器pcb还在，变相的占用了系统资源</p><p>孤儿进程的好处: 在父进程生成子进程之后，父进程就没有事情做了，然后自己退出，留下子进程被一号进程收养，就是所说的后台进程或者是守护进程的实现方式．</p><h4 id="请回答-进程有哪些状态-他们是如何进行切换的"><a href="#请回答-进程有哪些状态-他们是如何进行切换的" class="headerlink" title="请回答: 进程有哪些状态,他们是如何进行切换的?"></a>请回答: 进程有哪些状态,他们是如何进行切换的?</h4><p>三态模型和无态模型<br>三态：</p><ol><li>ready就绪态</li><li>running运行态</li><li>block阻塞态</li></ol><p>状态执行顺序<br>1-&gt;2-&gt;3<br>2-&gt;1 </p><p>就绪态和运行态是可以两个切换的<br>ready状态可以转换成running状态<br>就比如while(1){}他不会进行io等待也不会涉及到阻塞．<br>那么什么时候结束呢：进程调度器分配的cpu时间片耗尽了，就会回到ready状态.</p><p>running到block状态<br>阻塞主要是io等待，比如输入信息(cin 或者scanf).<br>有io等待的时候就会从运行态转变为block态，等待输入结束后到达ready.下次调度的时候才会被执行．</p><p>###</p><h4 id="请你对用户态-内核态以及系统调用这三个概念做出解释"><a href="#请你对用户态-内核态以及系统调用这三个概念做出解释" class="headerlink" title="请你对用户态,内核态以及系统调用这三个概念做出解释"></a>请你对用户态,内核态以及系统调用这三个概念做出解释</h4><h5 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h5><p>特权级</p><ol><li>对于X86架构的CPU硬件上有0-3四个特权级包括了特权指令和非特权指令</li><li>在Unix/linux系统中,只使用了0和3特权级．<h5 id="两者差别"><a href="#两者差别" class="headerlink" title="两者差别"></a>两者差别</h5></li><li>用户态</li><li>内核态</li><li>特权不同</li><li>处理器是否可被抢占</li></ol><h5 id="相互切换"><a href="#相互切换" class="headerlink" title="相互切换"></a>相互切换</h5><ol><li>有用户态到内核态<br>　以下三种本质上都是中断机制<ol><li>中断 </li><li>异常</li><li>系统调用(陷入)</li></ol></li><li>由内核态到用户态<ol><li>设置程序状态字 </li></ol></li></ol><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><ol><li>为了使上层应用能够访问到硬件资源，内存为上层应用提供了接口</li><li>是用户态主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作完成工作</li><li>包括<ol><li>进程控制</li><li>进程通信</li><li>文件操作</li><li>设备操作等</li></ol></li></ol><h4 id="线程同步是干什么的，线程同步有那些机制"><a href="#线程同步是干什么的，线程同步有那些机制" class="headerlink" title="线程同步是干什么的，线程同步有那些机制?"></a>线程同步是干什么的，线程同步有那些机制?</h4><p>线程同步的主要手段就是互斥.</p><ol><li>相关名词<ol><li>临界区</li><li>原子性</li><li>竞争</li><li>互斥</li></ol></li><li>为什么要有线程同步<br>　　线程安全性．</li><li>线程同步实现机制<ol><li>临界区<br>控制多线程执行某一段代码的顺序．<br>使可能并发的线程，让其一个一个串行化去执行的．</li><li>互斥量 互斥锁就是这种机制，当一个线程拥有这个对象的时候，其他线程就没办法拥有．只有拥有这个对象的人才能够执行这个操作．</li><li>信号量<br>信号量和互斥量不同的地方就是，信号量允许多个线程同时访问某个资源，就比如一个数据可以让五个线程访问，别的不可以．</li><li>事件<br>当内核感知到事件发生的时候，操作系统通知线程去做什么，这个叫事件．</li></ol></li></ol><h4 id="内核线程和用户线程有什么区别"><a href="#内核线程和用户线程有什么区别" class="headerlink" title="内核线程和用户线程有什么区别?"></a>内核线程和用户线程有什么区别?</h4><p>分类原则:<br>根据操作系统是否能感知到线程的存在分为</p><ol><li><p>用户线程:操作系统感知不到的线程</p></li><li><p>内核线程:操作系统能感知到的线程</p></li></ol><p>早期的操作系统没有线程只有进程，因为进程的创建上下文创建销毁的成本代价太高，所以说能不能有一个轻量级的，所以说有了线程的概念，最开始操作系统的内核没办法提供线程的支持的，线程是一些库提供用户层面的支持，所以说在创建一个线程，操作系统感知不到线程的存在的，再发展，操作系统的内核就渐渐的支持线程操作．后来线程由内核提供一下调用的接口，最后可以通过用户调用来创建一些线程，这个时候的线程对内核来说是可见的，内核可以看到这个线程，就是内核线程．</p><p>优缺点对比:</p><ol><li>用户态线程：<br>可以在不支持多线程的机器上实现多线程<br>在自己的线程空间里，自己调度销毁切换，所以相对来说，是比较灵活的，但是他有一个致命的缺点，内核不知道他的存在．只能感知到一个进程的存在，只要发生一个线程阻塞，操作系统就不会继续调度这个进程里边的其他线程，因为他只感知到当前进程处于阻塞状态．直到他重新处于就绪态的时候．他才可以调度其他线程.　</li><li>内核态线程<br>　由内核线程是由内核创建销毁切换的，所以说对于内核线程来说，每一个操作系统内核都知道这个线程的存在，所以说它的调度都是以这些线程为基本单位的，每一个进程里边如果有多个线程的话，操作系统会根据每个线程的状态（就绪，阻塞，运行等状态），来选择是否要调度他．真正意义上实现了并发不是用户写的．并且也不会因为一个线程阻塞导致整个进程的阻塞．<br>　由于线程在内核态，可以使用整个系统内能进行资源的竞争，也相当于对资源的有效利用提高了．<br>　每一个线程都支持一个线程控制块tcp,内核根据该控制块感知线程的存在，并进行控制．在一定程度上相当于进程．跟进程一样创建销毁操作，但是他是一种轻量级的．总的来说，是内核线程提供了一个轻量级的类似于进程的调度．</li></ol><p>linux的线程是什么线程?(加分项)</p><p>多线程模型</p><ol><li>多对一：多个线程对应一个线程．早期内核里一个线程（进程）在用户层面实现了多个线程，这就叫多对一模型．</li><li>一对一：这就是当前linux系统下多线程的主要方式，每一个用户创建的线程都对应着一个内核线程，所以说在内核层面就能感知到线程的存在，然后进行更为精细的调度．</li><li>多对多：对一种和二种方式进行混合，</li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>algorithm</title>
    <link href="http://example.com/posts/54839/"/>
    <id>http://example.com/posts/54839/</id>
    <published>2020-11-08T11:59:08.000Z</published>
    <updated>2020-11-13T13:24:57.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程"><a href="#如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程" class="headerlink" title="如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程"></a>如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程</h4><p>leedcode 中happy number,不是用链表但是用的是一个思想.</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="如果现在有k个有序数组-如何合并成一个有序数组"><a href="#如果现在有k个有序数组-如何合并成一个有序数组" class="headerlink" title="如果现在有k个有序数组,如何合并成一个有序数组"></a>如果现在有k个有序数组,如何合并成一个有序数组</h4><p>k路归并排序:</p><h4 id="请具体说明，为什么归并排序适合处理大数据排序情况"><a href="#请具体说明，为什么归并排序适合处理大数据排序情况" class="headerlink" title="请具体说明，为什么归并排序适合处理大数据排序情况"></a>请具体说明，为什么归并排序适合处理大数据排序情况</h4><p>如果现在有40g的外部文件，而内存只有2g,如何进行文件的排序操作，这种情况就需要对40g的内存进行划分,划分成20份2g的文件，通过内存排序算法对这20个文件进行排序，然后进行多路归并排序(外存排序算法).</p><p>其中二路归并排序是多路归并排序中的一种.</p><p>特点:　对内存要求很少而且大部分操作是在外存中进行的.</p><h4 id="如何快速的输出无序数组中前k大的值-请说明你的方法-并分析时间复杂度．"><a href="#如何快速的输出无序数组中前k大的值-请说明你的方法-并分析时间复杂度．" class="headerlink" title="如何快速的输出无序数组中前k大的值,请说明你的方法,并分析时间复杂度．"></a>如何快速的输出无序数组中前k大的值,请说明你的方法,并分析时间复杂度．</h4><ol><li>最差的方法: 选择排序(从未排序区选出最大或最小的元素进行插入已排序区尾部)，进而能选出第几大的值．</li><li>维护一个大小为k的大根堆(nlogk)<br>把带插入元素依次性的插入大根堆．</li><li>维护一个小根堆<br>参考堆排序和线性建堆法的过程<br>首先把数组用线性建堆法简历一个小根堆，建堆的时间复杂度O(n)<br>小根堆的时间复杂度是logn,弹出k次,所以总的时间复杂度为n + klogn;</li><li>BFPRT算法<br>基于快速选择算法<br>快速选择算法的影响因素主要是，基准值的选取能否尽可能的平分数组元素．<br>一条性质找到第ｋ位的元素,左边的元素都比ｋ小．</li></ol><p>如果数据量比较大(n或者k比较大)(大数据情况)<br>参考多路归并排序的过程</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h4 id="假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值"><a href="#假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值" class="headerlink" title="假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值"></a>假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值</h4><ol><li><p>蓄水池抽样<br>假设已经从n个元素中抽取了k个元素，概率为(k/n).<br>假设蓄水池中k个元素a1,a2,a3,….ak.<br>当a(n+1)个元素进来的时候，就会1到(n - 1)中随机一个数值，这个值如果小于等于k的时候，把a(n + 1)替换掉该位置．如果大于k的话,a(n + 1)这个值就不保留．</p></li><li><p>应用场景<br>如果是说大数据场景下的采样问题．大数据场景一般是确定数据大小的情况下．<br>而蓄水池抽样说的是一个为止大小的序列.<br>确切的说应用场景是数据流采样问题,<br>数据流采样问题: 一个请求发送给服务器VPN,然后服务器进行转发达到翻墙的目的.服务器想对所有数据进行等概率采样，</p></li></ol><h4 id="要求设计一个函数-运行100次-非顺序的输出1–100内所有数字，要求，不能使用数组．"><a href="#要求设计一个函数-运行100次-非顺序的输出1–100内所有数字，要求，不能使用数组．" class="headerlink" title="要求设计一个函数,运行100次,非顺序的输出1–100内所有数字，要求，不能使用数组．"></a>要求设计一个函数,运行100次,非顺序的输出1–100内所有数字，要求，不能使用数组．</h4><ol><li><p>使用链表:<br>一百个链表中存取100个数值，然后随机删除节点，来达到随机的目的.</p></li><li><p>线性同余法:<br> 用一个线性同余式进行不断地计算<br> 剩余系:就比如　(4^k) % 7 当ｋ取值1,2,3,4对应值为4,3,1,4出现了循环<br> 就表示该公式的剩余系为4,2,1.<br> 能满足条件的(3xk%101)</p></li><li><p>扩展知识: </p></li></ol><p>要求设计一个函数,运行k次,非顺序的输出1–k内所有数字，要求，不能使用数组</p><ol><li>欧拉定理</li><li>欧拉函数</li></ol><h4 id="简述语言的随机函数原理"><a href="#简述语言的随机函数原理" class="headerlink" title="简述语言的随机函数原理"></a>简述语言的随机函数原理</h4><ol><li><p>c语言中的应用<br>第一步：srand 设置随机种子<br>第二部：rand获取随机种子</p></li><li><p>原理介绍</p></li></ol><p>首先:真随机和伪随机的区别</p><p>其次:线性同余法(计算机中使用的方法)</p><p>最后:为什么设置随机种子<br>就是为了在随机序列上找到一个起始点，如果没有起始点的话，我们的程序就会在一个固定的地方运行，产生的随机数是一样的．<br>如果随机种子一样产生的值也是一样的，只能用时间这个一直在变的量，来进行设定．</p><p>### 　</p><h4 id="一个长度为n的数组-只有一个数字出现了一次，其与数字均出现了2次-请找到出现1次的这个数字"><a href="#一个长度为n的数组-只有一个数字出现了一次，其与数字均出现了2次-请找到出现1次的这个数字" class="headerlink" title="一个长度为n的数组,只有一个数字出现了一次，其与数字均出现了2次,请找到出现1次的这个数字."></a>一个长度为n的数组,只有一个数字出现了一次，其与数字均出现了2次,请找到出现1次的这个数字.</h4><ol><li>异或运算的性质<br>第一: 满足交换率<br>第二: 满足结合率<br>本质是统计相应二进制的奇偶性的</li></ol><ol start="2"><li>解题方法</li></ol><p>一次进行异或操作，相同数字异或为零，最后找到．</p><ol start="3"><li>拓展问题</li></ol><p>有两个数字出现一次．</p><h4 id="一个长度为n的数组，其中的数值范围是1–n-已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度-要求时间复杂度O-n-空间复杂度O-1"><a href="#一个长度为n的数组，其中的数值范围是1–n-已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度-要求时间复杂度O-n-空间复杂度O-1" class="headerlink" title="一个长度为n的数组，其中的数值范围是1–n,已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度.要求时间复杂度O(n),空间复杂度O(1)."></a>一个长度为n的数组，其中的数值范围是1–n,已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度.要求时间复杂度O(n),空间复杂度O(1).</h4><p>n的数组，和数值范围是1–n，就用数组下标来表示对应位数，如果下标为1值为5,就让第一位和第五位数进行对调，看看第一位是不是五，如果是就找到了，如果不是接着对调．</p><h4 id="一个长度为n的数组-已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．"><a href="#一个长度为n的数组-已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．" class="headerlink" title="一个长度为n的数组,　已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．"></a>一个长度为n的数组,　已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．</h4><p>第一类方法: 排序方法</p><ol><li><p>基数排序(raddix_sort)<br>时间复杂度O(n),常数的空间复杂度但常数较大.</p></li><li><p>其余排序(快排,堆排)</p></li></ol><p>空间复杂度O(nlogn)<br>空间复杂度O(1)</p><p>第二类方法: 哈希表</p><p>时间复杂度:O(n)<br>空间复杂度:O(n)</p><p>方法比较:</p><pre><code>具体场景分析：比如计算资源短缺，选时间复杂度小的，存储空间短缺，选空间复杂度小的.如果其中一个两个都优于另一个，直接舍去第二种．</code></pre><p>###　</p><h4 id="已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-2-请设计算法找到这个数字．"><a href="#已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-2-请设计算法找到这个数字．" class="headerlink" title="已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/2),请设计算法找到这个数字．"></a>已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/2),请设计算法找到这个数字．</h4><p>超过(n/2)的数称为关键元素.</p><p>代码实现:<br>    随机取出一个数值，进行比对，等于加1,不等就减1.</p><h4 id="已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-k-请设计算法找到这个数字．"><a href="#已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-k-请设计算法找到这个数字．" class="headerlink" title="已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/k),请设计算法找到这个数字．"></a>已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/k),请设计算法找到这个数字．</h4><p>摩尔投票法:<br>    记录k-1个数字，及次数.<br>    k个数字来的时候,如果与之前元素不同就说明找到了ｋ个元素，<br>    用一个集合，有相同数加1, </p><p>代码实现:</p><h4 id="在一个数组中，大多数数字都出现3次-只有一个数字出现次数不足3次，请设计算法找到这个数字．"><a href="#在一个数组中，大多数数字都出现3次-只有一个数字出现次数不足3次，请设计算法找到这个数字．" class="headerlink" title="在一个数组中，大多数数字都出现3次,只有一个数字出现次数不足3次，请设计算法找到这个数字．"></a>在一个数组中，大多数数字都出现3次,只有一个数字出现次数不足3次，请设计算法找到这个数字．</h4><ol><li>二进制位统计法:<br> 统计每一个二进制列上的1出现的次数是不是三的倍数,如果是则都是，如果有就说明不是出现了三次.</li></ol><ol start="2"><li>状态转换表:<br> 本质和前边一样的，<br>重新梳理</li></ol><p>###</p><h4 id="如何设计一个支持min操作的栈，min函数返回当前栈中的最小值-要求min-push-pop-操作时间复杂度都是O-1-函数如何设计"><a href="#如何设计一个支持min操作的栈，min函数返回当前栈中的最小值-要求min-push-pop-操作时间复杂度都是O-1-函数如何设计" class="headerlink" title="如何设计一个支持min操作的栈，min函数返回当前栈中的最小值,要求min,push,pop()操作时间复杂度都是O(1),函数如何设计."></a>如何设计一个支持min操作的栈，min函数返回当前栈中的最小值,要求min,push,pop()操作时间复杂度都是O(1),函数如何设计.</h4><h4 id="有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O-n"><a href="#有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O-n" class="headerlink" title="有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O(n);"></a>有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O(n);</h4><p>维护一个窗口为K的窗口,这K个序列用两个优先队列维护，一个维护最大MAX_N,一个维护最下MIN_N,MAX_N - MIN_N = k - 1 这样的条件.</p><h4 id="给定k值-如果找到链表的倒数第k个元素-一个指针怎么做-两个指针怎么做"><a href="#给定k值-如果找到链表的倒数第k个元素-一个指针怎么做-两个指针怎么做" class="headerlink" title="给定k值,如果找到链表的倒数第ｋ个元素,一个指针怎么做?两个指针怎么做?"></a>给定k值,如果找到链表的倒数第ｋ个元素,一个指针怎么做?两个指针怎么做?</h4><p>第一种做法: 一个指针,跑两次</p><p>一个指针先找到链表的长度，再算出该数在第几位．</p><p>第二种做法: 两个指针,跑一次<br>让两个指针之间的距离控制在ｋ，两个指针一起往后走，当后边指针指向为空时，前指针就是倒数第k位的数.走的步数是一样的.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql2</title>
    <link href="http://example.com/posts/15731/"/>
    <id>http://example.com/posts/15731/</id>
    <published>2020-10-31T07:56:33.000Z</published>
    <updated>2020-11-01T07:02:52.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库高级" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="http://example.com/posts/16097/"/>
    <id>http://example.com/posts/16097/</id>
    <published>2020-10-27T05:25:31.000Z</published>
    <updated>2020-11-01T13:09:31.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/203622688">大佬笔记入口</a><br><a href="https://www.nowcoder.com/discuss/389444">同上</a></p><h3 id="mysql的逻辑架构"><a href="#mysql的逻辑架构" class="headerlink" title="mysql的逻辑架构"></a>mysql的逻辑架构</h3><h3 id="数据库两个操作系统文件"><a href="#数据库两个操作系统文件" class="headerlink" title="数据库两个操作系统文件"></a>数据库两个操作系统文件</h3><p>每个 SQL Server 2005 数据库至少具有两个操作系统文件：<br>一个数据文件和一个日志文件。</p><ol><li>数据文件包含数据和对象，例容如表、索引、存储过程和视图。</li><li>日志文件包含恢复数据库中的所有事务所需的信息。为了便于分配和管理，可以将数据文件集合起来，放到文件组中。<br>主要数据文件包含数据库的启动信息，并指向数据库中的其他文件。用户数据和对象可存储在此文件中，也可以存储在次要数据文件中。每个数据库有一个主要数据文件。主要数据文件的建议文件扩展名是 .mdf。<br>事务日志文件保存用于恢复数据库的日志信息。每个数据库必须至少有一个日志文件。事务日志的建议文件扩展名是 .ldf。</li></ol><h3 id="1-事务四大特性"><a href="#1-事务四大特性" class="headerlink" title="1.事务四大特性"></a>1.事务四大特性</h3><p>事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</p><ol><li><p>原子性:<br>最小的执行单元： 要么全执行，要么全不执行</p></li><li><p>隔离性：<br>所有操作全部执行完以前其它会话不能看到过程</p></li><li><p>一致性：<br>事务前后，数据总额一致</p></li><li><p>持久性:<br> 一旦事务提交，对数据的改变就是永久的</p></li></ol><h3 id="隔离操作"><a href="#隔离操作" class="headerlink" title="隔离操作"></a>隔离操作</h3><h4 id="并行事物的四大问题"><a href="#并行事物的四大问题" class="headerlink" title="并行事物的四大问题"></a>并行事物的四大问题</h4><ol><li>更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）</li><li>脏读：读到别的事务未提交的数据。（万一回滚，数据就是脏的无效的了）</li><li>不可重复读：两次读之间有别的事务修改。</li><li>幻读：两次读之间有别的事务增删。</li></ol><h4 id="对应隔离级别"><a href="#对应隔离级别" class="headerlink" title="对应隔离级别"></a>对应隔离级别</h4><ol><li><p>READ UNCOMMITTED：读未提交，不处理。</p></li><li><p>READ COMMITTED：读已提交，只读提交的数据，无脏读；</p></li><li><p>REPEATABLE READ：可重复读，加行锁，两次读之间不会有修改，无脏读无重复读；</p></li><li><p>SERIALIZABLE: 串行化，加表锁，全部串行，无所有问题。<br>详细解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. READ UNCIMMITTED（未提交读）</span><br><span class="line">　　      事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读。</span><br><span class="line"></span><br><span class="line">2. READ COMMITTED（提交读）</span><br><span class="line">　　      首先大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象</span><br><span class="line"></span><br><span class="line">3. REPEATABLE READ（可重复读）</span><br><span class="line"> 　　     REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻行，顾名思义就是突然蹦出来的行数据。</span><br><span class="line">          指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。</span><br><span class="line"></span><br><span class="line">4. SERIALIZABLE（可串行化）</span><br><span class="line">          　　      SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，</span><br><span class="line">                   因此性能会比较低下，在需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四中隔离原理"><a href="#四中隔离原理" class="headerlink" title="四中隔离原理"></a>四中隔离原理</h4></li><li><p>READ_UNCOMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据不加锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。</span><br><span class="line">下面分别对应上面1，2产生的表现：</span><br><span class="line"></span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>READ_COMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>REPEATABLE READ 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1，事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SERIALIZABLE 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</span><br><span class="line">2，事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line">2，事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="数据库涉及的锁"><a href="#数据库涉及的锁" class="headerlink" title="数据库涉及的锁"></a>数据库涉及的锁</h4><p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，<br>MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）。<br>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。<br>所有的锁都是绑定在数据库的索引机制上的！！！</p><p>首先锁可以分为： </p><ol><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ol><p>而除了粒度，锁根据模式分为：</p><ol><li><p>共享锁(S)：发生在数据查找之前，多个事务的共享锁之间可以共存</p></li><li><p>排他锁(X)：发生在数据更新之前，排他锁是一个独占锁，与其他锁都不兼容</p></li><li><p>更新锁(U)：发生在更新语句中，更新锁用来查找数据，当查找的数据不是要更新的数据时转化为S锁，当是要更新的数据时转化为X锁</p></li><li><p>意向锁：发生在较低粒度级别的资源获取之前，表示对该资源下低粒度的资源添加对应的锁，意向锁有分为：<br>　　　　意向共享锁(IS) ，意向排他锁(IX)，意向更新锁(IU)，共享意向排他锁(SIX)，共享意向更新锁(SIU)，更新意向排他锁(UIX)</p></li></ol><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><ol><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ol><p>共享锁／排他锁／更新锁一般作用在较低级别上，例如数据行或数据页，意向锁一般作用在较高的级别上，例如数据表或数据。锁是有层级结构的，若在数据行上持有排他锁的时候，则会在所在的数据页上持有意向排他锁. 在一个事务中，可能由于锁持有的时间太长或个数太多，出于节约资源的考虑，会造成锁升级；</p><p>我理解的就以最后一个SERIALIZABLE来说，开始时是设置的表级共享锁，分为表级别的而且是共享锁，表级别就是作用于整个表，不是行级别！而共享锁，则说明了其他事务也是共享锁的情况下可以共享这个表！虽然仅限于读，但这样也可能存在脏读等情况的存在，而如果换成表级排它锁，那么第一个事务在使用了这个锁之后，那其他事务连这个表的读的权限也没有，从根本上避免了各种可能的问题。</p><h5 id="各个索引引擎的情况"><a href="#各个索引引擎的情况" class="headerlink" title="各个索引引擎的情况"></a>各个索引引擎的情况</h5><ol><li><p>InnoDB（MySQL默认存储引擎 从版本5.5.5开始）<br>支持事务，行级锁，以及外键，拥有高并发处理能力。但是在创建索引和加载数据时，比MyISAM慢。默认的隔离级别是Repeatable Read（可重复读）</p></li><li><p>MyISAM<br>不支持事务和行级锁。所以速度很快，性能优秀。可以对整张表加锁，支持并发插入，支持全文索引。</p></li><li><p>MEMORY<br>支持Hash索引，内存表，Memory引擎将数据存储在内存中，表结构不是存储在内存中的，查询时不需要执行磁盘I/O操作，所以要比MyISAM和InnoDB快很多倍，<br>但是数据库断电或是重启后，表中的数据将会丢失，表结构不会丢失。</p></li></ol><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h4><p>在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，乐观锁和悲观锁，可以在一定程度上解决并发访问。</p><h4 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h4><p>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>其他知识点</p><p>悲观锁主要是共享锁或排他锁<br>共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><h4 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h4><p>是应用系统层面和数据的业务逻辑层次上的（实际上并没有加锁，只是一种锁思想），利用程序处理并发， 它假定当某一个用户去读取某一个数据的时候，其他的用户不会来访问修改这个数据，但是在最后进行事务的提交的时候会进行数据的检查，以判断在该用户的操作过程中，没有其他用户修改了这个数据。乐观锁的实现大部分都是基于版本控制实现的， 除此之外，还有CAS操作实现</p><p>其他知识点</p><p>实现乐观锁一般来说有以下2种方式：</p><p>使用版本号<br>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><p>使用时间戳<br>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p><h4 id="悲观锁与乐观锁区别与联系？"><a href="#悲观锁与乐观锁区别与联系？" class="headerlink" title="悲观锁与乐观锁区别与联系？"></a>悲观锁与乐观锁区别与联系？</h4><h4 id="悲观锁与乐观锁的使用场景？"><a href="#悲观锁与乐观锁的使用场景？" class="headerlink" title="悲观锁与乐观锁的使用场景？"></a>悲观锁与乐观锁的使用场景？</h4><p>悲观锁</p><p>比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p><p>乐观锁</p><p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p><h3 id="innodbe-和-myisim掌握"><a href="#innodbe-和-myisim掌握" class="headerlink" title="innodbe 和 myisim掌握"></a>innodbe 和 myisim掌握</h3><h3 id="三个特性-双次写，插入缓存，自适应"><a href="#三个特性-双次写，插入缓存，自适应" class="headerlink" title="三个特性(双次写，插入缓存，自适应)"></a>三个特性(双次写，插入缓存，自适应)</h3><p>InnoDB存储引擎的关键特性包括插入缓冲、两次写（double write）、自适应哈希索引（adaptive hash index）。这些特性为InnoDB存储引擎带来了更好的性能和更高的可靠性。</p><p><a href="https://blog.csdn.net/ilovemilk/article/details/80024789">详细解释跳转</a></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程并发访问某一资源的机制。</p><h4 id="mvcc-乐观锁，悲观锁"><a href="#mvcc-乐观锁，悲观锁" class="headerlink" title="mvcc(乐观锁，悲观锁)"></a>mvcc(乐观锁，悲观锁)</h4><p>mvcc主要是为了提高并发读写性能，不用枷锁就能让多个事务并发读写．</p><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol><li>从对数据操作的类型（读/写）分<br>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li><li>从对数据操作的粒度分<br>表锁<br>行锁<h4 id="行锁-行锁，零件锁，间隙锁"><a href="#行锁-行锁，零件锁，间隙锁" class="headerlink" title="行锁(行锁，零件锁，间隙锁)"></a>行锁(行锁，零件锁，间隙锁)</h4></li></ol><p>nnodb存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。<br>Innodb与MyISAM的最大不同有两点：</p><ol><li>一是支持事务（TRANSACTION）</li><li>而是采用了行级锁</li></ol><p>由于行锁支持事务，复习老知识</p><p>事务（Transaction）及其ACID属性不可分</p><h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><ol><li><p>更新丢失（Lost Update）:<br> 当两个或多个事物选择同一行，然后基于最初选定的值更新该行时，由于每个事物都不知道其事物的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事物所做的更新．<br> 如果一个程序员完成并提交事物之前，另一个程序员不能访问同一文件，则可避免此问题.</p></li><li><p>脏读<br>一个事物正对一条记录做修改，在这个事物完成并提交前，这条记录的数据就处于不一致状态，这时，另一个事物也来读取同一条记录，如果不加控制，第二个事务读取了这些”脏”数据，并据此作进一步处理，就会产生未提交的数据依赖关系．</p></li><li><p>不可重复读<br>一个事物在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变，或某些记录已经被删除了！这种现象就叫做”不可重复读”．<br>　简而言之:事物ａ读取到了事物b已经提交的修改数据，不符合隔离性．</p></li><li><p>幻读<br>一个事物按相同的查询条件重新读取以前检索过的数据，却发现其他书屋插入了满足其查询条件的新数据，这种成为”幻读”．</p></li></ol><p>简而言之:事物ａ读取到了事物ｂ提交的新增数据，不符合隔离性．</p><p>注意：<br>脏读和幻读有些类似</p><ol><li>脏读是事物b里修改了数据.</li><li>幻读是事物b里边新增了数据.</li></ol><h5 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h5><p>脏读，不可重复读和幻读，其实都是数据库一致性问题，必须由数据库提供一定的事物隔离机制来解决．</p><p>四种解决方案</p><p>读数据一致性及允许的并发副作用隔离级别　　　　　　读数据一致性　　　　　　　　脏读　　不可重复读　　幻读　<br>未提交读　　　　　　　　　　　　最低级别，只能保证不读取物理上损坏的数据　　　　Ｙ　　　Ｙ　　　　　　Ｙ<br>已提交读　　　　　　　　　　　　　　　　　　　　语句级　　　　　　　　　　　　　Ｎ　　　Ｙ　　　　　　Ｙ<br>可重复读　　　　　　　　　　　　　　　　　　　　事物级　　　　　　　　　　　　　Ｎ　　　Ｎ　　　　　　Ｙ<br>可序列化　　　　　　　　　　　　　　　　　　最高级别，事物级　　　　　　　　　　Ｎ　　　Ｎ　　　　　　Ｎ</p><p>所以说数据库的事物隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是时事物在一定程度上”串行化进行”，这显然与”并发是矛盾的”，同时，不同的应用对对一致性和事物隔离程度的要求也是不同的，比如许多应用对”不可重复读”和幻读”并不敏感”，可能更关心数据并发访问的能力．<br>常看当前数据库的事物隔离级别: show variables like ‘tx_isolation’;</p><h5 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h5><p>如果在更新数据的时候出现了强制类型转换导致索引失效，使得行锁变表锁，即在操作不同行的时候，会出现阻塞的现象。</p><h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p>什么是间隙锁：<br>当我们用范围条件而不是相等条件索引数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。<br>危害：<br>因为Query执行过程中通过范围查找的话，会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p><p>结论</p><ol><li>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。</li><li>但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能更差。</li></ol><h5 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h5><p>如何分析行锁定</p><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><p>show status like ‘innodb_row_lock%’;<br>对各个状态量的说明如下：</p><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量；<br>innodb_row_lock_time：从系统启动到现在锁定总时间长度；<br>innodb_row_lock_time_avg：每次等待所花平均时间；<br>innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间；<br>innodb_row_lock_waits：系统启动后到现在总共等待的次数。<br>对于这5个变量，比较重要的是</p><p>innodb_row_lock_time_avg（等待平均时长）<br>innodb_row_lock_waits（等待总次数）<br>innodb_row_lock_time（等待总时长）<br>这三项<br>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><p>优化建议</p><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。<br>合理设计索引，尽量缩小锁的范围。<br>尽可能减少索引条件，避免间隙锁。<br>尽量控制事务大小，减少锁定资源量和时间长度。<br>尽可能低级别事务隔离</p><h4 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h4><ol><li>开销和加锁时间介于表锁和行锁之间。</li><li>会出现死锁。</li><li>锁定粒度介于表锁和行锁之间。</li><li>并发度一般</li></ol><h4 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h4><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><ol><li>手动增加表锁:</li></ol><p>lock table 表名字 read(write), 表名字2 read(write), 其他;<br>2. 查看表上加过的锁<br>show open tables;<br>3. 释放表锁</p><p>unlock tables;<br>4. 加读锁（我们为mylock表加read锁（读阻塞写例子））</p><ol start="5"><li>加写锁（我们为mylock表加write锁（MyISAM存储引擎的写阻塞读例子））</li></ol><p>案例结论</p><p>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是帮助MySQl高效获取数据的排好序的数据结构.</p><h4 id="数据结构（B-树，B树，Hash索引，全文本索引）"><a href="#数据结构（B-树，B树，Hash索引，全文本索引）" class="headerlink" title="数据结构（B+树，B树，Hash索引，全文本索引）"></a>数据结构（B+树，B树，Hash索引，全文本索引）</h4><p>二叉树索引的弊端：如果是序列有序(索引key 值)，就变成线性查找了．比如1,2,3,4,5,6,要查找6则需要搜索六次.</p><p>红黑树索引的弊端: 数据量过大索引次数过多(过多的磁盘io不能被接受)，虽然是一种平衡状态，比二叉树更优越，但是不能够被广泛使用.</p><p>由于树的高度限制了查询的效率</p><p>进而想到的解决办法：纵向不能伸长，就横向扩张．</p><p>进而B-tree就产生了：</p><p>B-tree很难进行范围查找，没有小箭头，而且值的分布不是都在叶子节点，需要每次查找等操作．<br>还有一个就是</p><p>然而数据库的底层用的是我们曾经写过的B+Tree<br>细节讲解：</p><p>为什么每个节点的成员个数有限?<br>因为在查询的到节点，进行磁盘IO,会把该节点的数据写入ARM中,在磁盘中的查找速度非常快，跟磁盘IO时间比较可以忽略不计，但是ARM存储空间毕竟是有限的，MySql中设置的16kb<br>数据库中存储值为bigint为8b后边的指针为6b, 16kb/(8+6)b 大概是1170个索引.<br>叶子节点data是地址，假设比加大给1kb的存储空间.一个叶子节点大概16个元素.<br>那么高度为三的树能容纳 1170 * 1170 * 16 大概2100多万．<br>而且在数据库中根节点是长驻内存的，时间更快了.时间可忽略不计.</p><p>千万级数据表如何用索引快速查找？（上边即为答案）<br>b+Tree的树高可以的得到很好的控制，即使数据量很大，也能把树高维持在一个很小的数值．</p><p>b+tree:<br>    下边的小箭头就是为了支持范围查找的，是一个双向指针．解决了范围查找问题，</p><p>非叶子节点都不存data,只存储索引(冗余).可以放更多的索引，实现了等高的b-tree和<br>b+tree ,b+tree存储量非常可观．<br>就是都是三层b+tree 能存2100多万数据，b+tree就能存16<em>16</em>16 =4096个而已．</p><h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引　"></a>hash索引　</h4><p>select * from t where t.col = 2;</p><ol><li>先通过hash(2) =定位哈西散列值就是对应值的存储地址　MD5或crc16/32就是hash散列算法.</li></ol><p>hash 是不是就是说比B+tree的查找速率高呢？</p><p>单个值的查找是很快的，但是范围查找就崩了，必须遍历查找．<br>2.<br>3. </p><h4 id="逻辑索引-主键，唯一，前缀，覆盖，联合，普通"><a href="#逻辑索引-主键，唯一，前缀，覆盖，联合，普通" class="headerlink" title="逻辑索引(主键，唯一，前缀，覆盖，联合，普通)"></a>逻辑索引(主键，唯一，前缀，覆盖，联合，普通)</h4><h4 id="存储结构-聚集索引-innodbe-排序索引-myisim"><a href="#存储结构-聚集索引-innodbe-排序索引-myisim" class="headerlink" title="存储结构(聚集索引(innodbe),排序索引(myisim))"></a>存储结构(聚集索引(innodbe),排序索引(myisim))</h4><h5 id="MyISAM存储索引实现"><a href="#MyISAM存储索引实现" class="headerlink" title="MyISAM存储索引实现"></a>MyISAM存储索引实现</h5><p>注意: 存储引擎是形容数据库表的不是形容数据库的．</p><p>数据中的表的数据存储位置：根目录的DATA目录.</p><ol><li>.frm文件:表的定义和结构信息.</li><li>.MYD文件:MyISAM-date 存储的数据</li><li>.MYI文件:MyISAM-index 表的索引信息.<br>举例子：<br>select * from T  where coll = 30 ;<br>先判断数据coll有无索引，如果有索引，就去myi文件中检索，快速定位节点，由于MySql中b+Tree的叶子节点的data域存的是数据表中索引所在行的磁盘地址,就是查出地址后根据该地址在MYD文件中查找所对应的数据．</li></ol><h5 id="InnoDB索引实现-聚集"><a href="#InnoDB索引实现-聚集" class="headerlink" title="InnoDB索引实现(聚集)"></a>InnoDB索引实现(聚集)</h5><p>表结构:</p><ol><li><p>frm表: 表的定义和结构信息</p></li><li><p>ibd表: 按照B-tree组织的一个索引结构文件.</p></li><li><p>InnoDB表的主键索引　<br>是聚集的</p></li><li><p>InnoDB表的非主键索引<br>是非聚集的<br>别的位置是一样的，主要是叶子节点，存储的是主键，首先查找到主键信息，然后再从主键索引树里边找到该索引对应的信息．</p></li></ol><p>为什么InnoDB表必须要有主键，并且推荐使用整型的自增主键呢?</p><p>如果自己没有在InnoDB表中规定主键信息，系统会在数据表中找到一列没有重复信息的列，把他确定为主键，并根据该信息维护一个b+tree的主键索引信息表.<br>如果都是有重复的列，系统就会生成一个隐藏的主键列，作为主键维护信息表.<br>所以说在使用的时候定义了主键，系统会减少很多麻烦效率更高.</p><p>整型:</p><p>反义的是UUID不推荐使用既不是整形也不是自增的.</p><p>整型在比较过程中比较快（类比字符串比较）</p><p>bigint 占8个字节如果是字符串字节较多<br>数据库存储环境是高速的SSD(硬盘),价格昂贵.</p><p>主键自增问题:</p><pre><code>涉及到hash索引b+Tree 叶子节点的小箭头</code></pre><p>如果b+Tree插入的顺序不是自增的，就会存在[1,2,4,5,] 这个节点满了，在插入3的情况是就会出现，节点分裂还需要做平衡，中间节点上移的问题，树会说＂我TM裂了＂！<br>正常自增的话就不会频繁出现这样的情况，减少了平衡的操作.<br>先维护索引，再运行insert语句比较快，</p><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引　"></a>聚集索引　</h5><p>叶子节点包含了完整的数据记录<br>说白了索引和数据放在一起的.</p><h5 id="类推非聚集索引-稀疏索引"><a href="#类推非聚集索引-稀疏索引" class="headerlink" title="类推非聚集索引(稀疏索引)"></a>类推非聚集索引(稀疏索引)</h5><p>同样的MyISM 索引文件和数据文件是分离的就是非聚集的.一部分放在了MYZ一部分放在了MYD文件中.</p><p>比较:<br>单纯从聚集和非聚集索引分析，聚集索引更快.直接找到值．</p><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引　"></a>联合索引　</h5><p>就比如(a,b,c)三个联合起来构成一个索引，底层结构什么样子.</p><p>底层采用的b+tree </p><p>如何排序呢：索引最左前缀原理</p><h6 id="索引最左前缀原理"><a href="#索引最左前缀原理" class="headerlink" title="索引最左前缀原理"></a>索引最左前缀原理</h6><p>先比较第一个字段，第一个能比较大小就排序(字典序比较)，若比较不了，比较第二个．<br>注意：不可跨字段，必须按照顺序应用，才能用到联合索引.<br>原因：b+tree 的排序规则，先按照第一个字段，在比较第二个字段．．．．．如果去掉第一个字段，剩下的第二个字段绝大多数可能是无序的，如果不是一个排好序的序列，就不能作为一个索引来用.还得所有值进行一次比较操作．</p><h4 id="索引失效，索引优化，索引下推，索引回表．"><a href="#索引失效，索引优化，索引下推，索引回表．" class="headerlink" title="索引失效，索引优化，索引下推，索引回表．"></a>索引失效，索引优化，索引下推，索引回表．</h4><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h3 id="分区分库分表，主从复制．"><a href="#分区分库分表，主从复制．" class="headerlink" title="分区分库分表，主从复制．"></a>分区分库分表，主从复制．</h3><h4 id="分区分库分表"><a href="#分区分库分表" class="headerlink" title="分区分库分表"></a>分区分库分表</h4><h5 id="分表："><a href="#分表：" class="headerlink" title="分表："></a>分表：</h5><p>分表就是为了减少单个数据库表的压力，当单表数据量达到百万级别时候，无论是插入和查询对将面临瓶颈，访问变慢，引入分表也是为了减轻单表的压力，常见的分表策略</p><p>对于业务表或者用户表，可以根据业务ID或者用户ID 对表数取模、范围a~b等，以取模为例%n,将表分为n个，如tb_uesr0,tb_user1,tb_user2,tb_user3….</p><p>对于用作分析或者统计时候，例如日志表，可以根据日期分表，如tb_log20180101,tb_log20180102….</p><h5 id="分区："><a href="#分区：" class="headerlink" title="分区："></a>分区：</h5><p>分区和分表大致相同，只是将单个数据表的数据分段存放在磁盘的不同区域，对外读写还是现实一张表，由DB去西东组织数据。</p><h5 id="分库："><a href="#分库：" class="headerlink" title="分库："></a>分库：</h5><p>分表减轻的是单个数据表的数据量压力，而分库则是应对并发请求下面数据库服务器的访问压力。分库也可以选择对关键字取模的方式选择访问的数据库</p><p>存放DB= 关键字段%DB数</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>基本原理 slave会从master读取binlog来进行数据同步</p><p>MySql复制过程分为三步:<br>    1. master将改变记录到二进制日志(binary log).这些记录过程叫二进制日志事件，binary log events;<br>    2. slave 将master的binary log events拷贝到他的中继日志(relay log).<br>    3. slave重做中继日志中的时间，将改变应用到自己的数据库中，MySql复制是异步的且串行化的．</p><p>复制的基本原则:<br>    1. 每个slave只有一个master<br>    2. 每个slave只能有一个唯一的服务器ID<br>    3. 每个master可以有多个slave</p><h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制?"></a>什么是主从复制?</h4><p><a href="https://blog.csdn.net/weixin_43879074/article/details/88525006#commentBox">主从复制牛逼博主跳转和图片来源</a><br>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库，主数据库一般是准实时的业务数据库。您看，像在mysql数据库中，支持单项、异步赋值。在赋值过程中，一个服务器充当主服务器，而另外一台服务器充当从服务器。此时主服务器会将更新信息写入到一个特定的二进制文件中。并会维护文件的一个索引用来跟踪日志循环。这个日志可以记录并发送到从服务器的更新中去。当一台从服务器连接到主服务器时，从服务器会通知主服务器从服务器的日志文件中读取最后一次成功更新的位置。然后从服务器会接收从哪个时刻起发生的任何更新，然后锁住并等到主服务器通知新的更新</p><h5 id="主从复制的作用（好处，或者说为什么要做主从）重点？"><a href="#主从复制的作用（好处，或者说为什么要做主从）重点？" class="headerlink" title="主从复制的作用（好处，或者说为什么要做主从）重点？"></a>主从复制的作用（好处，或者说为什么要做主从）重点？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p> 1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）<br>  2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）<br>   3–当主服务器出现问题时，可以切换到从服务器。（提升性能）</p><h5 id="主从复制的原理？"><a href="#主从复制的原理？" class="headerlink" title="主从复制的原理？"></a>主从复制的原理？</h5><p>一步能让你清晰理解操作的目的</p><p>   1.数据库有个bin-log二进制文件，记录了所有sql语句。</p><p>   2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。</p><p>   3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。</p><p>   4.下面的主从配置就是围绕这个原理配置</p><p>   5.具体需要三个线程来操作：</p><p>   1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：<br>   2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p><p>   3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p><pre><code>可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。</code></pre><h5 id="主从复制的好处？"><a href="#主从复制的好处？" class="headerlink" title="主从复制的好处？"></a>主从复制的好处？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p> 好处一:实现服务器负载均衡</p><p> 通过服务器复制功能，可以在主服务器和从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好地客户相应时间。通常情况下，数据库管理员会有两种思路。</p><p> 一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询。将数据更新与查询分别放在不同的服务器 上进行，即可以提高数据的安全性，同时也缩短应用程序的响应时间、提高系统的性能。</p><p> 二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作 业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。当然，像修改数据、插入数 据、删除数据等语句仍然会发送到主服务器中，以便主服务器和从服务器数据的同步。</p><p>  好处二：通过复制实现数据的异地备份</p><p>  可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。</p><p>  而如果使用复制来实现对数据的备份，就可以在从服务器上对数据进行备份。此时不仅不会干扰主服务气的正常运行，而且在备份过程中主服务器可以继 续处理相关的更新作业。同时在数据复制的同时，也实现了对数据的异地备份。除非主服务器和从服务器的两块硬盘同时损坏了，否则的话数据库管理员就可以在最 短时间内恢复数据，减少企业的由此带来的损失。</p><p>   好处三：提高数据库系统的可用性</p><p>   数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。</p><p>   一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道理。</p><p>   二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患。</p><h5 id="从数据库的读的延迟问题了解吗？如何解决？"><a href="#从数据库的读的延迟问题了解吗？如何解决？" class="headerlink" title="从数据库的读的延迟问题了解吗？如何解决？"></a>从数据库的读的延迟问题了解吗？如何解决？</h5><p>主库宕机后，数据可能丢失<br>从库只有一个sql Thread，主库写压力大，复制很可能延时<br>解决方法：</p><ol><li>半同步复制—解决数据丢失的问题</li></ol><p>半同步复制:　<br>就是在master 端放了wait_ack, 在slave端放了ack发送功能，在文件relay_log中写完数据后，发送一个确认ack,等收到ack在进行客户端的反馈．</p><ol start="2"><li><p>并行复制—-解决从库复制延迟的问题<br><a href="https://www.cnblogs.com/caicz/p/11009528.html">参考博客</a></p></li><li><p>那么如何并行化，并行IO线程，还是并行SQL线程？<br>其实两方面都可以并行，但是并行SQL线程的收益更大，因为SQL线程做的事情更多(解析，执行)。并行IO线程，可以将从Master拉取和写Relay lomZ分为两个线程；并行SQL线程则可以根据需要做到库级并行，表级并行，事务级并行。库级并行在mysql官方版本5.6已经实现。并行复制框架实际包含了一个协调线程和若干个工作线程，协调线程负责分发和解决冲突，工作线程只负责执行。</p></li><li><p>并行复制如何处理冲突？</p></li></ol><p>并发的世界是美好的，但不能乱并发，否则数据就乱了。Master上面通过锁机制来保证并发的事务有序进行，那么并行复制呢？Slave必需保证回放的顺序与Master上事务执行顺序一致，因此只要做到顺序读取binlog，将不冲突的事务并发执行即可。对于库级并发而言，协调线程要保证执行同一个库的事务放在一个工作线程串行执行；对于表级并发而言，协调线程要保证同一个表的事务串行执行；对于事务级而言，则是保证操作同一行的事务串行执行。</p><ol start="3"><li>是否粒度越细，性能越好？</li></ol><p>这个并不是一定的。相对于串行复制而言，并行复制多了一个协调线程。协调线程一个重要作用是解决冲突，粒度越细的并发，可能会有更多的冲突，最终可能也是串行执行的，但消耗了大量的冲突检测代价。</p><p>并行复制:<br>    在relay_log库信息读取操作转换为数据的过程中，采用多线程，执行效率增加．</p><h5 id="主从复制和主主复制区别？"><a href="#主从复制和主主复制区别？" class="headerlink" title="主从复制和主主复制区别？"></a>主从复制和主主复制区别？</h5><p>最大区别是<br>主从是对主操作数据，从会实时同步数据。反之对从操作，主不会同步数据，还有可能造成数据紊乱，导致主从失效。 主主则是无论对那一台操作，另一个都会同步数据。一般用作高容灾方案 </p><p><a href="https://blog.csdn.net/qq_22222499/article/details/79060495">以下部分参考网站</a></p><h3 id="2-数据库隔离级别"><a href="#2-数据库隔离级别" class="headerlink" title="2.数据库隔离级别"></a>2.数据库隔离级别</h3><p>多个事务读可能会道理以下问题<br>脏读：事务B读取事务A还没有提交的数据<br>不可重复读：，一行被检索两次，并且该行中的值在不同的读取之间不同时<br>幻读:当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时<br>这两个区别在于，不可重复读重点在一行，幻读的重点 ，返回 的集合不一样</p><h3 id="3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"><a href="#3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景" class="headerlink" title="3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"></a>3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</h3><p>引擎　　　　　　　　　　特性<br>MYISAM<br>　　　　　　　　　　　　不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描<br>INNODB<br>　　　　　　　　　　　　支持外键，行锁，查表总行数时，全表扫描</p><h3 id="4-索引有B-索引和hash索引"><a href="#4-索引有B-索引和hash索引" class="headerlink" title="4.索引有B+索引和hash索引"></a>4.索引有B+索引和hash索引</h3><p>索引　　　　　　　　　　区别<br>Hash<br>　　　　　　　　　　　　hash索引，等值查询效率高，不能排序,不能进行范围查询<br>B+<br>　　　　　　　　　　　　数据有序,范围查询</p><h3 id="5-聚集索引和非聚集索引"><a href="#5-聚集索引和非聚集索引" class="headerlink" title="5.聚集索引和非聚集索引"></a>5.聚集索引和非聚集索引</h3><p>索引　　　　　　　　　　区别<br>聚集索引<br>　　　　　　　　　　　　数据按索引顺序存储，中子结点存储真实的物理数据<br>非聚集索引<br>　　　　　　　　　　　　存储指向真正数据行的指针</p><h3 id="6-索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#6-索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="6.索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>6.索引的优缺点，什么时候使用索引，什么时候不能使用索引</h3><ol><li>索引最大的好处是提高查询速度，</li><li>缺点是更新数据时效率低，因为要同时更新索引</li><li>对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。</li></ol><h3 id="7-InnoDB索引和MyISAM索引的区别"><a href="#7-InnoDB索引和MyISAM索引的区别" class="headerlink" title="7.InnoDB索引和MyISAM索引的区别"></a>7.InnoDB索引和MyISAM索引的区别</h3><p>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主</p><h3 id="8-索引的底层实现（B-树，为何不采用红黑树，B树）重点"><a href="#8-索引的底层实现（B-树，为何不采用红黑树，B树）重点" class="headerlink" title="8.索引的底层实现（B+树，为何不采用红黑树，B树）重点"></a>8.索引的底层实现（B+树，为何不采用红黑树，B树）重点</h3><p>树                                 区别<br>红黑树<br>                                   增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间</p><p>B树也就是B-树<br>                                   B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。</p><p>B+树<br>                                   B+树相比较于另外两种树,显得更矮更宽，查询层次更浅</p><h3 id="9-B-树的实现"><a href="#9-B-树的实现" class="headerlink" title="9.B+树的实现"></a>9.B+树的实现</h3><p>一个m阶的B+树具有如下几个特征：</p><ol><li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li></ol><h3 id="10-为什么使用B-Tree"><a href="#10-为什么使用B-Tree" class="headerlink" title="10.为什么使用B+Tree"></a>10.为什么使用B+Tree</h3><ol><li>索引查找过程中就要产生磁盘I/O消耗,主要看IO次数，和磁盘存取原理有关。</li><li>根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，</li><li>将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入<br>局部性原理与磁盘预读</li></ol><h3 id="11-Sql的优化"><a href="#11-Sql的优化" class="headerlink" title="11.Sql的优化"></a>11.Sql的优化</h3><p>1.sql尽量使用索引,而且查询要走索引</p><p>2.对sql语句优化</p><ol><li>子查询变成left join</li><li>limit 分布优化，先利用ID定位，再分页</li><li>or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）</li><li>不必要的排序</li><li>where代替having,having 检索完所有记录，才进行过滤</li><li>避免嵌套查询</li><li>对多个字段进行等值查询时，联合索引</li></ol><h3 id="12-索引最左前缀问题"><a href="#12-索引最左前缀问题" class="headerlink" title="12.索引最左前缀问题"></a>12.索引最左前缀问题</h3><p>如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了</p><h3 id="13-索引分类，索引失效条件"><a href="#13-索引分类，索引失效条件" class="headerlink" title="13.索引分类，索引失效条件"></a>13.索引分类，索引失效条件</h3><p>索引类型　　　　　　　　　　　　　　　　　　概念<br>普通索引　　　　　　　　　　　　　最基本的索引，没有任何限制<br>唯一索引　　　　mZZ<br>失效条件:</p><p>条件是or,如果还想让or条件生效，给or每个字段加个索引<br>like查询，以%开发<br>内部函数<br>对索引列进行计算<br>is null不会用，is not null 会用</p><h3 id="14-数据库的主从复制"><a href="#14-数据库的主从复制" class="headerlink" title="14.数据库的主从复制"></a>14.数据库的主从复制</h3><p>复制方式：操作.</p><ol><li>异步复制：<br>默认异步复制，容易造成主库数据和从库不一致,一个数据库为Master,一个数据库为slave,通过Binlog日志,slave两个线程，一个线程去读master binlog日志，写到自己的中继日志一个线程解析日志，执行sql,master启动一个线程,给slave传递binlog日志</li><li>半同步复制: 只有把master发送的binlog日志写到slave的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低</li><li>并行操作:slave 多个线程去请求binlog日志</li></ol><h3 id="15-long-query怎么解决"><a href="#15-long-query怎么解决" class="headerlink" title="15.long_query怎么解决"></a>15.long_query怎么解决</h3><p>设置参数，开启慢日志功能，得到耗时超过一定时间的sql</p><h3 id="16-varchar和char的使用场景"><a href="#16-varchar和char的使用场景" class="headerlink" title="16.varchar和char的使用场景"></a>16.varchar和char的使用场景</h3><p>类型           使用场景<br>varchar        字符长度经常变的<br>char           用字符长度固定的</p><h3 id="17-数据库连接池的作用"><a href="#17-数据库连接池的作用" class="headerlink" title="17.数据库连接池的作用"></a>17.数据库连接池的作用</h3><p>维护一定数量的连接，减少创建连接的时间<br>更快的响应时间<br>统一的管理</p><h3 id="19-分库分表，主从复制，读写分离"><a href="#19-分库分表，主从复制，读写分离" class="headerlink" title="19.分库分表，主从复制，读写分离"></a>19.分库分表，主从复制，读写分离</h3><p>读写分离，读从库，写主库<br>spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。</p><h3 id="20-数据库三范式"><a href="#20-数据库三范式" class="headerlink" title="20.数据库三范式"></a>20.数据库三范式</h3><p>级别　　　　　　　　　　　　概念<br>1NF　　　　　　　　　　　　属性不可分<br>2NF　　　　　　　　　　　　非主键属性，完全依赖于主键属性<br>3NF　　　　　　　　　　　　非主键属性无传递依赖</p><h3 id="21-关系型数据库和非关系型数据库区别"><a href="#21-关系型数据库和非关系型数据库区别" class="headerlink" title="21.关系型数据库和非关系型数据库区别"></a>21.关系型数据库和非关系型数据库区别</h3><p>关系型数据库</p><p>优点：</p><p>1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</p><p>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。<br>5.支持事务</p><p>缺点<br>1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、不支持高并发读写需求；<br>4、不支持海量数据的高效率读写</p><p>非关系型数据库</p><p>1、使用键值对存储数据；<br>2、分布式；<br>优点<br>无需经过sql层的解析，读写性能很高<br>基于键值对，数据没有耦合性，容易扩展<br>存储数据的格式：nosql的存储格式是key,value形式<br>缺点<br>不提供sql支持</p><h3 id="22-数据库中join的left-join-inner-join-cross-join"><a href="#22-数据库中join的left-join-inner-join-cross-join" class="headerlink" title="22.数据库中join的left join , inner join, cross join"></a>22.数据库中join的left join , inner join, cross join</h3><ol><li><p>以A，B两张表为例<br>A left join B<br>选出A的所有记录，B表中没有的以null 代替<br>right join 同理</p></li><li><p>inner join<br>A,B有交集的记录</p></li><li><p>cross join (笛卡尔积)<br>A中的每一条记录和B中的每一条记录生成一条记录<br>例如A中有4条，B中有4条，cross join 就有16条记录</p></li></ol><h3 id="23-有哪些锁-select时怎么加排它锁"><a href="#23-有哪些锁-select时怎么加排它锁" class="headerlink" title="23.有哪些锁,select时怎么加排它锁"></a>23.有哪些锁,select时怎么加排它锁</h3><p>锁　　　　　　　　　　　　　　　　　　　概念<br>乐观锁　　　　　　　　　　　　　　　　　自己实现，通过版本号<br>悲观锁　　　　　　　　　　　　　　　　　共享锁，多个事务，只能读不能写，加 lock in share mode<br>排它锁　　　　　　　　　　　　　　　　　一个事务，只能写，for update<br>行锁　　　　　　　　　　　　　　　　　　作用于数据行<br>表锁　　　　　　　　　　　　　　　　　　作于用表</p><h3 id="24-死锁怎么解决"><a href="#24-死锁怎么解决" class="headerlink" title="24.死锁怎么解决"></a>24.死锁怎么解决</h3><p>找到进程号，kill 进程</p><h3 id="25-最左匹配原则"><a href="#25-最左匹配原则" class="headerlink" title="25.最左匹配原则"></a>25.最左匹配原则</h3><p>最左匹配原则是针对索引的<br>举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的，<br>这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了，<br>查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗，<br>按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="优化" scheme="http://example.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>balance-tree</title>
    <link href="http://example.com/posts/26821/"/>
    <id>http://example.com/posts/26821/</id>
    <published>2020-10-24T06:06:20.000Z</published>
    <updated>2020-10-27T02:06:58.973Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在绝望的时候才会尽最大的努力!</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B_tree"></a>B_tree</h3><p>全名为balance_tree(平衡多路查找树)，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而B_tree有多条路，即父节点有多个子节点。</p><h4 id="B-树用途"><a href="#B-树用途" class="headerlink" title="B-树用途"></a>B-树用途</h4><p>使用B_tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。</p><h4 id="B-tree定义及结构"><a href="#B-tree定义及结构" class="headerlink" title="B_tree定义及结构"></a>B_tree定义及结构</h4><h4 id="B-tree定义"><a href="#B-tree定义" class="headerlink" title="B_tree定义"></a>B_tree定义</h4><ol><li>树中每个节点至多有m棵子树(m表示树的阶数)</li><li>根前节点不是叶子节点,则至少有两棵子树(根节点必须俩儿子).</li><li>除根节点之外的所有非叶子节点至少有p个子节点([m/2] &lt;= p &lt;= m,[m/2]向上取整).或者[(m+1)/2].</li><li>所有的非叶子结点中包含以下数据：（n，A0，K1，A1，K2，…，Kn，An）<br>其中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ki（i&#x3D;1,2,…,n）为关键码，且Ki&lt;Ki+1（注：ki是真实数据，存放在线性表当中，且从左至右升序排列）</span><br><span class="line"></span><br><span class="line">Ai 为指向儿子的指针(i&#x3D;0,1,…,n)，且指针Ai-1 所指子树中所有结点的关键码均小于Ki (i&#x3D;1,2,…,n)，An 所指子树中所有结点的            关键码均大于Kn。（注：每个ki数据两旁各安放了一个指针，即Ai-1和Ai，左边的子树数据统统小于ki，右边子树的数据统             统大于ki）（注：总体来看指针数量比数据数量多1）</span><br><span class="line"></span><br><span class="line"> n 为关键码的个数（[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m - 1）。</span><br></pre></td></tr></table></figure></li><li> 所有的叶子结点都出现在同一层次上，即所有叶节点具有相同的深度，等于树高度。并且不带信息（可以看作是外部结点或查找失<br>败的结点，实际上这些结点不存在，指向这些结点的指针为空）。</li></ol><h4 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h4><ol><li>B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</li></ol><h4 id="B-tree和二叉树和红黑树的不同点"><a href="#B-tree和二叉树和红黑树的不同点" class="headerlink" title="B_tree和二叉树和红黑树的不同点"></a>B_tree和二叉树和红黑树的不同点</h4><p>与二叉树:</p><ol><li><p>二叉树节点中保存的数据只有一个，而B_树得节点中保存的是线性表，真实数据数据不止一个有很多。由于表中的指针和子节点一一对应，而子节点个数又有限定([m/2] &lt;= p &lt;= m,[m/2]向上取整)，又因为真实数据数量又比指针少一个所以真实数据也就有了限定（\left \lceil m/2 \right \rceil-1\leqslant n\leqslant m-1）。</p></li><li><p>二叉树至多有两个儿子节点，而B-树至多有m个节点（m为树的阶）</p></li></ol><p>与红黑树:<br>    不同在于：B树的节点可以有很多子女，从几个到几万个不等，<br>    相同：一颗含有n个节点的B树高度和红黑树是一样的，都是O（lgn）。</p><h4 id="B-tree和B-tree结构操作"><a href="#B-tree和B-tree结构操作" class="headerlink" title="B_tree和B+tree结构操作"></a>B_tree和B+tree结构操作</h4><p>小编传不了图片,但是我找到了一个特别全很牛逼的网站，作为歉意！<br><a href="https://www.bilibili.com/video/BV1vQ4y1N79m?p=1">简述构造树遵循的规则</a>：<br>以五叉BTree为例，key的数量公式推导<br>ceil(m/2)-1 &lt;= n &lt;= m-1,所以2 &lt;= n &lt;= 4,当n &gt; 4时，中间节点上升进入父节点，两边节点裂开．</p><ol><li><p>插入字母C,N,G,A,H,K.Q.M.F,W,L,T,Z,D,P,R,X,Y,S数据为例．<br>注意每组元素下边都有一组数组.length()+1个下标.<br>插入前四个字母: [A,C,G,H]</p></li><li><p>插入H,n&gt;4,中间元素G字母向上分裂到新的节点(晋升为父节点)<br>　　[G]<br>[A|C]　[H|N]</p></li><li><p>插入E,K,Q不需要分裂　<br>　　　[G]<br>[A|C|E]　[H|K|N|Q]</p></li><li><p>插入M,中间元素M字母向上分裂到父节点G　<br>　　　　[G|M]<br>[A|C|E]　[H|K]　 [NQ]</p></li><li><p>插入F,W,L,T不需要分裂<br>　　　　　[G|M]<br>[A|C|E|F]　[H|K|L]　[N|Q|T|W]</p></li><li><p>插入Z,中间元素T先上分裂到父节点中</p></li></ol><p>　　　　　　　[G|M|T]<br>[A|C|E|F]　[H|K|L]　[N|Q]　[W|Z]</p><p>以此类推最后建成.</p><p><a href="https://www.cnblogs.com/guohai-stronger/p/9225057.html">结构和各种操作</a></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h3 id="M阶B-数特点"><a href="#M阶B-数特点" class="headerlink" title="M阶B+数特点"></a>M阶B+数特点</h3><p>在mysql中增加了叶子节点前后指针(进行了B+tree的优化).提高区间访问的效率)</p><ol><li>有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成一个链表）。</li><li>所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</li><li>同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</li></ol><h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><ol><li>所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li><li>b+树的中间节点不保存数据，能容纳更多节点元素。</li></ol><h4 id="B-树的时间复杂度"><a href="#B-树的时间复杂度" class="headerlink" title="B+树的时间复杂度"></a>B+树的时间复杂度</h4><h3 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h3><ol><li><p>B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。</p></li><li><p>B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</p></li><li><p>B树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m-1%5D">m/2(向上取整)-1,m-1</a>，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m%5D">m/2(向上取整),m</a>，具有n个关键字的节点包含（n）棵子树。</p></li><li><p>B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。</p></li></ol><h3 id="B树和B-树的共同优点"><a href="#B树和B-树的共同优点" class="headerlink" title="B树和B+树的共同优点"></a>B树和B+树的共同优点</h3><p>考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Data_Sturctures" scheme="http://example.com/tags/Data-Sturctures/"/>
    
  </entry>
  
  <entry>
    <title>bug</title>
    <link href="http://example.com/posts/42182/"/>
    <id>http://example.com/posts/42182/</id>
    <published>2020-10-14T03:38:06.000Z</published>
    <updated>2020-10-14T04:15:50.162Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有的人走错一步就回来,有的人一直错,——–子弹上膛（小庄）<br>由于python2不能导入request包,所以升级为python3.</p><p>Ubuntu下将python从2.7.12升级到3.5.2</p><p>１．我们在Ubuntu中使用Ctrl+Alt+T  快捷键 调出 终端窗口。然后在终端中输入Python,查看当前版本.<br>２．在上面的步骤中，我们看到我们的Python版本是2.7.12 这是Ubuntu中默认安装的Python版本 。接下来我们执行 sudo apt-get install python3 命令 这时候 终端会提示我们需要管理员密码 输入即可。<br>３．稍等片刻 我们的Python3 已经安装完成了 ，但是如果这时候我们输入Python并且回车 我们会发现 我们的Python版本仍然是2.7.12 这个时候我们需要切换Python的版本。</p><p>我们在终端中输入 alias python=python3  回车  </p><p>然后我们再输入Python 这个时候的版本就已经变成Python3了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python环境问题" scheme="http://example.com/categories/python%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider2</title>
    <link href="http://example.com/posts/40133/"/>
    <id>http://example.com/posts/40133/</id>
    <published>2020-10-13T13:57:29.000Z</published>
    <updated>2020-10-14T08:00:33.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>精神,唯一的财富,其它都是虚的。——袁朗．<br>爬虫实战应用<br><a href="https://blog.csdn.net/qq_21933615/article/details/81171951">Python中BeautifulSoup库的用法</a></p><p><a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/">官方文档</a><br>以上都是爬虫的预备知识，掌握了之后就可以写代码去爬取我们想要爬的网站了。</p><p>Python提供了许多网络请求的库，比如Requests、urllib等，这里只说一下requests库</p><p>Requests库.</p><p>安装：pip(3) install requests</p><p>基本使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 发送 GET 请求获取响应</span><br><span class="line">response &#x3D; requests.get(url)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response常用属性：</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line">response.text 返回响应内容，响应内容为 str 类型</span><br><span class="line">respones.content 返回响应内容,响应内容为 bytes 类型</span><br><span class="line">response.status_code 返回响应状态码</span><br><span class="line">response.request.headers 返回请求头</span><br><span class="line">response.headers 返回响应头</span><br><span class="line">response.cookies 返回响应的 RequestsCookieJar 对象</span><br><span class="line"># 获取字节数据</span><br><span class="line">content &#x3D; response.content</span><br><span class="line"># 转换成字符串类型</span><br><span class="line">html &#x3D; content.decode(&#39;utf-8&#39;)</span><br></pre></td></tr></table></figure><p>自定义请求头.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 发送自定义请求头</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送Get请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 GET 请求参数</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 GET 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,params&#x3D;params)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送POST请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义post请求参数</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.post(url,headers&#x3D;headers,data&#x3D;data)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>为什么使用代理：1、让服务器以为请求是从多个客户端发出的。2、防止暴露我们的真实地址<br>代理作为中间量简介链接客户端和服务器.</p><p>使用方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 代理服务器</span><br><span class="line">proxies &#x3D; &#123;</span><br><span class="line">    &quot;http&quot;:&quot;http:&#x2F;&#x2F;IP地址:端口号&quot;,</span><br><span class="line">    &quot;https&quot;:&quot;https:&#x2F;&#x2F;IP地址:端口号&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,proxies&#x3D;proxies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求中携带cookie</p><p>作用：有些网站需要登录，这时候cookie就是记录了你的用户信息</p><p>方式：</p><p>直接在自定义请求头中携带</p><p>通过请求参数携带cookie</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line">    # 方式一：直接在请求头中携带Cookie内容</span><br><span class="line">    &quot;Cookie&quot;: &quot;Cookie值&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 方式二：定义 cookies 值</span><br><span class="line">cookies &#x3D; &#123;</span><br><span class="line">    &quot;xx&quot;:&quot;yy&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,cookies&#x3D;cookies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据提取</p><p>作用：从爬虫获取的数据中提取出我们想要的数据</p><p>方式：<br>json模块提取<br>xpath提取<br>正则提取<br>beautifulsoup<br>１．json.<br>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式<br>json.loads json字符串 转 Python数据类型<br>json.dumps Python数据类型 转 json字符串<br>json.load json文件 转 Python数据类型<br>json.dump Python数据类型 转 json文件<br>ensure_ascii=False 实现让中文写入的时候保持为中文<br>indent=空格数 通过空格的数量进行缩紧<br>２．xpath.<br>XPath 全称： XML Path Language，是一门在 XML 文档中查找信息的语言。<br>XPath 可用来在 XML 文档中对元素和属性进行遍历。<br>安装：pip(3) install lxml</p><p>常用规则：<br>表达式———–描述——–<br>nodename——–选取此节点的所有子节点<br>/—————-从当前节点选取直接子节点<br>//—————从当前节点选取子孙节点<br>.—————-选取当前节点<br>..—————选取当前节点的父节点<br>@—————-选取属性</p><p>正则；</p><p>Python中通过正则表达对字符串进行匹配是，可以使用re模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入re模块</span><br><span class="line">import re</span><br><span class="line"># 使用match方法进行匹配操作</span><br><span class="line">result &#x3D; re.match(正则表达式,要匹配的字符串)</span><br><span class="line"># 如果上一步匹配到数据的话，可以使用group方法来提取数据</span><br><span class="line">result.group()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/116509288">常用语法：</a></p><p><em>————-匹配前一个字符0次或无限次，例abc</em>,能匹配字符abccccc,<br>+————-匹配前一个字符1次或无限次，例abc+,能匹配字符abccccc,<br>?————-匹配前一个字符0次或一次，例abc?,能匹配字符abc或ab,<br>{m}————-匹配前一个字符m次，例ab{2}c,能匹配字符abbc,<br>\d————-说明:数字[0-9]</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫实战应用" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider1</title>
    <link href="http://example.com/posts/40325/"/>
    <id>http://example.com/posts/40325/</id>
    <published>2020-10-13T12:20:14.000Z</published>
    <updated>2020-10-14T02:55:03.194Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好好活就是做有意义的事,有意义的事就是好好活。 —–送给短暂渺茫的你（许三多）</p><p>爬虫思路</p><p>1：什么是爬虫</p><p>爬虫(spider，又网络爬虫)，是指向网站/网络发起请求，获取资源后分析并提取有用数据的程序。</p><p>从技术层面来说就是 通过程序模拟浏览器请求站点的行为.</p><p>把站点返回的HTML代码/JSON数据/二进制数据（图片、视频） 爬到本地，进而提取自己需要的数据，存放起来使用。</p><p>2：入门爬虫的干货</p><p>2.1： 爬虫的基本思路</p><p>通过URL或者文件获取网页，<br>分析要爬取的目标内容所在的位置<br>用元素选择器快速提取(Raw) 目标内容<br>处理提取出来的目标内容 （ 通常整理合成一个 Json）<br>存储处理好的目标内容 （比如放到 MongoDB 之类的数据库，或者写进文件里。）<br>爬虫流程:<br>发送请求-&gt;获取响应内容-&gt;解析内容-&gt;保存数据</p><p>robots协议：</p><p>网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，但它仅仅是道德层面上的约束</p><p>爬虫的用途：</p><p>1、12306抢票<br>2、短信轰炸<br>3、网络投票<br>4、监控数据<br>5、下载图片、小说、视频、音乐等</p><p>Http和Https：<br>发送请求，获取响应的过程其实就是发送Http或者Https请求和响应的过程。<br>HTTP</p><p>超文本传输协议<br>默认端口号:80<br>HTTPS</p><p>HTTP + SSL(安全套接字层)，即带有安全套接字层的超本文传输协议<br>默认端口号：443</p><p>作用：在传输过程中对数据进行加密，防止被窜改</p><p>区别：http因不需要加密，所以性能更高，但安全性差。</p><p>https安全性高，但是占用服务器资源</p><p>但是Https是未来的主流，比如小程序、ios、android客户端的接口都需要Https接口支持.</p><p>Http请求报文和状态码：参考上一个博客.<br>常见的HTTP状态码：<br>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它 URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p><p>常见请求头：</p><p>Cookie——————–作用—–Cookie<br>User-Agent—————-作用—–浏览器名称<br>Referer——————-作用—–页面跳转处<br>Host———————-作用—–主机和端口号<br>Connection—————-作用—–链接类型<br>Upgrade-Insecure-Requests-作用—–升级为HTTPS<br>Accept——————–作用—–传输文件类型<br>Accept-Encoding———–作用—–文件编解码格式<br>x-Requests-with:XMLHttpRequest作用ajax请求</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
</feed>

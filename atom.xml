<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌上花开缓缓归</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-13T13:23:51.492Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lys-studys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux系统</title>
    <link href="http://example.com/posts/63613/"/>
    <id>http://example.com/posts/63613/</id>
    <published>2020-11-12T11:05:40.000Z</published>
    <updated>2020-11-13T13:23:51.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>linux系统的开机过程是比较复杂的一个过程，但整体上可以分成四大步骤或四大块:<br>    1. 按电源按钮后BIOS开始工作,然后进行加电自检<br>    BOIS是英文”Basic input output system”的缩写词，就是进本的输入输出系统，BOIS是电脑启动时加载的第一个软件，其实,他是一组固化到计算机内主板上一个ROM(只读存储器)芯片上的程序.<br>    2. MBR引导(Boot Loader)(0磁盘的0柱面的第一个扇区)<br>     主引导记录(MBR,Main Boot Record)是位于磁盘最前边的一段引导(Loader)代码.它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判断,分区引导信息的定位，它由磁盘操作系统(DOS)对磁盘对象初始化时产生的．<br>    3. 启动内核<br>    4. 启动第一个进程init<br>    进程pid为1的进程,然后进行各个脚本的调用，脚本运行，</p><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><h3 id="BIOS-开机自检"><a href="#BIOS-开机自检" class="headerlink" title="BIOS/开机自检"></a>BIOS/开机自检</h3><h4 id="微控制器"><a href="#微控制器" class="headerlink" title="微控制器"></a>微控制器</h4><p>开机键-&gt;硬件工作(寄存器复位)-&gt;BIOS(执行BIOS里边的程序,作用是找到主引导记录MBR)-&gt;(MBR)-&gt;(MBR程序加载到内存)-&gt;接下来执行MBR的程序.</p><p>系统想要启动必须先加载BOIS,按下电源键时,给微控制器下达一条复位指令,个寄存器复位,最后下达一条跳转指令,跳转到BOIS的ROM,使得硬件去读取主板上的BOIS程序,在这之前都是由硬件来完成，之后硬件就会把控制权交给BOIS.</p><h4 id="BOIS-gt-POST"><a href="#BOIS-gt-POST" class="headerlink" title="BOIS-&gt;POST"></a>BOIS-&gt;POST</h4><p>  随后BOIS程序如果加载CMOS(可读写的RAM芯片(断电数据丢失),保存BIOS设置的硬件参数的数据)的信息,借CMOS取得主机的各项硬件配置:<br>  取得硬件配置的信息之后,BOIS进行加电自检(Power-on self Test, POST)过程检测计算机各种硬件信息,如果发现硬件错误则会报错(发出声音警告);<br>  之后BOIS对硬件进行初始化(检测硬件信息无误)．<br>  BOIS将自己复制到物理内存中继续执行,开始按顺序搜寻可引导存储设备,判断的标准就是判断每个磁盘前512个字节结尾是否存在55AA,有就是可引导，没有就继续检查下一个磁盘.一般第一张磁盘就是可引导磁盘,接下来就会读取磁盘的内容，但是要读取磁盘文件必须要有文件系统，这对BOIS挂载文件系统来说是不可能(BOIS非常小的),因此需要一个不依赖文件系统的方法使得BOIS读取磁盘内容,这种方法就是引入MBR.最后BOIS读取第一个可导的存储设备的MBR(0柱面0磁道第一扇区)中的boot Loader(根引导程序).将MBR加载到物理内存中执行．<br>  MBR载入内存后,BIOS将控制权转交给MBR(准确的说应该是MBR中的boot loader),然后MBR接管任务开始执行．</p><p>  小例子:<br>       如果开机密码忘记了，打开主板扣电池，BIOS断电,然后RAM芯片会全部还原为默认值,BIOS密码会消失.</p><h3 id="MBR引导-Boot-Loader"><a href="#MBR引导-Boot-Loader" class="headerlink" title="MBR引导(Boot Loader)"></a>MBR引导(Boot Loader)</h3><p>  载入了第一个可引导的存储设备的MBR后,MBR中的boot Loader就要读取所在磁盘的操作系统核心文件(即后面所说的内核)了.</p><h4 id="boot-Loader"><a href="#boot-Loader" class="headerlink" title="boot Loader"></a>boot Loader</h4><p>  但是呢还存在一些问题，不同操作系统的文件格式不同?还有我们知道一个磁盘可以安装多个操作系统，boot Loader怎么能够做到引导的就是我们想要的操作系统呢?这么多不同的功能单靠一个446字节的boot Loader是远远不够的．因此必须弄一个相对应的程序来处理各自对应的操作系统核心文件，这个程序就是操作系统的loader(注意不是MBR中的boot Loader,而是没个操作系统本身有一个自己的boot Loader),这样一来boot Loader只需要将控制权限交给对应操作系统的loader,让他负责去启动操作系统就行了．</p><p>第一个扇区512个字节<br>MBR　　　446字节<br>分区表　　64字节　16个字节一个分区<br>55AA标记　2字节</p><p>这里有张图更好的解释boot loader的作用:</p><p>图跳转.<br>扇区的0-2048就是存放这些东西的所以我们用不了</p><p>解读上图内容，我们知道一个硬盘的每个分区的第一个扇区叫做boot sector,这个扇区存放的就是操作系统的loader,所以我们常说一个分区只能安装一个操作系统，如上图，第一个分区的Boot sector存放这windowde的loader,第二个分区放着linux的loader,第三个第四个由于没有安装操作系统所以空着．至于MBR的boot Loader是干嘛呢,Boot Loader有三个功能:<br>    1. 提供选单<br>    2. 读取内存文件<br>    3. 转交给其他loader<br>    提供选单就是给用户提供一张选项单，让用户选择进入那个系统；<br>    读取内核文件，我们知道系统会有一个默认启动的操作系统，这个系统的loader在所有分区的boot sector有一份，除此之外也会将这个迷人启动的操作系统的loader复制一份到MBR的boot Loader中,这样一来MBR就会直接读取Boot Loader总的loader了，然后就是启动默认的操作系统．<br>    转交给其他的Loader,当用户选择其他操作系统启动的时候，Boot Loader会将控制权限转交给对应的loader,让他负责去启动操作系统的启动．<br>    另外，安装window操作系统的时候,window会主动复制一份自己的loader到MBR中的Boot Loader中,这种操作在linux下不会.所以我们安装多重操作系统的时候要求先安装window,然后在安装linux;我们假设先安装linux再安装windows的时候就会把windows的loader复制到MBR中的boot Loader,这样依赖就会默认优先启动windows.然后先安装windows,自动回复Windows的loader到boot Loader,再安装linux的时候,我们可以设置把linux的loader复制到boot Loader中,把原先windows的覆盖掉,这样才能设置linux默认启动.</p><h4 id="Linux的GRUB"><a href="#Linux的GRUB" class="headerlink" title="Linux的GRUB"></a>Linux的GRUB</h4><p>linux操作系统层面的loader使用的是grub.(loader包含在grub)<br>linux的Boot Loader和grub到底是什么关系呢?<br>图片跳转:<br>    我们可以看到很多文件，其实linux的Loader为stage1那个文件，linux所在分区的boot sector(一个扇区是512个字节)就是存放在stage1文件的内容，同时默认linux启动的话,也需要把stage1中的引导代码安装到MBR中的boot Loader中.该文件太小，能完成的功能有限，因此linux的Loader只是简单的引导作用．<br>    stage1完成了主程序的引导后，主引导程序开始加载配置文件了，但是加载这些配置文件之前需要有文件系统的支持，可是现在还没有文件系统呢,gurb在不依赖linux内核的情况下具有读取配置文件与内核映像的能力，gurb的内置文件系统其实是依赖stage1_5这些文件定义的,而且有不同文件系统对应不同的stage1_5文件.<br>    而后开始读取stage2开始真正的读取配置文件grub,conf.解析/boot/grub/grub.conf文件;<br>    (linux操作系统多个系统核心并存,linux内核更新没有覆盖原来的内核，而是增加了一个新的内核)．<br>    文件参数<br>    1. default = 0 第几个操作系统<br>    2. timeout = 5 系统选择页面显示时间．<br>    3. splashimage = (hd0, 0)/grud/splash.xpm.gz: (hd0, 0)磁盘分区的意思，grub表示磁盘是磁盘+坐标形式.<br>    大多数用的是SATA这种接口的硬盘，文件设备名字为sd, 第一块硬盘为Sda,第二块硬盘为 sdb….<br>　　grub中是以hd + 坐标的形式来展现的<br>　　　具体对应关系实现:<br>      　sda -&gt;1.-&gt;(hd0,0)<br>      　　　-&gt;2.-&gt;(hd0,1)<br>      　　　-&gt;3.-&gt;(hd0,2)<br>    4. haddenmenu 隐藏菜单<br>    5. (对应图片)启动系统名字<br> 　　　boot引导分区的根对应的/boot/这个地方．<br>　　　启动linux的内核，初始化一个虚拟的伪文件系统(,img),用来加载linux系统的核心模块，加载完成后，就把这个伪文件系统给删除掉，转而加载真正的linux系统所支持的真正的内核文件系统．</p><h3 id="gurb把内核文件加载到内存"><a href="#gurb把内核文件加载到内存" class="headerlink" title="gurb把内核文件加载到内存"></a>gurb把内核文件加载到内存</h3><h4 id="加载内核文件"><a href="#加载内核文件" class="headerlink" title="加载内核文件."></a>加载内核文件.</h4><p>MBR将内核文件(代码)载入物理内存中执行，内核就是/boot/vmlinuz-2.6.32-696.el6.x86_64.观察该文件，发现是一个压缩镜像文件．<br>看图．<br>控制权转交给内核后，内核重新检测各种硬件信息,(第一次为POST自检)我们前边说了，一个完整的linux包括内核和内核之上的程序需要使用硬件，还需要加载提供这些程序功能的模块（硬件驱动程序），然而这些模块都在根目录的/lib/modules/2.6.32-696.el.x86_64下(和/lib/modules/不能挂载不同的分区)，这时候内核还没有文件系统的概念，没有文件系统就没办法挂载到根目录，想要挂载根目录就需要相应的模块支持，而我们原本的问题就是如何加载模块，先有鸡后有蛋．</p><h4 id="加载initrd初始化ramfs文件系统"><a href="#加载initrd初始化ramfs文件系统" class="headerlink" title="加载initrd初始化ramfs文件系统"></a>加载initrd初始化ramfs文件系统</h4><p>看图<br>我们发现解压之后的内容类似于真正/目录下内容，这是因为这是一个最小化的linux根文件系统，内核就是先把这个文件展开，形成一个虚拟文件系统,内核接虚拟文件系统装在必要的模块，完成后释放该虚拟文件系统并挂载真正的根目录．</p><p>运行起来后真正的根会和fstable挂载在一起，并且会把根目录放在第一个硬盘挂载在一起sda1(?),然后在调用linux系统中的系统程序,第一个就是调用init,进程ID就是1,其他进程都是他的子进程.</p><h3 id="启动第一个进程init"><a href="#启动第一个进程init" class="headerlink" title="启动第一个进程init"></a>启动第一个进程init</h3><h4 id="init进程-主要功能是准备软件执行的环境"><a href="#init进程-主要功能是准备软件执行的环境" class="headerlink" title="init进程:主要功能是准备软件执行的环境"></a>init进程:主要功能是准备软件执行的环境</h4><p>内核完成硬件检测和加载模块后，内核会呼吁第一进程，就是/sbin/init,至此内核把控制权限交给init进程读取初始化配置文件/etc/inittab,决定操作系统的runlevel,/etc/inittab内有这样一句:<br>    id:runlevel:action:process,这里我的实验机器的值:id:3:initdefault:<br>    看图:</p><h4 id="etc-rc-d-rc-sysinit"><a href="#etc-rc-d-rc-sysinit" class="headerlink" title="/etc/rc.d/rc.sysinit"></a>/etc/rc.d/rc.sysinit</h4><p>读取/ect/rc.d/sinit系统初始化脚本，设置主机名，挂载/etc/fstab中的文件系统，修改/etc/systl.conf的内核参数等各项系统环境．<br>查看脚本内容，大致功能如下图:</p><pre><code>k开头的文件杀死，ｓ开头的文件启动．linux默认的号为３,就会扫描rc.d中的rc3.d文件．文件中一部分ｋ开头，一部分ｓ开头．</code></pre><p>根据运行级别(123456)进入相应的etc/rc.d/rcN,d目录，启动和关闭相关的系统服务．里边存放着一堆以k,S开头的软连接文件，分别是代表相应的服务.K开头表示运行级别下需要把该服务杀死，S开头表示该运行级别下需要把服务开启．上述操作都是有/etc/rc.d/rc脚本来完成的.另外我们还注意都S和K后边的数字，他们的数字代表了读取的顺序，因为有一些服务是具有一定的关联性．<br>　　而且每个rcN.d目录内最后都有一个S99local文件，该文件指向../rc.local脚本．</p><h4 id="etc-rc-d-rc-local"><a href="#etc-rc-d-rc-local" class="headerlink" title="/etc/rc,d/rc.local"></a>/etc/rc,d/rc.local</h4><p>　　系统根据runlevel执行完成/etc/rc.d/rcN.d中的脚本后，调用/etc/rc.d/rc.local脚本<br>　　这时候系统已经完成了各种必要系统服务的启动，假如我们想定自定义一些指令要在开机的时候启动，我们就可以把他们放到/etc/rc.d/rc.local内,该文件默认为空.</p><h4 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h4><p>　　接下来会由/sbin/mingetty指令启动终端，会启动6个命令行终端,最终呈现给我们的就是这样画面<br>看图启动过程<br>　<a href="https://blog.csdn.net/abc_ii/article/details/8740008">全面图解</a><br><a href="https://blog.51cto.com/itchentao/1912451">进阶图解强烈推荐</a><br><a href="https://s1.51cto.com/wyfs02/M00/8F/7A/wKiom1jfbn-zLndXAAJfq4gKqGA617.png">直接显示图</a></p><h3 id="Centos7-x的启动过程和相关配置文件"><a href="#Centos7-x的启动过程和相关配置文件" class="headerlink" title="Centos7.x的启动过程和相关配置文件"></a>Centos7.x的启动过程和相关配置文件</h3><p>Cenos7和Centos6启动流程差不多，只不过到init程序时候，改为了systemd,因此详细解释一下systemd后的启动流程，</p><ol><li>uefi或BIOS初始化,开始POST开机自检(uefi是BIOS发展的阶段)</li><li>加载mbr到内存</li><li>GRUB阶段，Centos6加载的是/boot/grub.grub.conf,而Centos7加载的是/boot/grub2/grub.conf</li><li>加载内核和initramfs模块</li><li>内核开始初始化，使用system来代替centos6以前的init程序,systemd使用”target”来处理引导和服务管理过程，这些system里的”target”文件被用于分组不同的引导单元以及自启动同步进程．</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>leedcode_动态规划</title>
    <link href="http://example.com/posts/34955/"/>
    <id>http://example.com/posts/34955/</id>
    <published>2020-11-11T03:23:11.000Z</published>
    <updated>2020-11-11T03:23:11.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux_system</title>
    <link href="http://example.com/posts/47607/"/>
    <id>http://example.com/posts/47607/</id>
    <published>2020-11-10T06:09:26.000Z</published>
    <updated>2020-11-10T10:55:26.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linxu" scheme="http://example.com/tags/linxu/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/posts/0/"/>
    <id>http://example.com/posts/0/</id>
    <published>2020-11-10T00:38:59.000Z</published>
    <updated>2020-11-10T06:07:05.849Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>heap_sort()<br>o(nlogn)</p><p>堆的一般性操作(底层是一个完全二叉树)．</p><ol><li>插入元素: 插入元素时根据堆自下而上进行调整，层数越高（越接近根节点）调整的次数越多．<br>实例：第零层(根节点位置)插入的时候进行零次调整，第一层元素最多调整1次依次类推.根据推导单个个元素需要调整的次数:<br> 调整次数 = 树高 - 1<br> 推导得到: 调整次数 = (nlogn + 1) - 1;<br> 调整次数 = nlogn;<br>整体的调整次数:（背景为一个满二叉树）<br>　　　　该层节点最多调整次数　节点个数<br>第一层:　　　　　０　　　　　　　2^0<br>第二层:　　　　　１　　　　　　　2^1<br>第三层:　　　　　２　　　　　　　2^2<br>第N层:　　 　　　Ｎ-1　　　　　　2^n<br>（背景满二叉树）<br>度为零的节点比度为二的节点多一个,<br>上边规律可得最后一层节点有2^n个，那么度为2的节点2^n - 1个.<br>这两个的和就是整个要维护的节点个数，之和就是N = 2^(n + 1) - 1个．</li></ol><p>叶子节点处理:<br>最后一层的节点调整之和就是(n - 1) * 2^n<br>转换为(log(2^n) - 1) * (2 ^ n)</p><p>把N代替了n,求全部节点调整次数：<br>(log2N - 2) * (N/2): 注释由于叶子节点和全部节点近似2倍的关系，所以简化为(N/2).</p><p>化简取其最大量级<br>整体的时间复杂度约为 O(NlogN).</p><h4 id="建堆的优化"><a href="#建堆的优化" class="headerlink" title="建堆的优化"></a>建堆的优化</h4><p>为了让建堆的时间复杂度变为O(n).使其层数越高的元素（层数越小），操作的次数越多，就需要自上而下的进行维护一个堆．<br>所以依据传统思路，找到了一个完全优于前者思路，前者思路就会淘汰．<br>得到公式：<br>n<em>2^1 + (n-1)*2^2 + (n-2)*2^3 +……+ 1</em>2^n (n依据上表分析)<br>注意第一项为第二次到顶层调整次数．<br>就比如最后一项: 最后一层节点数2^n个，需要调整的次数为1次.</p><p>这个公式的计算(等差乘等比)</p><p>当前项成公比，然后错位相减（纸上计算）</p><p>过程中需要加上2^0,2^1再整个减去3.可以得到<br>2^1 + 2^2 +…… 2^n -2<em>n - 3<br>等比序列求结果．Sn = a1(1 - q^n)/(1-q) <a href="https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97/1129457?fr=aladdin">公式跳转</a><br>结果为　2^(n+2) - 2</em>n -4 = 2^(n + 1) - 4.</p><p>对于这个结果分析一下:<br>    把n带入求得n+1层节点个数2^n,从下层调整个数2^(n+1).<br>    2^n变化为2^(n + 1)表明了让N = 2^n（表示节点的数量）可以得到等式N = 2N．趋于一种平衡状态．<br>    进一步推导可得O(2N) = O(N)的时间复杂度. </p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>k-归并排序</title>
    <link href="http://example.com/posts/32473/"/>
    <id>http://example.com/posts/32473/</id>
    <published>2020-11-10T00:27:16.000Z</published>
    <updated>2020-11-10T00:38:27.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>system_develop</title>
    <link href="http://example.com/posts/48539/"/>
    <id>http://example.com/posts/48539/</id>
    <published>2020-11-09T15:43:24.000Z</published>
    <updated>2020-11-09T15:44:31.421Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统开发" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="操作系统开发" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>programming_language</title>
    <link href="http://example.com/posts/21911/"/>
    <id>http://example.com/posts/21911/</id>
    <published>2020-11-09T15:42:36.000Z</published>
    <updated>2020-11-09T15:45:12.390Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程语言开发" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="编程语言开发" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>leedcode</title>
    <link href="http://example.com/posts/62607/"/>
    <id>http://example.com/posts/62607/</id>
    <published>2020-11-09T15:39:53.000Z</published>
    <updated>2020-11-09T15:40:34.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leedcode" scheme="http://example.com/categories/leedcode/"/>
    
    
    <category term="leedcode" scheme="http://example.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>socket+tcp</title>
    <link href="http://example.com/posts/14686/"/>
    <id>http://example.com/posts/14686/</id>
    <published>2020-11-09T13:22:27.000Z</published>
    <updated>2020-11-09T15:39:30.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>socket和tcp/udp以及计算机网络传输结合总结．<br>非常详细的博客</p><p><a href="https://blog.csdn.net/m0_37925202/article/details/80286946#commentBox">socket和tcp/udp网络中传输详解</a></p><p><a href="https://www.cnblogs.com/zgq0/p/8780893.html">进程间通信非常详细的博客</a></p><p><a href="https://blog.csdn.net/qq_38182963/article/list/2">tomcat详细解释-socket通信重点看三</a></p><p><a href="https://www.cnblogs.com/runtimeexception/p/10415821.html">nosql中的redis学习笔记</a></p><h3 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h3><ol><li><p>P地址、端口号……</p></li><li><p>socket API</p></li><li><p>实现UDP客户端/服务器</p></li><li><p>套接字<br>套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p></li></ol><h3 id="进程间通信（IPC）有很多种方式"><a href="#进程间通信（IPC）有很多种方式" class="headerlink" title="进程间通信（IPC）有很多种方式"></a>进程间通信（IPC）有很多种方式</h3><ol><li>管道（包括无名管道和命名管道）；</li><li>消息队列；</li><li>信号量；</li><li>共享存储。</li><li>……（ Socket和Streams支持不同主机上的两个进程IPC）。</li></ol><h3 id="认识网络层通信过程："><a href="#认识网络层通信过程：" class="headerlink" title="认识网络层通信过程："></a>认识网络层通信过程：</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>system</title>
    <link href="http://example.com/posts/59942/"/>
    <id>http://example.com/posts/59942/</id>
    <published>2020-11-09T05:47:41.000Z</published>
    <updated>2020-11-12T11:06:05.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="请简述进程，线程及程序三者有什么区别"><a href="#请简述进程，线程及程序三者有什么区别" class="headerlink" title="请简述进程，线程及程序三者有什么区别?"></a>请简述进程，线程及程序三者有什么区别?</h4><p>程序: 是编译好的可执行的二进制文件．<br>程序运行起来后，进入内存中就变成了进程.</p><p>进程: 进程是程序在内存中的镜像，他是一个实例</p><p>包括：加载的二进制程序，虚拟内存，内核资源（打开的文件,关联的用户,<br>关联用户：再分配权限过程，会把程序和用户进行关联，就是哪个用户来把这个程序运行起来的．</p><p>线程: 是进程内的执行单元，<br>如果只有一个线程，就是一个主线程，也就是进程自己.<br>如果有多个线程的话每个线程都是一个执行单元．<br>线程也是操作系统调度器调度的最小单元.</p><p>进程和线程的异同之处?<br>相同: 都是为了增加程序的并发度.为了使功能更为丰富．而实现的.<br>不同:<br>阶段一 进程中有一个虚拟内存，线程中有一个虚拟处理器的东西．得到的结论，进程是独享存，线程是独享CPU.<br>阶段二<br>进程在运行的过程中独占内存，不会感觉到有内存的争抢．<br>线程在运行的时候就会感觉我独占cpu的核心.没有被挣抢．<br>阶段三<br>进程独占内存：所以进程通信是较为复杂的东西．<br>线程没有虚拟内存，所以说线程会共享整个进程空间的内容，或者说整个进程空间．这样产生的后果就是，线程间的通信会变得很方便．<br>阶段四<br>线程调度的代价是相对较小的,因为在进程空间上的内容是共享的，所以在切换线程的时候，内存空间的消耗比较小的．<br>cpu的消耗，比如两个线程都在用cpu的时候,在线程调度和上下文切换消耗也是很小的．</p><p>第五阶段<br>进程和线程的优势:<br>    多进程程序：他运行起来比较稳定，某个进程退出，不会导致其他进程退出．<br>    多进程编程适合并发度比较小的情况，比如就启动程序后就需要两个进程就可以，并且他们做自己独立的无相关活动的情况．<br>    与我们生活息息相关的进程就是守护进程，守护进程就得用多进程去实现，而不能用多线程，<br>    多线程：让编程变得跟简单，就比如把某个模块抽象化出来，就规定一个线程去实现．相互之间的通信比较简单的．</p><p>弊端：<br>多进程：比较复杂，调度的代价比较大．<br>多线程：</p><ol><li>调试及其不容易</li><li>线程安全问题：主要涉及到资源的竞争，（就是三个进程同时访问一个空间上的资源，如果不加上锁，就会产生资源竞争<br>就是即使加了锁，也会产生死锁问题）</li></ol><h4 id="请简述你所知道的fork-函数，以及再多进程编程中需要注意的事项"><a href="#请简述你所知道的fork-函数，以及再多进程编程中需要注意的事项" class="headerlink" title="请简述你所知道的fork()函数，以及再多进程编程中需要注意的事项"></a>请简述你所知道的fork()函数，以及再多进程编程中需要注意的事项</h4><p>函数问题三个考虑方向</p><ol><li><p>用途 : 克隆了一个父进程产生了一个子进程，基本上拷贝了父进程的进程空间，只进行了一个写拷贝（不会进行马上拷贝，而是发生了写操作的时候，才进行拷贝）．</p></li><li><p>函数原型：　无参数</p></li><li><p>函数返回值：是我们遇到的有多个返回值的函数，可能的三个返回值<br>(1): 在子进程中返回的是零<br>(2): 在父进程中返回的是子进程的pid;<br>在子进程中获得父进程的pid 就是getppid(),获得自己的pid就是getpid();<br>在父进程没办法获取子进程的pid只能通过返回值的形式给他．<br>为什么会不能返回呢？<br>因为fork()之后，子进程就是一个独立的内存空间了，父进程失去了对它的控制．<br>(3): 在系统编程或者io操作上，返回-1有明显的含义的，表示出错了，fork()函数不能出现参数出错的情况，只能是</p></li><li><p>存在问题</p></li></ol><p>第一个问题：<br>比如 简单举个例子<br>for(int i = 0; i != 10; i++){<br>    fork();<br>}<br>这样是产生不了10个子进程的．或者说fork第一次就会产生一个子进程，再执行到for循环的时候，就会是父子进程都执行到了下次变成了四个子进程以此类推．所以说产生不了我们想要的十个子进程，只有判断进程的pid</p><p>第二个问题：<br>比如fork()函数前边有一个printf(),函数没有输出回车(\n),fork就可能会把缓冲区的数据进行一下复制，这个子进程这时就会输出两次．</p><p>第三个问题：</p><p>会引起孤儿进程或者是僵尸进程，<br>僵尸进程：　子进程先于父进程死了，父进程不给他收尸，就会产生僵尸进程．<br>孤儿进程：　子进程活着父进程死了，就会产生孤儿进程．孤儿进程会被一号进程收养．<br>僵尸进程不会被一号进程收养是因为他的父进程还存在，所以不会归到一号进程．<br>僵尸进程的危害: 占用pid,进程控制器pcb还在，变相的占用了系统资源</p><p>孤儿进程的好处: 在父进程生成子进程之后，父进程就没有事情做了，然后自己退出，留下子进程被一号进程收养，就是所说的后台进程或者是守护进程的实现方式．</p><h4 id="请回答-进程有哪些状态-他们是如何进行切换的"><a href="#请回答-进程有哪些状态-他们是如何进行切换的" class="headerlink" title="请回答: 进程有哪些状态,他们是如何进行切换的?"></a>请回答: 进程有哪些状态,他们是如何进行切换的?</h4><p>三态模型和无态模型<br>三态：</p><ol><li>ready就绪态</li><li>running运行态</li><li>block阻塞态</li></ol><p>状态执行顺序<br>1-&gt;2-&gt;3<br>2-&gt;1 </p><p>就绪态和运行态是可以两个切换的<br>ready状态可以转换成running状态<br>就比如while(1){}他不会进行io等待也不会涉及到阻塞．<br>那么什么时候结束呢：进程调度器分配的cpu时间片耗尽了，就会回到ready状态.</p><p>running到block状态<br>阻塞主要是io等待，比如输入信息(cin 或者scanf).<br>有io等待的时候就会从运行态转变为block态，等待输入结束后到达ready.下次调度的时候才会被执行．</p><p>###</p><h4 id="请你对用户态-内核态以及系统调用这三个概念做出解释"><a href="#请你对用户态-内核态以及系统调用这三个概念做出解释" class="headerlink" title="请你对用户态,内核态以及系统调用这三个概念做出解释"></a>请你对用户态,内核态以及系统调用这三个概念做出解释</h4><h5 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h5><p>特权级</p><ol><li>对于X86架构的CPU硬件上有0-3四个特权级包括了特权指令和非特权指令</li><li>在Unix/linux系统中,只使用了0和3特权级．<h5 id="两者差别"><a href="#两者差别" class="headerlink" title="两者差别"></a>两者差别</h5></li><li>用户态</li><li>内核态</li><li>特权不同</li><li>处理器是否可被抢占</li></ol><h5 id="相互切换"><a href="#相互切换" class="headerlink" title="相互切换"></a>相互切换</h5><ol><li>有用户态到内核态<br>　以下三种本质上都是中断机制<ol><li>中断 </li><li>异常</li><li>系统调用(陷入)</li></ol></li><li>由内核态到用户态<ol><li>设置程序状态字 </li></ol></li></ol><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><ol><li>为了使上层应用能够访问到硬件资源，内存为上层应用提供了接口</li><li>是用户态主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作完成工作</li><li>包括<ol><li>进程控制</li><li>进程通信</li><li>文件操作</li><li>设备操作等</li></ol></li></ol><h4 id="线程同步是干什么的，线程同步有那些机制"><a href="#线程同步是干什么的，线程同步有那些机制" class="headerlink" title="线程同步是干什么的，线程同步有那些机制?"></a>线程同步是干什么的，线程同步有那些机制?</h4><p>线程同步的主要手段就是互斥.</p><ol><li>相关名词<ol><li>临界区</li><li>原子性</li><li>竞争</li><li>互斥</li></ol></li><li>为什么要有线程同步<br>　　线程安全性．</li><li>线程同步实现机制<ol><li>临界区<br>控制多线程执行某一段代码的顺序．<br>使可能并发的线程，让其一个一个串行化去执行的．</li><li>互斥量 互斥锁就是这种机制，当一个线程拥有这个对象的时候，其他线程就没办法拥有．只有拥有这个对象的人才能够执行这个操作．</li><li>信号量<br>信号量和互斥量不同的地方就是，信号量允许多个线程同时访问某个资源，就比如一个数据可以让五个线程访问，别的不可以．</li><li>事件<br>当内核感知到事件发生的时候，操作系统通知线程去做什么，这个叫事件．</li></ol></li></ol><h4 id="内核线程和用户线程有什么区别"><a href="#内核线程和用户线程有什么区别" class="headerlink" title="内核线程和用户线程有什么区别?"></a>内核线程和用户线程有什么区别?</h4><p>分类原则:<br>根据操作系统是否能感知到线程的存在分为</p><ol><li><p>用户线程:操作系统感知不到的线程</p></li><li><p>内核线程:操作系统能感知到的线程</p></li></ol><p>早期的操作系统没有线程只有进程，因为进程的创建上下文创建销毁的成本代价太高，所以说能不能有一个轻量级的，所以说有了线程的概念，最开始操作系统的内核没办法提供线程的支持的，线程是一些库提供用户层面的支持，所以说在创建一个线程，操作系统感知不到线程的存在的，再发展，操作系统的内核就渐渐的支持线程操作．后来线程由内核提供一下调用的接口，最后可以通过用户调用来创建一些线程，这个时候的线程对内核来说是可见的，内核可以看到这个线程，就是内核线程．</p><p>优缺点对比:</p><ol><li>用户态线程：<br>可以在不支持多线程的机器上实现多线程<br>在自己的线程空间里，自己调度销毁切换，所以相对来说，是比较灵活的，但是他有一个致命的缺点，内核不知道他的存在．只能感知到一个进程的存在，只要发生一个线程阻塞，操作系统就不会继续调度这个进程里边的其他线程，因为他只感知到当前进程处于阻塞状态．直到他重新处于就绪态的时候．他才可以调度其他线程.　</li><li>内核态线程<br>　由内核线程是由内核创建销毁切换的，所以说对于内核线程来说，每一个操作系统内核都知道这个线程的存在，所以说它的调度都是以这些线程为基本单位的，每一个进程里边如果有多个线程的话，操作系统会根据每个线程的状态（就绪，阻塞，运行等状态），来选择是否要调度他．真正意义上实现了并发不是用户写的．并且也不会因为一个线程阻塞导致整个进程的阻塞．<br>　由于线程在内核态，可以使用整个系统内能进行资源的竞争，也相当于对资源的有效利用提高了．<br>　每一个线程都支持一个线程控制块tcp,内核根据该控制块感知线程的存在，并进行控制．在一定程度上相当于进程．跟进程一样创建销毁操作，但是他是一种轻量级的．总的来说，是内核线程提供了一个轻量级的类似于进程的调度．</li></ol><p>linux的线程是什么线程?(加分项)</p><p>多线程模型</p><ol><li>多对一：多个线程对应一个线程．早期内核里一个线程（进程）在用户层面实现了多个线程，这就叫多对一模型．</li><li>一对一：这就是当前linux系统下多线程的主要方式，每一个用户创建的线程都对应着一个内核线程，所以说在内核层面就能感知到线程的存在，然后进行更为精细的调度．</li><li>多对多：对一种和二种方式进行混合，</li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>algorithm</title>
    <link href="http://example.com/posts/54839/"/>
    <id>http://example.com/posts/54839/</id>
    <published>2020-11-08T11:59:08.000Z</published>
    <updated>2020-11-09T05:46:22.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程"><a href="#如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程" class="headerlink" title="如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程"></a>如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程</h4><p>leedcode 中happy number,不是用链表但是用的是一个思想.</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="如果现在有k个有序数组-如何合并成一个有序数组"><a href="#如果现在有k个有序数组-如何合并成一个有序数组" class="headerlink" title="如果现在有k个有序数组,如何合并成一个有序数组"></a>如果现在有k个有序数组,如何合并成一个有序数组</h4><p>k路归并排序:</p><h4 id="请具体说明，为什么归并排序适合处理大数据排序情况"><a href="#请具体说明，为什么归并排序适合处理大数据排序情况" class="headerlink" title="请具体说明，为什么归并排序适合处理大数据排序情况"></a>请具体说明，为什么归并排序适合处理大数据排序情况</h4><p>如果现在有40g的外部文件，而内存只有2g,如何进行文件的排序操作，这种情况就需要对40g的内存进行划分,划分成20份2g的文件，通过内存排序算法对这20个文件进行排序，然后进行多路归并排序(外存排序算法).</p><p>其中二路归并排序是多路归并排序中的一种.</p><p>特点:　对内存要求很少而且大部分操作是在外存中进行的.</p><h4 id="如何快速的输出无序数组中前k大的值-请说明你的方法-并分析时间复杂度．"><a href="#如何快速的输出无序数组中前k大的值-请说明你的方法-并分析时间复杂度．" class="headerlink" title="如何快速的输出无序数组中前k大的值,请说明你的方法,并分析时间复杂度．"></a>如何快速的输出无序数组中前k大的值,请说明你的方法,并分析时间复杂度．</h4><ol><li>最差的方法: 选择排序(从未排序区选出最大或最小的元素进行插入已排序区尾部)，进而能选出第几大的值．</li><li>维护一个大小为k的大根堆(nlogk)<br>把带插入元素依次性的插入大根堆．</li><li>维护一个小根堆<br>参考堆排序和线性建堆法的过程<br>首先把数组用线性建堆法简历一个小根堆，建堆的时间复杂度O(n)<br>小根堆的时间复杂度是logn,弹出k次,所以总的时间复杂度为n + klogn;</li><li>BFPRT算法<br>基于快速选择算法<br>快速选择算法的影响因素主要是，基准值的选取能否尽可能的平分数组元素．<br>一条性质找到第ｋ位的元素,左边的元素都比ｋ小．</li></ol><p>如果数据量比较大(n或者k比较大)(大数据情况)<br>参考多路归并排序的过程</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h4 id="假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值"><a href="#假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值" class="headerlink" title="假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值"></a>假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值</h4><ol><li><p>蓄水池抽样<br>假设已经从n个元素中抽取了k个元素，概率为(k/n).<br>假设蓄水池中k个元素a1,a2,a3,….ak.<br>当a(n+1)个元素进来的时候，就会1到(n - 1)中随机一个数值，这个值如果小于等于k的时候，把a(n + 1)替换掉该位置．如果大于k的话,a(n + 1)这个值就不保留．</p></li><li><p>应用场景<br>如果是说大数据场景下的采样问题．大数据场景一般是确定数据大小的情况下．<br>而蓄水池抽样说的是一个为止大小的序列.<br>确切的说应用场景是数据流采样问题,<br>数据流采样问题: 一个请求发送给服务器VPN,然后服务器进行转发达到翻墙的目的.服务器想对所有数据进行等概率采样，</p></li></ol><h4 id="要求设计一个函数-运行100次-非顺序的输出1–100内所有数字，要求，不能使用数组．"><a href="#要求设计一个函数-运行100次-非顺序的输出1–100内所有数字，要求，不能使用数组．" class="headerlink" title="要求设计一个函数,运行100次,非顺序的输出1–100内所有数字，要求，不能使用数组．"></a>要求设计一个函数,运行100次,非顺序的输出1–100内所有数字，要求，不能使用数组．</h4><ol><li><p>使用链表:<br>一百个链表中存取100个数值，然后随机删除节点，来达到随机的目的.</p></li><li><p>线性同余法:<br> 用一个线性同余式进行不断地计算<br> 剩余系:就比如　(4^k) % 7 当ｋ取值1,2,3,4对应值为4,3,1,4出现了循环<br> 就表示该公式的剩余系为4,2,1.<br> 能满足条件的(3xk%101)</p></li><li><p>扩展知识: </p></li></ol><p>要求设计一个函数,运行k次,非顺序的输出1–k内所有数字，要求，不能使用数组</p><ol><li>欧拉定理</li><li>欧拉函数</li></ol><h4 id="简述语言的随机函数原理"><a href="#简述语言的随机函数原理" class="headerlink" title="简述语言的随机函数原理"></a>简述语言的随机函数原理</h4><ol><li><p>c语言中的应用<br>第一步：srand 设置随机种子<br>第二部：rand获取随机种子</p></li><li><p>原理介绍</p></li></ol><p>首先:真随机和伪随机的区别</p><p>其次:线性同余法(计算机中使用的方法)</p><p>最后:为什么设置随机种子<br>就是为了在随机序列上找到一个起始点，如果没有起始点的话，我们的程序就会在一个固定的地方运行，产生的随机数是一样的．<br>如果随机种子一样产生的值也是一样的，只能用时间这个一直在变的量，来进行设定．</p><p>### 　</p><h4 id="一个长度为n的数组-只有一个数字出现了一次，其与数字均出现了2次-请找到出现1次的这个数字"><a href="#一个长度为n的数组-只有一个数字出现了一次，其与数字均出现了2次-请找到出现1次的这个数字" class="headerlink" title="一个长度为n的数组,只有一个数字出现了一次，其与数字均出现了2次,请找到出现1次的这个数字."></a>一个长度为n的数组,只有一个数字出现了一次，其与数字均出现了2次,请找到出现1次的这个数字.</h4><ol><li>异或运算的性质<br>第一: 满足交换率<br>第二: 满足结合率<br>本质是统计相应二进制的奇偶性的</li></ol><ol start="2"><li>解题方法</li></ol><p>一次进行异或操作，相同数字异或为零，最后找到．</p><ol start="3"><li>拓展问题</li></ol><p>有两个数字出现一次．</p><h4 id="一个长度为n的数组，其中的数值范围是1–n-已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度-要求时间复杂度O-n-空间复杂度O-1"><a href="#一个长度为n的数组，其中的数值范围是1–n-已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度-要求时间复杂度O-n-空间复杂度O-1" class="headerlink" title="一个长度为n的数组，其中的数值范围是1–n,已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度.要求时间复杂度O(n),空间复杂度O(1)."></a>一个长度为n的数组，其中的数值范围是1–n,已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度.要求时间复杂度O(n),空间复杂度O(1).</h4><p>n的数组，和数值范围是1–n，就用数组下标来表示对应位数，如果下标为1值为5,就让第一位和第五位数进行对调，看看第一位是不是五，如果是就找到了，如果不是接着对调．</p><h4 id="一个长度为n的数组-已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．"><a href="#一个长度为n的数组-已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．" class="headerlink" title="一个长度为n的数组,　已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．"></a>一个长度为n的数组,　已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．</h4><p>第一类方法: 排序方法</p><ol><li><p>基数排序(raddix_sort)<br>时间复杂度O(n),常数的空间复杂度但常数较大.</p></li><li><p>其余排序(快排,堆排)</p></li></ol><p>空间复杂度O(nlogn)<br>空间复杂度O(1)</p><p>第二类方法: 哈希表</p><p>时间复杂度:O(n)<br>空间复杂度:O(n)</p><p>方法比较:</p><pre><code>具体场景分析：比如计算资源短缺，选时间复杂度小的，存储空间短缺，选空间复杂度小的.如果其中一个两个都优于另一个，直接舍去第二种．</code></pre><p>###　</p><h4 id="已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-2-请设计算法找到这个数字．"><a href="#已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-2-请设计算法找到这个数字．" class="headerlink" title="已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/2),请设计算法找到这个数字．"></a>已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/2),请设计算法找到这个数字．</h4><p>超过(n/2)的数称为关键元素.</p><p>代码实现:<br>    随机取出一个数值，进行比对，等于加1,不等就减1.</p><h4 id="已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-k-请设计算法找到这个数字．"><a href="#已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-k-请设计算法找到这个数字．" class="headerlink" title="已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/k),请设计算法找到这个数字．"></a>已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/k),请设计算法找到这个数字．</h4><p>摩尔投票法:<br>    记录k-1个数字，及次数.<br>    k个数字来的时候,如果与之前元素不同就说明找到了ｋ个元素，<br>    用一个集合，有相同数加1, </p><p>代码实现:</p><h4 id="在一个数组中，大多数数字都出现3次-只有一个数字出现次数不足3次，请设计算法找到这个数字．"><a href="#在一个数组中，大多数数字都出现3次-只有一个数字出现次数不足3次，请设计算法找到这个数字．" class="headerlink" title="在一个数组中，大多数数字都出现3次,只有一个数字出现次数不足3次，请设计算法找到这个数字．"></a>在一个数组中，大多数数字都出现3次,只有一个数字出现次数不足3次，请设计算法找到这个数字．</h4><ol><li>二进制位统计法:<br> 统计每一个二进制列上的1出现的次数是不是三的倍数,如果是则都是，如果有就说明不是出现了三次.</li></ol><ol start="2"><li>状态转换表:<br> 本质和前边一样的，<br>重新梳理</li></ol><p>###</p><h4 id="如何设计一个支持min操作的栈，min函数返回当前栈中的最小值-要求min-push-pop-操作时间复杂度都是O-1-函数如何设计"><a href="#如何设计一个支持min操作的栈，min函数返回当前栈中的最小值-要求min-push-pop-操作时间复杂度都是O-1-函数如何设计" class="headerlink" title="如何设计一个支持min操作的栈，min函数返回当前栈中的最小值,要求min,push,pop()操作时间复杂度都是O(1),函数如何设计."></a>如何设计一个支持min操作的栈，min函数返回当前栈中的最小值,要求min,push,pop()操作时间复杂度都是O(1),函数如何设计.</h4><h4 id="有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O-n"><a href="#有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O-n" class="headerlink" title="有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O(n);"></a>有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O(n);</h4><p>维护一个窗口为K的窗口,这K个序列用两个优先队列维护，一个维护最大MAX_N,一个维护最下MIN_N,MAX_N - MIN_N = k - 1 这样的条件.</p><h4 id="给定k值-如果找到链表的倒数第k个元素-一个指针怎么做-两个指针怎么做"><a href="#给定k值-如果找到链表的倒数第k个元素-一个指针怎么做-两个指针怎么做" class="headerlink" title="给定k值,如果找到链表的倒数第ｋ个元素,一个指针怎么做?两个指针怎么做?"></a>给定k值,如果找到链表的倒数第ｋ个元素,一个指针怎么做?两个指针怎么做?</h4><p>第一种做法: 一个指针,跑两次</p><p>一个指针先找到链表的长度，再算出该数在第几位．</p><p>第二种做法: 两个指针,跑一次<br>让两个指针之间的距离控制在ｋ，两个指针一起往后走，当后边指针指向为空时，前指针就是倒数第k位的数.走的步数是一样的.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql2</title>
    <link href="http://example.com/posts/15731/"/>
    <id>http://example.com/posts/15731/</id>
    <published>2020-10-31T07:56:33.000Z</published>
    <updated>2020-11-01T07:02:52.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库高级" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="http://example.com/posts/16097/"/>
    <id>http://example.com/posts/16097/</id>
    <published>2020-10-27T05:25:31.000Z</published>
    <updated>2020-11-01T13:09:31.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/203622688">大佬笔记入口</a><br><a href="https://www.nowcoder.com/discuss/389444">同上</a></p><h3 id="mysql的逻辑架构"><a href="#mysql的逻辑架构" class="headerlink" title="mysql的逻辑架构"></a>mysql的逻辑架构</h3><h3 id="数据库两个操作系统文件"><a href="#数据库两个操作系统文件" class="headerlink" title="数据库两个操作系统文件"></a>数据库两个操作系统文件</h3><p>每个 SQL Server 2005 数据库至少具有两个操作系统文件：<br>一个数据文件和一个日志文件。</p><ol><li>数据文件包含数据和对象，例容如表、索引、存储过程和视图。</li><li>日志文件包含恢复数据库中的所有事务所需的信息。为了便于分配和管理，可以将数据文件集合起来，放到文件组中。<br>主要数据文件包含数据库的启动信息，并指向数据库中的其他文件。用户数据和对象可存储在此文件中，也可以存储在次要数据文件中。每个数据库有一个主要数据文件。主要数据文件的建议文件扩展名是 .mdf。<br>事务日志文件保存用于恢复数据库的日志信息。每个数据库必须至少有一个日志文件。事务日志的建议文件扩展名是 .ldf。</li></ol><h3 id="1-事务四大特性"><a href="#1-事务四大特性" class="headerlink" title="1.事务四大特性"></a>1.事务四大特性</h3><p>事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</p><ol><li><p>原子性:<br>最小的执行单元： 要么全执行，要么全不执行</p></li><li><p>隔离性：<br>所有操作全部执行完以前其它会话不能看到过程</p></li><li><p>一致性：<br>事务前后，数据总额一致</p></li><li><p>持久性:<br> 一旦事务提交，对数据的改变就是永久的</p></li></ol><h3 id="隔离操作"><a href="#隔离操作" class="headerlink" title="隔离操作"></a>隔离操作</h3><h4 id="并行事物的四大问题"><a href="#并行事物的四大问题" class="headerlink" title="并行事物的四大问题"></a>并行事物的四大问题</h4><ol><li>更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）</li><li>脏读：读到别的事务未提交的数据。（万一回滚，数据就是脏的无效的了）</li><li>不可重复读：两次读之间有别的事务修改。</li><li>幻读：两次读之间有别的事务增删。</li></ol><h4 id="对应隔离级别"><a href="#对应隔离级别" class="headerlink" title="对应隔离级别"></a>对应隔离级别</h4><ol><li><p>READ UNCOMMITTED：读未提交，不处理。</p></li><li><p>READ COMMITTED：读已提交，只读提交的数据，无脏读；</p></li><li><p>REPEATABLE READ：可重复读，加行锁，两次读之间不会有修改，无脏读无重复读；</p></li><li><p>SERIALIZABLE: 串行化，加表锁，全部串行，无所有问题。<br>详细解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. READ UNCIMMITTED（未提交读）</span><br><span class="line">　　      事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读。</span><br><span class="line"></span><br><span class="line">2. READ COMMITTED（提交读）</span><br><span class="line">　　      首先大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象</span><br><span class="line"></span><br><span class="line">3. REPEATABLE READ（可重复读）</span><br><span class="line"> 　　     REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻行，顾名思义就是突然蹦出来的行数据。</span><br><span class="line">          指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。</span><br><span class="line"></span><br><span class="line">4. SERIALIZABLE（可串行化）</span><br><span class="line">          　　      SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，</span><br><span class="line">                   因此性能会比较低下，在需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四中隔离原理"><a href="#四中隔离原理" class="headerlink" title="四中隔离原理"></a>四中隔离原理</h4></li><li><p>READ_UNCOMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据不加锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。</span><br><span class="line">下面分别对应上面1，2产生的表现：</span><br><span class="line"></span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>READ_COMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>REPEATABLE READ 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1，事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SERIALIZABLE 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</span><br><span class="line">2，事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line">2，事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="数据库涉及的锁"><a href="#数据库涉及的锁" class="headerlink" title="数据库涉及的锁"></a>数据库涉及的锁</h4><p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，<br>MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）。<br>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。<br>所有的锁都是绑定在数据库的索引机制上的！！！</p><p>首先锁可以分为： </p><ol><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ol><p>而除了粒度，锁根据模式分为：</p><ol><li><p>共享锁(S)：发生在数据查找之前，多个事务的共享锁之间可以共存</p></li><li><p>排他锁(X)：发生在数据更新之前，排他锁是一个独占锁，与其他锁都不兼容</p></li><li><p>更新锁(U)：发生在更新语句中，更新锁用来查找数据，当查找的数据不是要更新的数据时转化为S锁，当是要更新的数据时转化为X锁</p></li><li><p>意向锁：发生在较低粒度级别的资源获取之前，表示对该资源下低粒度的资源添加对应的锁，意向锁有分为：<br>　　　　意向共享锁(IS) ，意向排他锁(IX)，意向更新锁(IU)，共享意向排他锁(SIX)，共享意向更新锁(SIU)，更新意向排他锁(UIX)</p></li></ol><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><ol><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ol><p>共享锁／排他锁／更新锁一般作用在较低级别上，例如数据行或数据页，意向锁一般作用在较高的级别上，例如数据表或数据。锁是有层级结构的，若在数据行上持有排他锁的时候，则会在所在的数据页上持有意向排他锁. 在一个事务中，可能由于锁持有的时间太长或个数太多，出于节约资源的考虑，会造成锁升级；</p><p>我理解的就以最后一个SERIALIZABLE来说，开始时是设置的表级共享锁，分为表级别的而且是共享锁，表级别就是作用于整个表，不是行级别！而共享锁，则说明了其他事务也是共享锁的情况下可以共享这个表！虽然仅限于读，但这样也可能存在脏读等情况的存在，而如果换成表级排它锁，那么第一个事务在使用了这个锁之后，那其他事务连这个表的读的权限也没有，从根本上避免了各种可能的问题。</p><h5 id="各个索引引擎的情况"><a href="#各个索引引擎的情况" class="headerlink" title="各个索引引擎的情况"></a>各个索引引擎的情况</h5><ol><li><p>InnoDB（MySQL默认存储引擎 从版本5.5.5开始）<br>支持事务，行级锁，以及外键，拥有高并发处理能力。但是在创建索引和加载数据时，比MyISAM慢。默认的隔离级别是Repeatable Read（可重复读）</p></li><li><p>MyISAM<br>不支持事务和行级锁。所以速度很快，性能优秀。可以对整张表加锁，支持并发插入，支持全文索引。</p></li><li><p>MEMORY<br>支持Hash索引，内存表，Memory引擎将数据存储在内存中，表结构不是存储在内存中的，查询时不需要执行磁盘I/O操作，所以要比MyISAM和InnoDB快很多倍，<br>但是数据库断电或是重启后，表中的数据将会丢失，表结构不会丢失。</p></li></ol><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h4><p>在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，乐观锁和悲观锁，可以在一定程度上解决并发访问。</p><h4 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h4><p>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>其他知识点</p><p>悲观锁主要是共享锁或排他锁<br>共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><h4 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h4><p>是应用系统层面和数据的业务逻辑层次上的（实际上并没有加锁，只是一种锁思想），利用程序处理并发， 它假定当某一个用户去读取某一个数据的时候，其他的用户不会来访问修改这个数据，但是在最后进行事务的提交的时候会进行数据的检查，以判断在该用户的操作过程中，没有其他用户修改了这个数据。乐观锁的实现大部分都是基于版本控制实现的， 除此之外，还有CAS操作实现</p><p>其他知识点</p><p>实现乐观锁一般来说有以下2种方式：</p><p>使用版本号<br>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><p>使用时间戳<br>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p><h4 id="悲观锁与乐观锁区别与联系？"><a href="#悲观锁与乐观锁区别与联系？" class="headerlink" title="悲观锁与乐观锁区别与联系？"></a>悲观锁与乐观锁区别与联系？</h4><h4 id="悲观锁与乐观锁的使用场景？"><a href="#悲观锁与乐观锁的使用场景？" class="headerlink" title="悲观锁与乐观锁的使用场景？"></a>悲观锁与乐观锁的使用场景？</h4><p>悲观锁</p><p>比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p><p>乐观锁</p><p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p><h3 id="innodbe-和-myisim掌握"><a href="#innodbe-和-myisim掌握" class="headerlink" title="innodbe 和 myisim掌握"></a>innodbe 和 myisim掌握</h3><h3 id="三个特性-双次写，插入缓存，自适应"><a href="#三个特性-双次写，插入缓存，自适应" class="headerlink" title="三个特性(双次写，插入缓存，自适应)"></a>三个特性(双次写，插入缓存，自适应)</h3><p>InnoDB存储引擎的关键特性包括插入缓冲、两次写（double write）、自适应哈希索引（adaptive hash index）。这些特性为InnoDB存储引擎带来了更好的性能和更高的可靠性。</p><p><a href="https://blog.csdn.net/ilovemilk/article/details/80024789">详细解释跳转</a></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程并发访问某一资源的机制。</p><h4 id="mvcc-乐观锁，悲观锁"><a href="#mvcc-乐观锁，悲观锁" class="headerlink" title="mvcc(乐观锁，悲观锁)"></a>mvcc(乐观锁，悲观锁)</h4><p>mvcc主要是为了提高并发读写性能，不用枷锁就能让多个事务并发读写．</p><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol><li>从对数据操作的类型（读/写）分<br>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li><li>从对数据操作的粒度分<br>表锁<br>行锁<h4 id="行锁-行锁，零件锁，间隙锁"><a href="#行锁-行锁，零件锁，间隙锁" class="headerlink" title="行锁(行锁，零件锁，间隙锁)"></a>行锁(行锁，零件锁，间隙锁)</h4></li></ol><p>nnodb存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。<br>Innodb与MyISAM的最大不同有两点：</p><ol><li>一是支持事务（TRANSACTION）</li><li>而是采用了行级锁</li></ol><p>由于行锁支持事务，复习老知识</p><p>事务（Transaction）及其ACID属性不可分</p><h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><ol><li><p>更新丢失（Lost Update）:<br> 当两个或多个事物选择同一行，然后基于最初选定的值更新该行时，由于每个事物都不知道其事物的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事物所做的更新．<br> 如果一个程序员完成并提交事物之前，另一个程序员不能访问同一文件，则可避免此问题.</p></li><li><p>脏读<br>一个事物正对一条记录做修改，在这个事物完成并提交前，这条记录的数据就处于不一致状态，这时，另一个事物也来读取同一条记录，如果不加控制，第二个事务读取了这些”脏”数据，并据此作进一步处理，就会产生未提交的数据依赖关系．</p></li><li><p>不可重复读<br>一个事物在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变，或某些记录已经被删除了！这种现象就叫做”不可重复读”．<br>　简而言之:事物ａ读取到了事物b已经提交的修改数据，不符合隔离性．</p></li><li><p>幻读<br>一个事物按相同的查询条件重新读取以前检索过的数据，却发现其他书屋插入了满足其查询条件的新数据，这种成为”幻读”．</p></li></ol><p>简而言之:事物ａ读取到了事物ｂ提交的新增数据，不符合隔离性．</p><p>注意：<br>脏读和幻读有些类似</p><ol><li>脏读是事物b里修改了数据.</li><li>幻读是事物b里边新增了数据.</li></ol><h5 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h5><p>脏读，不可重复读和幻读，其实都是数据库一致性问题，必须由数据库提供一定的事物隔离机制来解决．</p><p>四种解决方案</p><p>读数据一致性及允许的并发副作用隔离级别　　　　　　读数据一致性　　　　　　　　脏读　　不可重复读　　幻读　<br>未提交读　　　　　　　　　　　　最低级别，只能保证不读取物理上损坏的数据　　　　Ｙ　　　Ｙ　　　　　　Ｙ<br>已提交读　　　　　　　　　　　　　　　　　　　　语句级　　　　　　　　　　　　　Ｎ　　　Ｙ　　　　　　Ｙ<br>可重复读　　　　　　　　　　　　　　　　　　　　事物级　　　　　　　　　　　　　Ｎ　　　Ｎ　　　　　　Ｙ<br>可序列化　　　　　　　　　　　　　　　　　　最高级别，事物级　　　　　　　　　　Ｎ　　　Ｎ　　　　　　Ｎ</p><p>所以说数据库的事物隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是时事物在一定程度上”串行化进行”，这显然与”并发是矛盾的”，同时，不同的应用对对一致性和事物隔离程度的要求也是不同的，比如许多应用对”不可重复读”和幻读”并不敏感”，可能更关心数据并发访问的能力．<br>常看当前数据库的事物隔离级别: show variables like ‘tx_isolation’;</p><h5 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h5><p>如果在更新数据的时候出现了强制类型转换导致索引失效，使得行锁变表锁，即在操作不同行的时候，会出现阻塞的现象。</p><h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p>什么是间隙锁：<br>当我们用范围条件而不是相等条件索引数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。<br>危害：<br>因为Query执行过程中通过范围查找的话，会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p><p>结论</p><ol><li>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。</li><li>但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能更差。</li></ol><h5 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h5><p>如何分析行锁定</p><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><p>show status like ‘innodb_row_lock%’;<br>对各个状态量的说明如下：</p><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量；<br>innodb_row_lock_time：从系统启动到现在锁定总时间长度；<br>innodb_row_lock_time_avg：每次等待所花平均时间；<br>innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间；<br>innodb_row_lock_waits：系统启动后到现在总共等待的次数。<br>对于这5个变量，比较重要的是</p><p>innodb_row_lock_time_avg（等待平均时长）<br>innodb_row_lock_waits（等待总次数）<br>innodb_row_lock_time（等待总时长）<br>这三项<br>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><p>优化建议</p><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。<br>合理设计索引，尽量缩小锁的范围。<br>尽可能减少索引条件，避免间隙锁。<br>尽量控制事务大小，减少锁定资源量和时间长度。<br>尽可能低级别事务隔离</p><h4 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h4><ol><li>开销和加锁时间介于表锁和行锁之间。</li><li>会出现死锁。</li><li>锁定粒度介于表锁和行锁之间。</li><li>并发度一般</li></ol><h4 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h4><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><ol><li>手动增加表锁:</li></ol><p>lock table 表名字 read(write), 表名字2 read(write), 其他;<br>2. 查看表上加过的锁<br>show open tables;<br>3. 释放表锁</p><p>unlock tables;<br>4. 加读锁（我们为mylock表加read锁（读阻塞写例子））</p><ol start="5"><li>加写锁（我们为mylock表加write锁（MyISAM存储引擎的写阻塞读例子））</li></ol><p>案例结论</p><p>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是帮助MySQl高效获取数据的排好序的数据结构.</p><h4 id="数据结构（B-树，B树，Hash索引，全文本索引）"><a href="#数据结构（B-树，B树，Hash索引，全文本索引）" class="headerlink" title="数据结构（B+树，B树，Hash索引，全文本索引）"></a>数据结构（B+树，B树，Hash索引，全文本索引）</h4><p>二叉树索引的弊端：如果是序列有序(索引key 值)，就变成线性查找了．比如1,2,3,4,5,6,要查找6则需要搜索六次.</p><p>红黑树索引的弊端: 数据量过大索引次数过多(过多的磁盘io不能被接受)，虽然是一种平衡状态，比二叉树更优越，但是不能够被广泛使用.</p><p>由于树的高度限制了查询的效率</p><p>进而想到的解决办法：纵向不能伸长，就横向扩张．</p><p>进而B-tree就产生了：</p><p>B-tree很难进行范围查找，没有小箭头，而且值的分布不是都在叶子节点，需要每次查找等操作．<br>还有一个就是</p><p>然而数据库的底层用的是我们曾经写过的B+Tree<br>细节讲解：</p><p>为什么每个节点的成员个数有限?<br>因为在查询的到节点，进行磁盘IO,会把该节点的数据写入ARM中,在磁盘中的查找速度非常快，跟磁盘IO时间比较可以忽略不计，但是ARM存储空间毕竟是有限的，MySql中设置的16kb<br>数据库中存储值为bigint为8b后边的指针为6b, 16kb/(8+6)b 大概是1170个索引.<br>叶子节点data是地址，假设比加大给1kb的存储空间.一个叶子节点大概16个元素.<br>那么高度为三的树能容纳 1170 * 1170 * 16 大概2100多万．<br>而且在数据库中根节点是长驻内存的，时间更快了.时间可忽略不计.</p><p>千万级数据表如何用索引快速查找？（上边即为答案）<br>b+Tree的树高可以的得到很好的控制，即使数据量很大，也能把树高维持在一个很小的数值．</p><p>b+tree:<br>    下边的小箭头就是为了支持范围查找的，是一个双向指针．解决了范围查找问题，</p><p>非叶子节点都不存data,只存储索引(冗余).可以放更多的索引，实现了等高的b-tree和<br>b+tree ,b+tree存储量非常可观．<br>就是都是三层b+tree 能存2100多万数据，b+tree就能存16<em>16</em>16 =4096个而已．</p><h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引　"></a>hash索引　</h4><p>select * from t where t.col = 2;</p><ol><li>先通过hash(2) =定位哈西散列值就是对应值的存储地址　MD5或crc16/32就是hash散列算法.</li></ol><p>hash 是不是就是说比B+tree的查找速率高呢？</p><p>单个值的查找是很快的，但是范围查找就崩了，必须遍历查找．<br>2.<br>3. </p><h4 id="逻辑索引-主键，唯一，前缀，覆盖，联合，普通"><a href="#逻辑索引-主键，唯一，前缀，覆盖，联合，普通" class="headerlink" title="逻辑索引(主键，唯一，前缀，覆盖，联合，普通)"></a>逻辑索引(主键，唯一，前缀，覆盖，联合，普通)</h4><h4 id="存储结构-聚集索引-innodbe-排序索引-myisim"><a href="#存储结构-聚集索引-innodbe-排序索引-myisim" class="headerlink" title="存储结构(聚集索引(innodbe),排序索引(myisim))"></a>存储结构(聚集索引(innodbe),排序索引(myisim))</h4><h5 id="MyISAM存储索引实现"><a href="#MyISAM存储索引实现" class="headerlink" title="MyISAM存储索引实现"></a>MyISAM存储索引实现</h5><p>注意: 存储引擎是形容数据库表的不是形容数据库的．</p><p>数据中的表的数据存储位置：根目录的DATA目录.</p><ol><li>.frm文件:表的定义和结构信息.</li><li>.MYD文件:MyISAM-date 存储的数据</li><li>.MYI文件:MyISAM-index 表的索引信息.<br>举例子：<br>select * from T  where coll = 30 ;<br>先判断数据coll有无索引，如果有索引，就去myi文件中检索，快速定位节点，由于MySql中b+Tree的叶子节点的data域存的是数据表中索引所在行的磁盘地址,就是查出地址后根据该地址在MYD文件中查找所对应的数据．</li></ol><h5 id="InnoDB索引实现-聚集"><a href="#InnoDB索引实现-聚集" class="headerlink" title="InnoDB索引实现(聚集)"></a>InnoDB索引实现(聚集)</h5><p>表结构:</p><ol><li><p>frm表: 表的定义和结构信息</p></li><li><p>ibd表: 按照B-tree组织的一个索引结构文件.</p></li><li><p>InnoDB表的主键索引　<br>是聚集的</p></li><li><p>InnoDB表的非主键索引<br>是非聚集的<br>别的位置是一样的，主要是叶子节点，存储的是主键，首先查找到主键信息，然后再从主键索引树里边找到该索引对应的信息．</p></li></ol><p>为什么InnoDB表必须要有主键，并且推荐使用整型的自增主键呢?</p><p>如果自己没有在InnoDB表中规定主键信息，系统会在数据表中找到一列没有重复信息的列，把他确定为主键，并根据该信息维护一个b+tree的主键索引信息表.<br>如果都是有重复的列，系统就会生成一个隐藏的主键列，作为主键维护信息表.<br>所以说在使用的时候定义了主键，系统会减少很多麻烦效率更高.</p><p>整型:</p><p>反义的是UUID不推荐使用既不是整形也不是自增的.</p><p>整型在比较过程中比较快（类比字符串比较）</p><p>bigint 占8个字节如果是字符串字节较多<br>数据库存储环境是高速的SSD(硬盘),价格昂贵.</p><p>主键自增问题:</p><pre><code>涉及到hash索引b+Tree 叶子节点的小箭头</code></pre><p>如果b+Tree插入的顺序不是自增的，就会存在[1,2,4,5,] 这个节点满了，在插入3的情况是就会出现，节点分裂还需要做平衡，中间节点上移的问题，树会说＂我TM裂了＂！<br>正常自增的话就不会频繁出现这样的情况，减少了平衡的操作.<br>先维护索引，再运行insert语句比较快，</p><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引　"></a>聚集索引　</h5><p>叶子节点包含了完整的数据记录<br>说白了索引和数据放在一起的.</p><h5 id="类推非聚集索引-稀疏索引"><a href="#类推非聚集索引-稀疏索引" class="headerlink" title="类推非聚集索引(稀疏索引)"></a>类推非聚集索引(稀疏索引)</h5><p>同样的MyISM 索引文件和数据文件是分离的就是非聚集的.一部分放在了MYZ一部分放在了MYD文件中.</p><p>比较:<br>单纯从聚集和非聚集索引分析，聚集索引更快.直接找到值．</p><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引　"></a>联合索引　</h5><p>就比如(a,b,c)三个联合起来构成一个索引，底层结构什么样子.</p><p>底层采用的b+tree </p><p>如何排序呢：索引最左前缀原理</p><h6 id="索引最左前缀原理"><a href="#索引最左前缀原理" class="headerlink" title="索引最左前缀原理"></a>索引最左前缀原理</h6><p>先比较第一个字段，第一个能比较大小就排序(字典序比较)，若比较不了，比较第二个．<br>注意：不可跨字段，必须按照顺序应用，才能用到联合索引.<br>原因：b+tree 的排序规则，先按照第一个字段，在比较第二个字段．．．．．如果去掉第一个字段，剩下的第二个字段绝大多数可能是无序的，如果不是一个排好序的序列，就不能作为一个索引来用.还得所有值进行一次比较操作．</p><h4 id="索引失效，索引优化，索引下推，索引回表．"><a href="#索引失效，索引优化，索引下推，索引回表．" class="headerlink" title="索引失效，索引优化，索引下推，索引回表．"></a>索引失效，索引优化，索引下推，索引回表．</h4><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h3 id="分区分库分表，主从复制．"><a href="#分区分库分表，主从复制．" class="headerlink" title="分区分库分表，主从复制．"></a>分区分库分表，主从复制．</h3><h4 id="分区分库分表"><a href="#分区分库分表" class="headerlink" title="分区分库分表"></a>分区分库分表</h4><h5 id="分表："><a href="#分表：" class="headerlink" title="分表："></a>分表：</h5><p>分表就是为了减少单个数据库表的压力，当单表数据量达到百万级别时候，无论是插入和查询对将面临瓶颈，访问变慢，引入分表也是为了减轻单表的压力，常见的分表策略</p><p>对于业务表或者用户表，可以根据业务ID或者用户ID 对表数取模、范围a~b等，以取模为例%n,将表分为n个，如tb_uesr0,tb_user1,tb_user2,tb_user3….</p><p>对于用作分析或者统计时候，例如日志表，可以根据日期分表，如tb_log20180101,tb_log20180102….</p><h5 id="分区："><a href="#分区：" class="headerlink" title="分区："></a>分区：</h5><p>分区和分表大致相同，只是将单个数据表的数据分段存放在磁盘的不同区域，对外读写还是现实一张表，由DB去西东组织数据。</p><h5 id="分库："><a href="#分库：" class="headerlink" title="分库："></a>分库：</h5><p>分表减轻的是单个数据表的数据量压力，而分库则是应对并发请求下面数据库服务器的访问压力。分库也可以选择对关键字取模的方式选择访问的数据库</p><p>存放DB= 关键字段%DB数</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>基本原理 slave会从master读取binlog来进行数据同步</p><p>MySql复制过程分为三步:<br>    1. master将改变记录到二进制日志(binary log).这些记录过程叫二进制日志事件，binary log events;<br>    2. slave 将master的binary log events拷贝到他的中继日志(relay log).<br>    3. slave重做中继日志中的时间，将改变应用到自己的数据库中，MySql复制是异步的且串行化的．</p><p>复制的基本原则:<br>    1. 每个slave只有一个master<br>    2. 每个slave只能有一个唯一的服务器ID<br>    3. 每个master可以有多个slave</p><h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制?"></a>什么是主从复制?</h4><p><a href="https://blog.csdn.net/weixin_43879074/article/details/88525006#commentBox">主从复制牛逼博主跳转和图片来源</a><br>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库，主数据库一般是准实时的业务数据库。您看，像在mysql数据库中，支持单项、异步赋值。在赋值过程中，一个服务器充当主服务器，而另外一台服务器充当从服务器。此时主服务器会将更新信息写入到一个特定的二进制文件中。并会维护文件的一个索引用来跟踪日志循环。这个日志可以记录并发送到从服务器的更新中去。当一台从服务器连接到主服务器时，从服务器会通知主服务器从服务器的日志文件中读取最后一次成功更新的位置。然后从服务器会接收从哪个时刻起发生的任何更新，然后锁住并等到主服务器通知新的更新</p><h5 id="主从复制的作用（好处，或者说为什么要做主从）重点？"><a href="#主从复制的作用（好处，或者说为什么要做主从）重点？" class="headerlink" title="主从复制的作用（好处，或者说为什么要做主从）重点？"></a>主从复制的作用（好处，或者说为什么要做主从）重点？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p> 1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）<br>  2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）<br>   3–当主服务器出现问题时，可以切换到从服务器。（提升性能）</p><h5 id="主从复制的原理？"><a href="#主从复制的原理？" class="headerlink" title="主从复制的原理？"></a>主从复制的原理？</h5><p>一步能让你清晰理解操作的目的</p><p>   1.数据库有个bin-log二进制文件，记录了所有sql语句。</p><p>   2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。</p><p>   3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。</p><p>   4.下面的主从配置就是围绕这个原理配置</p><p>   5.具体需要三个线程来操作：</p><p>   1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：<br>   2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p><p>   3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p><pre><code>可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。</code></pre><h5 id="主从复制的好处？"><a href="#主从复制的好处？" class="headerlink" title="主从复制的好处？"></a>主从复制的好处？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p> 好处一:实现服务器负载均衡</p><p> 通过服务器复制功能，可以在主服务器和从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好地客户相应时间。通常情况下，数据库管理员会有两种思路。</p><p> 一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询。将数据更新与查询分别放在不同的服务器 上进行，即可以提高数据的安全性，同时也缩短应用程序的响应时间、提高系统的性能。</p><p> 二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作 业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。当然，像修改数据、插入数 据、删除数据等语句仍然会发送到主服务器中，以便主服务器和从服务器数据的同步。</p><p>  好处二：通过复制实现数据的异地备份</p><p>  可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。</p><p>  而如果使用复制来实现对数据的备份，就可以在从服务器上对数据进行备份。此时不仅不会干扰主服务气的正常运行，而且在备份过程中主服务器可以继 续处理相关的更新作业。同时在数据复制的同时，也实现了对数据的异地备份。除非主服务器和从服务器的两块硬盘同时损坏了，否则的话数据库管理员就可以在最 短时间内恢复数据，减少企业的由此带来的损失。</p><p>   好处三：提高数据库系统的可用性</p><p>   数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。</p><p>   一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道理。</p><p>   二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患。</p><h5 id="从数据库的读的延迟问题了解吗？如何解决？"><a href="#从数据库的读的延迟问题了解吗？如何解决？" class="headerlink" title="从数据库的读的延迟问题了解吗？如何解决？"></a>从数据库的读的延迟问题了解吗？如何解决？</h5><p>主库宕机后，数据可能丢失<br>从库只有一个sql Thread，主库写压力大，复制很可能延时<br>解决方法：</p><ol><li>半同步复制—解决数据丢失的问题</li></ol><p>半同步复制:　<br>就是在master 端放了wait_ack, 在slave端放了ack发送功能，在文件relay_log中写完数据后，发送一个确认ack,等收到ack在进行客户端的反馈．</p><ol start="2"><li><p>并行复制—-解决从库复制延迟的问题<br><a href="https://www.cnblogs.com/caicz/p/11009528.html">参考博客</a></p></li><li><p>那么如何并行化，并行IO线程，还是并行SQL线程？<br>其实两方面都可以并行，但是并行SQL线程的收益更大，因为SQL线程做的事情更多(解析，执行)。并行IO线程，可以将从Master拉取和写Relay lomZ分为两个线程；并行SQL线程则可以根据需要做到库级并行，表级并行，事务级并行。库级并行在mysql官方版本5.6已经实现。并行复制框架实际包含了一个协调线程和若干个工作线程，协调线程负责分发和解决冲突，工作线程只负责执行。</p></li><li><p>并行复制如何处理冲突？</p></li></ol><p>并发的世界是美好的，但不能乱并发，否则数据就乱了。Master上面通过锁机制来保证并发的事务有序进行，那么并行复制呢？Slave必需保证回放的顺序与Master上事务执行顺序一致，因此只要做到顺序读取binlog，将不冲突的事务并发执行即可。对于库级并发而言，协调线程要保证执行同一个库的事务放在一个工作线程串行执行；对于表级并发而言，协调线程要保证同一个表的事务串行执行；对于事务级而言，则是保证操作同一行的事务串行执行。</p><ol start="3"><li>是否粒度越细，性能越好？</li></ol><p>这个并不是一定的。相对于串行复制而言，并行复制多了一个协调线程。协调线程一个重要作用是解决冲突，粒度越细的并发，可能会有更多的冲突，最终可能也是串行执行的，但消耗了大量的冲突检测代价。</p><p>并行复制:<br>    在relay_log库信息读取操作转换为数据的过程中，采用多线程，执行效率增加．</p><h5 id="主从复制和主主复制区别？"><a href="#主从复制和主主复制区别？" class="headerlink" title="主从复制和主主复制区别？"></a>主从复制和主主复制区别？</h5><p>最大区别是<br>主从是对主操作数据，从会实时同步数据。反之对从操作，主不会同步数据，还有可能造成数据紊乱，导致主从失效。 主主则是无论对那一台操作，另一个都会同步数据。一般用作高容灾方案 </p><p><a href="https://blog.csdn.net/qq_22222499/article/details/79060495">以下部分参考网站</a></p><h3 id="2-数据库隔离级别"><a href="#2-数据库隔离级别" class="headerlink" title="2.数据库隔离级别"></a>2.数据库隔离级别</h3><p>多个事务读可能会道理以下问题<br>脏读：事务B读取事务A还没有提交的数据<br>不可重复读：，一行被检索两次，并且该行中的值在不同的读取之间不同时<br>幻读:当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时<br>这两个区别在于，不可重复读重点在一行，幻读的重点 ，返回 的集合不一样</p><h3 id="3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"><a href="#3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景" class="headerlink" title="3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"></a>3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</h3><p>引擎　　　　　　　　　　特性<br>MYISAM<br>　　　　　　　　　　　　不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描<br>INNODB<br>　　　　　　　　　　　　支持外键，行锁，查表总行数时，全表扫描</p><h3 id="4-索引有B-索引和hash索引"><a href="#4-索引有B-索引和hash索引" class="headerlink" title="4.索引有B+索引和hash索引"></a>4.索引有B+索引和hash索引</h3><p>索引　　　　　　　　　　区别<br>Hash<br>　　　　　　　　　　　　hash索引，等值查询效率高，不能排序,不能进行范围查询<br>B+<br>　　　　　　　　　　　　数据有序,范围查询</p><h3 id="5-聚集索引和非聚集索引"><a href="#5-聚集索引和非聚集索引" class="headerlink" title="5.聚集索引和非聚集索引"></a>5.聚集索引和非聚集索引</h3><p>索引　　　　　　　　　　区别<br>聚集索引<br>　　　　　　　　　　　　数据按索引顺序存储，中子结点存储真实的物理数据<br>非聚集索引<br>　　　　　　　　　　　　存储指向真正数据行的指针</p><h3 id="6-索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#6-索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="6.索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>6.索引的优缺点，什么时候使用索引，什么时候不能使用索引</h3><ol><li>索引最大的好处是提高查询速度，</li><li>缺点是更新数据时效率低，因为要同时更新索引</li><li>对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。</li></ol><h3 id="7-InnoDB索引和MyISAM索引的区别"><a href="#7-InnoDB索引和MyISAM索引的区别" class="headerlink" title="7.InnoDB索引和MyISAM索引的区别"></a>7.InnoDB索引和MyISAM索引的区别</h3><p>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主</p><h3 id="8-索引的底层实现（B-树，为何不采用红黑树，B树）重点"><a href="#8-索引的底层实现（B-树，为何不采用红黑树，B树）重点" class="headerlink" title="8.索引的底层实现（B+树，为何不采用红黑树，B树）重点"></a>8.索引的底层实现（B+树，为何不采用红黑树，B树）重点</h3><p>树                                 区别<br>红黑树<br>                                   增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间</p><p>B树也就是B-树<br>                                   B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。</p><p>B+树<br>                                   B+树相比较于另外两种树,显得更矮更宽，查询层次更浅</p><h3 id="9-B-树的实现"><a href="#9-B-树的实现" class="headerlink" title="9.B+树的实现"></a>9.B+树的实现</h3><p>一个m阶的B+树具有如下几个特征：</p><ol><li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li></ol><h3 id="10-为什么使用B-Tree"><a href="#10-为什么使用B-Tree" class="headerlink" title="10.为什么使用B+Tree"></a>10.为什么使用B+Tree</h3><ol><li>索引查找过程中就要产生磁盘I/O消耗,主要看IO次数，和磁盘存取原理有关。</li><li>根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，</li><li>将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入<br>局部性原理与磁盘预读</li></ol><h3 id="11-Sql的优化"><a href="#11-Sql的优化" class="headerlink" title="11.Sql的优化"></a>11.Sql的优化</h3><p>1.sql尽量使用索引,而且查询要走索引</p><p>2.对sql语句优化</p><ol><li>子查询变成left join</li><li>limit 分布优化，先利用ID定位，再分页</li><li>or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）</li><li>不必要的排序</li><li>where代替having,having 检索完所有记录，才进行过滤</li><li>避免嵌套查询</li><li>对多个字段进行等值查询时，联合索引</li></ol><h3 id="12-索引最左前缀问题"><a href="#12-索引最左前缀问题" class="headerlink" title="12.索引最左前缀问题"></a>12.索引最左前缀问题</h3><p>如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了</p><h3 id="13-索引分类，索引失效条件"><a href="#13-索引分类，索引失效条件" class="headerlink" title="13.索引分类，索引失效条件"></a>13.索引分类，索引失效条件</h3><p>索引类型　　　　　　　　　　　　　　　　　　概念<br>普通索引　　　　　　　　　　　　　最基本的索引，没有任何限制<br>唯一索引　　　　mZZ<br>失效条件:</p><p>条件是or,如果还想让or条件生效，给or每个字段加个索引<br>like查询，以%开发<br>内部函数<br>对索引列进行计算<br>is null不会用，is not null 会用</p><h3 id="14-数据库的主从复制"><a href="#14-数据库的主从复制" class="headerlink" title="14.数据库的主从复制"></a>14.数据库的主从复制</h3><p>复制方式：操作.</p><ol><li>异步复制：<br>默认异步复制，容易造成主库数据和从库不一致,一个数据库为Master,一个数据库为slave,通过Binlog日志,slave两个线程，一个线程去读master binlog日志，写到自己的中继日志一个线程解析日志，执行sql,master启动一个线程,给slave传递binlog日志</li><li>半同步复制: 只有把master发送的binlog日志写到slave的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低</li><li>并行操作:slave 多个线程去请求binlog日志</li></ol><h3 id="15-long-query怎么解决"><a href="#15-long-query怎么解决" class="headerlink" title="15.long_query怎么解决"></a>15.long_query怎么解决</h3><p>设置参数，开启慢日志功能，得到耗时超过一定时间的sql</p><h3 id="16-varchar和char的使用场景"><a href="#16-varchar和char的使用场景" class="headerlink" title="16.varchar和char的使用场景"></a>16.varchar和char的使用场景</h3><p>类型           使用场景<br>varchar        字符长度经常变的<br>char           用字符长度固定的</p><h3 id="17-数据库连接池的作用"><a href="#17-数据库连接池的作用" class="headerlink" title="17.数据库连接池的作用"></a>17.数据库连接池的作用</h3><p>维护一定数量的连接，减少创建连接的时间<br>更快的响应时间<br>统一的管理</p><h3 id="19-分库分表，主从复制，读写分离"><a href="#19-分库分表，主从复制，读写分离" class="headerlink" title="19.分库分表，主从复制，读写分离"></a>19.分库分表，主从复制，读写分离</h3><p>读写分离，读从库，写主库<br>spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。</p><h3 id="20-数据库三范式"><a href="#20-数据库三范式" class="headerlink" title="20.数据库三范式"></a>20.数据库三范式</h3><p>级别　　　　　　　　　　　　概念<br>1NF　　　　　　　　　　　　属性不可分<br>2NF　　　　　　　　　　　　非主键属性，完全依赖于主键属性<br>3NF　　　　　　　　　　　　非主键属性无传递依赖</p><h3 id="21-关系型数据库和非关系型数据库区别"><a href="#21-关系型数据库和非关系型数据库区别" class="headerlink" title="21.关系型数据库和非关系型数据库区别"></a>21.关系型数据库和非关系型数据库区别</h3><p>关系型数据库</p><p>优点：</p><p>1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</p><p>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。<br>5.支持事务</p><p>缺点<br>1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、不支持高并发读写需求；<br>4、不支持海量数据的高效率读写</p><p>非关系型数据库</p><p>1、使用键值对存储数据；<br>2、分布式；<br>优点<br>无需经过sql层的解析，读写性能很高<br>基于键值对，数据没有耦合性，容易扩展<br>存储数据的格式：nosql的存储格式是key,value形式<br>缺点<br>不提供sql支持</p><h3 id="22-数据库中join的left-join-inner-join-cross-join"><a href="#22-数据库中join的left-join-inner-join-cross-join" class="headerlink" title="22.数据库中join的left join , inner join, cross join"></a>22.数据库中join的left join , inner join, cross join</h3><ol><li><p>以A，B两张表为例<br>A left join B<br>选出A的所有记录，B表中没有的以null 代替<br>right join 同理</p></li><li><p>inner join<br>A,B有交集的记录</p></li><li><p>cross join (笛卡尔积)<br>A中的每一条记录和B中的每一条记录生成一条记录<br>例如A中有4条，B中有4条，cross join 就有16条记录</p></li></ol><h3 id="23-有哪些锁-select时怎么加排它锁"><a href="#23-有哪些锁-select时怎么加排它锁" class="headerlink" title="23.有哪些锁,select时怎么加排它锁"></a>23.有哪些锁,select时怎么加排它锁</h3><p>锁　　　　　　　　　　　　　　　　　　　概念<br>乐观锁　　　　　　　　　　　　　　　　　自己实现，通过版本号<br>悲观锁　　　　　　　　　　　　　　　　　共享锁，多个事务，只能读不能写，加 lock in share mode<br>排它锁　　　　　　　　　　　　　　　　　一个事务，只能写，for update<br>行锁　　　　　　　　　　　　　　　　　　作用于数据行<br>表锁　　　　　　　　　　　　　　　　　　作于用表</p><h3 id="24-死锁怎么解决"><a href="#24-死锁怎么解决" class="headerlink" title="24.死锁怎么解决"></a>24.死锁怎么解决</h3><p>找到进程号，kill 进程</p><h3 id="25-最左匹配原则"><a href="#25-最左匹配原则" class="headerlink" title="25.最左匹配原则"></a>25.最左匹配原则</h3><p>最左匹配原则是针对索引的<br>举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的，<br>这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了，<br>查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗，<br>按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="优化" scheme="http://example.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>balance-tree</title>
    <link href="http://example.com/posts/26821/"/>
    <id>http://example.com/posts/26821/</id>
    <published>2020-10-24T06:06:20.000Z</published>
    <updated>2020-10-27T02:06:58.973Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在绝望的时候才会尽最大的努力!</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B_tree"></a>B_tree</h3><p>全名为balance_tree(平衡多路查找树)，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而B_tree有多条路，即父节点有多个子节点。</p><h4 id="B-树用途"><a href="#B-树用途" class="headerlink" title="B-树用途"></a>B-树用途</h4><p>使用B_tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。</p><h4 id="B-tree定义及结构"><a href="#B-tree定义及结构" class="headerlink" title="B_tree定义及结构"></a>B_tree定义及结构</h4><h4 id="B-tree定义"><a href="#B-tree定义" class="headerlink" title="B_tree定义"></a>B_tree定义</h4><ol><li>树中每个节点至多有m棵子树(m表示树的阶数)</li><li>根前节点不是叶子节点,则至少有两棵子树(根节点必须俩儿子).</li><li>除根节点之外的所有非叶子节点至少有p个子节点([m/2] &lt;= p &lt;= m,[m/2]向上取整).或者[(m+1)/2].</li><li>所有的非叶子结点中包含以下数据：（n，A0，K1，A1，K2，…，Kn，An）<br>其中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ki（i&#x3D;1,2,…,n）为关键码，且Ki&lt;Ki+1（注：ki是真实数据，存放在线性表当中，且从左至右升序排列）</span><br><span class="line"></span><br><span class="line">Ai 为指向儿子的指针(i&#x3D;0,1,…,n)，且指针Ai-1 所指子树中所有结点的关键码均小于Ki (i&#x3D;1,2,…,n)，An 所指子树中所有结点的            关键码均大于Kn。（注：每个ki数据两旁各安放了一个指针，即Ai-1和Ai，左边的子树数据统统小于ki，右边子树的数据统             统大于ki）（注：总体来看指针数量比数据数量多1）</span><br><span class="line"></span><br><span class="line"> n 为关键码的个数（[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m - 1）。</span><br></pre></td></tr></table></figure></li><li> 所有的叶子结点都出现在同一层次上，即所有叶节点具有相同的深度，等于树高度。并且不带信息（可以看作是外部结点或查找失<br>败的结点，实际上这些结点不存在，指向这些结点的指针为空）。</li></ol><h4 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h4><ol><li>B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</li></ol><h4 id="B-tree和二叉树和红黑树的不同点"><a href="#B-tree和二叉树和红黑树的不同点" class="headerlink" title="B_tree和二叉树和红黑树的不同点"></a>B_tree和二叉树和红黑树的不同点</h4><p>与二叉树:</p><ol><li><p>二叉树节点中保存的数据只有一个，而B_树得节点中保存的是线性表，真实数据数据不止一个有很多。由于表中的指针和子节点一一对应，而子节点个数又有限定([m/2] &lt;= p &lt;= m,[m/2]向上取整)，又因为真实数据数量又比指针少一个所以真实数据也就有了限定（\left \lceil m/2 \right \rceil-1\leqslant n\leqslant m-1）。</p></li><li><p>二叉树至多有两个儿子节点，而B-树至多有m个节点（m为树的阶）</p></li></ol><p>与红黑树:<br>    不同在于：B树的节点可以有很多子女，从几个到几万个不等，<br>    相同：一颗含有n个节点的B树高度和红黑树是一样的，都是O（lgn）。</p><h4 id="B-tree和B-tree结构操作"><a href="#B-tree和B-tree结构操作" class="headerlink" title="B_tree和B+tree结构操作"></a>B_tree和B+tree结构操作</h4><p>小编传不了图片,但是我找到了一个特别全很牛逼的网站，作为歉意！<br><a href="https://www.bilibili.com/video/BV1vQ4y1N79m?p=1">简述构造树遵循的规则</a>：<br>以五叉BTree为例，key的数量公式推导<br>ceil(m/2)-1 &lt;= n &lt;= m-1,所以2 &lt;= n &lt;= 4,当n &gt; 4时，中间节点上升进入父节点，两边节点裂开．</p><ol><li><p>插入字母C,N,G,A,H,K.Q.M.F,W,L,T,Z,D,P,R,X,Y,S数据为例．<br>注意每组元素下边都有一组数组.length()+1个下标.<br>插入前四个字母: [A,C,G,H]</p></li><li><p>插入H,n&gt;4,中间元素G字母向上分裂到新的节点(晋升为父节点)<br>　　[G]<br>[A|C]　[H|N]</p></li><li><p>插入E,K,Q不需要分裂　<br>　　　[G]<br>[A|C|E]　[H|K|N|Q]</p></li><li><p>插入M,中间元素M字母向上分裂到父节点G　<br>　　　　[G|M]<br>[A|C|E]　[H|K]　 [NQ]</p></li><li><p>插入F,W,L,T不需要分裂<br>　　　　　[G|M]<br>[A|C|E|F]　[H|K|L]　[N|Q|T|W]</p></li><li><p>插入Z,中间元素T先上分裂到父节点中</p></li></ol><p>　　　　　　　[G|M|T]<br>[A|C|E|F]　[H|K|L]　[N|Q]　[W|Z]</p><p>以此类推最后建成.</p><p><a href="https://www.cnblogs.com/guohai-stronger/p/9225057.html">结构和各种操作</a></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h3 id="M阶B-数特点"><a href="#M阶B-数特点" class="headerlink" title="M阶B+数特点"></a>M阶B+数特点</h3><p>在mysql中增加了叶子节点前后指针(进行了B+tree的优化).提高区间访问的效率)</p><ol><li>有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成一个链表）。</li><li>所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</li><li>同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</li></ol><h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><ol><li>所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li><li>b+树的中间节点不保存数据，能容纳更多节点元素。</li></ol><h4 id="B-树的时间复杂度"><a href="#B-树的时间复杂度" class="headerlink" title="B+树的时间复杂度"></a>B+树的时间复杂度</h4><h3 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h3><ol><li><p>B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。</p></li><li><p>B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</p></li><li><p>B树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m-1%5D">m/2(向上取整)-1,m-1</a>，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m%5D">m/2(向上取整),m</a>，具有n个关键字的节点包含（n）棵子树。</p></li><li><p>B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。</p></li></ol><h3 id="B树和B-树的共同优点"><a href="#B树和B-树的共同优点" class="headerlink" title="B树和B+树的共同优点"></a>B树和B+树的共同优点</h3><p>考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Data_Sturctures" scheme="http://example.com/tags/Data-Sturctures/"/>
    
  </entry>
  
  <entry>
    <title>bug</title>
    <link href="http://example.com/posts/42182/"/>
    <id>http://example.com/posts/42182/</id>
    <published>2020-10-14T03:38:06.000Z</published>
    <updated>2020-10-14T04:15:50.162Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有的人走错一步就回来,有的人一直错,——–子弹上膛（小庄）<br>由于python2不能导入request包,所以升级为python3.</p><p>Ubuntu下将python从2.7.12升级到3.5.2</p><p>１．我们在Ubuntu中使用Ctrl+Alt+T  快捷键 调出 终端窗口。然后在终端中输入Python,查看当前版本.<br>２．在上面的步骤中，我们看到我们的Python版本是2.7.12 这是Ubuntu中默认安装的Python版本 。接下来我们执行 sudo apt-get install python3 命令 这时候 终端会提示我们需要管理员密码 输入即可。<br>３．稍等片刻 我们的Python3 已经安装完成了 ，但是如果这时候我们输入Python并且回车 我们会发现 我们的Python版本仍然是2.7.12 这个时候我们需要切换Python的版本。</p><p>我们在终端中输入 alias python=python3  回车  </p><p>然后我们再输入Python 这个时候的版本就已经变成Python3了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python环境问题" scheme="http://example.com/categories/python%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider2</title>
    <link href="http://example.com/posts/40133/"/>
    <id>http://example.com/posts/40133/</id>
    <published>2020-10-13T13:57:29.000Z</published>
    <updated>2020-10-14T08:00:33.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>精神,唯一的财富,其它都是虚的。——袁朗．<br>爬虫实战应用<br><a href="https://blog.csdn.net/qq_21933615/article/details/81171951">Python中BeautifulSoup库的用法</a></p><p><a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/">官方文档</a><br>以上都是爬虫的预备知识，掌握了之后就可以写代码去爬取我们想要爬的网站了。</p><p>Python提供了许多网络请求的库，比如Requests、urllib等，这里只说一下requests库</p><p>Requests库.</p><p>安装：pip(3) install requests</p><p>基本使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 发送 GET 请求获取响应</span><br><span class="line">response &#x3D; requests.get(url)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response常用属性：</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line">response.text 返回响应内容，响应内容为 str 类型</span><br><span class="line">respones.content 返回响应内容,响应内容为 bytes 类型</span><br><span class="line">response.status_code 返回响应状态码</span><br><span class="line">response.request.headers 返回请求头</span><br><span class="line">response.headers 返回响应头</span><br><span class="line">response.cookies 返回响应的 RequestsCookieJar 对象</span><br><span class="line"># 获取字节数据</span><br><span class="line">content &#x3D; response.content</span><br><span class="line"># 转换成字符串类型</span><br><span class="line">html &#x3D; content.decode(&#39;utf-8&#39;)</span><br></pre></td></tr></table></figure><p>自定义请求头.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 发送自定义请求头</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送Get请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 GET 请求参数</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 GET 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,params&#x3D;params)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送POST请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义post请求参数</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.post(url,headers&#x3D;headers,data&#x3D;data)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>为什么使用代理：1、让服务器以为请求是从多个客户端发出的。2、防止暴露我们的真实地址<br>代理作为中间量简介链接客户端和服务器.</p><p>使用方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 代理服务器</span><br><span class="line">proxies &#x3D; &#123;</span><br><span class="line">    &quot;http&quot;:&quot;http:&#x2F;&#x2F;IP地址:端口号&quot;,</span><br><span class="line">    &quot;https&quot;:&quot;https:&#x2F;&#x2F;IP地址:端口号&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,proxies&#x3D;proxies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求中携带cookie</p><p>作用：有些网站需要登录，这时候cookie就是记录了你的用户信息</p><p>方式：</p><p>直接在自定义请求头中携带</p><p>通过请求参数携带cookie</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line">    # 方式一：直接在请求头中携带Cookie内容</span><br><span class="line">    &quot;Cookie&quot;: &quot;Cookie值&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 方式二：定义 cookies 值</span><br><span class="line">cookies &#x3D; &#123;</span><br><span class="line">    &quot;xx&quot;:&quot;yy&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,cookies&#x3D;cookies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据提取</p><p>作用：从爬虫获取的数据中提取出我们想要的数据</p><p>方式：<br>json模块提取<br>xpath提取<br>正则提取<br>beautifulsoup<br>１．json.<br>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式<br>json.loads json字符串 转 Python数据类型<br>json.dumps Python数据类型 转 json字符串<br>json.load json文件 转 Python数据类型<br>json.dump Python数据类型 转 json文件<br>ensure_ascii=False 实现让中文写入的时候保持为中文<br>indent=空格数 通过空格的数量进行缩紧<br>２．xpath.<br>XPath 全称： XML Path Language，是一门在 XML 文档中查找信息的语言。<br>XPath 可用来在 XML 文档中对元素和属性进行遍历。<br>安装：pip(3) install lxml</p><p>常用规则：<br>表达式———–描述——–<br>nodename——–选取此节点的所有子节点<br>/—————-从当前节点选取直接子节点<br>//—————从当前节点选取子孙节点<br>.—————-选取当前节点<br>..—————选取当前节点的父节点<br>@—————-选取属性</p><p>正则；</p><p>Python中通过正则表达对字符串进行匹配是，可以使用re模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入re模块</span><br><span class="line">import re</span><br><span class="line"># 使用match方法进行匹配操作</span><br><span class="line">result &#x3D; re.match(正则表达式,要匹配的字符串)</span><br><span class="line"># 如果上一步匹配到数据的话，可以使用group方法来提取数据</span><br><span class="line">result.group()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/116509288">常用语法：</a></p><p><em>————-匹配前一个字符0次或无限次，例abc</em>,能匹配字符abccccc,<br>+————-匹配前一个字符1次或无限次，例abc+,能匹配字符abccccc,<br>?————-匹配前一个字符0次或一次，例abc?,能匹配字符abc或ab,<br>{m}————-匹配前一个字符m次，例ab{2}c,能匹配字符abbc,<br>\d————-说明:数字[0-9]</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫实战应用" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider1</title>
    <link href="http://example.com/posts/40325/"/>
    <id>http://example.com/posts/40325/</id>
    <published>2020-10-13T12:20:14.000Z</published>
    <updated>2020-10-14T02:55:03.194Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好好活就是做有意义的事,有意义的事就是好好活。 —–送给短暂渺茫的你（许三多）</p><p>爬虫思路</p><p>1：什么是爬虫</p><p>爬虫(spider，又网络爬虫)，是指向网站/网络发起请求，获取资源后分析并提取有用数据的程序。</p><p>从技术层面来说就是 通过程序模拟浏览器请求站点的行为.</p><p>把站点返回的HTML代码/JSON数据/二进制数据（图片、视频） 爬到本地，进而提取自己需要的数据，存放起来使用。</p><p>2：入门爬虫的干货</p><p>2.1： 爬虫的基本思路</p><p>通过URL或者文件获取网页，<br>分析要爬取的目标内容所在的位置<br>用元素选择器快速提取(Raw) 目标内容<br>处理提取出来的目标内容 （ 通常整理合成一个 Json）<br>存储处理好的目标内容 （比如放到 MongoDB 之类的数据库，或者写进文件里。）<br>爬虫流程:<br>发送请求-&gt;获取响应内容-&gt;解析内容-&gt;保存数据</p><p>robots协议：</p><p>网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，但它仅仅是道德层面上的约束</p><p>爬虫的用途：</p><p>1、12306抢票<br>2、短信轰炸<br>3、网络投票<br>4、监控数据<br>5、下载图片、小说、视频、音乐等</p><p>Http和Https：<br>发送请求，获取响应的过程其实就是发送Http或者Https请求和响应的过程。<br>HTTP</p><p>超文本传输协议<br>默认端口号:80<br>HTTPS</p><p>HTTP + SSL(安全套接字层)，即带有安全套接字层的超本文传输协议<br>默认端口号：443</p><p>作用：在传输过程中对数据进行加密，防止被窜改</p><p>区别：http因不需要加密，所以性能更高，但安全性差。</p><p>https安全性高，但是占用服务器资源</p><p>但是Https是未来的主流，比如小程序、ios、android客户端的接口都需要Https接口支持.</p><p>Http请求报文和状态码：参考上一个博客.<br>常见的HTTP状态码：<br>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它 URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p><p>常见请求头：</p><p>Cookie——————–作用—–Cookie<br>User-Agent—————-作用—–浏览器名称<br>Referer——————-作用—–页面跳转处<br>Host———————-作用—–主机和端口号<br>Connection—————-作用—–链接类型<br>Upgrade-Insecure-Requests-作用—–升级为HTTPS<br>Accept——————–作用—–传输文件类型<br>Accept-Encoding———–作用—–文件编解码格式<br>x-Requests-with:XMLHttpRequest作用ajax请求</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web_spider</title>
    <link href="http://example.com/posts/50097/"/>
    <id>http://example.com/posts/50097/</id>
    <published>2020-10-13T04:18:51.000Z</published>
    <updated>2020-10-13T08:03:26.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>高成：我酒量一斤，陪你二斤吧．<br>袁朗: 我酒量二两，陪你喝舍命!</p><p>爬虫技术基础<br>—–替代繁琐的操作，程序化实现.<br><a href="https://www.cnblogs.com/ranyonsue/p/5984001.html">参考网站</a><br><a href="https://www.cnblogs.com/an-wen/p/11180076.html">参考网站</a></p><h3 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h3><p>(非重点)<br>历史有兴趣可看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</span><br><span class="line"></span><br><span class="line">HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</span><br><span class="line"></span><br><span class="line">2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP&#x2F;2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP&#x2F;2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</span><br></pre></td></tr></table></figure><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><h3 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h3><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B/S及C/S模式。</p><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤：</p><p>１．客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.luffycity.com./">http://www.luffycity.com。</a></p><p>２．发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>３．服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>４．释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>５．客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><p>1.浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2.解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5.释放 TCP连接;<br>6.浏览器将该 html 文本并显示内容; 　</p><h4 id="http协议是基于TCP-IP协议之上的应用层协议。"><a href="#http协议是基于TCP-IP协议之上的应用层协议。" class="headerlink" title="http协议是基于TCP/IP协议之上的应用层协议。"></a>http协议是基于TCP/IP协议之上的应用层协议。</h4><h4 id="基于-请求-响应-的模式"><a href="#基于-请求-响应-的模式" class="headerlink" title="基于 请求-响应 的模式"></a>基于 请求-响应 的模式</h4><p>　　HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应</p><h4 id="无状态保存"><a href="#无状态保存" class="headerlink" title="无状态保存"></a>无状态保存</h4><p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。<br>　　　　使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。有关Cookie的详细内容稍后讲解。</p><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><p>GET<br>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p><p>HEAD<br>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p><p>POST<br>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><p>PUT<br>向指定资源位置上传其最新内容。</p><p>DELETE<br>请求服务器删除Request-URI所标识的资源。</p><p>TRACE<br>回显服务器收到的请求，主要用于测试或诊断。</p><p>OPTIONS<br>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p><p>CONNECT<br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。<br>注意事项：<br>1.方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。<br>2.HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源。<br>请求方式: get与post请求（通过form表单我们自己写写看）</p><p>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中.</p><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>GET与POST请求在服务端获取请求数据方式不同，就是我们自己在服务端取请求数据的时候的方式不同了，这句废话昂</p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><p>1.-1xx消息——请求已被服务器接收，继续处理<br>2.-2xx成功——请求已成功被服务器接收、理解、并接受<br>3.-3xx重定向——需要后续操作才能完成这一请求<br>4.-4xx请求错误——请求含有词法错误或者无法被执行<br>5.-5xx服务器错误——服务器在处理某个正确请求时发生错误<br>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p><h4 id="URL-基本解释"><a href="#URL-基本解释" class="headerlink" title="URL(基本解释)"></a>URL(基本解释)</h4><p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p><p>传送协议。<br>层级URL标记符号(为[//],固定不变)<br>访问资源需要的凭证信息（可省略）<br>服务器。（通常为域名，有时为IP地址）<br>端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）<br>路径。（以“/”字符区别路径中的每一个目录名称）<br>查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）<br>片段。以“#”字符为起点<br>以<a href="http://www.luffycity.com/news/index.html?id=250&amp;page=1">http://www.luffycity.com:80/news/index.html?id=250&amp;page=1</a> 为例, 其中：</p><p>http，是协议；<br><a href="http://www.luffycity.com,是服务器;/">www.luffycity.com，是服务器；</a><br>80，是服务器上的默认网络端口号，默认不显示；<br>/news/index.html，是路径（URI：直接定位到对应的资源）；<br>?id=250&amp;page=1，是查询。<br>大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（<a href="http://www.luffycity.com/news/index.html?id=250&amp;page=1%EF%BC%89%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">www.luffycity.com:80/news/index.html?id=250&amp;page=1）就可以了。</a></p><p>由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务。</p><h4 id="URL划分部分解释"><a href="#URL划分部分解释" class="headerlink" title="URL划分部分解释"></a>URL划分部分解释</h4><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p><p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a><br>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p><p>2.域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></p><p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p><p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p><p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p><p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p><p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p><p>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p><h4 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h4><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br><a href="https://www.cnblogs.com/an-wen/p/11180076.html">HTTP请求格式(请求协议)</a></p><h4 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h4><p>GET请求<br>GET /books/?sex=man&amp;name=Professional HTTP/1.1<br>Host: <a href="http://www.wrox.com/">www.wrox.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Connection: Keep-Alive<br>注意最后一行是空行</p><p>POST请求<br>POST / HTTP/1.1<br>Host: <a href="http://www.wrox.com/">www.wrox.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 40<br>Connection: Keep-Alive</p><p>name=Professional%20Ajax&amp;publisher=Wiley<br>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p><p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p><p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变<br>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p><p>而在实际开发中存在的限制主要有：</p><p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p><p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p><p>POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p><p>3、安全性</p><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p><p>4、Http get,post,soap协议都是在http上运行的</p><p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p><p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p><p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><p>我们看看GET和POST的区别</p><p>１．GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p><p>２．GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>３．GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p><p>４．GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>mysql1</title>
    <link href="http://example.com/posts/15411/"/>
    <id>http://example.com/posts/15411/</id>
    <published>2020-10-13T02:46:27.000Z</published>
    <updated>2020-10-31T01:04:46.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果你想拥有你从未有过的东西，那么你必须去做你从未做过的事情。－－－向羽．</p><p>数据库底层请看B+树</p><p>首先引荐一个挺全的<a href="https://www.cnblogs.com/cainiao-chuanqi/p/11191647.html">数据库基础知识</a><br>书写顺序:<br>    select (distinct])<br>    from<br>    join（如left join）<br>    on<br>    where<br>    group by<br>    having<br>    union<br>    order by<br>    limit<br>执行顺序:<br>    from<br>    on<br>    join<br>    where<br>    group by<br>    having<br>    select<br>    distinct<br>    union<br>    order by </p><h3 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h3><ol><li>持久化数据库到本地</li><li>可以实现结构化查询，方便管理.</li></ol><h3 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h3><p>DB:</p><p>数据库(database); 存储数据的”仓库”，它保存了一系列有组织的数据的容器.</p><p>DBMS:</p><p>数据库管理系统(database Management System),数据库通过DBMS创建和操作的容器．管理DB中的数据.</p><p>SQL:</p><p>结构化查询语言(Structure Query Language):专门用于数据库通信的语言.</p><p>SQL的优点:<br>    1. 不是某个特定数据库供应商专有的语言，几乎所有的DBMS都支持SQL.<br>    2. 简单<br>    3. 可以进行非常复杂和高级的数据库操作．</p><p>数据库存储数据的特点:<br>    1. 将数据放到表中，表再放到库中．<br>    2. 一个数据库有多个表，每个表都有一个名字，用来标识自己，表名具有唯一性．<br>    3. 表具有一些特征，这些特性定义了数据在表中如何存储，类似类的设计．<br>    4. 表由列组成，我们也称为字段，所有表都是由一个或多个列组成，每一列相当于java中的属性.<br>    5. 表中的数据是按行存储的，每一行类似于java中的”对象”．</p><h3 id="数据库相关配置和环境暂时略"><a href="#数据库相关配置和环境暂时略" class="headerlink" title="数据库相关配置和环境暂时略"></a>数据库相关配置和环境暂时略</h3><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><ol><li><p>查看当前所有的数据库<br>show database;</p></li><li><p>打开指定的库<br>use 库名</p></li><li><p>查看当前库的所有表<br>show tables;</p></li><li><p>查看其库的所有表<br>show tables from 库名;</p></li><li><p>创建表<br>create table 表名{<br>　　列名　列类型;<br>　　列名　列类型;<br>};</p></li><li><p>查看表结构<br>desc 表名;</p></li><li><p>查看服务器的版本</p></li></ol><p>方式一: 登录到mysql服务器<br>select version();<br>方式二:没有登录到mysql服务器</p><p>mysql –version/ –V</p><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><ol><li>不区分大小写,建议关键字大写表，表名列名小写．</li><li>每条命令最好用分号结尾．</li><li>每条命令根据需要，可以进行缩进或换行．</li><li>注释　<br>单行注释：＃注释文字或者－－空格注释文字．<br>多行注释：/<em>注释文字</em>/</li></ol><h3 id="MySQL基础表的介绍"><a href="#MySQL基础表的介绍" class="headerlink" title="MySQL基础表的介绍"></a>MySQL基础表的介绍</h3><h3 id="基础查询介绍"><a href="#基础查询介绍" class="headerlink" title="基础查询介绍"></a>基础查询介绍</h3><p>select 查询列表　from 表明;<br>类似java中: System.out.println(打印东西);<br>特点：</p><ol><li>查询列表可以使：表中的字段，常量值，表达式，函数.</li><li>查询的结果是一个虚拟的表格.<h4 id="预操作"><a href="#预操作" class="headerlink" title="预操作"></a>预操作</h4>建议在查询操作之前添加所操作的库．<br>use myemployess;<br>类似C++的作用域;</li></ol><p>#``(着重号)<br>用来区分是关键字和字段,不添加也可以.</p><h4 id="查询单个字段"><a href="#查询单个字段" class="headerlink" title="查询单个字段"></a>查询单个字段</h4><p>select lastname from employess;</p><p>查询表中的多个字段<br>注意：最后没有逗号，顺序跟原来的表格可以不同.<br>select lastname,salary,email from employess;</p><h4 id="查询表中的所有字段"><a href="#查询表中的所有字段" class="headerlink" title="查询表中的所有字段"></a>查询表中的所有字段</h4><p>方式一．<br>select 可以双击点击表中的字段 from employess;</p><p>或者</p><p>方式二<br>#select (*) from employess;</p><h4 id="查询常量值"><a href="#查询常量值" class="headerlink" title="查询常量值"></a>查询常量值</h4><p>select 100;</p><p>查询字符字符串一个形式．<br>select ‘john’;</p><h4 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h4><p>直接返回的是结果.<br>select 100*99;</p><h4 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h4><p>调用该函数，显示返回值．<br>select version();</p><h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><ol><li>起别名容易读取，易读．</li><li>如果要查询的字段有重名的情况，可用别名可以区分开来．</li></ol><p>方式一：<br>select 100 * 98 as 结果；</p><p>罗列出来的表，列属性的名字直接替换为姓．<br>select lastname as 姓，firstname as 名 from employess;</p><p>方式二：</p><p>直接把as省略掉.<br>select lastname 姓，firstname 名 from employess;</p><p>例如：查询salary,显示结果为out put</p><p>取别名的时候，如果有特殊字符如空格，就加上双引号或者单引号．<br>select salary as “out put” from employess;</p><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>案例：查询员工表中涉及到的所有的部门编号．</p><p>去重关键字: distinct.</p><p>select distinct departmentid from employess;</p><h4 id="的作用域"><a href="#的作用域" class="headerlink" title="+的作用域"></a>+的作用域</h4><p>java 中:</p><ol><li>运算符，表示操作数都是数值型．</li><li>连接符，只要有一个操作数为字符串．</li></ol><p>MySQL中的加号:<br>    只有一个功能：运算符，</p><ol><li> 两个操作室都是数值型，就做加法运算．</li><li> 其中一方为字符型，就将字符型转换为数值型，如果转换成功就做加法运算．转换失败就将字符型转换为0;接着拿0和后边数进行加法运算.</li><li>其中一方为NULL,则结果就为NULL;</li></ol><p>案例：查询员工名和姓连接成一个字段，并显示为姓名．</p><p>这个样子是不对的．<br>select lastname + firstname as 姓名<br>from  employess; </p><p>改正样子:<br>    concat表示字符串链接功能，相当于一列和另一列结合．然后属性取了别名．<br>　　select concat(‘lastname’,’firstname’) as 姓名<br>　　from employess;</p><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>案例：显示表departments的结构，并查询其中的全部数据.<br>关键字　desc;<br>desc departments;<br>select * from departments;</p><p>显示出表employess中的全部job_id(不重复)<br>select distinct job_id from employess;</p><p>显示出表employess的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</p><p>第一部分表示如果lastname 如果为NULL，就显示成0,改名为奖金率<br>所以选出了两列，一个是更名的，一个是没有更名的．</p><p>select IFNILL(lastname, 0) as 奖金率,<br>       lastname<br>from<br>       employess;</p><p>select<br>       concat(firstname,’,’,lastname) as OUT_PUT<br>from<br>       employess;</p><p>改正后　：</p><p>select<br>       concat(firstname,’,’,IFNILL(lastname,0))<br>from<br>       employess;</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>where 相当于 if.</p><p>语法：<br>select<br>　　　　查询列表<br>from<br>　　　　表名<br>where<br>　　　　筛选条件;</p><p>语法执行顺序:</p><ol><li>表名．</li><li>筛选条件．</li><li>查询列表．</li></ol><p>分类：</p><ol><li><p>按条件表达式筛选<br>条件运算符:&gt;,&lt;,=(类似==),&lt;&gt;(类似!=),&gt;=,&lt;=.</p></li><li><p>按逻辑表达式筛选</p></li></ol><p>java中：逻辑运算符: &amp;&amp;, \,!(与,或,非)<br>MySQL: and, or, not.</p><p>3.模糊查询</p><ol><li>like </li><li>between</li><li>in</li><li>is null</li></ol><h4 id="按条件表达式筛选"><a href="#按条件表达式筛选" class="headerlink" title="按条件表达式筛选"></a>按条件表达式筛选</h4><p>案例一: 查询工资&gt;12000的员工信息．<br>select  *<br>from employess<br>where salary &gt; 12000;</p><p>案例二: 查询部门编号不等于90号的员工名和部门编号.<br>的后边是谁select后边就是谁.</p><p>select lastname, departmentid<br>from employess<br>where departmentid ＜＞90;<br>或者　前者建议使用<br>where departmentid != 90;</p><h4 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h4><p>案例一：查询工资在10000到20000之间的员工名，工资以及奖金.</p><p>select lastname,salary,commissionpct<br>from employess<br>where salary&gt;=10000<br>and salary＜＝20000</p><p>案例二:查询部门编号不是在90到110间,或者工资高于15000的员工信息</p><p>select *<br>from employess</p><p>where not(departmentid＞＝90 and departmentid＜＝110) or salary&gt;15000;<br>或者<br>where departmentid&lt;90 or departmentid&gt;110 or salary&gt;15000;</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><h5 id="like一般和通配符使用"><a href="#like一般和通配符使用" class="headerlink" title="like一般和通配符使用"></a>like一般和通配符使用</h5><p>通配符:<br>    %表示任意多个字符包含零个字符<br>    _表示任意单个字符<br>    表示通配符的时候用\进行转义.</p><p>案例一: 查询员工名中包含字符的员工信息<br>like前字符型的值必须加单引号.<br>%表示通配符，若干个．<br>select * from employess where lastname like ‘%a% ‘</p><p>案例二:查询员工名中第三个字符为e,第五个字符为a的员工名和工资．<br>select lastname,salary from employess where lastname like ‘__e_a%’;</p><p>案例三：查询员工名中第二个字符为（下划线）的员工名．注释：没办法打出来．<br>用转义<br>select lastname from employess where lastname like ‘<em>\</em>%’;<br>_<br>定义转义符号<br>重新弄个符号定义为转义符，关键字　escape.<br>select lastname from employess where lastname like ‘<em>$</em>%’ escape ‘$’;</p><h5 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h5><ol><li>使用between and 可以提高语句的简洁度．</li><li>包含临界值</li><li>两个值不可以交换顺序．</li></ol><p>案例一: 查询员工编号在100到120之间的所有员工信息．</p><p>select * from employess </p><p>where employessid &gt;= 100 and employess_id &lt;= 120;<br>或者<br>where employessid between 100 and 120;<br>完全等价以　&gt;= 和　&lt;= </p><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>判断某字段的值是否属于in列表中的某一项</p><ol><li>使用in提高语句的简洁渡.</li><li>in列表中的类型必须一致或者兼容．(‘123’) 和123 ，’123’可以转换成123.</li><li>in的列表不能是省略的形式，比如%12%这样的.</li></ol><p>案例:查询员工的工种编号 IT_PROG,AD_VP,AD_PRES中的一个员工和工种编号．<br>select<br>      lastname,<br>      job_id<br>from </p><p>job_id = ‘IT_PROG’ or job_id = ‘AD_VP’ or job_id = ‘AD_PRES’;<br>或者<br>job_id in(‘IT_PROG’,’AD_VP’,’AD_PRES’);</p><h5 id="is-NULL"><a href="#is-NULL" class="headerlink" title="is NULL"></a>is NULL</h5><ol><li>=或&lt;&gt;不能用于判断NULL值<br>is null 或　is not null 可以判断NULL值.</li></ol><p>实例: 查询没有奖金的员工名和奖金率．<br>select lastname,<br>       commissionpct<br>from   employess</p><p>where commissionpct = NULL; 注意＝不能判断NULL;<br>改正<br>where commissionpct is NULL;<br>如果是有奖金<br>where commissionpct is not NULL;</p><p>安全等于 &lt;=&gt; 即可判断NULL 也可判断普通值.</p><p>面试题:<br>访问select * from employess 和<br>select * from employess where commissionpct like ‘%%’ and lastname like ‘%%’;<br>有什么不同，说明原因.<br>答案：<br>是不一样，<br>如果判断的字段有null值的化，第二种情况就不对了，第二种%表示有不表示空．</p><p>改正，前提如果两个属性对应的位置不存在全为NULL 的情况就可以下边方式更改．<br>select * from employess where commissionpct like ‘%%’ 或 lastname like ‘%%’;</p><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法:</p><ol><li>select 查询列表</li><li>from 表</li><li>[where 筛选条件]</li><li>order by 排序列表　asc\desc (升序或降序)</li></ol><p>执行顺序2,3,1,4</p><ol><li>asc代表是升序，desc 代表降序，若果不写默认是升序．</li><li>order by 子句中可以支持单个字段，多个字段，表达式，函数别名．</li><li>order by 子句一般放在查询语句的最后．limit子句更为靠后,</li></ol><p>案例一:查询员工信息，要求工资从高到低排序<br>select * from employess order by salary desc;<br>select * from employess order by salary ;　//升序</p><p>案例二:查询部门编号&gt;= 90的员工信息，按入职时间的先后进行．(添加筛选条件)<br>select * from employess where dapartment_id &gt;= 90 order by hiredata asc;</p><p>案例三: 按年薪的高低显示员工的信息和年薪［按表达式排序］<br>select *,salary * 12 *(1 + IFNILL(commissionpct, 0)) 年薪<br>from employess<br>order by salary * 12 *(1 + IFNILL(commissionpct, 0)) desc；</p><p>案例四: 按年薪的高低显示员工的信息和年薪［按别名排序］</p><p>select *, salary * 12 * (1 + IFNILL(commissionpct, 0)) 年薪<br>from employess<br>order by 年薪　desc;</p><p>案例四：　按姓名的长度来显示员工的姓名和工资［按函数排序］<br>select LENGTH(“john”);  //LENGTH 表示输出长度的函数　</p><p>答案:</p><p>select LENGTH (lastname) 字节长度，lastname,salary<br>from employess<br>order by LENGTH(lastname) desc;</p><p>案例六：查询员工信息，要求按工资升序排序，再按员工编号降序排序[按多个字段排序]</p><p>select * from employess order by salary asc, employess_id desc;</p><p>解释: 就是先按照工资排序，工资一样按员工编号排序．</p><h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><p>概念: 类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名<br>好处: </p><ol><li>隐藏了实现细节．</li><li>提高了代码的重用性．</li></ol><p>调用: select 函数名（实参列表）［from 表］；　［中若有from表就写若没有就不写］</p><p>特点:<br>    1. 函数名字<br>    2. 函数功能</p><p>分类:<br>    1. 单行函数<br>    如: concat, length, IFNILL等<br>    2. 分组函数<br>    功能:做统计使用.又称为统计函数，聚合函数，组函数．</p><h5 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h5><p>额外的知识:<br>    utf8 字符占用一个字节<br>    汉字三个字节<br>    ｊｄｋ汉字是两个字节．</p><ol><li><p>length函数获取参数的字节个数．<br>select LENGTH(‘john’); 返回4<br>select LENGTH(‘哈哈哈’)；　utf8为9.</p></li><li><p>concat拼接字符</p></li></ol><p>select concat(lastname,’__’,firstname) from employess;<br>_为中间字符进行了拼接.<br>3. upper,lower<br>大小写变换<br>select upper(‘john’);<br>select lower(‘john’);</p><p>示例: 将姓变大写，名变小写，然后拼接．<br>select concat(upper(lastname),lower(firstname)) 名字　from employess;</p><ol start="4"><li>substr,substring .<br>注意；索引从１开始<br>返回陆展元<br>select substr(‘李莫愁爱上陆展元’,7) OUT_PUT;截取从⑦开始的所有字符</li></ol><p>返回李莫愁；</p><p>select substr(‘李莫愁爱上陆展元’,1, 3) OUT_PUT;截取开始位置及长度．</p><p>案例:姓名中的首字符大写，然后用下划线进行链接．<br>select concat(upper(substr(lastname, 1, 1)),’_ ‘,lower(substr(lastname, 2))) from employess;<br>_</p><ol start="5"><li>instr</li></ol><p>instr(‘杨不悔爱上了殷六侠’，＇殷六侠＇) as OUT_PUT ；//返回子串在父串中首次出现的的下标索引值．如果没有即为０．</p><ol start="6"><li>trim</li></ol><p>select LENGTH(trim(‘    张翠山　　　‘)) as OUT_PUT;</p><p>去掉前后空格，不去中间．</p><p>select trim(‘a’ from ‘aaaa蛋蛋aaaa蛋蛋aaaa’) as OUT_PUT;</p><p>输出蛋蛋aaaa蛋蛋．</p><ol start="7"><li>lpad 用指定的字符实现左填充指定长度．超了就截取．</li></ol><p>select lpad (‘殷素素’,10,’*’) as OUT_PUT;</p><p>不够十个左边用*填充;</p><p>8.rpad 用指定的字符实现右填充指定长度</p><ol start="9"><li>replace(‘张无忌爱上周芷若’，’周芷若’，’赵敏’)　as OUT_PUT;<br>周芷若替换成赵敏.全部替换</li></ol><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><ol><li>round 四舍五入<br>select round(-1.55); //绝对值进行四舍五入然后加上符号．<br>select round(1.567,2); 小数点后两位．</li></ol><ol start="2"><li>ceil 向上取整向上返回&gt;=该参数的最小整数</li></ol><p>select ceil (1,00);</p><ol start="3"><li><p>floar向下取整,返回&lt;= 该参数的最大整数.<br>select floar(-9.99); -9</p></li><li><p>truncate 截断<br>select truncate (1.6999999,1);<br>小数点后一位.</p></li></ol><ol start="5"><li>mod取余<br>mod (a, b) : a - a/b * b;<br>正负数带入就好.<br>select mod (10 ,-3)</li></ol><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>now：返回当前系统日期+时间</p><p>curdate：返回当前系统日期，不包含时间</p><p>curtime：返回当前时间，不包含日期</p><p>可以获取指定的部分，年、月、日、小时、分钟、秒</p><p>SELECT<br>  YEAR(hiredate) 年<br>FROM<br>    employees ;</p><p>str_to_date：将日期格式的字符转换成指定格式的日期</p><p>  SELECT<br>    STR_TO_DATE(‘1998-3-2’, ‘%Y-%c-%d’) AS output ;</p><p>  查询入职日期为1992-4-3的员工信息</p><p>  SELECT<br>    *<br>    FROM<br>      employees<br>      WHERE hiredate = STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’) ;</p><p>date_format：将日期转换成字符串</p><p>SELECT<br>  DATE_FORMAT(NOW(), ‘%y年%m月%d日)’) AS output ;<br>  查询有奖金的员工名和入职日期（xx月/xx日 xx年）</p><p>  SELECT<br>    last_name,<br>      DATE_FORMAT(hiredate, ‘%m月/%d日 %y年’) AS 入职日期<br>      FROM<br>        employees<br>        WHERE commission_pct IS NOT NULL ;<br>        datediff：返回两个日期相差的天数</p><pre><code>    monthname：以英文形式返回月</code></pre><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>SELECT VERSION();<br>当前数据库服务器的版本<br>SELECT DATABASE();<br>当前打开的数据库<br>SELECT USER();</p><p>当前用户<br>password(‘字符’);<br>流程控制函数</p><p>if函数：if else的效果</p><p>SELECT<br>  last_name,<br>  commission_pct,<br>  IF(<br>    commission_pct IS NULL,<br>    ‘没奖金，呵呵’,<br>    ‘有奖金，嘻嘻’<br>  ) 备注<br>FROM<br>  employees ;</p><p>case函数的使用1：switch case的效果</p><p>语法：</p><p>case 要判断的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量2 then 要显示的值2或语句2;<br>…<br>else 要显示的值n或语句n;<br>end</p><p>查询员工的工资，要求：</p><p>部门号=30，显示的工资为1.1倍</p><p>部门号=40，显示的工资为1.2倍</p><p>部门号=50，显示的工资为1.3倍</p><p>其他部门，显示的工资为原工资</p><p>SELECT<br>  salary AS 原始工资,<br>  department_id,<br>  CASE<br>    department_id<br>    WHEN 30<br>    THEN salary * 1.1<br>    WHEN 40<br>    THEN salary * 1.2<br>    WHEN 50<br>    THEN salary * 1.3<br>    ELSE salary<br>  END AS 新工资<br>FROM<br>  employees ;</p><p>case函数的使用2：类似于多重if</p><p>case<br>when 条件1 then 要显示的值1或语句1<br>when 条件2 then 要显示的值2或语句2<br>…<br>else 要显示的值n或语句n<br>end</p><p>查询员工的工资情况</p><p>如果工资&gt;20000，显示A级别</p><p>如果工资&gt;15000，显示B级别</p><p>如果工资&gt;10000，显示C级别</p><p>否则，显示D级别</p><p>SELECT<br>  salary,<br>  CASE<br>    WHEN salary &gt; 20000<br>    THEN ‘A’<br>    WHEN salary &gt; 15000<br>    THEN ‘B’<br>    WHEN salary &gt; 10000<br>    THEN ‘C’<br>    ELSE ‘D’<br>  END AS 工资级别<br>FROM<br>  employees ;</p><p>测试题</p><p>显示系统时间（日期+时间）</p><p>SELECT NOW();<br>1<br>查询员工号，姓名，工资，以及工资提高20%后的结果（new salary）</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  salary,<br>  salary * 1.2 AS “new salary”<br>FROM<br>  employees ;</p><p>将员工的姓名按首字母排序，并写出姓名的长度（length）</p><p>SELECT<br>  last_name,<br>  LENGTH(last_name)<br>FROM<br>  employees<br>ORDER BY SUBSTR(last_name, 1, 1) ;</p><p>做一个查询</p><p>SELECT<br>  CONCAT(<br>    last_name,<br>    ‘ earns ‘,<br>    salary,<br>    ‘ monthly but wants ‘,<br>    salary * 3<br>  ) AS “Dream Salary”<br>FROM<br>  employees ;</p><p>case-when训练</p><p>SELECT<br>  last_name,<br>  job_id AS job,<br>  CASE<br>    job_id<br>    WHEN ‘AD_PRES’<br>    THEN ‘A’<br>    WHEN ‘ST_MAN’<br>    THEN ‘B’<br>    WHEN ‘IT_PROG’<br>    THEN ‘C’<br>    WHEN ‘SA_PRE’<br>    THEN ‘D’<br>    WHEN ‘ST_CLERK’<br>    THEN ‘E’<br>  END AS Grade<br>FROM<br>  employees<br>WHERE job_id = ‘AD_PRES’ ;</p><h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><p>功能：用作统计使用，又称为聚合函数或统计函数或组函数</p><p>分类：sum 求和、avg 平均值、max 最大值、min 最小值、count 计数（非空）</p><p>SELECT SUM(salary) FROM employees;</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>sum、avg一般用于处理数值型数据</li><li>max、min、count可以处理任何类型数据</li><li>以上分组函数都忽略null值</li><li>可以和distinct搭配实现去重的运算</li></ol><p><a href="https://blog.csdn.net/qq_39729527/article/details/82377925">count</a><br>_<br>SELECT<br>  SUM(DISTINCT salary),<br>  SUM(salary)<br>FROM<br>  employees ;</p><p>SELECT<br>  COUNT(DISTINCT salary),<br>  COUNT(salary)<br>FROM<br>  employees ;</p><h5 id="count函数的单独介绍"><a href="#count函数的单独介绍" class="headerlink" title="count函数的单独介绍"></a>count函数的单独介绍</h5><p>效率</p><p>MYISAM存储引擎下，count(<em>)的效率高<br>INNODB存储引擎下，count(</em>)和count(1)效率差不多，比count(字段)要高一些<br>使用count(*) 统计一共有多少行</p><p>SELECT COUNT(salary) FROM employees;<br>SELECT COUNT(*) FROM employees;//对行数进行统计<br>SELECT COUNT(1) FROM employees;//  对表中第一列的值的函数进行计算，忽略countNULL列.</p><p>count(列名字)对表中特定的列的值的行数进行计算，不包括null;</p><ol start="5"><li>和分组函数一同查询的字段有限制，要求是group by后的字段</li></ol><p>训练题</p><p>查询公司员工工资的最大值，最小值，平均值，总和</p><p>SELECT<br>  MAX(salary),<br>  MIN(salary),<br>  AVG(salary),<br>  SUM(salary)<br>FROM<br>  employees ;</p><p>查询员工表中的最大入职时间和最小入职时间的相差天数（difference）</p><p>SELECT<br>  DATEDIFF(MAX(hiredate), MIN(hiredate)) DIFFERENCE<br>FROM<br>  employees ;</p><p>查询部门编号为90的员工个数</p><p>SELECT<br>  COUNT(*)<br>FROM<br>  employees<br>WHERE department_id = 90 ;</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>select 分组函数，列（要求出现在group by的后面）</p><p>from 表</p><p>【where 筛选条件】</p><p>group by 分组的列表</p><p>【having 分组后的筛选】</p><p>【order by 子句】</p><p>注意：查询列表比较特殊，要求是分组函数和group by后出现的字段</p><p>特点：</p><p>分组查询中的筛选条件分为两类：<br>　　　　　　数据源 　　　　位置 　　　　　　　　关键字</p><p>分组前筛选 原始表 　　group by子句的前面 　　　　where</p><p>分组后筛选 分组后的结果集 group by子句的后面 　　having</p><p>分组函数做条件肯定是放在having子句中</p><p>能用分组前筛选的，就优先考虑使用分组前筛选</p><p>group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开没有顺序要求），表达式或函数（用得较少）</p><p>也可以添加排序（排序放在整个分组查询最后位置）</p><p>查询每个工种的最高工资</p><p>SELECT<br>  MAX(salary),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id ;</p><p>查询每个位置上的部门个数</p><p>SELECT<br>  COUNT(*),<br>  location_id<br>FROM<br>  departments<br>GROUP BY location_id ;</p><p>查询邮箱中包含a字符的，每个部门的平均工资</p><p>SELECT<br>  AVG(salary),<br>  department_id<br>FROM<br>  employees<br>WHERE email LIKE ‘%a%’<br>GROUP BY department_id ;</p><p>查询有奖金的每个领导手下员工的最高工资</p><p>SELECT<br>  MAX(salary),<br>  manager_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY manager_id ;</p><p>查询那个部门的员工个数&gt;2</p><p>查询每个部门的员工个数</p><p>SELECT<br>  COUNT(*) AS 员工个数,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id ;</p><p>根据上面的结果进行筛选，查询哪个部门的员工个数＞2</p><p>SELECT<br>  COUNT(*) AS 员工个数,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING 员工个数 &gt; 2 ;</p><p>添加分组后的筛选用having，分组前的用where</p><p>查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p><ol><li>查询每个工种有奖金的员工的最高工资</li></ol><p>SELECT<br>  MAX(salary),<br>  job_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id ;</p><ol start="2"><li>根据上面的结果继续筛选，最高工资&gt;12000</li></ol><p>SELECT<br>  MAX(salary) AS 最高工资,<br>  job_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING 最高工资 &gt; 12000 ;</p><p>查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及其最低工资</p><p>SELECT<br>  MIN(salary) AS 最低工资,<br>  manager_id<br>FROM<br>  employees<br>WHERE manager_id &gt; 102<br>GROUP BY manager_id<br>HAVING 最低工资 &gt; 5000 ;</p><p>按表达式或函数分组</p><p>按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些</p><ol><li>查询每个长度的员工个数</li></ol><p>SELECT<br>  COUNT(*) 员工个数,<br>  LENGTH(last_name) 姓名长度<br>FROM<br>  employees<br>GROUP BY 姓名长度 ;</p><ol start="2"><li>添加筛选条件</li></ol><p>SELECT<br>  COUNT(*) 员工个数,<br>  LENGTH(last_name) 姓名长度<br>FROM<br>  employees<br>GROUP BY 姓名长度<br>HAVING 员工个数 &gt; 5 ;</p><ol start="3"><li>按多个字段分组</li></ol><p>查询每个部门每个工种的员工的平均工资</p><p>SELECT<br>  AVG(salary),<br>  department_id,<br>  job_id<br>FROM<br>  employees<br>GROUP BY department_id,<br>  job_id ;//这两个一样才能划分为一组.</p><p>添加排序</p><p>查询每个部门每个工种的员工的平均工资，并按平均工资的高低显示</p><p>SELECT<br>  AVG(salary) AS 平均工资,<br>  department_id,<br>  job_id<br>FROM<br>  employees<br>GROUP BY department_id,<br>  job_id<br>ORDER BY 平均工资 DESC ;</p><p>练习题</p><p>查询各job_id的员工工资的最大值、最小值、平均值，总和，并按job_id升序</p><p>SELECT<br>  MAX(salary),<br>  MIN(salary),<br>  AVG(salary),<br>  SUM(salary),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id<br>ORDER BY job_id ;</p><p>查询员工最高工资和最低工资的差距（DIFFERENCE）</p><p>SELECT<br>  MAX(salary) - MIN(salary) AS DIFFERENCE<br>FROM<br>  employees ;</p><p>查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</p><p>SELECT<br>  MIN(salary) AS 最低工资<br>FROM<br>  employees<br>WHERE manager_id IS NOT NULL<br>GROUP BY manager_id<br>HAVING 最低工资 &gt;= 6000 ;</p><p>查询所有部门的编号，员工数量和工资平均值，并按平均工资降序</p><p>SELECT<br>  department_id,<br>  COUNT(*) AS 员工数量,<br>  AVG(salary) AS 工资平均值<br>FROM<br>  employees<br>GROUP BY department_id<br>ORDER BY 工资平均值 DESC ;</p><p>查询具有各个job_id的员工人数</p><p>SELECT<br>  COUNT(*),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id ;</p><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p><p>笛卡尔乘积现象：表1有m行，表2有n行，结果=m*n</p><p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件<br>分类：</p><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接<br>按功能分类：<br>内连接:<br>  等值连接<br>  非等值连接<br>  自连接<br>外连接:<br>  左外连接<br>  右外连接<br>  全外连接（mysql不支持）<br>交叉连接:</p><h5 id="sql92标准"><a href="#sql92标准" class="headerlink" title="sql92标准"></a>sql92标准</h5><h6 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h6><p>多表等值连接的结果为多表的交集部分</p><p>n表连接，至少需要n-1个连接条件</p><p>多表的顺序没有要求</p><p>一般需要为表起别名</p><p>可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p><p>查询女神名和对应的男神名：</p><p>SELECT<br>  NAME,<br>  boyname<br>FROM<br>  boys,<br>  beauty<br>WHERE beauty.boyfriend_id = boys.id ;</p><p>查询员工名和对应的部门名</p><p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees,<br>  departments<br>WHERE employees.<code>department_id</code> = departments.<code>department_id</code> ;</p><p>为表起别名</p><p>提高语句的简洁度</p><p>区分多个重名的字段</p><p>注意：如果为表起了别名，则查询 的字段就不能使用原始的表明去限定</p><p>查询员工名、工种号、工种名</p><p>SELECT<br>  last_name,<br>  e.<code>job_id</code>,<br>  job_title<br>FROM<br>  employees e,<br>  jobs j<br>WHERE e.<code>job_id</code> = j.<code>job_id</code> ;</p><p>两个表的顺序是否可以调换</p><p>查询员工名、工种号、工种名</p><p>SELECT<br>  last_name,<br>  e.<code>job_id</code>,<br>  job_title<br>FROM<br>  jobs j ,<br>  employees e<br>WHERE e.<code>job_id</code> = j.<code>job_id</code> ;</p><p>可以加筛选</p><p>查询有奖金的员工名、部门名</p><p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees AS e,<br>  departments AS d<br>WHERE e.<code>department_id</code> = d.<code>department_id</code><br>  AND e.<code>commission_pct</code> IS NOT NULL ;</p><p>查询城市名中第二个字符为o的部门名和城市名</p><p>SELECT<br>  department_name,<br>  city<br>FROM<br>  departments d,<br>  locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>  AND city LIKE ‘_o%’ ;</p><p>可以加分组</p><p>查询每个城市的部门个数</p><p>SELECT<br>  COUNT(*) 个数,<br>  city<br>FROM<br>  departments d,<br>  locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>GROUP BY city ;</p><p>查询有将近的每个部门的部门名和部门的领导编号和该部门的最低工资</p><p>SELECT<br>  department_name,<br>  d.manager_id,<br>  MIN(salary)<br>FROM<br>  departments d,<br>  employees e<br>WHERE d.<code>department_id</code> = e.<code>department_id</code><br>  AND commission_pct IS NOT NULL<br>GROUP BY department_name,<br>  d.manager_id ;</p><p>可以加排序</p><p>查询每个工种的工种名和员工的个数，并且按员工个数降序</p><p>SELECT<br>  job_title,<br>  COUNT(*) AS 个数<br>FROM<br>  employees e,<br>  jobs j<br>WHERE e.<code>job_id</code> = j.<code>job_id</code><br>GROUP BY job_title<br>ORDER BY 个数 DESC ;</p><p>可是实现三表连接：</p><p>查询员工名、部门名和所在的城市</p><p>SELECT<br>  last_name,<br>  department_name,<br>  city<br>FROM<br>  employees e,<br>  departments d,<br>  locations l<br>WHERE e.<code>department_id</code> = d.<code>department_id</code><br>  AND d.<code>location_id</code> = l.<code>location_id</code> ;</p><h6 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h6><p>查询员工的工资和工资级别</p><p>SELECT<br>  salary,<br>  grade_level<br>FROM<br>  employees e,<br>  job_grades g<br>WHERE salary BETWEEN g.lowest_sal<br>  AND g.highest_sal ;</p><p>自连接</p><p>查询 员工名和上级的名称</p><p>SELECT<br>  e.employee_id,<br>  e.last_name,<br>  m.employee_id,<br>  m.last_name<br>FROM<br>  employees e,<br>  employees m<br>WHERE e.<code>manager_id</code> = m.<code>employee_id</code> ;</p><p>测试题：</p><p>显示员工表的最大工资，工资平均值</p><p>SELECT<br>  MAX(salary),<br>  AVG(salary)<br>FROM<br>  employees ;</p><p>查询员工表的employee_id，job_id，last_name，按department_id降序，salary升序</p><p>SELECT<br>  employee_id,<br>  job_id,<br>  last_name<br>FROM<br>  employees<br>ORDER BY department_id DESC,<br>  salary ASC ;</p><p>查询员工表的job_id中包含a和e的，并且a在e的前面</p><p>SELECT<br>  job_id<br>FROM<br>  employees<br>WHERE job_id LIKE ‘%a%e%’ ;</p><p>显示当前日期，以及去前后空格，截取子字符串的函数</p><p>select now();<br>select trim();<br>select substr(str, startIndex, [length])</p><p>sql99语法</p><p>语法：</p><p>select 查询列表</p><p>from 表1 别名 【连接类型】</p><p>join 表2 别名</p><p>on 连接条件</p><p>【where 筛选条件】</p><p>【group by 分组】</p><p>【having 筛选条件】</p><p>【order by 排序列表】</p><p>内连接（同上）：连接类型是inner</p><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><p>左外：left 【outer】<br>右外：right【outer】<br>全外：full 【outer】<br>交叉连接：cross</p><p>内连接：</p><p>语法：</p><p>select 查询列表</p><p>from 表1 别名</p><p>inner join 表2 别名</p><p>on 连接条件</p><p>…</p><p>分类：</p><p>等值连接</p><p>非等值连接</p><p>自连接</p><p>特点：</p><p>添加排序、分组、筛选<br>inner可以省略<br>筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p><ol><li>等值连接：</li></ol><p>查询员工名、部门名</p><p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees e<br>  INNER JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code> ;</p><p>查询名字中包含e的给员工名和工种名</p><p>SELECT<br>  last_name,<br>  job_title<br>FROM<br>  employees e<br>  INNER JOIN jobs j<br>    ON e.<code>job_id</code> = j.<code>job_id</code><br>WHERE last_name LIKE “%e%” ;</p><p>查询部门个数&gt;3的城市名和部门个数</p><p>SELECT<br>  city,<br>  COUNT(*) 部门个数<br>FROM<br>  departments d<br>  INNER JOIN locations l<br>    ON d.<code>location_id</code> = l.<code>location_id</code><br>GROUP BY city<br>HAVING 部门个数 &gt; 3 ;</p><p>查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按个数降序排序</p><p>SELECT<br>  department_name,<br>  COUNT(*) 员工个数<br>FROM<br>  departments d<br>  INNER JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>GROUP BY d.<code>department_id</code><br>HAVING 员工个数 &gt; 3<br>ORDER BY 员工个数 DESC ;</p><p>查询员工名、部门名、工种名，并按部门名降序.三表连接（有连接条件能连就可以）<br>SELECT<br>  last_name,<br>  department_name,<br>  job_title<br>FROM<br>  employees e<br>  INNER JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code><br>  INNER JOIN jobs j<br>    ON e.<code>job_id</code> = j.<code>job_id</code><br>ORDER BY d.<code>department_id</code> DESC ;</p><p>2, 非等值连接</p><p>查询员工的工资级别</p><p>SELECT<br>  salary,<br>  grade_level<br>FROM<br>  employees e<br>  INNER JOIN job_grades g<br>    ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p><p>查询每个工资级别&gt;20的个数，并且按工资级别降序</p><p>SELECT<br>  COUNT(<em>),<br>  grade_level<br>FROM<br>  employees e<br>  INNER JOIN job_grades g<br>    ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code><br>GROUP BY grade_level<br>HAVING COUNT(</em>) &gt; 20<br>ORDER BY grade_level DESC ;</p><ol start="3"><li>自连接</li></ol><p>把一张表当成两张表使用.</p><p>查询员工的名字、上级的名字</p><p>SELECT<br>  e.last_name,<br>  m.last_name<br>FROM<br>  employees e<br>  INNER JOIN employees m<br>    ON e.<code>manager_id</code> = m.<code>employee_id</code> ;</p><p>查询姓名中包含字符k的员工的名字、上级的名字</p><p>SELECT<br>  e.last_name,<br>  m.last_name<br>FROM<br>  employees e<br>  INNER JOIN employees m<br>    ON e.<code>manager_id</code> = m.<code>employee_id</code><br>WHERE e.<code>last_name</code> LIKE “%k%” ;</p><p>外连接</p><p>应用场景：用于查询一个表中有，另一个表没有的记录</p><p>特点：</p><p>外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的，则显示匹配的值，如果从表中没有和它匹配的，则显示null<br>外连接查询结果=内连接结果+主表中有而从表中没有的记录<br>左外连接：left join左边的是主表<br>右外连接：right join右边的是主表<br>左外和右外交换两个表的顺序，可以实现同样的效果<br>圈外链接=内连接的结果+表1中有但表2中没有的+表2中有但表1中没有的</p><p>查询没有男朋友的女神名</p><p>SELECT<br>  b.name,<br>  bo.*<br>FROM<br>  beauty b<br>  LEFT JOIN boys bo<br>    ON b.boyfriend_id = bo.id<br>WHERE bo.<code>id</code> IS NULL ;</p><p>查询哪个部门没有员工</p><p>左外：</p><p>SELECT<br>  d.*,<br>  e.employee_id<br>FROM<br>  departments d<br>  LEFT OUTER JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE e.<code>employee_id</code> IS NULL ;</p><p>右外：</p><p>SELECT<br>  d.*,<br>  e.employee_id<br>FROM<br>  employees e<br>  RIGHT OUTER JOIN departments d<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE e.<code>employee_id</code> IS NULL ;</p><p>全外连接</p><p>mysql不支持</p><p>案例：</p><p>SELECT<br>  b.<em>,<br>  bo.</em><br>FROM<br>  beauty b FULL<br>  OUTER JOIN boys bo<br>    ON b.<code>boyfriend_id</code> = bo.id ;</p><p>交叉连接（也就是笛卡尔乘积）</p><p>案例：</p><p>SELECT<br>  b.<em>,<br>  bo.</em><br>FROM<br>  beauty b<br>  CROSS JOIN boys bo ;</p><p>sql92 和 sql99 pk</p><p>功能：sql99支持的较多<br>可读性：sql99实现连接条件和筛选条件的分离，可读性较高<br>练习：</p><p>查询编号&gt;3的女神的男朋友信息，如果有则列出详细信息，如果没有，则用null填充</p><p>SELECT<br>  a.id,<br>  a.name,<br>  b.*<br>FROM<br>  beauty a<br>  LEFT JOIN boys b<br>    ON a.<code>boyfriend_id</code> = b.<code>id</code><br>WHERE a.<code>id</code> &gt; 3 ;</p><p>查询哪个城市没有部门</p><p>SELECT<br>  city,<br>  d.*<br>FROM<br>  departments d<br>  RIGHT JOIN locations l<br>    ON d.location_id = l.location_id<br>WHERE d.department_id IS NULL ;</p><p>查询部门名为SAL或IT的员工信息</p><p>SELECT<br>  d.<code>department_name</code>,<br>  e.*<br>FROM<br>  departments d<br>  LEFT JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE d.<code>department_name</code> = ‘SAL’<br>  OR d.<code>department_name</code> = ‘IT’ ;</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>含义：出现在其他语句中的select语句，称为子查询或内查询；外部的查询语句，称为主查询或外查询</p><p>嵌套在其他语句内部的select语句成为子查询或内查询</p><p>外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多</p><p>外面如果为select语句，则此语句称为外查询或主查询</p><p>分类：</p><p>按子查询出现的位置：<br>select后面：仅仅支持标量子查询<br>from后面：支持表子查询<br>where或having后面：支持标量子查询，列子查询，行子查询（较少）<br>exists后面（相关子查询）：支持表子查询<br>按功能、结果集的行列数不同：<br>标量子查询（结果集只有一行一列）<br>列子查询（结果集只有一列多行）<br>行子查询（结果集有一行多列）<br>表子查询（结果集一般为多行多列）</p><p>where或having后面</p><ol><li><p>标量子查询（单行子查询）</p></li><li><p>列子查询（多行子查询）</p></li><li><p>行子查询（多列多行）</p></li></ol><p>特点：</p><p>子查询放在小括号内<br>子查询一般放在条件的右侧，where，having<br>标量子查询，一般搭配着单行操作符使用（&gt; &lt; &gt;= &lt;= = &lt;&gt;）<br>列子查询，一般搭配着多行操作符使用（IN、ANY/SOME、ALL）<br>子查询的执行优选与主查询执行，主查询的条件用到了子查询的结果<br>标量子查询<br>案例1：谁的工资比Abel高？</p><p>SELECT<br>  salary<br>FROM<br>  employees<br>WHERE last_name = ‘Abel’ ;</p><p>案例2：返回job_id与141号员工相同，salary比143员工多的员工，姓名，job_id，工资</p><p>SELECT<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE job_id =<br>  (  SELECT<br>      job_id<br>     FROM<br>      employees<br>      WHERE employee_id = 141)<br>  AND salary &gt;<br>  (   SELECT<br>       salary<br>      FROM<br>       employees<br>       WHERE employee_id = 143) ;</p><p>案例3：返回公司工资最少的员工的last_name, job_id和salary</p><p>SELECT<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary =<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees) ;</p><p>案例4：查询最低工资大于50号部门的最低工资的部门id和其最低工资</p><p>SELECT<br>  MIN(salary),<br>  e.<code>department_id</code><br>FROM<br>  employees e<br>GROUP BY e.<code>department_id</code><br>HAVING MIN(salary) &gt;<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees<br>  WHERE department_id = 50) ;</p><p>列子查询<br>（多行子查询）</p><p>多行比较操作符：</p><p>IN/NOT IN：等于列表中的任意一个</p><p>ANY|SOME：和子查询返回的某一个值比较，用的较少</p><p>ALL：和子查询返回的所有值比较</p><p>案例1：返回location_id是1400或1700的部门中的所有员工姓名</p><p>SELECT<br>  last_name<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    departments<br>  WHERE location_id IN (1400, 1700)) ;</p><p>案例2：返回其他工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id以及salary</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt; ANY<br>  (SELECT DISTINCT<br>    salary<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>或者用max代替any</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt;<br>  (SELECT<br>    MAX(salary)<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>案例3：返回其他工种中比job_id为‘IT_PROG’工种所有工资都低的员工的员工号、姓名、job_id以及salary</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt; ALL<br>  (SELECT DISTINCT<br>    salary<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>或者用min代替all</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt;<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>行子查询<br>结果集一行多列或多行多列</p><p>案例1：查询员工编号最少并且工资最高的员工信息<br>把两个合在一起一起查询.<br>SELECT </p><ul><li>FROM<br>employees<br>WHERE (employee_id, salary) =<br>(SELECT<br>MIN(employee_id),<br>MAX(salary)<br>FROM<br>employees) ;</li></ul><p>select后面<br>仅仅支持标量子查询</p><p>案例1：查询每个部门的员工个数</p><p>SELECT<br>  d.<em>,<br>  (SELECT<br>    COUNT(</em>)<br>  FROM<br>    employees e<br>  WHERE e.department_id = d.department_Id) 个数<br>FROM<br>  departments d ;</p><p>案例2：查询员工号=102的部门名</p><p>SELECT<br>  (SELECT<br>    department_name<br>  FROM<br>    departments d<br>    INNER JOIN employees e<br>      ON d.department_id = e.department_id<br>  WHERE e.employee_id = 102) 部门名 ;</p><p>from后面<br>将子查询结果充当一张表，要求必须起别名</p><p>案例1：查询每个部门的平均工资的工资等级</p><p>SELECT<br>  ag_dep.*,<br>  g.<code>grade_level</code><br>FROM<br>  (SELECT<br>    AVG(salary) ag,<br>    department_id<br>  FROM<br>    employees<br>  GROUP BY department_id) ag_dep<br>  INNER JOIN job_grades g<br>    ON ag_dep.ag BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p><p>exists后面<br>相关子查询</p><p>语法：exists（完整的查询语句）</p><p>结果：1或0</p><p>案例1：查询有员工的部门名</p><p>SELECT<br>  department_name<br>FROM<br>  departments d<br>WHERE EXISTS<br>  (SELECT<br>    *<br>  FROM<br>    employees e<br>  WHERE d.<code>department_id</code> = e.<code>department_id</code>) ;</p><p>用in更简单</p><p>SELECT<br>  department_name<br>FROM<br>  departments d<br>WHERE d.<code>department_id</code> IN<br>  (SELECT<br>    department_id<br>  FROM<br>    employees e) ;</p><p>习题集</p><p>查询和zlotkey相同部门的员工姓名和工资</p><p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE department_id =<br>  (SELECT<br>    department_id<br>  FROM<br>    employees e<br>  WHERE e.<code>last_name</code> = ‘Zlotkey’) ;</p><p>查询工资比公司平均工资高的员工的员工号，姓名和工资</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  salary<br>FROM<br>  employees e<br>WHERE e.<code>salary</code> &gt;<br>  (SELECT<br>    AVG(salary)<br>  FROM<br>    employees) ;</p><p>查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  salary<br>FROM<br>  employees e<br>  INNER JOIN<br>    (SELECT<br>      AVG(salary) ag,<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id) nt<br>    ON nt.department_id = e.department_id<br>WHERE salary &gt; ag ;</p><p>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</p><p>SELECT<br>  employee_id,<br>  last_name<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    employees<br>  WHERE last_name LIKE ‘%u%’) ;</p><p>查询在部门的location_id为1700的部门工作的员工的员工号</p><p>SELECT<br>  employee_id<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    departments<br>  WHERE location_id = 1700) ;</p><p>查询管理者是King的员工姓名和工资</p><p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE manager_id IN<br>  (SELECT<br>    employee_id<br>  FROM<br>    employees<br>  WHERE last_name = ‘K_ing’) ;</p><p>查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</p><p>SELECT<br>  CONCAT(nt.first_name, nt.last_name) “姓.名”<br>FROM<br>  (SELECT<br>    first_name,<br>    last_name<br>  FROM<br>    employees<br>  WHERE salary =<br>    (SELECT<br>      MAX(salary)<br>    FROM<br>      employees)) nt ;</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p><p>语法：</p><p>select 查询列表</p><p>from 表</p><p>【join type】 join 表2</p><p>on 连接条件</p><p>where 筛选条件</p><p>group by 分组字段</p><p>having 分组后的筛选</p><p>order by 排序的字段】</p><p>limit offset，size；</p><p>offset：要显示条目的起始索引（从0开始）</p><p>size：要显示的条目个数</p><p>特点：</p><p>limit语句放在查询语句的最后</p><p>公式：</p><p>要显示的页数page，每页的条目数size</p><p>select 查询列表</p><p>from 表</p><p>limit （page - 1）* size， size；</p><p>案例1：查询前5条员工信息</p><p>SELECT * FROM employees LIMIT 0, 5;<br>或者<br>SELECT * FROM employees LIMIT 5;</p><p>案例2：查询第11条-第25条</p><p>SELECT * FROM employees LIMIT 10, 15;<br>1<br>案例3：有奖金的员工信息，并且工资较高的前10名显示出来</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE commission_pct IS NOT NULL<br>ORDER BY salary DESC<br>LIMIT 10 ;</li></ul><p>经典案例1：</p><p>查询工资最低的员工信息：last_name, salary</p><p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE salary =<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees) ;</p><p>查询平均工资最低的部门信息</p><p>SELECT </p><ul><li>FROM<br>departments<br>WHERE department_id =<br>(SELECT<br>department_id<br>FROM<br>employees<br>GROUP BY department_id<br>ORDER BY AVG(salary) ASC<br>LIMIT 1) ;</li></ul><p>查询平均工资最低的部门信息和该部门的平均工资</p><p>SELECT<br>  d.*,<br>  dd.ag<br>FROM<br>  departments d<br>  INNER JOIN<br>    (SELECT<br>      AVG(salary) ag,<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id<br>    ORDER BY ag<br>    LIMIT 1) dd<br>    ON d.<code>department_id</code> = dd.department_id ;</p><p>查询平均工资最高的job信息</p><p>SELECT </p><ul><li>FROM<br>jobs j<br>WHERE j.<code>job_id</code> =<br>(SELECT<br>job_id<br>FROM<br>employees<br>GROUP BY job_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1) ;</li></ul><p>查询平均工资高于公司平均工资的部门有哪些</p><p>SELECT<br>  AVG(salary) ag,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING ag &gt;<br>  (SELECT<br>    AVG(salary)<br>  FROM<br>    employees) ;</p><p>查询出公司中所有manager的详细信息</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE employee_id IN<br>(SELECT DISTINCT<br>manager_id<br>FROM<br>employees<br>WHERE manager_id IS NOT NULL) ;</li></ul><p>各个部门中，最高工资中，最低的那个部门的最低工资是多少</p><p>SELECT<br>  MIN(salary)<br>FROM<br>  employees<br>WHERE department_id =<br>  (SELECT<br>    department_id<br>  FROM<br>    employees<br>  GROUP BY department_id<br>  ORDER BY MAX(salary) ASC<br>  LIMIT 1) ;</p><p>查询平均工资最高的部门的manager的详细信息</p><p>SELECT<br>  last_name,<br>  department_id,<br>  email,<br>  salary<br>FROM<br>  employees<br>WHERE employee_id =<br>  (SELECT DISTINCT<br>    manager_id<br>  FROM<br>    employees<br>  WHERE department_id =<br>    (SELECT<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary) DESC<br>    LIMIT 1)<br>    AND manager_id IS NOT NULL) ;</p><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>union：联合，合并，将多条查询语句的结果合并成一个结果</p><p>引入案例：查询部门编号&gt;90或邮箱包含a的员工信息</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE email LIKE “%a%”<br>OR department_id &gt; 90 ;</li></ul><p>用联合查询为：</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE email LIKE “%a%”<br>UNION<br>SELECT </li><li>FROM<br>employees<br>WHERE department_id &gt; 90;</li></ul><p>语法：</p><p>查询语句1</p><p>union 【ALL】</p><p>查询语句2</p><p>union 【ALL】</p><p>…</p><p>应用场景：要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致</p><p>特点：</p><p>要求多条查询语句的查询列数是一致的<br>要求多条查询语句的查询的每一列的类型和顺序最好是一致的<br>union关键字默认去重，如果使用union all可以包含重复项</p><h4 id="查询总结"><a href="#查询总结" class="headerlink" title="查询总结"></a>查询总结</h4><p>语法：</p><p>select 查询列表 7</p><p>from 表1 别名 1</p><p>连接类型 join 表2 2</p><p>on 连接条件 3</p><p>where 筛选 4</p><p>group by 分组列表 5</p><p>having 筛选 6</p><p>order by 排序列表 8</p><p>limit 排序列表 9</p><h3 id="DML（Data-Manipulation-Language）数据操作语言"><a href="#DML（Data-Manipulation-Language）数据操作语言" class="headerlink" title="DML（Data Manipulation Language）数据操作语言"></a>DML（Data Manipulation Language）数据操作语言</h3><p>涉mZ到数据的<br>插入：insert<br>修改：update<br>删除：delete</p><h4 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h4><p>方式1：</p><p>语法：insert into 表名（列名，…） values（值1，…）</p><p>示例1：插入的值的类型要与列的类型一致或兼容</p><p>INSERT INTO beauty (<br>  id,<br>  NAME,<br>  sex,<br>  borndate,<br>  phone,<br>  photo,<br>  boyfriend_id<br>)<br>VALUES<br>  (<br>    13,<br>    ‘唐艺昕’,<br>    ‘女’,<br>    ‘1990-4-23’,<br>    ‘18934531234’,<br>    NULL,<br>    2<br>  );</p><p>示例2：不可以为null的列必须插入值。可以为null的列如何插入值？</p><p>方式1：字段的值写null<br>方式2：不写该字段</p><p>示例3：列的顺序是否可以调换</p><p>INSERT INTO beauty(NAME, sex, id, phone)<br>VALUES(‘蒋欣’, ‘女’, 16, ‘110’);</p><p>示例4：列数和值的个数必须一致</p><p>示例5：可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</p><p>INSERT INTO beauty<br>VALUES(18, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL);<br>1<br>2<br>方式2：</p><p>语法：insert into 表名 set 列名=值，列名=值，…</p><p>INSERT INTO beauty SET id = 19,<br>NAME = ‘刘涛’,<br>phone = ‘999’ ;</p><p>两种方式大pk</p><p>方式1支持插入多行，但是方式2不支持</p><p>INSERT INTO beauty<br>VALUES<br>(20, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL),<br>(21, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL),<br>(22, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL);</p><p>方式1支持子查询，方式2不支持</p><p>INSERT INTO beauty(id, NAME, phone)<br>SELECT 26, ‘送钱’, ‘12341234’;</p><ol start="2"><li>修改语句<br>语法：</li></ol><p>修改单表的记录</p><p>update 表名</p><p>set 列=新值，列=新值…</p><p>where 筛选条件；</p><p>修改多表的记录</p><p>sql92语法</p><p>update 表1 别名，表2 别名</p><p>set 列=值…</p><p>where 筛选条件</p><p>and 筛选条件；</p><p>sql99语法：</p><p>update 表1 别名</p><p>inner | left | right join 表2 别名</p><p>on 连接条件</p><p>set 列=值，…</p><p>where 筛选条件；</p><p>修改单表的记录<br>案例1：修改beauty表中姓唐的女神电话为109090909</p><p>UPDATE<br>  beauty<br>SET<br>  phone = ‘109090909’<br>WHERE NAME LIKE ‘唐%’ ;</p><p>案例2：修改boys表中id号位2的名称为张飞，魅力值为10</p><p>UPDATE<br>  boys<br>SET<br>  boyname = ‘张飞’,<br>  usercp = 10<br>WHERE id = 2 ;</p><p>修改多表的记录<br>案例1：修改张无忌的女朋友的手机号为114</p><p>UPDATE<br>  boys b<br>  INNER JOIN beauty be<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code> SET be.<code>phone</code> = ‘114’<br>WHERE b.<code>boyName</code> = ‘张无忌’ ;</p><p>案例2：修改没有男朋友的女神的男朋友编号都为 2号</p><p>UPDATE<br>  boys b<br>  RIGHT JOIN beauty be<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code> SET be.<code>boyfriend_id</code> = 2<br>WHERE be.<code>boyfriend_id</code> IS NULL ;</p><ol start="3"><li>删除语句<br>方式1：delete</li></ol><p>语法</p><p>单表的删除</p><p>delete from 表名 where 筛选条件</p><p>多表的删除</p><p>sql92语法</p><p>delete 别名（要删哪个表就写哪个表的别名，都删就都写）</p><p>from 表1 别名，表2 别名</p><p>where 连接条件</p><p>and 筛选条件</p><p>limit 条目数；</p><p>sql99语法</p><p>delete 别名（要删哪个表就写哪个表的别名，都删就都写）</p><p>from 表1 别名</p><p>inner | left | right join 表2 别名 on 连接条件</p><p>where 筛选条件</p><p>limit 条目数；</p><p>案例1：删除手机号以9结尾的女神信息</p><p>DELETE<br>FROM<br>  beauty<br>WHERE phone LIKE ‘%9’ ;</p><p>案例2：删除张无忌的女朋友的信息</p><p>DELETE<br>  be<br>FROM<br>  beauty be<br>  INNER JOIN boys b<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code><br>WHERE b.<code>boyName</code> = ‘张无忌’ ;</p><p>案例3：删除黄晓明的信息以及他女朋友的信息</p><p>DELETE<br>  b,<br>  be<br>FROM<br>  beauty be<br>  INNER JOIN boys b<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code><br>WHERE b.<code>boyName</code> = ‘黄晓明’ ;</p><p>方式2：truncate</p><p>语法</p><p>truncate table 表名；</p><p>truncate语句中不许加where</p><p>一删全删</p><p>TRUNCATE TABLE boyes ;<br>1<br>delete pk truncate</p><p>delete可以加where条件，truncate不可以<br>truncate删除效率高一些<br>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。<br>truncate删除没有返回值，delete删除有返回值<br>truncate删除不能回滚，delete删除可以回滚<br>DDL（Data Definition Language）数据定义语言<br>库和表的管理<br>库的管理：创建、修改、删除<br>标的管理：创建、修改、删除<br>创建：create<br>修改：alter<br>删除：frop</p><ol><li>库的管理<br>库的创建</li></ol><p>语法：create database [if not exists] 库名 [character set 字符集名]；</p><p>案例：创建库book</p><p>CREATE DATABASE IF NOT EXISTS books;<br>1<br>库的修改</p><p>修改库名的语句【已停用】</p><p>RENAME DATABASE books TO new_books;<br>1<br>更改库的字符集</p><p>ALTER DATABASE books CHARACTER SET gbk;<br>1<br>库的删除</p><p>DROP DATABASE IF EXISTS books;<br>1</p><h4 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h4><p>表的创建</p><p>语法：<br>create table 【if not exists】 表名(</p><p>​ 列名 列的类型【（长度） 约束】，</p><p>​ 列名 列的类型【（长度） 约束】，</p><p>​ …</p><p>)</p><p>案例1：创建表 book</p><p>CREATE TABLE book (<br>  id INT,<br>  bname VARCHAR (20),<br>  price DOUBLE,<br>  authorid INT,<br>  publishdate DATETIME<br>) ;</p><p>案例2：创建表author</p><p>CREATE TABLE author (<br>  id INT,<br>  au_name VARCHAR (20),<br>  nation VARCHAR (10)<br>) ;</p><p>案例3：查看创建的表</p><p>DESC author;<br>1<br>表的修改</p><p>语法：alter table 表名 add | drop | modify | change column 列名 【列类型 约束】；</p><p>添加列：alter table 表名 add column 列名 类型 【first | after 字段名】；</p><p>修改列的类型或约束：alter table 表名 modify column 列名 新类型 【新约束】；</p><p>修改列名：alter table 表名 change column 旧列名 新列名 类型；</p><p>删除列：alter table 表名 drop column 列名；</p><p>修改表名：alter table 表名 rename 【to】 新表名；</p><p>修改列名</p><p>ALTER TABLE book<br>  CHANGE COLUMN publishdate pubdate DATETIME ;</p><p>修改列的类型或约束</p><p>ALTER TABLE book<br>  MODIFY COLUMN pubdate TIMESTAMP ;</p><p>添加新列</p><p>ALTER TABLE author<br>  ADD COLUMN annual DOUBLE ;</p><p>删除列</p><p>ALTER TABLE author<br>  DROP COLUMN annual ;</p><p>修改表名</p><p>ALTER TABLE author<br>  RENAME TO book_author ;</p><p>表的删除</p><p>语法：drop table if exists 表名；</p><p>查看有哪些表：show tables；</p><p>if exists 只能在库，表的创建和删除的时候使用，列的操作不能使用。</p><p>通用的写法：</p><p>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;</p><p>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE 表名();</p><p>表的复制</p><p>仅仅复制表的结构</p><p>CREATE TABLE copy LIKE book_author ;<br>1<br>复制表的结构+数据</p><p>CREATE TABLE copy2<br>SELECT </p><ul><li>FROM<br>book_author ;</li></ul><p>只复制部分数据</p><p>CREATE TABLE copy3<br>SELECT<br>  id,<br>  au_name<br>FROM<br>  book_author<br>WHERE nation = ‘中国’ ;</p><p>仅仅复制某些字段（部分结构）：设置where不满足，那么就没有数据</p><p>CREATE TABLE copy4<br>SELECT<br>  id,<br>  au_name<br>FROM<br>  book_author<br>WHERE 0 ;</p><p>习题集</p><p>创建表dept1</p><p>USE myemployees;<br>CREATE TABLE dept1 (id INT (7), NAME VARCHAR (25)) ;</p><p>将表departments中的数据插入新表dept2中</p><p>CREATE TABLE dept2<br>SELECT<br>  department_id,<br>  department_name<br>FROM<br>  departments ;</p><p>创建表emp5</p><p>CREATE TABLE emp5 (<br>  id INT (7),<br>  first_name VARCHAR (25),<br>  last_name VARCHAR (25),<br>  dept_id INT (7)<br>) ;</p><p>将last_name的长度修改为50</p><p>ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);<br>1<br>根据表employees创建employee2</p><p>CREATE TABLE employee2 LIKE employees ;<br>1<br>删除表emp5</p><p>DROP TABLE IF EXISTS emp5;<br>1<br>将表empoyees2重命名为emp5</p><p>ALTER TABLE employee2<br>  RENAME TO emp5 ;</p><p>在表dept和emp5中添加新列test_column，并检查所做的操作</p><p>ALTER TABLE emp5<br>  ADD COLUMN test_column INT ;<br>DESC emp5;</p><p>直接删除表emp5中的列dept_id</p><p>ALTER TABLE emp5<br>  DROP COLUMN dept_id ;</p><h4 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h4><p>数值型：<br>整型<br>浮点型<br>定点数<br>浮点数<br>字符型：<br>较短的文本：char、varchar<br>较长的文本：text、blob（较长的二进制数据）<br>日期型：<br>整型<br>分类：Tinyint、Smallint、Mediumint、int/integer、bigint<br>特点<br>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值<br>如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用，并且默认变为无符号的整型！</p><p>小数<br>分类<br>浮点型<br>float（M，D）<br>double（M，D）<br>定点型<br>dec（M，D）<br>decimal（M，D）<br>特点<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值<br>M和D都可以省略，如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度<br>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用定点型<br>原则：所选择的类型越简单越好，能保存数值的类型越小越好</p><p>字符型<br>较短的文本：char、varchar<br>较长的文本：text，blob<br>特点：<br>写法 M的意思 特点 空间耗费 效率<br>char char(M) 最大的字符数，可以省略，默认为1 固定长度的字符 比较耗费 高<br>varchar varchar(M) 最大的字符数，不可以省略 可变长度的字符 比较节省 低</p><p>其他类型<br>binary和varbinary用于保存较短的二进制<br>enum：枚举，eg. enum(‘男’, ‘女’)<br>set：集合，eg. set(‘a’, ‘b’, ‘c’, ‘d’)<br>日期型<br>分类：<br>date：只保存日期<br>time：值保存时间<br>year：值保存年<br>datetime：保存日期+时间<br>timestamp：保存日期+时间，更能反映真实时间<br>特点：<br>​ 字节 范围 时区等的影响<br>datetime 8 1000-9999 不受<br>timestamp 4 1970-2038 受</p><h4 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h4><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><p>分类：六大约束</p><p>not null：非空，用于保证该字段的值不能为空。比如姓名、学号等。<br>default：默认，用于保证该字段有默认值。比如性别。<br>primary key：主键，用于保证该字段的值具有唯一性，并且非空。比如学号、员工编号等。<br>unique：唯一，用于保证该字段的值具有唯一性，可以为空。比如座位号。<br>check：检查约束【mysql中不支持】。不日年龄、性别。<br>foreign key：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。在从表添加外键约束，用于应用主表中某列的值。比如学生表的专业编号，员工表的部门编号，员工表的工种编号。<br>添加约束的时机：</p><p>创建表时<br>修改表时<br>约束添加的分类：</p><p>列级约束：六大约束语法上都支持，但外键约束没有效果</p><p>表级约束：除了非空、默认，其他的都支持</p><p>位置    支持的约束类型    是否可以起约束名<br>列级约束    列的后面    语法都支持，但外键没有效果    不可以<br>表级约束    所有列的下面    默认和非空不支持，其他支持    可以（主键没有效果）<br>创建表时添加约束<br>添加列级约束</p><p>CREATE DATABASE students;<br>USE students;</p><p>CREATE TABLE stuinfo (<br>  id INT PRIMARY KEY,<br>  stuname VARCHAR (20) NOT NULL,    # 非空<br>  gender CHAR(1) CHECK (gender = ‘男’<br>    OR gender = ‘女’),<br>  seat INT UNIQUE,    # 唯一<br>  age INT DEFAULT 18,    # 默认<br>  majorID INT REFERENCES major (id)<br>) ;</p><p>CREATE TABLE major (<br>  id INT PRIMARY KEY,<br>  majorName VARCHAR (20)<br>) ;</p><p>DESC stuinfo;<br>SHOW INDEX FROM stuinfo;</p><p>语法：直接在字段名和类型后面追加约束类型即可。<br>只支持：默认、非空、主键、唯一（除了外键都支持）<br>添加表级约束</p><p>DROP TABLE IF EXISTS stuinfo ;</p><p>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT,</p><p>CONSTRAINT pk PRIMARY KEY(id),<br>CONSTRAINT uq UNIQUE(seat),<br>CONSTRAINT ck CHECK(gender=’男’ OR gender=’女’),<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)<br>);</p><p>SHOW INDEX FROM stuinfo;</p><p>语法：在各个字段的最下面</p><p>【constraint 约束名】 约束类型（字段名）</p><p>除了非空、默认，其他的都支持</p><p>通用的写法：</p><p>CREATE TABLE IF NOT EXISTS stuinfo (<br>  id INT PRIMARY KEY,<br>  stuname VARCHAR (20) NOT NULL,<br>  gender CHAR(1),<br>  seat INT UNIQUE,<br>  age INT DEFAULT 18,<br>  majorID INT,<br>  CONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major (id)<br>) ;</p><p>表级约束pk列级约束</p><p>支持类型    可以起约束名与否<br>列级约束    除了外键    不可以<br>表级约束    除了非空和默认    可以，但对主键无效<br>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p><p>主键和唯一的大对比</p><pre><code>   保证唯一性    是否允许为空    一个表中可以有多少个    是否允许组合</code></pre><p>1<br>主键 √ × 至多有1个 √，但不推荐<br>唯一 √ √ 可以有多个 √，但不推荐<br>外键特点</p><p>要求在从表设置外键关系</p><p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p><p>主表的关联列必须是一个key（一般是主键或唯一）</p><p>插入数据时，先插入主表，再插入从表</p><p>删除数据时，先删除从表，再删除主表</p><p>方式1：级联删除</p><p>ALTER TABLE stuinfo ad CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;<br>1<br>删除的时候，主表和从表对应的行都删了。</p><p>方式2：级联置空</p><p>ALTER TABLE stuinfo ad CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;<br>1<br>删除的时候，主表对应的行被删除了，从表引入的地方变为空值null。</p><p>修改表时添加约束<br>添加列级约束：alter table 表名 modify column 字段名 字段类型 新约束；</p><p>添加表级约束：alter table 表名 add 【constraint 约束名】 约束类型（字段名）【外键的引用】；</p><p>添加非空约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL;<br>1<br>添加默认约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br>1<br>添加主键</p><h4 id="列级约束的写法"><a href="#列级约束的写法" class="headerlink" title="列级约束的写法"></a>列级约束的写法</h4><p>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</p><h5 id="表级约束的写法"><a href="#表级约束的写法" class="headerlink" title="表级约束的写法"></a>表级约束的写法</h5><p>ALTER TABLE stuinfo ADD PRIMARY KEY(id);</p><p>添加唯一</p><h5 id="列级约束的写法-1"><a href="#列级约束的写法-1" class="headerlink" title="列级约束的写法"></a>列级约束的写法</h5><p>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</p><h5 id="表级约束的写法-1"><a href="#表级约束的写法-1" class="headerlink" title="表级约束的写法"></a>表级约束的写法</h5><p>ALTER TABLE stuinfo ADD UNIQUE(seat);</p><p>添加外键</p><p>ALTER TABLE (CONSTRAINT fk_stuinfo_major) stuinfo ADD FOREIGN KEY(majorid) REFERENCES major(id);<br>1<br>修改表时删除约束<br>删除非空约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;<br>1<br>删除默认约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN age INT;<br>1<br>删除主键</p><p>ALTER TABLE stuinfo DROP PRIMARY KEY;<br>1<br>删除唯一</p><p>ALTER TABLE stuinfo DROP INDEX seat;<br>1<br>删除外键</p><p>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;<br>1<br>总结</p><p>非空</p><p>添加非空：alter table 表名 modify column 字段名 字段类型 not null；</p><p>删除非空：alter table 表名 modify column 字段名 字段类型；</p><p>默认</p><p>添加默认：alter table 表名 modify column 字段名 字段类型 default；</p><p>删除默认：alter table 表名 modify column 字段名 字段类型；</p><p>主键</p><p>添加主键：alter table 表名 add 【constraint 约束名】 primary key（字段名）；</p><p>删除主键：alter table 表名 drop primary key；</p><p>唯一</p><p>添加唯一：alter table 表名 add 【constraint 约束名】unique（字段名）；</p><p>删除唯一：alter table 表名 drop index 索引名；</p><p>外键</p><p>添加外键：alter table 表名 add 【constraint 约束名】foreign key（字段名） references 主表（被引用列）；</p><p>删除唯一：alter table 表名 drop foreign key 约束名；</p><h4 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h4><p>又称为自增长列</p><p>含义：可以不用手动的插入值，系统提供默认的序列值</p><p>特点：</p><p>标识列必须和主键搭配吗？不一定，但要求是一个key。<br>一个表可以有几个标识列？至多一个。<br>标识列的类型？只能是数值型（int（一般是int），float，double）<br>标识列可以通过**SET auto_increment_increment = 1;**设置步长；可以通过手动插入值设置起始值。<br>创建表时设置表时列</p><p>create table 表（</p><p>​ 字段名 字段类型 约束 auto_increment</p><p>）</p><p>CREATE TABLE tab_identity (<br>  id INT PRIMARY KEY AUTO_INCREMENT,<br>  NAME varcahr (20)<br>) ;</p><p>设置表时列的步长</p><p>SHOW VARIABLES LIKE ‘%auto_increment%’;<br>SET auto_increment_increment = 3;<br>1<br>2<br>设置表时列的起始值：想在什么地方更改自增长列的值，则手动插入值（不手动的时候，值是null）。</p><p>修改表时设置标识列</p><p>alter table 表 modify column 字段名 字段类型 约束 auto_increment</p><p>ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;<br>1<br>修改表时删除标识列</p><p>alter table 表 modify column 字段名 字段类型 约束</p><p>ALTER TABLE tab_identity MODIFY COLUMN id INT;<br>1</p><h3 id="TCL（Transaction-Control-Language）事务控制语言"><a href="#TCL（Transaction-Control-Language）事务控制语言" class="headerlink" title="TCL（Transaction Control Language）事务控制语言"></a>TCL（Transaction Control Language）事务控制语言</h3><p>事务的含义：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p><p>存储引擎：在mysql中的数据用各种不同的技术存储在文件（或内存）中。</p><p>通过show engines来查看mysql支持的存储引擎。<br>在mysql中用的最多的存储引擎有：innodb、myisam、memory等。其中innodb支持事务，而myisam、memory等不支持事务。<br>事务的ACID属性</p><p>原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。<br>隔离性（Isolation）：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。<br>事务的创建</p><p>隐式事务：事务没有明显的开启和结束的标记。比如insert、update、delete语句</p><p>显式事务：事务具有明显的开启和结束的标记</p><p>前提：必须先设置自动提交功能为禁用</p><p>SET autocommit=0;<br>1<br>步骤1：开启事务</p><p>SET autocommit=0;<br>START TRANSACTION;（可选）<br>2<br>步骤2：编写事务中的sql语句(select insert update delete，只有增删改查，不包括DDL语言)</p><p>语句1；</p><p>语句2；</p><p>…</p><p>步骤3：结束事务</p><p>commit；提交事务</p><p>rollback；回滚事务</p><p>savepoint 结点名：设置保存点</p><p>SET autocommit = 0 ;</p><p>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;<br>DELETE FROM accound WHERE id=28;<br>ROLLBACK TO a;</p><p>delete和truncate在事务使用时的区别</p><p>delete删除后支持回滚<br>SET autocommit = 0 ;<br>START TRANSACTION;<br>DELETE FROM account;<br>ROLLBACK;</p><p>truncate删除后不支持回滚<br>SET autocommit = 0 ;<br>START TRANSACTION;<br>TRUNCATE TABLE account;<br>ROLLBACK;</p><p>数据库的隔离级别</p><p>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：<br>脏读：对于两个事务T1，T2。T1读取了已经被T2更新但还没有被提交的字段之后，若T2回滚，T1读取的内容就是临时且无效的。主要是其他事务更新的数据<br>不可重复读：对于两个事务T1，T2。T1读取了一个字段，然后T2更新了该字段之后，T1再次读取同一个字段，值就不同了。<br>幻读：对于两个事务T1，T2。T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行之后，如果T1再次读取同一个表，就会多出几行。主要是其他事务插入的数据<br>数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。<br><strong>一个事务与其他事务隔离的程度称为隔离级别。</strong>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性弱。<br>数据库提供的4种事务隔离级别：img<br>Oracle支持2种事务隔离级别：READ COMMITED，SERIALIZABLE。Oracle默认的事务隔离级别是：READ COMMITED。<br>Mysql支持4种事务隔离级别。Mysql默认的事务隔离级别为：REPEATABLE READ。<br>每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前事务隔离级别。<br>查看当前的隔离级别：select @@tx_isolation;<br>设置当前mysql连接的隔离级别：set transaction isolation level read committed;<br>设置数据库系统的全局的隔离级别：set global transaction isolation level read committed;</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>含义：虚拟表，和普通表一样使用。并且使用视图时动态生成的，值保存了sql逻辑，不保存成查询结果。</p><p>mysql5.1版本出现的新特性，是通过表动态生成的数据</p><p>应用场景：</p><p>多个地方用到同样的查询结果<br>该查询结果使用的sql语句较复杂<br>案例1：查询姓张的学生名和专业名</p><p>普通写法<br>SELECT<br>  stuname,<br>  majorname<br>FROM<br>  suinfo s<br>  INNER JOIN major m<br>    ON s.majorid = m.<code>id</code><br>WHERE s.stuname LIKE ‘张%’ ;</p><p>视图写法<br>CREATE VIEW v1 AS<br>SELECT<br>  stuname,<br>  majorname<br>FROM<br>  suinfo s<br>  INNER JOIN major m<br>    ON s.majorid = m.<code>id</code> ;</p><p>SELECT </p><ul><li>FROM<br>v1<br>WHERE stuname LIKE ‘张%’ ;</li></ul><p>创建视图</p><p>语法：</p><p>create view 视图名 as 查询语句；</p><p>视图的好处：</p><p>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性<br>练习题：</p><p>习题1：查询姓名中包含a字符的员工名、部门名和工种信息</p><p>CREATE VIEW myv1 AS<br>SELECT<br>  last_name,<br>  department_name,<br>  job_title<br>FROM<br>  employees e<br>  JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code><br>  JOIN jobs j<br>    ON j.<code>job_id</code> = e.<code>job_id</code> ;</p><p>SELECT </p><ul><li>FROM<br>myv1<br>WHERE last_name LIKE ‘%a%’ ;</li></ul><p>习题2：查询各部门的平均工资级别</p><h5 id="创建视图查看每个部门的平均工资"><a href="#创建视图查看每个部门的平均工资" class="headerlink" title="创建视图查看每个部门的平均工资"></a>创建视图查看每个部门的平均工资</h5><p>CREATE VIEW myv2 AS<br>SELECT<br>  AVG(salary) ag,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id ;</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>SELECT<br>  myv2.<code>ag</code>,<br>  g.grade_level<br>FROM<br>  myv2<br>  JOIN job_grades g<br>    ON myv2.<code>ag</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p><p>习题3：查询平均工资最低的部门信息</p><h5 id="用习题2的视图myv2"><a href="#用习题2的视图myv2" class="headerlink" title="用习题2的视图myv2"></a>用习题2的视图myv2</h5><p>SELECT </p><ul><li>FROM<br>myv2<br>ORDER BY ag<br>LIMIT 1 ;</li></ul><p>习题4：查询平均工资最低的部门名和工资</p><p>CREATE VIEW myv3 AS<br>SELECT </p><ul><li>FROM<br>myv2<br>ORDER BY ag LIMIT 1 ;</li></ul><p>SELECT<br>  d.*,<br>  m.<code>ag</code><br>FROM<br>  myv3 m<br>  JOIN departments d<br>    ON m.<code>department_id</code> = d.<code>department_id</code> ;</p><p>视图的修改</p><p>方式1：create or replace view 视图名 as 查询语句；<br>方式2：alter view 视图名 as 查询语句；<br>删除视图</p><p>语法：drop view 视图名，视图名，…；<br>查看视图</p><p>语法：</p><p>show create view 视图名；</p><p>desc 视图名；</p><p>案例1：创建一个视图emp_v1，要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</p><p>CREATE OR REPLACE VIEW emp_v1 AS<br>SELECT<br>  last_name,<br>  salary,<br>  email<br>FROM<br>  employees<br>WHERE phone_number LIKE ‘011%’ ;</p><p>案例2：创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</p><p>CREATE OR REPLACE VIEW emp_v2 AS<br>SELECT<br>  MAX(salary) mx,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING MAX(salary) &gt; 12000 ;</p><p>SELECT </p><ul><li>FROM<br>emp_v2 ;</li></ul><p>SELECT<br>  d.*,<br>  m.mx<br>FROM<br>  departments d<br>  JOIN emp_v2 m<br>    ON m.department_id = d.<code>department_id</code> ;</p><p>视图的更新</p><p>增、删、改（视图基于的表也会发生更改）</p><p>CREATE OR REPLACE VIEW myv1 AS<br>SELECT<br>  last_name,<br>  email<br>FROM<br>  employees;</p><p>SELECT * FROM myv1;</p><h5 id="mZ插入"><a href="#mZ插入" class="headerlink" title="mZ插入"></a>mZ插入</h5><p>INSERT INTO myv1 VALUES(‘张飞’, ‘zhangfei’);</p><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>UPDATE myv1 SET last_name=’张无忌’ WHERE last_name = ‘张飞’;</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>DELETE FROM myv1 WHERE last_name=’张无忌’;</p><p>视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的。（注意：视图一般用于查询，而不是更新。）</p><p>包含以下关键字的sql语句：分组函数、distinct、group by、having、union或union all<br>常量视图<br>select中包含子查询<br>join<br>from 一个不能更新的视图<br>where子句的子查询应用了from子句中的表<br>视图和表的对比</p><p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view    只是保存了sql逻辑    增删改查，一般不能增删改<br>表    create table    保存了实际的数据    增删改查<br>测试题</p><p>题1：创建表</p><p>CREATE TABLE book (<br>  bid INT PRIMARY KEY,<br>  bname VARCHAR (20) UNIQUE nut NULL,<br>  price FLOAT DEFAULT 10,<br>  btypeid INT,<br>  FOREIGN KEY (btypeid) REFERENCES booktype (id)<br>) ;</p><p>题2：开启事务，向表中插入1行数据，并结束</p><p>SET autocommit = 0 ;<br>INSERT INTO book(bid, bname, price, btypeid)<br>VALUES(1, ‘小李飞刀’, 100, 1);<br>COMMIT;</p><p>题3：创建视图，实现查询价格大于100的书名和类型名</p><p>CREATE VIEW myv1 AS<br>SELECT<br>  bname,<br>  NAME<br>FROM<br>  book b<br>  INNER JOIN booktype t<br>    ON b.btypeid = t.id<br>WHERE price &gt; 100 ;</p><p>题4：修改视图，实现查询价格在90-120之间的书名和价格</p><p>CREATE OR REPLACE VIEW myv1 AS<br>SELECT<br>  bname,<br>  price<br>FROM<br>  book<br>WHERE price BETWEEN 90<br>  AND 120 ;</p><p>题5：删除刚才创建的视图</p><p>DROP VIEW myv1;<br>1</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>系统变量</p><p>说明：变量由系统提供，不是用户定义，属于服务器层面</p><p>注意：如果是全局级别，则需要加global；如果是会话级别，则需要加session；如果不写，则默认session</p><p>使用的语法：</p><p>查看所有的系统变量</p><p>SHOW GLOBAL|【SESSION】 VARIABLES;<br>1<br>查看满足条件的部分系统变量</p><p>SHOW GLOBAL|【SESSION】 VARIABLES LIKE ‘%char%’;<br>1<br>查看指定的某个系统变量的值</p><p>SELECT @@GLOBAL|【SESSION】.系统变量名;<br>1<br>为某个系统变量赋值</p><p>方式一</p><p>set GLOBAL|【SESSION】 系统变量名 = 值;<br>1<br>方式二</p><p>set @@GLOBAL|【SESSION】.系统变量名 = 值;<br>1<br>分类：</p><p>全局变量</p><p>服务器层面上的，必须拥有super权限才能为系统变量赋值。</p><p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启。</p><p>查看所有的全局变量</p><p>SHOW GLOBAL VARIABLES;</p><ul><li>查看部分的全局变量</li></ul><p>SHOW GLOBAL VARIABLES LIKE ‘%char%’;</p><ul><li>查看指定的全局变量的值</li></ul><p>SELECT @@global.autocommit;<br>SELECT @@global.tx_isolation;</p><ul><li><p>为某个指定的全局变量赋值</p></li><li><p>方式1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li><li><p>方式2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@global.autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li></ul><p>会话变量</p><p>服务器为每一个连接的客户端都提供了系统变量。</p><p>作用域：仅仅针对于当前会话（连接）有效。</p><p>查看所有的会话变量</p><p>SHOW 【SESSION】 VARIABLES;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查看部分的会话变量</span><br><span class="line"></span><br><span class="line">SHOW 【SESSION】 VARIABLES LIKE ‘%char%’;</span><br></pre></td></tr></table></figure><p>查看指定的某个会话变量</p><p>SELECT @@【SESSION.】autocommit;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">为某个会话变量赋值</span><br><span class="line"></span><br><span class="line">方式1：</span><br><span class="line"></span><br><span class="line">set session autocommit&#x3D;0;</span><br></pre></td></tr></table></figure><ul><li><p>方式2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@【session.】autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li></ul><p>自定义变量</p><p>变量是用户自定义的，不是由系统定义的</p><p>使用步骤：声明 赋值 使用（查看、比较、运算等）</p><p>分类</p><p>用户变量</p><p>作用域：针对于当前会话（连接）有效，等同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end的外面<br>声明并初始化（三种方式）</p><p>set @用户变量名=值；<br>set @用户变量名:=值；（推荐）<br>select @用户变量名:=值；</p><p>赋值（更新用户变量的值）</p><p>方式1：通过set或select（同上）</p><p>set @用户变量名=值；<br>set @用户变量名:=值；（推荐）<br>select @用户变量名:=值；</p><p>案例1：</p><p>SET @name=’John’;<br>SET @name=100;</p><p>方式2：通过select into</p><p>select 字段 into 变量名<br>from 表；</p><p>案例1：</p><p>SELECT<br>  COUNT(*) INTO @count<br>FROM<br>  employees ;</p><p>使用（查看用户变量的值）</p><p>select @用户变量名；</p><p>局部变量</p><p>作用域：仅仅在定义它的begin end中有效<br>应用在begin end中的第一句话<br>声明</p><p>declare 变量名 类型；</p><p>declare 变量名 类型 default 值；</p><p>赋值</p><p>方式1：通过set或select（同上）</p><p>set 局部变量名=值；<br>set 局部变量名:=值；（推荐）<br>select @局部变量名:=值；</p><p>方式2：通过select into</p><p>select 字段 into 局部变量名<br>from 表；</p><p>使用</p><p>select 局部变量名；</p><p>对比用户变量和局部变量：</p><p>作用域    定义和使用的位置    语法<br>用户变量    当前会话    会话中的任何地方    必须加@符号，不用限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句话    一般不用加@符号，需要限定类型<br>案例1：声明两个变量并赋初始值，求和，并打印</p><p>用户变量</p><p>SET @m=1;<br>SET @n=2;<br>SET @sum=@m+@n;<br>SELECT @sum;</p><p>局部变量</p><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 2;<br>DECLARE SUM INT;<br>SET SUM=m+n;<br>SELECT SUM;</p><h4 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h4><p>类似于java中的方法<br>好处：<br>提高代码的重用性<br>简化操作</p><h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><p>含义：一组预先编译好的sql语句的集合，理解成批处理语句</p><p>好处：</p><p>提高代码的重用性<br>简化操作<br>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>语法：</p><p>创建语法</p><p>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN<br>    存储过程体(一组合法的SQL语句)<br>END</p><p>注意</p><p>参数列表包含三部分：参数模式，参数名，参数类型</p><p>举例：in stuname varchar(20)<br>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又需要返回值<br>如果存储过程体仅仅只有一句话，begin end可以省略</p><p>存储过程体中的每条SQL语句的结尾要求必须加分号</p><p>存储过程的结尾可以使用 DELIMITER 重新设置</p><p>语法：DELIMITER 结束标记</p><p>案例：</p><p>DELIMITER $<br>1<br>调用语法</p><p>call 存储过程名(实参列表)；<br>空参列表</p><p>案例1：插入到admin表中五条记录</p><p>SELECT * FROM admin;<br>DELIMITER $</p><p>CREATE PROCEDURE myp1()<br>BEGIN<br>INSERT INTO admin(username, <code>password</code>)<br>VALUES<br>(‘john1’, ‘0000’),<br>(‘asd’, ‘0000’),<br>(‘joqqhn1’, ‘0000’),<br>(‘qa’, ‘0000’),<br>(‘ww’, ‘0000’);<br>END $</p><p>CALL myp1()$</p><p>创建带in模式参数的存储过程</p><p>案例1：创建存储过程实现：根据女神名，查询对应的男神信息</p><p>CREATE PROCEDURE myp2(IN beautyname VARCHAR(20))<br>BEGIN<br>SELECT bo.*<br>FROM boys bo<br>RIGHT JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL myp2(‘柳岩’)$<br>CALL myp2(‘王语嫣’)$</p><p>案例2：创建存储过程实现，用户是否登录成功</p><p>CREATE PROCEDURE myp4(IN username VARCHAR(20), IN passward VARCHAR(20))<br>BEGIN<br>DECLARE result INT DEFAULT 0;    # 声明并初始化</p><p>SELECT COUNT(*) INTO result    # 赋值<br>FROM admin<br>WHERE admin.username = username<br>AND admin.password = PASSWORD;</p><p>SELECT IF(result&gt;0, ‘成功！’, ‘失败！’); # 使用<br>END $</p><p>CALL myp4(‘张飞’, ‘8888’)$</p><p>创建带out模式的存储过程</p><p>案例1：根据女神名，返回对应的男神名</p><p>CREATE PROCEDURE myp5(IN beautyname VARCHAR(20), OUT boyname VARCHAR(20))<br>BEGIN<br>SELECT bo.boyname INTO boyname<br>FROM boys bo<br>INNER JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL myp5(‘王语嫣’, @bname)$<br>SELECT @bname$</p><p>案例2：根据女神名，返回对应的男神名和男神魅力值</p><p>CREATE PROCEDURE myp6(IN beautyname VARCHAR(20), OUT boyname VARCHAR(20), OUT usercp INT)<br>BEGIN<br>SELECT bo.boyname, bo.usercp INTO boyname, usercp<br>FROM boys bo<br>INNER JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL myp6(‘王语嫣’, @bname, @usercp)$<br>SELECT @bname, @usercp$</p><p>创建带inout模式参数的存储过程</p><p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p><p>CREATE PROCEDURE myp8(INOUT a INT, INOUT b INT)<br>BEGIN<br>SET a=a<em>2;<br>SET b=b</em>2;<br>END $</p><p>SET @m=10$<br>SET @n=20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$</p><p>练习题</p><p>习题1：创建存储过程实现传入用户名和密码，插入到admin表中</p><p>CREATE PROCEDURE test_pro1(IN username VARCHAR(20), IN loginpwd VARCHAR(20))<br>BEGIN<br>INSERT INTO admin(admin.<code>username</code>, PASSWORD)<br>VALUES(username, loginpwd);<br>END $</p><p>CALL test_pro1(‘litian’, ‘1234’)$<br>SELECT * FROM admin$</p><p>习题2：创建存储过程实现传入女神编号，返回女神名称和女神电话</p><p>CREATE PROCEDURE test_pro2(IN id INT, OUT NAME VARCHAR(20), OUT phone VARCHAR(20))<br>BEGIN<br>SELECT b.name, b.phone INTO NAME, phone<br>FROM beauty b<br>WHERE b.id=id;<br>END $</p><p>SET @n=’’$<br>SET @m=’’$<br>CALL test_pro2(1, @n, @m)$<br>SELECT @m,@n$</p><p>习题3：创建存储过程来实现传入两个女神生日，返回大小</p><p>CREATE PROCEDURE test_pro3(IN birth1 DATETIME, IN birth2 DATETIME, OUT result INT)<br>BEGIN<br>SELECT DATEDIFF(birth1, birth2) INTO result;<br>END $</p><p>CALL test_pro3(‘1990-2-3’, NOW(), @result)$<br>SELECT @result$</p><p>存储过程的删除</p><p>语法：drop procedure 存储过程名</p><p>DROP PROCEDURE myp1;<br>1<br>不能同时删除多个存储过程</p><p>查看存储过程的信息</p><p>语法：show create procedure 存储过程名</p><p>SHOW CREATE PROCEDURE myp2;<br>1<br>不能修改存储过程中的语句，需要修改的话，就删了重写。</p><p>练习题</p><p>练习题1：创建存储过程实现传入一个日期，格式化成xx年xx月xx日并返回</p><p>CREATE PROCEDURE test_pro4(IN mydate DATETIME, OUT strdate VARCHAR(20))<br>BEGIN<br>SELECT DATE_FORMAT(mydate, ‘%y年%m月%d天’) INTO strdate;<br>END $</p><p>CALL test_pro4(NOW(), @str)$<br>SELECT @str $</p><p>练习题2：创建存储过程实现传入女神名称，返回：女神 and 男神 格式的字符串</p><p>CREATE PROCEDURE test_pro5(IN beautyname VARCHAR(20), OUT str VARCHAR(50))<br>BEGIN<br>SELECT CONCAT(beautyname, ‘ and ‘, IFNULL(boyname, ‘null’)) INTO str<br>FROM boys bo<br>RIGHT JOIN beauty b<br>ON b.boyfriend_id=bo.id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL test_pro5(‘王语嫣’, @result)$<br>SELECT @result$</p><p>练习题3：创建存储过程，根据传入的起始索引和条目数，查询beauty表的记录</p><p>CREATE PROCEDURE test_pro6(IN startindex INT, IN size INT)<br>BEGIN<br>SELECT * FROM beauty LIMIT startindex, size;<br>END $</p><p>CALL test_pro6(3, 3)$</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>好处：</p><p>提高代码的重用性<br>简化操作<br>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>与存储过程的区别：</p><p>存储过程：可以有0个返回，也可以有多个返回（适合做批量插入、更新）<br>函数：有且仅有1个返回（适合处理数据后返回一个结果）<br>创建语法：</p><p>create function 函数名（参数列表） returns 返回类型</p><p>begin</p><p>函数体</p><p>end</p><p>注意事项：<br>参数列表：包含两部分：参数名 参数类型，注意：没有in，out，inout这种模式了<br>函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议<br>函数体中仅有一句话，则可以省略begin end<br>使用delimiter语句设置结束标记<br>调用语法：select 函数名(参数列表)</p><p>无参有返回</p><p>案例1：返回公司的员工个数</p><p>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN<br>DECLARE c INT DEFAULT 0;# 定义变量<br>SELECT COUNT(*) INTO c# 赋值<br>FROM employees;<br>RETURN c;<br>END $</p><p>SELECT myf1()$</p><p>有参有返回</p><p>案例1：根据员工名，返回他的工资</p><p>CREATE FUNCTION myf2(empname VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>SET @sal=0;<br>定义用户变量<br>SELECT salary INTO @sal# 赋值<br>FROM employees<br>WHERE last_name = empname;<br>RETURN @sal;<br>END $</p><p>SELECT myf2(‘kochhar’)$</p><p>案例2：根据部门名，返回该部门的平均工资</p><p>CREATE FUNCTION myf3(deptname VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>DECLARE sal DOUBLE;<br>SELECT AVG(salary) INTO sal<br>FROM employees e<br>JOIN departments d ON e.department_id = d.department_id<br>WHERE d.department_name=deptname;</p><p>RETURN sal;<br>END $</p><p>SELECT myf3(‘IT’)$</p><p>查看函数：</p><p>SHOW CREATE FUNCTION myf3;<br>1<br>删除函数：</p><p>DROP FUNCTION myf3;<br>1<br>案例1：创建函数，实现传入两个float，返回二者之和</p><p>CREATE FUNCTION test_fun1(num1 FLOAT, num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>DECLARE SUM FLOAT DEFAULT 0;<br>SET SUM=num1+num2;<br>RETURN SUM;<br>END $</p><p>SELECT test_fun1(1,2)$</p><p>流程控制结构<br>分类</p><p>顺序结构：结构从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上，重复执行一段代码<br>分支结构</p><p>if函数</p><p>功能：实现简单的双分支</p><p>语法：</p><p>select if(表达式1，表达式2，表达式3)</p><p>执行顺序：</p><p>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值</p><p>应用环境：任何地方</p><p>case结构</p><p>情况1：类似于java中的switch语句，一般用于实现等值判断</p><p>语法：</p><p>case 变量|表达式|字段</p><p>when 要判断的值 then 返回的值1或语句1；</p><p>when 要判断的值 then 返回的值2或语句2；</p><p>…</p><p>else 要返回的值n或语句n；</p><p>end case；</p><p>情况2：类似于java中的多重if语句，一般用于实现区间判断</p><p>语法：</p><p>case</p><p>when 要判断的条件1 then 返回的值1或语句1；</p><p>when 要判断的条件2 then 返回的值2或语句2；</p><p>…</p><p>else 要返回的值n或语句n；</p><p>end case；</p><p>特点：</p><p>可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end 中，或 begin end 的外面<br>也可以作为独立的语句去使用，只能放在begin end 中<br>如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case<br>如果都不满足，则执行else中的语句或值<br>else可以省略，如果else省略了，并且所有的when条件都不满足，则返回null<br>img</p><p>img</p><p>案例1：创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：90-100，显示A；80-90：显示B；60-80：显示C；否则显示D</p><p>CREATE PROCEDURE test_case(IN score INT)<br>BEGIN<br>CASE<br>WHEN score &gt;= 90 AND score &lt;= 100 THEN SELECT ‘A’;<br>WHEN score &gt;=80 THEN SELECT ‘B’;<br>WHEN score &gt;= 60 THEN SELECT ‘C’;<br>ELSE SELECT ‘D’;<br>END CASE;<br>END $</p><p>CALL test_case(95)$</p><p>if结构</p><p>功能：实现多重分支</p><p>语法：</p><p>if 条件1 then 语句1；</p><p>elseif 条件2 then 语句2；</p><p>…</p><p>【else 语句n；】</p><p>end if；</p><p>应用场合：应用在begin end中</p><p>案例2：创建存储过程，根据传入的成绩，来返回等级，比如传入的成绩：90-100，返回A；80-90：返回B；60-80：返回C；否则返回D</p><p>CREATE FUNCTION test_if(score INT) RETURNS CHAR<br>BEGIN<br>IF score &gt;= 90 AND score &lt;= 100 THEN RETURN ‘A’;<br>ELSEIF score &gt;=80 THEN RETURN ‘B’;<br>ELSEIF score &gt;= 60 THEN RETURN ‘C’;<br>ELSE RETURN ‘D’;<br>END IF;<br>END $</p><p>SELECT test_if(86)$</p><p>循环结构</p><p>分类：while、loop、repeat</p><p>循环控制：</p><p>iterate：类似于continue，继续；结束本次循环，继续下一次<br>leave：类似于break，跳出；结束当前所在循环<br>while</p><p>语法：</p><p>[标签：】while 循环条件 do</p><p>循环体；</p><p>end while 【标签】；</p><p>loop</p><p>语法：</p><p>【标签：】loop</p><p>循环体；</p><p>end loop 【标签】；</p><p>可以用来模拟简单的死循环</p><p>repeat</p><p>语法：</p><p>【标签：】repeat</p><p>循环体；</p><p>until 结束循环的条件</p><p>end repeat【标签】；</p><p>对比：</p><p>这人三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称<br>loop：一般用于实现简单的死循环<br>while：先判断后执行<br>repeat：先执行后判断，无条件至少执行一次<br>案例1：没有添加循环控制语句</p><p>批量插入，根据次数插入到admin表中多条记录</p><p>CREATE PROCEDURE pro_while1(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>WHILE i &lt;= insertcount DO<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘Rose’, i), ‘666’);<br>SET i=i+1;<br>END WHILE;<br>END $</p><p>CALL pro_while1(100)$<br>SELECT * FROM admin;</p><p>案例2：添加leave语句</p><p>批量插入，根据次数插入到admin表中20条记录</p><p>CREATE PROCEDURE test_while1(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>a:WHILE i &lt;= insertcount DO<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘xiaohua’, i), ‘000’);<br>IF i&gt;=20 THEN LEAVE a;<br>END IF;<br>SET i=i+1;<br>END WHILE a;<br>END $</p><p>CALL test_while1(100)$<br>SELECT * FROM admin;</p><p>案例3：添加iterate语句</p><p>批量插入，根据次数插入到admin表中多条记录，只插入偶数次</p><p>CREATE PROCEDURE test_while2(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>a:WHILE i &lt;= insertcount DO<br>SET i=i+1;<br>IF MOD(i,2) != 0 THEN ITERATE a;<br>END IF;<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘xiaohua’, i), ‘000’);<br>END WHILE a;<br>END $</p><p>CALL test_while2(100)$<br>SELECT * FROM admin;</p><p>案例4：已知表stringcontent，其中字段id 自增长；content varchar(20)，向该表中插入指定个数的随机的字符串</p><p>USE test;<br>DROP TABLE IF EXISTS stringcontent;<br>CREATE TABLE stringcontent(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>content VARCHAR(20)<br>);</p><p>DELIMITER $<br>CREATE PROCEDURE test_randstr_insert(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;# 定义一个循环变量i，表示插入次数<br>DECLARE str VARCHAR(26) DEFAULT ‘abcdefghijklmnopqrstuvwxyz’;<br>DECLARE startindex INT DEFAULT 1;# 代表起始索引<br>DECLARE len INT DEFAULT 1;# 代表截取的字符的长度<br>WHILE i&lt;=insertcount DO<br>SET len=FLOOR(RAND()*(20-startindex+1)+1);# 产生一个随机的整数，代表截取长度，1-(26-startindex+1)<br>SET startindex=FLOOR(RAND()*26+1);# 产生一个随机的整数，代表起始索引1-26<br>INSERT INTO stringcontent(content) VALUES(SUBSTR(str, startindex, len));<br>SET i=i+1;<br>END WHILE;<br>END $</p><p>CALL test_randstr_insert(10)$<br>SELECT * FROM stringcontent;<br>CALL test_randstr_insert(10)$<br>SELECT * FROM stringcontent;</p><p>返回该字符的密码形式<br>md5()</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c-4</title>
    <link href="http://example.com/posts/39404/"/>
    <id>http://example.com/posts/39404/</id>
    <published>2020-10-11T02:04:42.000Z</published>
    <updated>2020-10-12T05:31:22.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相关模式.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
</feed>

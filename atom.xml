<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌上花开缓缓归</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-27T13:47:17.666Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lys-studys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高精度</title>
    <link href="http://example.com/posts/40472/"/>
    <id>http://example.com/posts/40472/</id>
    <published>2021-07-27T13:35:53.000Z</published>
    <updated>2021-07-27T13:47:17.666Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>    &gt; File Name: 加法.cpp<br>    &gt; Author:<br>    &gt; Mail:<br>    &gt; Created Time: 2021年07月27日 星期二 08时47分49秒<br> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">505</span>], s2[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">505</span>],b[<span class="number">505</span>],c[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> la, lb, lc;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s1);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s2);</span><br><span class="line">la = <span class="built_in">strlen</span>(s1);</span><br><span class="line"> lb = <span class="built_in">strlen</span>(s2);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; la; i++)&#123;</span><br><span class="line">      a[la - i] = s1[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//倒置　</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; lb; i++)&#123;</span><br><span class="line">     b[lb - i] = s2[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//倒置</span></span><br><span class="line"> &#125;</span><br><span class="line"> lc = max(la, lb) + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lc; i++)&#123;</span><br><span class="line">      c[i] += a[i] + b[i];</span><br><span class="line">     c[i + <span class="number">1</span>] = c[i] / <span class="number">10</span>;</span><br><span class="line">     c[i] = c[i] % <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(c[lc] == <span class="number">0</span> &amp;&amp; lc &gt; <span class="number">0</span>) lc--;<span class="comment">//删除前导零 &amp;&amp; 保留唯一零</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = lc; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>    &gt; File Name: 减法.cpp<br>    &gt; Author:<br>    &gt; Mail:<br>    &gt; Created Time: 2021年07月27日 星期二 08时55分27秒<br> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">10090</span>],s2[<span class="number">10090</span>],s3[<span class="number">10090</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10090</span>], b[<span class="number">10090</span>], c[<span class="number">10090</span>];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">char</span> s1[], <span class="keyword">char</span> s2[])</span></span>&#123; <span class="comment">// s1 &gt;= s2如果是true否则false;</span></span><br><span class="line">    <span class="keyword">int</span> u = <span class="built_in">strlen</span>(s1), v = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">if</span>(u != v) <span class="keyword">return</span> u &gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] != s2[i]) <span class="keyword">return</span> s1[i] &gt; s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la, lb, lc;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s2);</span><br><span class="line">    <span class="keyword">if</span>(!compare(s1, s2))&#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(s3, s1);</span><br><span class="line">        <span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line">        <span class="built_in">strcpy</span>(s2, s3);</span><br><span class="line">    &#125;</span><br><span class="line">    la = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    lb = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; la; i++)&#123;</span><br><span class="line">        a[la - i] = s1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lb; i++)&#123;</span><br><span class="line">        b[lb - i] = s2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lc = max(la, lb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lc; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i])&#123;</span><br><span class="line">            a[i+<span class="number">1</span>]--;</span><br><span class="line">            a[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c[i] = a[i] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c[lc] == <span class="number">0</span> &amp;&amp; lc &gt; <span class="number">1</span>) lc--;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lc; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>    &gt; File Name: 乘法.cpp<br>    &gt; Author:<br>    &gt; Mail:<br>    &gt; Created Time: 2021年07月27日 星期二 09时25分19秒<br> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">2005</span>], s2[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2005</span>], b[<span class="number">2005</span>], c[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la, lb, lc;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s2);</span><br><span class="line">    la = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    lb = <span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; la; i++)&#123;</span><br><span class="line">        a[la - i] = s1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lb; i++)&#123;</span><br><span class="line">        b[lb - i] = s2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lc = la + lb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lb; j++)&#123;</span><br><span class="line">            c[i + j - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">            c[i + j] += c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">            c[i + j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c[lc] == <span class="number">0</span> &amp;&amp; lc &gt; <span class="number">0</span>) lc--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lc; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>    &gt; File Name: 高精度.cpp<br>    &gt; Author:<br>    &gt; Mail:<br>    &gt; Created Time: Tue 27 Jul 2021 01:37:50 PM CST<br> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逐步求商。大整数除以整数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b, x, c[<span class="number">5005</span>], a[<span class="number">5005</span>], la, lc;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// cin &gt;&gt; s1 &gt;&gt; b;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s1);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b);</span><br><span class="line">    la = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; i++) a[i] = a[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; ++i)&#123;</span><br><span class="line">        c[i] = (x * <span class="number">10</span> + a[i]) % b;</span><br><span class="line">        x = (x * <span class="number">10</span> + a[i]) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    lc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c[lc] == <span class="number">0</span> &amp;&amp; lc &lt; la) lc++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lc; i &lt;= la; ++i)<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, c[i]); <span class="comment">//cout &lt;&lt; c[i];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>    &gt; File Name: 高精度2.cpp<br>    &gt; Author:<br>    &gt; Mail:<br>    &gt; Created Time: Tue 27 Jul 2021 02:14:31 PM CST<br> <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逐位式商法不能适用</span></span><br><span class="line"><span class="comment">//减法模拟除法来进行。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">305</span>], s2[<span class="number">305</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">305</span>], b[<span class="number">305</span>], c[<span class="number">305</span>], tmp[<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">305</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    x[<span class="number">0</span>] = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        x[x[<span class="number">0</span>] - i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;<span class="comment">//倒置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minu</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[])</span></span>&#123;<span class="comment">// 1: a &gt; b  0: a = b  -1: a &lt; b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[i])&#123;</span><br><span class="line">            a[i + <span class="number">1</span>]--;</span><br><span class="line">            a[i] = a[i] + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = a[i] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a[a[<span class="number">0</span>]] == <span class="number">0</span> &amp;&amp; a[<span class="number">0</span>] &gt; <span class="number">0</span>) a[<span class="number">0</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">numcpy</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> q[], <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//将p数组整体移动n位到q数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p[<span class="number">0</span>]; i++) q[i + n - <span class="number">1</span>] = p[i];</span><br><span class="line">    q[<span class="number">0</span>] = p[<span class="number">0</span>] + n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(a);<span class="comment">//a[0]存位数 b[] c[]同理.</span></span><br><span class="line">    init(b);</span><br><span class="line">    c[<span class="number">0</span>] = a[<span class="number">0</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">        numcpy(b, tmp, i);<span class="comment">// 将除数移动i位</span></span><br><span class="line">        <span class="keyword">while</span>(compare(a, tmp) &gt;= <span class="number">0</span>)&#123;<span class="comment">//循环减下去</span></span><br><span class="line">            c[i]++;<span class="comment">//每次减去一个，c[i]就会增加一，以减带除</span></span><br><span class="line">            minu(a, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c[c[<span class="number">0</span>]] == <span class="number">0</span> &amp;&amp; c[<span class="number">0</span>] &gt; <span class="number">0</span>) c[<span class="number">0</span>]--;</span><br><span class="line">    print(c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    print(a);<span class="comment">// 余数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>dp专栏</title>
    <link href="http://example.com/posts/62516/"/>
    <id>http://example.com/posts/62516/</id>
    <published>2021-07-25T11:29:29.000Z</published>
    <updated>2021-07-25T11:31:31.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="从递归到递推（一）"><a href="#从递归到递推（一）" class="headerlink" title="从递归到递推（一）"></a>从递归到递推（一）</h3><h5 id="兔子繁殖问题"><a href="#兔子繁殖问题" class="headerlink" title="兔子繁殖问题"></a>兔子繁殖问题</h5><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722103017137.png" alt="image-20210722103017137" style="zoom: 80%;" /><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722103353621.png" alt="image-20210722103353621"></p><p>定义状态：f(n)表示第n个月小兔子的数量。</p><p>同图标分析可知本月的兔子数量为上一个月和上两个月繁殖兔子数量之和。</p><p>枚举所有情况可得 n == 1 或者2的时候，f(n) 为n，其他情况f(n) = f(n - 1) + f(n - 2)。</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722103808756.png" alt="image-20210722103808756"></p><h5 id="兔子繁殖问题代码及优化"><a href="#兔子繁殖问题代码及优化" class="headerlink" title="兔子繁殖问题代码及优化"></a>兔子繁殖问题代码及优化</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f(int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return n;</span><br><span class="line">return f(n - 1) + f(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此函数的数据范围到达四十或者六十，会因为过多的重复执行超时。如图</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722105313835.png" alt="image-20210722105313835"></p><p>图中的红色部分为重复计算的部分。</p><h5 id="递推中的递归实现方法的优化（记忆化）"><a href="#递推中的递归实现方法的优化（记忆化）" class="headerlink" title="递推中的递归实现方法的优化（记忆化）"></a>递推中的递归实现方法的优化（记忆化）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_N 1000 &#x2F;&#x2F; 这个长度为整个n的长度。这个计算数据的个数。</span><br><span class="line">int f_keep[MAX_N + 5];</span><br><span class="line">int f(int n)&#123;</span><br><span class="line">if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return n;</span><br><span class="line">if(f_keep[n]) return f_keep[n];&#x2F;&#x2F;记忆化部分</span><br><span class="line">f_keep[n] &#x3D; f(n - 1) + f(n - 2);</span><br><span class="line">return f_keep[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>爬楼梯问题</p><ol><li><p>确定递推状态  f(n)表示走到第n个台阶的方法整数。</p></li><li><p>找到递推公式  f(n) = f(n - 2) + f(n - 3);</p></li><li><p>程序实现方法一（递归 + 记忆化） 方法二（循环） O(n);   <strong>滚动数组优化。</strong></p></li></ol><p>   <strong>墙壁涂色问题</strong></p>   <img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210723185243148.png" alt="image-20210723185243148" style="zoom: 67%;" /><p>   <img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210723190059534.png" alt="image-20210723190059534"></p><p>   解决环的状态： 最特殊的两块就是首位两块，首先确定两块的颜色即可。</p><p>   第n种颜色确定，第n - 1种颜色只能为两种。</p><p>   <img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210723190652683.png" alt="image-20210723190652683"></p><p>f[1]为 n = 1 的时候的矩阵，那个矩阵表示为一块板子都图1或者2或者3的种类数都是1种，对应了矩阵中的1.</p><p>f[2]同理。只有两块板子，肯定不能涂先沟通的颜色。</p><p><strong>钱币问题</strong></p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210723192156946.png" alt="image-20210723192156946"></p><p>递推公式表示为：不用第i种钱币凑j元钱的总数 + 用第i种钱币凑（j - w[i]）元钱的总数（这里用减去w[i]表示一定用w[i]）。</p><p>作业！！！！！</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210723193135220.png" alt="image-20210723193135220"></p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续….."></a>未完待续…..</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://example.com/posts/49176/"/>
    <id>http://example.com/posts/49176/</id>
    <published>2021-07-25T11:25:35.000Z</published>
    <updated>2021-07-25T11:26:26.784Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="计算机虚拟化概述"><a href="#计算机虚拟化概述" class="headerlink" title="计算机虚拟化概述"></a>计算机虚拟化概述</h3><p>计算机虚拟化起始于上世纪60年代的IBM公司。</p><p>虚拟化：将底层的计算机资源抽象（虚拟）为多组彼此之间互相隔离的计算平台，每个计算平台都应该具有五大基本部件中的所有设备</p><ul><li>CPU</li><li>内存（Memory）</li><li>IO（keyboard键盘，monitor显示器）</li></ul><h3 id="1-1-CPU的虚拟化"><a href="#1-1-CPU的虚拟化" class="headerlink" title="1.1 CPU的虚拟化"></a>1.1 CPU的虚拟化</h3><p>所有的内核在开发时都以为自己可以操作所有的硬件设备，也就是运行在环0上</p><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202010/1278240-20201021143127275-3141383.png" alt="img"></p><h4 id="1-1-1-模拟：emulation"><a href="#1-1-1-模拟：emulation" class="headerlink" title="1.1.1 模拟：emulation"></a>1.1.1 模拟：emulation</h4><ul><li>虚拟是直接在每个虚拟机上用软件虚拟化一个CPU，用纯软件的方式实现，性能很差</li><li>底层和上层的架构可以不一致</li><li>要模拟CPU的环0、1、2、3 //环这里表示运行权限等级。</li></ul><h4 id="1-1-2-虚拟：virtulization"><a href="#1-1-2-虚拟：virtulization" class="headerlink" title="1.1.2 虚拟：virtulization"></a>1.1.2 虚拟：virtulization</h4><ul><li>上层架构和底层架构要保持一致</li><li>虚拟只需要模拟环0</li><li>因为上层架构和底层架构一致，所以Guest上用户空间的指令直接可以放到Host上来运行</li><li>注：<strong>Host</strong> OS (主人操作系统）就是安装在你硬件设备上的系统，而<strong>Guest</strong> OS (客人操作系统）则是安装在虚拟机（VM）上面的系统。</li></ul><p><strong>1）完全虚拟化（full-virtulization）</strong></p><p>所谓完全虚拟化，即虚拟机都不知道自己是运行在虚拟环境中的</p><p>完全虚拟化一定会导致中间有个转换的过程</p><ul><li>BT：（二进制翻译软件）<ul><li>能让客户机对特权指令的调用按需直接翻译成宿主机对特权指令的调用</li><li>Guest的用户空间在环3上，Guest的内核空间在环1上，Host的内核空间在环0上，BT就监控在环1上，随时将Guest的内核的调用转换成特权指令的调用</li></ul></li><li>HVM：（硬件辅助的虚拟机，硬件虚拟化）<ul><li>多增一个指令环，有5个级别的环</li><li>宿主机的内核空间在环-1上，Guest直接运行在环0上，但是环0上没有指令，但它能自动捕获后放到环-1上运行</li></ul></li></ul><p><strong>2）半虚拟化（para-virtulization）</strong></p><ul><li>宿主机系统是明确知道自己在虚拟环境中的（特制的内核）</li><li>对hypervisor（宿主机）的调用被称为hyper call</li></ul><h3 id="1-2-Memory及I-O的虚拟化"><a href="#1-2-Memory及I-O的虚拟化" class="headerlink" title="1.2 Memory及I/O的虚拟化"></a>1.2 Memory及I/O的虚拟化</h3><p><strong>1）内存的虚拟化</strong></p><ul><li>进程：线性地址空间</li><li>内核：物理地址空间</li><li>shadow page table</li><li>MMU的虚拟化<ul><li>Interl：EPT，Extend Page Table</li><li>AMD：NTP，Nested Page Table</li></ul></li><li>TLB的虚拟化<ul><li>tagged TLB</li></ul></li></ul><p><strong>2）I/O的虚拟化</strong></p><ul><li>模拟：完全用软件来模拟真实硬件（键盘鼠标通常都是完全模拟实现的）</li><li>半虚拟化（这种虚拟通常只适用于硬盘和网卡）<ul><li>IO frontend 前端驱动</li><li>IO backend 后端驱动</li></ul></li><li>IO-through：IO透传<ul><li>让虚拟机直接去操作硬件，但依然需要hypervisor来协调</li></ul></li><li>Intel：VT-d<ul><li>要完成中断映射</li><li>基于北桥的硬件辅助的虚拟化技术</li></ul></li></ul><h3 id="1-3-虚拟化的实现及分类"><a href="#1-3-虚拟化的实现及分类" class="headerlink" title="1.3 虚拟化的实现及分类"></a>1.3 虚拟化的实现及分类</h3><p><strong>1）虚拟化的两种实现方式</strong></p><ul><li>Type-I<ul><li>直接在硬件上运行hypervisor，所有运行在当前机器上的都是虚拟机</li><li>如 xen，vmware ESX/ESXi</li></ul></li><li>Type-II<ul><li>宿主机运行在硬件上，在宿主机上运行客户机</li><li>kvm，vmware workstation，virtualbox</li></ul></li></ul><p><strong>2）虚拟化技术的分类</strong></p><ul><li>模拟：著名的模拟器：PearPC，Bochs，<strong>QEMU</strong></li><li>完全虚拟化（native virtulization）<ul><li>两种加速方式<ul><li>BT 二进制翻译</li><li>HVM 硬件辅助虚拟化</li></ul></li><li>产品：VMware Workstation，VMware Server，KVM，Xen（HVM）</li></ul></li><li>半虚拟化（para-virtulization）<ul><li>xen，uml（user-mod linux）</li></ul></li><li>OS级别的虚拟化<ul><li>OpenVZ</li><li>LXC</li><li>Solaris Containers</li><li>FreeBSD jails</li></ul></li><li>库虚拟化：wine</li><li>应用程序虚拟化：jvm</li></ul><h3 id="1-4-创建和配置桥"><a href="#1-4-创建和配置桥" class="headerlink" title="1.4 创建和配置桥"></a>1.4 创建和配置桥</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>1.虚拟网桥与NAT网桥区别<br>    1）bridged networking（桥接模式）<br>    在这种模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。在桥接模式下，需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，配置好网关和DNS的地址后，以实现通过局域网的网关或路由器访问互联网。<br>    2）network address translation(NAT模式)<br>    NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，只需要宿主机器能访问互联网，你不需要配置IP地址，子网掩码，网关，但是DNS地址还是要根据实际情况填的。添加DNS地址除了在网卡属性中填写，还可以在虚拟机中的“虚拟网络编辑器”中的NAT选项卡中点击“编辑”按钮中来添加。<br>    总结：<br>    桥接：虚拟出来的一个独立主机;需要手动配和宿主机同一个网段的ip地址和子网掩码，可实现与宿主机之间的通信。<br>如果配置好网关和DNS后，可实现局域网的网管或路由访问互联网。总之，桥接可实现虚机与网络内部和外部通信之间的<br>互相通信。<br>    NAT模式：通过NAT功能，需要依赖宿主机与外界互联网通信，不能实现与宿主机通信；只需要配DNS；联网简单，只<br>要宿主机能访问网络，虚拟系统就能接入网络。 从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下（也可<br>通过相关配置实现互相通信），外部网络终端也无法访问到虚拟机。</p><h3 id="创建和配置桥"><a href="#创建和配置桥" class="headerlink" title="创建和配置桥"></a>创建和配置桥</h3><ul><li>桥设备不支持使用NetworkManager来管理服务，必须确保NetworkManager处于关闭状态</li><li>要先安装一个桥设备管理程序包：<strong>yum install bridge-utils</strong></li><li><strong>桥0也就是br0是被当做了一台交换机来使用（它其实就是宿主机的物理网卡），而原本宿主机的IP地址被配置在了一块虚拟出来的网卡上，且这块网卡被桥接到了br0上</strong></li></ul><p><strong>1）使用brctl的配置过程</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brctl add br0              # 创建br0桥</span><br><span class="line">brctl stp br0 on           # 开启生成树</span><br><span class="line">ifconfig eth0 0 up         # 要将eth0的地址删除</span><br><span class="line">brctl addif br0 eth0       # 向br0上添加eth0</span><br><span class="line">ifconfig br0 IP&#x2F;NETMASK up # 在br0上添加IP地址</span><br><span class="line">route add default gw GW    # 添加默认网关</span><br></pre></td></tr></table></figure><p><strong>2）全手动配置</strong></p><p>看起来ens33更像是桥，但实际上是把ens33做成交br0的桥了，引用的时候要引用br0</p><ul><li><p>ifcfg-ens33</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">NM_CONTROLLED&#x3D;no</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">IPV6INIT&#x3D;no</span><br><span class="line">NAME&#x3D;ens33</span><br><span class="line">DEVICE&#x3D;ens33</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BRIDGE&#x3D;br0   # 这块网卡桥接到br0上</span><br><span class="line">USERCTL&#x3D;no</span><br></pre></td></tr></table></figure></li><li><p>ifcfg-dr0</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Bridge</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">NM_CONTROLLED&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;no</span><br><span class="line">NAME&#x3D;br0</span><br><span class="line">DEVICE&#x3D;br0</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;10.0.0.201</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;10.0.0.2</span><br><span class="line">DNS1&#x3D;10.0.0.2</span><br><span class="line">USERCTL&#x3D;no</span><br></pre></td></tr></table></figure></li></ul><p><strong>3）查看桥设备特征</strong></p><p>copy</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示当前的桥设备及桥设备的特征</span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure><h3 id="Docker前世LXC"><a href="#Docker前世LXC" class="headerlink" title="Docker前世LXC"></a>Docker前世LXC</h3><p>LXC（Linux Container）是一种轻量级的虚拟化手段，LXC提供了在单一可控主节点上支持多个相互隔离的server container通知执行的机制。</p><p>LXC有点像chroot，提供了一个拥有自己进程的网络空间的虚拟环境，但又有别于虚拟机，因为lxc是一种操作系统层次上的资源的虚拟化。</p><p>容器将单个操作系统管理的资源划分到孤立的组中，可以更好的平衡孤立的组之间资源使用的冲突。</p><p>docker底层使用了LXC来实现，LXC将linux进程沙盒化，使得进程之间相互隔离，并且能够控制各进程的资源分配。在LXC的基础之上，docker提供了一系列更强大的功能。</p><p><strong>沙盒化</strong>：就是把一个整体虚拟化为若干部分，每一部分有特定的权限职能。</p><h3 id="Docker的概述"><a href="#Docker的概述" class="headerlink" title="Docker的概述"></a>Docker的概述</h3><p><strong>1）Docker简介</strong></p><p>docker只是LXC的前端工具，Docker的底层就是通过LXC来实现，LXC将Linux进程沙盒化，使进程之间相互孤立，并且能够控制各进程的资源分配。</p><p>docker是一个开源的应用容器引擎，基于go语言开发。</p><p>docker可以让开发者打包到他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的linux服务器，也可以实现虚拟化。容器是完全适用沙盒机制，相互之间不会有任何接口，并且容器开销及其低。</p><p><strong>2）docker的版本</strong></p><ul><li>CE：Community Edition 社区版</li><li>EE：Enterprise Edition 商业版</li></ul><p><strong>3）虚拟机、容器、镜像</strong></p><ul><li>虚拟机：<ul><li>虚拟机运行的是一个完整的操作系统，通过虚拟机管理程序对主机资源进行访问</li></ul></li><li>容器：<ul><li>容器共享主机的内核，它运行的是一个独立的进程，且不占用其他任何可执行文件的内存</li></ul></li><li>镜像：<ul><li>通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的内容如代码、运行时间、库、环境变量、配置文件等</li><li>容器是镜像的运行实例</li></ul></li></ul><p><strong>4）docker的运行方式</strong></p><p>docker的运行方式：“分层构建 联合挂载”</p><p>一个docker启动一个进程，它就是一个普通的进程，非常方便，再挂载外部目录进行存储</p><p>大规模使用docker时必须由编排工具，因为如果有很多台服务器，为了使得资源不滥用或者过度空闲，需要将需求（业务端）和资源端（服务器）对接起来，将这个需求放到最合适的服务器上并开始构建，人是不知道哪台服务器闲置的（或者需要提前检查），编排工具就可以。一些服务启动或关闭有依赖关系（dependent），这些docker本身也无法解决，也需要编排工具来解决。如lnmp搭载的系统。</p><h3 id="2-3-容器在内核中支持的2种重要技术"><a href="#2-3-容器在内核中支持的2种重要技术" class="headerlink" title="2.3 容器在内核中支持的2种重要技术"></a>2.3 容器在内核中支持的2种重要技术</h3><p>docker本质就是宿主机中的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制机制（copy-on-write）实现高效的文件操作（类似虚拟机的磁盘分配500G并不是占用物理磁盘500G）</p><p><strong>1）namespace名称空间</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103133659161-76177737.png" alt="img"></p><p><strong>2）Control Group控制组</strong></p><ul><li>cgroup的特点：<ul><li>cgroup的api以一个伪文件系统的实现方式，用户的程序可以通过文件系统实现cgroup的组件管理</li><li>cgroup的组件管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源再分配和再利用</li><li>所有资源管理的功能都以子系统的方式实现，接口同一子任务创建之初与其父任务处于同一个cgroup的控制组</li></ul></li><li>四大功能：<ul><li>资源限制：可以对任务使用的资源总额进行限制</li><li>优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级</li><li>资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等</li><li>任务控制：cgroup可以对任务执行挂起、恢复等操作</li></ul></li></ul><h3 id="2-4-镜像-amp-容器-amp-仓库"><a href="#2-4-镜像-amp-容器-amp-仓库" class="headerlink" title="2.4 镜像&amp;容器&amp;仓库"></a>2.4 镜像&amp;容器&amp;仓库</h3><p><strong>1）image镜像</strong></p><p>docker镜像含有启动容器所需要的文件系统及其内容，因此其用于创建并启动docker容器</p><ul><li>docker镜像就是一个只读模板；比如，一个镜像可以包含一个完整的centos，里面仅安装apache或用户的其他应用，镜像可以用来创建docker容器</li><li>docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用</li></ul><p>采用分层构建机制，最底层为bootfs，其上为rootfs：</p><ul><li>bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约内存资源</li><li>rootfs：位于bootfs之上，表现为docker容器的根文件系统<ul><li>传统模式中，系统启动之时，内核挂载rootfs时会首先将其挂载为“只读”模式，完整性自检完成后将其重新挂载为读写模式</li><li>docker中，rootfs由内核挂载为“只读”模式，而后通过 “联合挂载” 技术额外挂载一个 “可写” 层</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103135810133-1696172476.png" alt="img"></p><p>镜像的层次：</p><ul><li>位于下层的镜像称为父镜像（parent image），最底层的称为基础镜像（base image）</li><li>最上层的为 “可读写” 层，其下的均为 “只读” 层</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103140115071-1457873933.png" alt="img"></p><p>关于Aufs（advanced multi-layered unification filesystem）高级多层同一文件系统：</p><ul><li><p>aufs用于为Linux系统实现 “联合挂载”</p></li><li><p>aufs是之前的UnionFS的重新实现，docker最初使用aufs作为容器文件系统层，它目前仍然作为存储后端之一来支持</p></li><li><p>aufs的竞争产品是<strong>overlayfs</strong>，overlayfs从3.18版本开始被合并到Linux内核</p></li><li><p>docker的分层镜像，除了aufs，docker还支持btrfs，devicemaapper和vfs等</p><ul><li>在Ubuntu系统下，docker默认Ubuntu的aufs，而在CentOS7上，用的是devicemapper</li></ul><p><strong>挂载</strong>：linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。</p></li></ul><p><strong>2）container容器</strong></p><p>docker利用容器来运行应用，容器是从镜像创建的运行实例，它可以被启动、开始、停止、删除。</p><p>每个容器都是互相隔离的，保证安全的平台，可以把容器看做是个简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p><strong>3）repository仓库</strong></p><ul><li>由某特定的docker镜像的所有迭代版本组成的镜像仓库</li><li>一个Registry中可以存在多个Repository<ul><li>Repository可分为 “顶层仓库” 和 “用户仓库” </li><li>用户仓库名称格式为 “用户名/仓库名”</li></ul></li><li>Index<ul><li>维护用户账号、镜像的校验以及公共命名空间的信息</li><li>相当于为Registry提供了一个完成用户认证等功能的检索接口</li></ul></li></ul><p><strong>4）图示</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103141355858-1248166948.png" alt="img"></p><ul><li>标识一个镜像：<ul><li>仓库名+标签，如  nginx:1.10</li><li>nginx是仓库名，1.10是标签</li><li>如果只给仓库名而没有给标签，则默认是最新版，nginx:latest</li></ul></li><li>镜像：<ul><li>静态的</li><li>镜像文件是只读的</li></ul></li><li>容器：<ul><li>动态的，有生命周期</li><li><strong>因为一个容器只运行单个应用程序，所以这个应用程序必须运行在前台，否则容器会直接停止</strong></li></ul></li></ul><h2 id="3-Docker架构概述"><a href="#3-Docker架构概述" class="headerlink" title="3. Docker架构概述"></a>3. Docker架构概述</h2><h3 id="3-1-docker-client"><a href="#3-1-docker-client" class="headerlink" title="3.1 docker client"></a>3.1 docker client</h3><ul><li>docker client是docker架构中用户用来和docker daemon建立通信的客户端<ul><li>用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。</li></ul></li><li>docker client可以通过三种方式和docker daemon建立通信：<ul><li>tcp://host:port</li><li>unix:path_to_socker</li><li>fd://sockerfd</li></ul></li><li>docker可以通过设置命令行flag参数的形式设置安全传输层（TLS）的有关参数，保证传输的安全性</li><li>docker client发送容器管理请求后，由docker daemon接受并处理请求，当docker client接收到返回的请求响应并简单处理后，docker client一次完整的生命周期就结束了<ul><li>当需要继续发送容器管理请求后，用户必须再次通过docker可执行文件创建docker client</li></ul></li></ul><h3 id="3-2-docker-daemon"><a href="#3-2-docker-daemon" class="headerlink" title="3.2 docker daemon"></a>3.2 docker daemon</h3><ul><li>docker daemon是docker架构中一个常驻在后台的系统进程，它负责接收处理docker client发送的请求<ul><li>该守护进程在后台启动一个server，server负责接受docker client发送的请求</li><li>接受请求后，server通过路由与分发调度，找到相应的handler来执行请求</li></ul></li><li>docker daemon启动所使用的可执行文件也为docker，与docker client启动所使用的可执行文件docker相同，在docker命令执行时，通过传入的参数来判别docker daemon与docker client</li></ul><h3 id="3-3-docker-server"><a href="#3-3-docker-server" class="headerlink" title="3.3 docker server"></a>3.3 docker server</h3><ul><li> docker server在docker架构中专门服务于docker client的server，该server的功能是接受并调度分发docker client发送的请求</li></ul><p><strong>架构图示：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201108155340149-20535033.png![img](https://img2018.cnblogs.com/blog/1464965/201907/1464965-20190725202426969-1450304880.jpg" alt="img"></p><ul><li><a href="https://www.cnblogs.com/zhangxingeng/p/11236968.html#auto_id_15">更为详细的docker软件架构分析</a></li></ul><h2 id="4-Docker的安装和使用"><a href="#4-Docker的安装和使用" class="headerlink" title="4. Docker的安装和使用"></a>4. Docker的安装和使用</h2><h3 id="4-1-Docker的安装和配置"><a href="#4-1-Docker的安装和配置" class="headerlink" title="4.1 Docker的安装和配置"></a>4.1 Docker的安装和配置</h3><p><strong>1）安装docker</strong></p><p>配置清华大学镜像源，然后直接yum安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-ce  -y</span><br></pre></td></tr></table></figure><p>注意：如果直接下载repo文件的话，需要手动修改其中的源信息，因为这个文件中是直接指向了docker官方的地址的，需要改成国内的源</p><p><strong>2）配置镜像加速</strong></p><p>要在 /etc/docker/daemon.json 文件中定义一个镜像加速器（这是一个json格式的数组，这个文件需要自己创建）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    &quot;registry-mirrors&quot;:  [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;,&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）启动docker服务</strong></p><p>因为docker是运行方式是C/S架构模式的，需要启动docker守护进程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl  start  docker</span><br></pre></td></tr></table></figure><h3 id="4-2-docker的基本使用命令"><a href="#4-2-docker的基本使用命令" class="headerlink" title="4.2 docker的基本使用命令"></a>4.2 docker的基本使用命令</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103143308182-1700569082.png" alt="img"></p><p><strong>1）基本信息查看</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看docker版本及其他信息</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"># 镜像查看</span><br><span class="line">docker image ls</span><br><span class="line"># 查看容器信息</span><br><span class="line">docker container ls</span><br><span class="line">docker container ls -a</span><br><span class="line"># 状态查看</span><br><span class="line">docker ps </span><br><span class="line">docker ps -a  # 可以查看处于停止状态的容器</span><br><span class="line"># 查看网络状态</span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p><strong>2）镜像的搜索和拉取</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 镜像搜索</span><br><span class="line">docker search nginx:latest</span><br><span class="line">docker search nginx:1.16</span><br><span class="line"></span><br><span class="line">### 镜像的拉取和删除</span><br><span class="line"># 镜像拉取</span><br><span class="line">docker image pull busybox</span><br><span class="line"># 镜像删除</span><br><span class="line">docker image rm busybox  # 删除镜像</span><br><span class="line">docker rmi busybox     # 删除镜像</span><br><span class="line">docker rm busybox      # 删除容器</span><br></pre></td></tr></table></figure><p><strong>3）镜像的启动和停止</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker start -i -a b1</span><br><span class="line">    # -i 交互式</span><br><span class="line">    # -a 依附于终端</span><br><span class="line"></span><br><span class="line"># 创建并启动容器 </span><br><span class="line"># docker run可以创建并启动容器，如果没有镜像会自动去下载镜像</span><br><span class="line">docker run --name b1 -i -t busybox:latest</span><br><span class="line">docker run --name web1 -d nginx:1.16</span><br><span class="line">    # -d 剥离终端</span><br><span class="line">    # -t 启用终端</span><br><span class="line"></span><br><span class="line"># 停止容器</span><br><span class="line">docker stop b1</span><br><span class="line"># 杀死容器</span><br><span class="line">docker kill b1</span><br><span class="line"># 删除容器</span><br><span class="line">docker rm b1</span><br><span class="line"></span><br><span class="line"># 查看指定容器的日志</span><br><span class="line">docker logs web1</span><br><span class="line"></span><br><span class="line"># 查看容器的信息</span><br><span class="line">docker inspect b1</span><br><span class="line"></span><br><span class="line"># 在指定的容器中执行指定的命令</span><br><span class="line">docker container exec -i -t web1 &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line"># 依附于一个启动的容器</span><br><span class="line">docker attach b1 </span><br><span class="line"></span><br><span class="line"># 如果不想运行容器中给定的命令，只需在docker run后面给定命令即可</span><br><span class="line">docker run --name tinyweb -it --rm -P tinyhttpd:v0.2-5 ls &#x2F;data&#x2F;web&#x2F;html</span><br></pre></td></tr></table></figure><p><strong>4）从别的地址来拉取镜像</strong></p><ul><li><p>拉取镜像的语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull &lt;registry&gt;[:&lt;port&gt;]&#x2F;[&lt;namespace&gt;&#x2F;]&lt;name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></li><li><p>默认是从docker hub来拉取镜像，如果要从别的地址拉取镜像，如 quay.io这个地址来拉取：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull quay.io&#x2F;coreos&#x2F;flannel</span><br><span class="line"># 默认是443端口</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-基于容器制作镜像"><a href="#4-3-基于容器制作镜像" class="headerlink" title="4.3 基于容器制作镜像"></a>4.3 基于容器制作镜像</h3><ul><li>镜像的生成途径<ul><li>Dockerfile：通过build命令来制作</li><li>基于容器制作</li><li>Docker Hub automated builds</li></ul></li></ul><p><strong>1）运行一个busybox并做些改动</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 运行一个busybox</span><br><span class="line">docker run --name b1 -it busybox</span><br><span class="line"></span><br><span class="line"># 创建一个html文件并写入一些内容</span><br><span class="line">vi  &#x2F;data&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p><strong>2）创建镜像并打上标签</strong></p><ul><li>注意：要新开一个会话</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新开一个ssh会话，创建镜像</span><br><span class="line">docker commit -p b1</span><br><span class="line">    # -p 表示在commit的时候暂停容器</span><br><span class="line">    # 也可以在创建镜像的时候就打上标签</span><br><span class="line">        docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line"># 为镜像打上标签，语法：docker tag 镜像的ID号  标签</span><br><span class="line">docker tag  镜像ID  dockerhgzero&#x2F;httpd:v0.1</span><br><span class="line"># 还可以再打个标签</span><br><span class="line">docker tag hgzero&#x2F;httpd:v0.1 dockerhgzero&#x2F;httpd:latest</span><br></pre></td></tr></table></figure><p><strong>3）修改镜像启动时要运行的命令</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker inspect 中有个Cmd的项，此项就是容器启动时要执行的命令</span><br><span class="line">docker inspect dockerhgzero&#x2F;httpd:latest</span><br><span class="line"></span><br><span class="line"># 修改原有基础镜像启动时要运行的命令，改Cmd就行了</span><br><span class="line">docker commit -a &quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; -c &#39;CMD [&quot;&#x2F;bin&#x2F;httpd&quot;,&quot;-f&quot;,&quot;-h&quot;,&quot;&#x2F;data&#x2F;html&quot;]&#39; -p b1 dockerhgzerowzh&#x2F;httpd:v1.1</span><br><span class="line">    # docker commit 的选项：</span><br><span class="line">         # -a 指明作者名</span><br><span class="line">         # -c 改动列表</span><br><span class="line">         # -p 制作时让其处于暂停状态</span><br><span class="line">    # httpd的选项：</span><br><span class="line">         # -f 运行在前台</span><br><span class="line">         # -h 指明网页文件的目录</span><br></pre></td></tr></table></figure><p><strong>4）将镜像推送到Docker Hub</strong></p><ul><li>要先在Docekr Hub上建立个仓库，并且本地的名称和仓库的名称要保持一致</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在推送之前要登录</span><br><span class="line"># 也可以指定服务器，默认是登录Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"># 推送到dockerhub</span><br><span class="line">docker image push dockerhgzerowzh&#x2F;httpd</span><br></pre></td></tr></table></figure><ul><li>如果要推送到其他从库，在打标时必须带上仓库地址</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 推送到阿里云</span><br><span class="line">docker tag hgzerowzh&#x2F;httpd:v0.1 registry.cn-qingdao.aliyuncs.com&#x2F;hgzerowzh&#x2F;httpd:v0.2</span><br></pre></td></tr></table></figure><h3 id="4-4-镜像的导入和导出"><a href="#4-4-镜像的导入和导出" class="headerlink" title="4.4 镜像的导入和导出"></a>4.4 镜像的导入和导出</h3><p><strong>1）镜像的导出</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o myimage.gz dockerhgzerowzh&#x2F;httpd:v0.1 dockerhgzerowzh&#x2F;httpd:v1.1</span><br><span class="line"># -o 指明保存为一个文件</span><br><span class="line"># 会自动压缩</span><br></pre></td></tr></table></figure><p><strong>2）镜像的导入</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i myimage.gz</span><br><span class="line"># 使用这种方式要事先准备好本地镜像，否则执行docker run的时候它还是会到docker hub上去下载</span><br></pre></td></tr></table></figure><h2 id="5-容器虚拟化网络"><a href="#5-容器虚拟化网络" class="headerlink" title="5. 容器虚拟化网络"></a>5. 容器虚拟化网络</h2><h3 id="5-1-docker中的网络模式概述"><a href="#5-1-docker中的网络模式概述" class="headerlink" title="5.1 docker中的网络模式概述"></a>5.1 docker中的网络模式概述</h3><ul><li>默认docker会自动创建3个网络：host、none、bridge</li></ul><p><strong>1）Host</strong></p><p>相当于VMware中的桥接模式，与宿主机在同一个网络中，但是没有独立的IP地址。</p><p>Docker使用了Linux的Namespace技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、iptables规则等都与其他的Network Namespace隔离。</p><p>一个Docker容器一般会分配一个独立的Network Namespace，但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机公用一个Network Namespace，容器将不会虚拟出自己动网卡、配置自己的IP等，而是使用宿主机的IP和端口。</p><p>外界访问容器中的应用，不用任何NAT转换，就如同直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><p><strong>2）None</strong></p><p>该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。</p><p>实际上，该模式关闭了容器的网络功能，在如下情况中是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）</p><p><strong>3）Bridge</strong></p><p> 相当于VMware中的NAT模式，容器使用独立的Network Namespace，并连接到docker0的虚拟网卡（默认模式）。通过docker0网桥以及iptables nat表配置与宿主机通信。</p><p>bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</p><p><strong>4）Container</strong></p><p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。</p><p>新创建的容器不会创建自己的网卡、配置自己的IP，而是和一个指定的容器共享IP地址、端口范围等。</p><p>两个容器除了网络方面，其他的如文件系统、进程列表还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p><h3 id="5-2-Bridge模式详解"><a href="#5-2-Bridge模式详解" class="headerlink" title="5.2 Bridge模式详解"></a>5.2 Bridge模式详解</h3><p><strong>1）Bridge模式的拓扑详解</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201104120921949-1802562682.png" alt="img"></p><p>当Docker Server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>接下来会为容器分配IP，Docker会从私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如一般Docker会使用172.17.0.0/16这个网段，并将172.17.0.1/16分配给docker0网桥（在主机上使用ficonfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p><p><strong>2）Docker网络模式详解</strong></p><p>Docker完成以上网络配置的过程大致是这样：</p><ol><li><p>在主机上创建一堆虚拟网卡veth pair设备。veth设备总是成对出现，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p></li><li><p>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以eth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令来查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.02425f21c208       no</span><br></pre></td></tr></table></figure></li><li><p>从docker0子网中分配一个IP给容器使用，并设备docker0的IP地址为容器的默认网关</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看容器网络</span><br><span class="line">docker inspect 9582dbec7981</span><br><span class="line"></span><br><span class="line"># 查看桥设备信息</span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure></li></ol><p><strong>3）bridge模式下容器的通信</strong></p><p>在bridge模式下，连在同一网桥上的容器可以相互通信；出于安全考虑，也可以禁止它们之间通信：在DOCKER_OPTS变量中设置 –icc=false，这样只有使用–link才能使两个容器通信。</p><p>Docker可以开启容器间通信（意味着默认配置 –icc=true），也就是说，宿主机上的所有容器可以不受任何限制的相互通信，这可能导致拒绝服务攻击；Docker可以通过–ip_forward和–iptables两个选项控制容器间、容器和外部世界的通信。</p><p>容器也可以和外部通信，主机上定义了如下iptables规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A POSTROUTING -s 172.17.0.0&#x2F;16 ! -o docker0 -j MASQUERADE</span><br><span class="line"># 这条规则会将源地址为172.17.0.0&#x2F;16的包（也就是从Docker容器产生的包）</span><br><span class="line"># 　　并且不是从docker0网卡发出的包，进行源地址转换，转换成主机网卡的地址</span><br><span class="line">#　　 这样在外界看来，这个包是从主机网卡上发出来的，Docker容器对外是不可见的</span><br></pre></td></tr></table></figure><h3 id="5-3-自定义网络"><a href="#5-3-自定义网络" class="headerlink" title="5.3 自定义网络"></a>5.3 自定义网络</h3><ul><li><a href="https://www.cnblogs.com/zuxing/articles/8780661.html">https://www.cnblogs.com/zuxing/articles/8780661.html</a></li></ul><h3 id="5-4-Docker中设置网络"><a href="#5-4-Docker中设置网络" class="headerlink" title="5.4 Docker中设置网络"></a>5.4 Docker中设置网络</h3><ul><li>默认创建容器时如果没有特别指定，则都使用的是桥接网络（bridge），是NAT桥</li><li>指定容器的网络模式：docker container run <strong>–network</strong> xxx</li></ul><p><strong>1）查看网络的相关内容</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看网络模式</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"># 查看网络的现骨干内容</span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p><strong>2）docker中设置网络</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name t1 -it --network bridge --rm busybox:latest</span><br><span class="line">    --rm </span><br><span class="line">　　　　　# 表示容器退出自动删除</span><br><span class="line">    --network  # 指定网络类型</span><br><span class="line">        # none</span><br><span class="line">        # bridge 默认</span><br><span class="line">    --hostname www.hgzerowzh.com  </span><br><span class="line">　　　　　# 设置主机名，注入到容器中</span><br><span class="line">    --dns 114.114.114.114 </span><br><span class="line">　　　　　# 注入设置DNS</span><br><span class="line">    --dns-search hgzerowzh.com  </span><br><span class="line">　　　　　# 向容器中注入搜索域</span><br><span class="line">    --add-host www.hgzerowzh.com:10.0.0.201 </span><br><span class="line">　　　　　# 向容器中注入hosts文件解析记录</span><br></pre></td></tr></table></figure><p><strong>3）设置端口映射</strong></p><ul><li>查看指定容器上的端口映射：docker port myweb</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将myweb容器上的80端口暴露到宿主机的随机端口（一般是3万之后）</span><br><span class="line">docker run --name myweb --rm -p 80 hgzerowzh&#x2F;httpd:v0.2</span><br><span class="line">    # 可以在iptables生成的规则中查看这个随机端口</span><br><span class="line">    # iptables -t nat -vnl</span><br><span class="line">    # 这条iptables规则会随着容器的删除而自动删除</span><br><span class="line"></span><br><span class="line"># 端口映射的规则，-p选项可以使用多次</span><br><span class="line">    -p 80 </span><br><span class="line">        # 将容器的80端口expose至宿主机的随机端口（一般是3万之后）</span><br><span class="line">　　　　　# 会暴露到宿主机上所有的IP上</span><br><span class="line">    -p 宿主机IP::容器端口</span><br><span class="line">        # 将指定的容器端口映射到主机指定IP的动态端口</span><br><span class="line">　　　　　# 只是指定宿主机的IP地址，宿主机的端口还是随机的</span><br><span class="line">    -p 80:80</span><br><span class="line">        # 将宿主机的80端口映射到容器的80端口（前面的80表示宿主机）</span><br><span class="line">    -p 宿主机IP:宿主机端口:容器端口</span><br><span class="line">    　 　# 将宿主机指定IP的指定端口映射到容器的端口</span><br><span class="line">    -P  # 大P表示直接暴露容器中暴露的端口</span><br><span class="line">　　　　 # 表示只要容器中暴露了端口，则将其直接暴露到宿主机中</span><br></pre></td></tr></table></figure><h3 id="5-5-联盟式容器"><a href="#5-5-联盟式容器" class="headerlink" title="5.5 联盟式容器"></a>5.5 联盟式容器</h3><p><strong>1）概述</strong></p><p>联盟式容器指用某个已经存在的网络接口的容器，接口被联盟内的各容器共享使用，因此，联盟式容器彼此间完全无隔离。</p><p>联盟式容器彼此之间虽然共享一个网络名称空间，但其他名称空间如User、Mount等还是隔离的。</p><p>联盟式容器彼此间存在端口冲突的可能性，因此，通常只会在多个容器上的程序需要程序loopback接口互相通信、或对某已存的容器的网络属性进行监控时才使用此种模式的网络模型。</p><p><strong>2）容器之间共享网络名称空间</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个监听于2222端口的http服务容器</span><br><span class="line">docker run --name b1 -d -it --rm -p 2222 busybox:latest &#x2F;bin&#x2F;httpd -p 2222 -f </span><br><span class="line"></span><br><span class="line"># 创建一个联盟式容器，并查看其监听的端口</span><br><span class="line">docker run --name b2 -it --rm --network container:b1 buxybox:latest netstat -tan</span><br><span class="line">    # --network container:b1 表示这个b2容器共享b1容器的网络名称空间</span><br></pre></td></tr></table></figure><h3 id="5-6-自定义网桥"><a href="#5-6-自定义网桥" class="headerlink" title="5.6 自定义网桥"></a>5.6 自定义网桥</h3><p><strong>1）自定义docker0桥网络属性信息</strong></p><ul><li>编辑 <strong>/etc/docker/daemon.json</strong> 文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bip&quot;: &quot;192.168.1.5&#x2F;24&quot;,</span><br><span class="line">  &quot;fixed-cidr&quot;: &quot;10.20.0.0&#x2F;16&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1500,</span><br><span class="line">  &quot;default-gateway&quot;: &quot;10.20.1.1&quot;,</span><br><span class="line">  &quot;default-gateway-v6&quot;: &quot;2001:db8:abcd::89&quot;,</span><br><span class="line">  &quot;dns&quot;: [&quot;10.20.1.2&quot;,&quot;10.20.1.3&quot;]              </span><br><span class="line">&#125;</span><br><span class="line"># 核心选项为bip，即bridge ip之意，用于指定docker0桥自身的IP地址# 配置文件中最后一个key后面不能有逗号，否则语法错误# 一般指定bip就可以了，其他选项会自动计算得知，如果希望容器的dns不使用系统的dns，也可以指定dns</span><br></pre></td></tr></table></figure><p><strong>2）自己创建桥</strong></p><ul><li>可以自己手动再创建一个网桥</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 再创建一个网桥mybr0，地址是172.26.0.0&#x2F;16，网关是172.26.0.1</span><br><span class="line">docker network create -d bridge --subnet &quot;172.26.0.0&#x2F;16&quot; --gateway &quot;172.26.0.1&quot; mybr0</span><br><span class="line"># mybr0只是网络叫mybr0，网络接口的名字是 自动生成的，可以改成其他名字</span><br></pre></td></tr></table></figure><ul><li>创建一个容器，加入刚刚的网络</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name t1 -it --network mybr0 busybox:latest</span><br><span class="line"></span><br><span class="line"># 在宿主机上打开核心转发，就可以让两个网段的容器通信</span><br><span class="line"># 如果ping不通，是跟iptables规则有关，被iptables阻断了而已</span><br></pre></td></tr></table></figure><p><strong>3）允许docker从外部连入</strong></p><ul><li>默认docker是监听在本机的Unix Sock套接字上</li><li>docker的守护进程的C/S，其默认仅监听Unix Socker格式的地址，/var/run/docker.sock</li><li>如果要使用TCP套接字，需要修改配置文件 /etc/docker/daemon.json</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hosts&quot;: [&quot;tcp:&#x2F;&#x2F;0.0.0.0:2375&quot;, &quot;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock&quot;]</span><br></pre></td></tr></table></figure><ul><li>远程连入docker：<ul><li>docker -H 10.0.0.204:2375 ps</li><li>docker -H 10.0.0.204:2374 image ls</li></ul></li></ul><p><strong>4）docker配置允许从外部tcp连接时报错</strong></p><ul><li><p>报错信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dockerd[2144]: unable to configure the Docker daemon with file &#x2F;etc&#x2F;docker&#x2F;daemon.json: the following directives are specified both as a flag and in the configuratio</span><br><span class="line">n file: hosts: (from flag: [fd:&#x2F;&#x2F;], from file: [unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock])</span><br></pre></td></tr></table></figure></li><li><p>解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service中将ExecStart项中docker启动的 -H fd:&#x2F;&#x2F; 删掉即可</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-docker存储卷"><a href="#6-docker存储卷" class="headerlink" title="6. docker存储卷"></a>6. docker存储卷</h2><h3 id="6-1-存储卷概述"><a href="#6-1-存储卷概述" class="headerlink" title="6.1 存储卷概述"></a>6.1 存储卷概述</h3><p><strong>1）文件的写时复制</strong></p><p>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层。</p><p>如果运行中的容器修改了现有的一个已经存在的文件，那该文件会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，此即“写时复制（COW）”机制。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201103231616546-553686731.png" alt="img"></p><p><strong>2）数据持久化问题</strong></p><p>当关闭并重启容器时，其数据不受影响，但是如果删除Docker容器，则其更改将会全部丢失。</p><ul><li>容器存储数据会存在如下问题：<ul><li>容器中的数据存储于联合文件系统中，不易于宿主机访问</li><li>容器间数据共享不便</li><li>删除容器其数据会丢失</li></ul></li><li>解决方案：卷（volume）<ul><li>“卷” 是容器上的一个或多个 “目录”，此类目录可以绕过联合文件系统，与宿主机上的某目录“绑定（关联）”</li></ul></li></ul><p>Volume与容器初始化之时就会创建，由base image提供的卷中的数据会于此期间完成复制。</p><p>Volume的初衷是独立于容器的生命周期实现数据持久化，因此删除容器的时候既不会删除卷，也不会对未被引用的卷做垃圾回收操作。</p><p><strong>3）独立于容器的数据管理机制</strong></p><p>可以把“镜像”想成静态文件，例如“程序”，把卷类比为动态内容，例如“数据”，于是，镜像可以重用，而卷可以共享</p><p>卷实现了“程序（镜像）”和“数据（卷）”分离，以及“程序（镜像）”和“制作镜像的主机”分离，用户制作镜像时无须再考虑镜像运行的容器所在的主机的环境。</p><p><strong>3）常见的服务可以分为有状态的服务和无状态的服务两种</strong></p><ul><li>有状态的服务：mysql、redis、tomcat，需要持久存储</li><li>无状态的服务：nginx、httpd等</li></ul><h3 id="6-2-卷的类型Volume-Type"><a href="#6-2-卷的类型Volume-Type" class="headerlink" title="6.2 卷的类型Volume Type"></a>6.2 卷的类型Volume Type</h3><ul><li>Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同。</li></ul><p><strong>1）Bind mount volume （绑定挂载卷）</strong></p><ul><li>明确指定容器和宿主机上的对应位置</li><li>即需要手工指定宿主机和容器内目录的绑定关系</li><li><strong>注意：bind方式创建的目录在容器删除后依旧可以实现持久化存储，不会删除或消失</strong></li></ul><p><strong>2）Docker-managed volume （Docker管理的卷）</strong></p><ul><li>在容器中指定位置，但它在宿主机中对应的位置由docker来自行管控</li><li>不需要特别指定绑定关系，而由docker管理，一般绑定的目录为/var/lib/docker/volumes/container id 目录下</li><li><strong>注意：这种方式创建的文件会在容器删除后自动删除，不能实现真正的持久化</strong></li></ul><h3 id="6-3-在docker中使用volumes"><a href="#6-3-在docker中使用volumes" class="headerlink" title="6.3 在docker中使用volumes"></a><strong>6.3 在docker中使用volumes</strong></h3><ul><li>为docker run命令使用-v选项即可使用Volumes</li></ul><p><strong>1）Docker管理的卷</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将容器的&#x2F;data目录映射到宿主机的docker管理的目录中</span><br><span class="line">docker run -it --name bbox1 -v &#x2F;data busybox</span><br><span class="line"></span><br><span class="line"># 可以使用docker inspect bbox1来查看&#x2F;data在宿主机上所对应的目录位置</span><br><span class="line"># 在docker inspect的Mounts建所对应的值中查看</span><br></pre></td></tr></table></figure><ul><li>过滤docker inspect中的内容</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 过滤显示根下的Mounts中的内容</span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; b2</span><br><span class="line"></span><br><span class="line"># 过滤显示根下的NetworkSettings中的内容</span><br><span class="line">docker inspect -f &#123;&#123;.NetworkSettings&#125;&#125; b2</span><br><span class="line"></span><br><span class="line"># 过滤显示根下的NetworkSettings下的IPAddress中的内容</span><br><span class="line">docker inspect -f &#123;&#123;.NetworkSettings.IPAddress&#125;&#125; b2</span><br><span class="line"></span><br><span class="line"># 以上的 . 点 表示docker inspect显示内容的根</span><br></pre></td></tr></table></figure><p><strong>2）绑定挂载卷</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 语法：docker run -it -v HOSTDIR:VOLUMEDIR --name bbox2 busybox</span><br><span class="line"></span><br><span class="line"># 将宿主机中的&#x2F;data&#x2F;volumes&#x2F;b2目录和容器中的&#x2F;data目录做映射</span><br><span class="line">docker run -it -v &#x2F;data&#x2F;volumes&#x2F;b2:&#x2F;data busybox</span><br><span class="line"></span><br><span class="line"># 默认会在宿主机上自动创建目录</span><br></pre></td></tr></table></figure><p><strong>3）复制使用其他容器的卷</strong></p><ul><li>为docker run命令使用 –volumes-from 选项即可</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建bbox2时直接复制使用bbox1的卷</span><br><span class="line">docker run -it --name bbox2 --volumes-from bbox1 busybox</span><br></pre></td></tr></table></figure><h2 id="7-dockerfile文件详解"><a href="#7-dockerfile文件详解" class="headerlink" title="7. dockerfile文件详解"></a>7. dockerfile文件详解</h2><h3 id="7-1-Dockerfile简介"><a href="#7-1-Dockerfile简介" class="headerlink" title="7.1 Dockerfile简介"></a>7.1 Dockerfile简介</h3><p><strong>1）Dockerfile</strong></p><ul><li>将用来全自动构建镜像文件，命名为Dockerfile</li><li>注释行用 # 号开头</li><li>用docker build做镜像时，docker build主机还要隐藏式的启用一个容器，以提供容器制作环境</li></ul><p><strong>2）打包时过滤文件</strong></p><p>可以做一个单独的隐藏文件： <strong>.dockerignore</strong></p><p>在这个文件可以写文件路径，一行一个，可以使用通配符；在打包时，凡是在此文件中的内容，在打包时都不包含进来，包括dockerignore本身和dockerignore中定义的文件，都不会被打包进来</p><h3 id="7-2-Dockerfile中的环境变量"><a href="#7-2-Dockerfile中的环境变量" class="headerlink" title="7.2 Dockerfile中的环境变量"></a><strong>7.2 Dockerfile中的环境变量</strong></h3><p><strong>1）变量的定义</strong></p><ul><li>可以用ENV指令来定义环境变量</li></ul><p><strong>2）变量的引用</strong>（以下两种写法等价）</p><ul><li>$variable_name</li><li>${variable_name}</li></ul><p><strong>3）其他用法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;variable:-word&#125;</span><br><span class="line">    # 如果该变量没有值或者值为空，则将word赋值给该变量</span><br><span class="line">    # 如果变量有值，就用变量自身的值</span><br><span class="line">$&#123;variable:+word&#125;</span><br><span class="line">    # 如果变量有值，则将word赋值给该变量</span><br><span class="line">    # 如果该变量没有值，则不设置该变量的值</span><br></pre></td></tr></table></figure><p><strong>4）在docker run时，向变量传值</strong></p><ul><li>在docker run时，使用-e参数即可向变量传值</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name web1 --rm -P -e WEB_SERVER_PACKAGE&#x3D;&quot;nginx-1.15.1&quot; tinyhttpd:v0.1-7 printenv </span><br></pre></td></tr></table></figure><h3 id="7-3-Dockerfile文件编写指令及语法"><a href="#7-3-Dockerfile文件编写指令及语法" class="headerlink" title="7.3 Dockerfile文件编写指令及语法"></a><strong>7.3 Dockerfile文件编写指令及语法</strong></h3><ul><li>在Dockerfile文件中是不区分字符大小写的</li><li>在Dockerfile中，每一条指令都会生成一个新的镜像层，因此，如果能把两条指令写成一条，就一定要写成一条</li></ul><p><strong>1）FROM</strong></p><ul><li><p>FROM指定必须为Dockerfile文件开篇的第一个非注释行，用于为构建过程指定基准镜像，后续的指令运行于此基准镜像所提供的运行环境。</p></li><li><p>基准镜像可以是任何可用镜像文件，默认情况下，docker build会在docker主机上查找指定的镜像文件，在其不存在时，则会从Docker Hub Registry上拉取所需的镜像文件。如果找不到指定的镜像文件，docker build会返回一个错误信息。</p></li><li><p>两种使用语法格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一种，直接指定仓库和标签</span><br><span class="line">FROM &lt;repository&gt;[:&lt;tag&gt;]</span><br><span class="line"># 如 FROM busybox:latest</span><br><span class="line"># 如果不指定tag，则默认就为latest</span><br><span class="line"></span><br><span class="line"># 第二种，指定镜像的哈希码，以防止镜像被别人冒名顶替</span><br><span class="line">FROM &lt;repository&gt;@&lt;digest&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>2）LABEL</strong></p><ul><li><p>用于让Dockefile制作者提供本人的详细信息，定义为key=value的形式</p></li><li><p>一个镜像可以有多个LABEL，并且可以将多个LABEL定义在一行</p></li><li><p>两种语法格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下两种方式等价</span><br><span class="line">LABEL  &quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line">LABEL  maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; </span><br></pre></td></tr></table></figure></li></ul><p><strong>3）COPY</strong></p><ul><li><p>用于从Docker主机复制文件至创建的新印象文件</p></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY  &lt;src&gt;  ...  &lt;dest&gt;</span><br><span class="line"># &lt;src&gt; 表示要复制的源文件或目录，支持使用通配符</span><br><span class="line"># &lt;dest&gt;  表示目标路径，即真在创建的image的文件系统路径，</span><br><span class="line">    # 建议dest使用绝对路径，否则COPY指定则以WORKDIR为其起始路径</span><br><span class="line"></span><br><span class="line"># 如果路径中有空白字符时，可以使用如下格式</span><br><span class="line">COPY  [&quot;&lt;src&gt;&quot; ... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure></li><li><p>注意事项：</p><ul><li><src> 必须是build上下文中的路径，不能是其父目录中的文件</li><li>如果<src>是目录，则其内部文件或子目录会被递归复制，但<src>目录自身不会被复制（如果源是目录，那么只会复制该目录下的所有文件）</li><li>如果指定了多个<src>，或在<src>中使用了通配符，则<dest>必须是一个目录，且必须以 / 结尾</li></ul></li></ul><p><strong>4）ADD</strong></p><ul><li><p>ADD指令类似于COPY指令，ADD支持使用tar文件和URL路径</p></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD  &lt;src&gt; ... &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"># 或者使用如下形式</span><br><span class="line">ADD  [&quot;&lt;src&gt;&quot; ... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure></li><li><p>注意事项:</p><ul><li>如果<src>为URL，且<dest>不以 / 结尾，则<src>指定的文件将被下载并创建为<dest>；如果<dest>以 / 结尾，则文件名URL指定的文件将被下载并保存为<dest>/<filename></li><li>如果<src>是一个本地系统上压缩格式的tar文件，它将被展开为一个目录，其行为类似于“tar -x”命令；但是通过URL获取到的tar文件将不会自动展开</li><li>如果<src>有多个，或其使用了通配符，则<dest>必须是一个以 / 结尾的目录路径；如果<dest>不以 / 结尾，则其被视作一个普通文件，<src>的内容将被直接写入到<dest></li></ul></li></ul><p><strong>5）WORKDIR</strong></p><ul><li><p>用于为Dockerfile中所有的RUN、CMD、ENTRYPOINT、COPY和ADD设定工作目录</p></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用格式</span><br><span class="line">WORKDIR  &lt;dir_path&gt;</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">WORKDIR &#x2F;var&#x2F;log</span><br><span class="line">WORKDIR $STATEPATH</span><br></pre></td></tr></table></figure></li><li><p>注意事项：</p><ul><li>在Dockerfile文件中，WORKDIR指令可出现多次，其路径也可以为相对路径，但它是相对于此前一个WORKDIR指令指定的路径</li><li>WORKDIR也可以调用有ENV指定定义的变量</li></ul></li></ul><p><strong>6）VOLUME</strong></p><ul><li><p>用于在image中创建一个挂载点目录，以挂载Docker host上的卷或其他容器上的卷</p></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME   &lt;mountpoint&gt;</span><br><span class="line"></span><br><span class="line"># 或者使用如下语法</span><br><span class="line">VOLUME  [&quot;&lt;mountpoint&gt;&quot;]</span><br></pre></td></tr></table></figure></li><li><p>注意事项：</p><ul><li>如果挂载点目录路径下存在文件，docker run命令会在卷挂载完成后将此前的所有文件复制到新挂载的卷中</li></ul></li></ul><p><strong>7）EXPOSE</strong></p><ul><li><p>用于为容器打开指定要监听的端口以实现与外部通信</p></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE  &lt;port&gt;[&#x2F;&lt;protocol&gt;][&lt;port&gt;[&#x2F;&lt;protocol&gt;] ... ]</span><br><span class="line"># &lt;protocol&gt;用于指定传输层协议，可为tcp或udp二者之一，默认为TCP协议</span><br><span class="line"></span><br><span class="line"># EXPOSE指令可一次指定多个端口</span><br><span class="line">EXPOSE  11211&#x2F;udp  11211&#x2F;tcp</span><br></pre></td></tr></table></figure></li></ul><p><strong>8）ENV</strong></p><ul><li><p>用于为镜像定义所需要的环境变量，并可被Dockerfile文件中位于其后的其他指令（如ENV、ADD、COPY等）所调用</p></li><li><p>调用格式为 $variable_name 或 ${variable_name}</p></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &lt;key&gt;之后的所有内容均会被视作其&lt;value&gt;的组成部分，因此，一次只能设置一个变量</span><br><span class="line">ENV  &lt;key&gt;  &lt;value&gt;</span><br><span class="line"></span><br><span class="line"># 可用一次设置多个变量，每个变量为一个&quot;&lt;key&gt;&#x3D;&lt;value&gt;&quot;的键值对</span><br><span class="line"># 如果&lt;value&gt;中包含空格，可以以反斜线 \ 进行转义，也可以通过对&lt;value&gt;加引号进行标识</span><br><span class="line"># 反斜线也可以用于续行ENV  &lt;key&gt;&#x3D;&lt;value&gt; ...</span><br></pre></td></tr></table></figure></li><li><p>注意事项：</p><ul><li>定义多个变量时，建议使用第二种方式，以便在同一层中完成所有功能</li></ul></li></ul><p><strong>9）RUN</strong></p><ul><li><p>用于指定docker build过程中运行的程序，其可以是任何命令</p><ul><li>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础</li><li>镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的 版本控制</li></ul></li><li><p>exec会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号</p></li><li><p>exec方式不会调用一个命令shell，所以也不会继承相应的变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 第一种使用语法</span><br><span class="line">RUN &lt;command&gt;</span><br><span class="line"># 在这种格式中，&lt;command&gt;通常是一个shell命令，且以&quot;&#x2F;bin&#x2F;sh -c&quot;来运行</span><br><span class="line"># 这意味着此进程在容器中的PID不为1，不能接收到Unix信号，因此，当使用docker stop命令停止容器时，此进程接收不到SIGTERM信号</span><br><span class="line"></span><br><span class="line">### 第二种使用语法</span><br><span class="line">RUN　&lt;&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;&gt;</span><br><span class="line"># 在这种格式中的参数是一个JSON格式的数组，&lt;executable&gt;为要运行的命令，后面的&lt;param&gt;为传递给命令的选项或参数</span><br><span class="line"># 但是这种格式指令的命令不会以&quot;&#x2F;bin&#x2F;sh -c&quot;来发起，因此常见的shell操作如变量替换以及通配符(?,*等)替换将不会进行</span><br><span class="line"># 如要要运行的命令依赖于此shell特性的时，可以将其替换为如下格式：</span><br><span class="line">RUN [&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;]</span><br><span class="line">RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot; ]</span><br><span class="line"># RUN产生的缓存在下一次构建的时候是不会失效的，会被重用</span><br><span class="line"># 可以使用--no-cache选项，即docker build-no-cache，这样便不会缓存</span><br></pre></td></tr></table></figure></li></ul><p>基本使用示例 ：</p><ul><li><p>mkdir test &amp;&amp; cd test</p></li><li><p>vim Dockerfile</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Description： test image</span><br><span class="line">FROM busybox:latest</span><br><span class="line">#FROM busybox@哈希码</span><br><span class="line"># MAINTAINER &quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line">ENV DOC_ROOT&#x3D;&#x2F;data&#x2F;web&#x2F;html \</span><br><span class="line">    WEB_SERVER_PACKAGE&#x3D;&quot;nginx-1.15.2&quot;</span><br><span class="line">COPY index.html $&#123;DOC_ROOT:-&#x2F;data&#x2F;web&#x2F;html&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">ADD http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.15.2.tar.gz &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line"></span><br><span class="line"># WORKDIR &#x2F;usr&#x2F;local</span><br><span class="line"></span><br><span class="line">COPY yum.repos.d &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line"># ADD $&#123;WEB_SERVER_PACKAGE&#125;.tar.gz &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line"></span><br><span class="line">VOLUME &#x2F;data&#x2F;mysql&#x2F;</span><br><span class="line"></span><br><span class="line">EXPOSE 80&#x2F;tcp</span><br><span class="line"></span><br><span class="line">RUN cd &#x2F;usr&#x2F;local&#x2F;src &amp;&amp; \</span><br><span class="line">    tar -x nginx-1.15.2.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>docker build -t tinyhttpd:v0.1-1 ./</p><ul><li>-t  表示打上标签</li></ul></li></ul><p><strong>10）CMD</strong></p><p><strong><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1278240/202011/1278240-20201104203633080-994909625.png" alt="img"></strong></p><ul><li><p>类似于RUN指令，CMD指令也可用于运行任何命令或应用程序，但是二者的运行时间点不同</p><ul><li>RUN指令运行于印象文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新映像文件启动一个容器时</li><li>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；但CMD指定的命令可以为docker run 的命令行选项所覆盖</li><li>在Dockerfile中可以存在多个CMD指令，但仅最后一个会生效</li></ul></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下面这两种语法格式的意义同RUNCMD  &lt;command&gt;  # 这种CMD运行命令的方式pid不为1</span><br><span class="line">CMD  [&quot;&lt;executable&gt;&quot;, &quot;&lt;param1&gt;&quot;, &quot;&lt;param2&gt;&quot;]</span><br><span class="line"></span><br><span class="line"># 这种语法格式用于为ENTRYPOINT指令提供默认参数CMD  [&quot;&lt;param1&gt;&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure></li><li><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; app&#x3D;&quot;httpd&quot;</span><br><span class="line"></span><br><span class="line">ENV WEB_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&quot;</span><br><span class="line"></span><br><span class="line">RUN mkdir -p $WEB_DOC_ROOT &amp;&amp; \</span><br><span class="line">    echo &quot;&lt;h1&gt;Busybox httpd server.&lt;&#x2F;h1&gt;&quot; &gt; $&#123;WEB_DOC_ROOT&#125;&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># CMD &#x2F;bin&#x2F;httpd -f -h $&#123;WEB_DOC_ROOT&#125;</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;&#x2F;bin&#x2F;httpd&quot;,&quot;-f&quot;,&quot;-h $&#123;WEB_DOC_ROOT&#125;&quot;]</span><br></pre></td></tr></table></figure></li></ul><p><strong>11）ENTRYPOINT</strong></p><ul><li><p>类似CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一个单独的可执行程序</p></li><li><p>由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，这些命令行参数会被当做参数传递给ENTRYPOINT指定的程序</p><ul><li>docker run命令的–entrypoint选项的参数可以覆盖ENTRYPOINT指令指定的程序</li></ul></li><li><p>如果dockerfile文件中同时存在CMD和ENTRYPOINT，则CMD的参数将被作为可选项传递给ENTRYPOINT</p><ul><li>如果docker run中指定有命令行参数选项，则这些命令行参数将会覆盖掉CMD，并附加到ENTRYPOINT命令行作为其参数使用，否则才会将CMD作为参数传递给ENTRYPOINT</li><li>dockerfile文件中也可以存在多个ENTRYPOINT，但只有最后一个有效</li></ul></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 跟RUN类似，在这种格式中，command通常为一个shell命令，且以&quot;&#x2F;bin&#x2F;sh -c&quot;来运行</span><br><span class="line"># 此进程在容器中的PID不为1</span><br><span class="line">ENTRYPOINT &lt;command&gt;</span><br><span class="line"></span><br><span class="line"># 跟RUN类似，这种格式指定的命令不会以&quot;&#x2F;bin&#x2F;sh -c&quot;发起，无法使用shell通配符等特性</span><br><span class="line">ENTRYPOINT [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;]</span><br></pre></td></tr></table></figure></li><li><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot; app&#x3D;&quot;httpd&quot;</span><br><span class="line"></span><br><span class="line">ENV WEB_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">RUN mkdir -p $WEB_DOC_ROOT &amp;&amp; \</span><br><span class="line">    echo &quot;&lt;h1&gt;Busybox httpd server.&lt;h1&gt;&quot; &gt; $&#123;WEB_DOC_ROOT&#125;&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># CMD &#x2F;bin&#x2F;httpd -f -h $&#123;WEB_DOC_ROOT&#125;</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;httpd&quot;,&quot;-f&quot;,&quot;-h $&#123;WEB_DOC_ROOT&#125;&quot;]</span><br><span class="line">ENTRYPOINT &#x2F;bin&#x2F;sh -c</span><br><span class="line"># 这样运行时会用&#x2F;bin&#x2F;sh -c 来运行ENTRYPOINT中的&#x2F;bin&#x2F;sh -c ，并且CMD中的命令将会作为参数传递给ENTRYPOINT中的指令</span><br><span class="line"># 如果不想重复启用&#x2F;bin&#x2F;sh -c ，可以写成如下格式：</span><br><span class="line"># ENTRYPOINT [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;]</span><br></pre></td></tr></table></figure></li></ul><p>实际使用示例：</p><ul><li><p>dockerfile文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.14-alpine</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">ENV NGX_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&quot;</span><br><span class="line"></span><br><span class="line">ADD index.html $&#123;NGX_DOC_ROOT&#125;</span><br><span class="line">ADD entrypoint.sh &#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure></li><li><p>被调用的shell脚本文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">#</span><br><span class="line">cat &gt; &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;www.conf &lt;&lt; EOF</span><br><span class="line">server &#123;</span><br><span class="line">  server_name $&#123;HOSTNAME&#125;;</span><br><span class="line">  listen $&#123;IP:-0.0.0.0&#125;:$&#123;PORT:-80&#125;;</span><br><span class="line">  root $&#123;NGX_DOC_ROOT:-&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#125;;  </span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br><span class="line"># 因为CMD指令中的内容将会作为参数传递给ENTRYPOINT，# 所以当ENTRYPOINT调用此脚本文件执行完毕后，可以用exec来调用CMD指令内容中的nginx来覆盖当前进程# 这样保证了nginx进程的PID号依然为1</span><br></pre></td></tr></table></figure></li></ul><p><strong>12）USER</strong></p><ul><li><p>用于指定运行image时的用户名或UID</p></li><li><p>或者指定运行Dockerfile中任何RUN、CMD、ENTRYPOINT指令指定的程序时的用户名或UID</p></li><li><p>默认情况下，容器的运行身份为root用户</p></li><li><p>使用语法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER &lt;UID&gt; | &lt;UserName&gt;</span><br><span class="line"># &lt;UID&gt;可以为任意数字，但实践中必须为&#x2F;etc&#x2F;passwd中某用户的有效UID，否则docker run命令将运行失败</span><br></pre></td></tr></table></figure></li></ul><p><strong>13）HEALTHCHECK</strong></p><ul><li><p>监控检查，可以根据主进程所提供的服务正常与否来进行判定健康与否</p></li><li><p>使用语法及参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 两种语法形式HEALTHCHECK  [OPTIONS]  CMD  command # CMD关键词后也可以跟执行shell脚本的命令或者exec数组</span><br><span class="line">HEALTHCHECK NONE  # 意思是禁止从父镜像继承的HEALTHCHECK生效</span><br><span class="line"></span><br><span class="line"># OPTIONS可设定的参数（下面选项中的值都是默认值）</span><br><span class="line">　　--interval&#x3D;30s    # 每隔多长时间进行一次健康检查（从容器运行起来开始计时），单位s、m、h</span><br><span class="line">　　--timeout&#x3D;30s     # 执行command的超时时间</span><br><span class="line">　　--start-period&#x3D;0s # 启动时间，也就是在这里指定的时候之后再进行健康检查</span><br><span class="line">　　--retries&#x3D;3       # 重试次数，连续检查次数</span><br><span class="line"></span><br><span class="line"># CMD执行完成可能的返回值</span><br><span class="line">　　0  health状态</span><br><span class="line">　　1  unhealth状态</span><br><span class="line">　　2  reserved状态</span><br><span class="line"></span><br><span class="line"># 注意：在Dockerfile中只能有一个HEALTHCHECK指令，如果列出多个，则只有最后一个生效</span><br></pre></td></tr></table></figure></li><li><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK --interval&#x3D;5m --timeout&#x3D;3s \</span><br><span class="line">    CMD curl -f http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure></li><li><p>实际案例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.14-alpine</span><br><span class="line">LABEL maintainer&#x3D;&quot;hgzerowzh &lt;hgzerowzh@qq.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">ENV NGX_DOC_ROOT&#x3D;&quot;&#x2F;data&#x2F;web&#x2F;html&quot;</span><br><span class="line"></span><br><span class="line">ADD index.html $&#123;NGX_DOC_ROOT&#125;</span><br><span class="line">ADD entrypoint.sh &#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">HEALTHCHECK --start-period&#x3D;3s CMD wget -O - -q http:&#x2F;&#x2F;$&#123;IP:-0.0.0.0&#125;:$&#123;PORT:-80&#125;&#x2F;</span><br><span class="line"></span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&#x2F;bin&#x2F;entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure></li></ul><p><strong>14）SHELL</strong></p><ul><li><p>SHELL指令允许覆盖用于shell形式命令的默认shell</p><ul><li>Linux上默认的shell是 [“/bin/sh”, “-c”]</li><li>Windows上是 [“cmd”, “/S”, “/C”]</li></ul></li><li><p>SHELL指令必须以JSON格式写入Dockerfile，且SHELL指令可以出现多次，每个SHELL指令都会覆盖所有先前的SHELL指令，并影响所有后续指令</p></li><li><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM microsoft&#x2F;windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;&#x2F;S&quot;, &quot;&#x2F;C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure></li></ul><p><strong>15）STOPSIGNAL</strong></p><ul><li><p>STOPSIGNAL指令设置将发送到容器的系统调用信号以退出</p><ul><li>此信号可以是与内核的系统调用表中的位置匹配的有效无符号数，如9，或SIGNAME格式的信号名，如SIGKILL</li><li>停止进程的信号，默认是发15的信号，也可以改成9</li></ul></li><li><p>默认的stop-signal是SIGTERM，在docker stop的时候会给容器内PID为1的进程发送这个signal，主要的目的是为了让容器内的应用程序在接收到signal之后可以先做一些事情，实现容器的平滑退出，如果不做任何处理，容器将在一段时间之后强制退出，会造成业务的强制中断，这个时间默认是10s</p></li><li><p>使用语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure></li></ul><p><strong>16）ARG</strong></p><ul><li><p>可以在dockerfile文件中用ARG指令定义一些变量，然后在docker build的时候将这些变量传递进去</p><ul><li>ARG所定义的参数，在docker build命令中以 –build-arg NAME=VALUE的形式进行赋值</li><li>如果docker build命令传递的参数在Dockerfile中没有对应的参数，则会抛出警告</li></ul></li><li><p>使用示例：</p><ul><li><p>先在dockerfile文件中定义ARG</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG author&#x3D;“hgzerowzh”</span><br></pre></td></tr></table></figure></li><li><p>然后在dockerbuild的时候通过 –build-arg 将对应的值传进去</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build --build-arg author&#x3D;“wzh” -t myweb:v0.3-10 .&#x2F;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>17）ONBUILD</strong></p><ul><li><p>ONBUILD用于在dockerfile中定义一个触发器</p><ul><li>这个触发器不是在自己被build的时候执行，而是此镜像被别人拿去做基础镜像时触发执行，也就是被别人FROM的时候触发执行</li><li>一般ONBUILD都是执行RUN或者ADD</li></ul></li><li><p>ONBUILD不能自我嵌套，且不会触发FROM和MAINTAINER指令</p></li><li><p>使用包含ONBUILD指令的Dockerfile构建的镜像应该使用特殊的标签，如ruby:2.0-onbuild</p></li><li><p>在ONBUILD指令中使用ADD或COPY指令时应该要特别注意，因为新构建过程的上下文在缺少指定的源文件时会失败</p></li><li><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD ADD . &#x2F;app&#x2F;src</span><br><span class="line">ONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build --dri &#x2F;app&#x2F;src</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-构建私有Registry"><a href="#8-构建私有Registry" class="headerlink" title="8. 构建私有Registry"></a>8. 构建私有Registry</h2><h3 id="8-1-私有Registry概述"><a href="#8-1-私有Registry概述" class="headerlink" title="8.1 私有Registry概述"></a>8.1 私有Registry概述</h3><p><strong>1）私有仓库搭建的好处</strong></p><ul><li>节约带宽</li><li>可以自己定制系统</li><li>更加安全</li></ul><p><strong>2）构建私有Registry的方式</strong></p><ol><li>利用官方提供的工具docker-registry来配置私库<ul><li>这个工具是一个镜像，直接下载并使用registry镜像启动docker实例就可以了</li></ul></li><li>利用Harbor-Registry来搭建私库<ul><li>Harbor是一个用于存储Docker镜像的企业级Registry服务</li></ul></li></ol><h3 id="8-2-通过docker-registry来配置私库"><a href="#8-2-通过docker-registry来配置私库" class="headerlink" title="8.2 通过docker-registry来配置私库"></a>8.2 通过docker-registry来配置私库</h3><p><strong>1）安装docker私有仓库</strong></p><ul><li>要在私库上安装好docker，然后直接yum安装docker-registry</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker-registry</span><br><span class="line"></span><br><span class="line"># 安装完成后即可直接启动服务,要注意这里的是docker-distribution</span><br><span class="line">systemctl start docker-distribution</span><br><span class="line"></span><br><span class="line"># 安装完成后可以查看一下生成的文件</span><br><span class="line">rpm -ql docker-distribution</span><br></pre></td></tr></table></figure><p><strong>2）配置文件</strong></p><ul><li>vim <strong>/etc/docker-distribution/registry/config.yml</strong> </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry        # 定义启动的服务</span><br><span class="line">storage:</span><br><span class="line">    cache:</span><br><span class="line">        layerinfo: inmemory  # 定义缓存在内存中</span><br><span class="line">    filesystem:</span><br><span class="line">        rootdirectory: &#x2F;var&#x2F;lib&#x2F;registry  # 定义数据存放的位置</span><br><span class="line">http:  </span><br><span class="line">    addr: :5000              # 定义监听的端口，冒号后面没写地址表示监听本机的所有地址</span><br></pre></td></tr></table></figure><p><strong>3）把镜像推送到刚刚建好的私有仓库</strong></p><ul><li><p>先要对镜像打标：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dcoekr tag myweb:v0.3-11  node1.hgzerowzh.com:5000&#x2F;myweb:v0.3-11</span><br><span class="line"># myweb前面没有加其他的用户名，这里表示这是一个顶层仓库</span><br><span class="line"># node1.hgzerowzh.com:5000是仓库的地址</span><br></pre></td></tr></table></figure></li><li><p>然后将镜像推送上去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果不给标签，会推送整个仓库</span><br><span class="line">docker push node1.hgzerowzh.com:5000&#x2F;myweb</span><br><span class="line"></span><br><span class="line"># 推送时，因为客户端使用的是https的连接，而服务端是http的响应，所以推送时会出错</span><br><span class="line">docker push node1.hgzerowzh.com:5000&#x2F;myweb:v0.3-11</span><br><span class="line"></span><br><span class="line"># 仓库必须做成https的</span><br><span class="line"># 如果是在内网使用，确实不想使用https，就可以在客户端添加配置，明确说明要使用非安全的docker registry</span><br></pre></td></tr></table></figure></li></ul><p><strong>4）明确指定要使用非安全的docker-registry</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 特别注意，如下配置是要在客户端配置的，谁要连接docker-registry就在谁上配置</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">        &quot;insecure-registries&quot;:[&quot;node1.hgzerowzh.com:5000&quot;]  # 在这里指定非安全的docker-registry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-通过harbor-registry来配置私库"><a href="#8-3-通过harbor-registry来配置私库" class="headerlink" title="8.3 通过harbor-registry来配置私库"></a>8.3 通过harbor-registry来配置私库</h3><p><strong>1）harbor概述</strong></p><p>harbor是VMwar公司基于docker registry开发的一个用于存储和分发docker镜像的企业级registry服务器。</p><p>harbor通过添加需要的功能如安全性、身份认证、管理来扩展了源Docker Distribution，提升了镜像的传输效率；harbor支持registry之间复制镜像，还提供了更高级的安全功能，比如：漏洞分析、用户管理、访问控制、活动审计等。</p><p><strong>2）harbor的安装</strong></p><p>harbor有两种安装方式：online installer / offline installer</p><p>online installer：从docker hub下载安装</p><p>offline installer：没有网络时，下载离线安装包安装</p><ul><li><a href="https://www.cnblogs.com/zhangxingeng/p/11598708.html#auto_id_11">详细安装步骤</a></li></ul><h2 id="9-Docker资源限制"><a href="#9-Docker资源限制" class="headerlink" title="9. Docker资源限制"></a>9. Docker资源限制</h2><h3 id="9-1-内存资源限制"><a href="#9-1-内存资源限制" class="headerlink" title="9.1 内存资源限制"></a>9.1 内存资源限制</h3><h3 id="9-2-CPU资源限制"><a href="#9-2-CPU资源限制" class="headerlink" title="9.2 CPU资源限制"></a>9.2 CPU资源限制</h3><p> 参考：</p><ul><li><a href="https://www.cnblogs.com/xiaoshancun/p/12352981.html">https://www.cnblogs.com/xiaoshancun/p/12352981.html</a></li><li><a href="https://www.cnblogs.com/zuxing/articles/8780661.html">https://www.cnblogs.com/zuxing/articles/8780661.html</a></li><li><a href="https://www.cnblogs.com/zhangxingeng/p/11236968.html">https://www.cnblogs.com/zhangxingeng/p/11236968.html</a></li><li><a href="https://www.cnblogs.com/zhangxingeng/p/11558782.html">https://www.cnblogs.com/zhangxingeng/p/11558782.html</a></li><li><a href="https://www.cnblogs.com/zhangxingeng/p/11598708.html">https://www.cnblogs.com/zhangxingeng/p/11598708.html</a></li><li><a href="https://www.cnblogs.com/hgzero/p/13852259.html">Docker详解 - Praywu - 博客园 (cnblogs.com)</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python微服务框架nameko</title>
    <link href="http://example.com/posts/56673/"/>
    <id>http://example.com/posts/56673/</id>
    <published>2021-07-25T11:22:14.000Z</published>
    <updated>2021-07-25T11:23:17.692Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python微服务框架nameko的简单使用"><a href="#Python微服务框架nameko的简单使用" class="headerlink" title="Python微服务框架nameko的简单使用"></a>Python微服务框架nameko的简单使用</h1><p>本人的环境为window+xshell+阿里云服务器（ubuntu系统）</p><h2 id="环境部署流程"><a href="#环境部署流程" class="headerlink" title="环境部署流程"></a>环境部署流程</h2><h3 id="ubuntu中安装Docker"><a href="#ubuntu中安装Docker" class="headerlink" title="ubuntu中安装Docker"></a>ubuntu中安装Docker</h3><ol><li><p>更新ubuntu的apt源索引</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装包允许apt通过HTTPS使用仓库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker官方GPG key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.   curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p> 设置Docker稳定版仓库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \   $(lsb_release -cs) \   stable&quot;</span><br></pre></td></tr></table></figure></li><li><p>添加仓库后，更新apt源索引</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装最新版Docker CE（社区版）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>检查Docker CE是否安装正确</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></li><li><p>安装成功显示</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722182730194.png" alt="image-20210722182730194"></p></li><li><p><strong>Docker的启动与停止</strong></p><p>安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动docker</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"># 停止docker</span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line"># 重启docker</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装注册中心"><a href="#安装注册中心" class="headerlink" title="安装注册中心"></a>安装注册中心</h3><p>nameko采用RabbitMQ作为注册中心，所以使用nameko必须要先安装RabbitMQ</p><p>以docker容器的方式运行RabbitMQ是最为简便快捷的方式，两行命令就搞定了，这里介绍如何使用docker运行RabbitMQ。</p><p>第一步：从DockerHub拉取rabbitmq镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:managemen</span><br></pre></td></tr></table></figure><p>第二部：运行RabbitMQ容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname my-rabbit --name rabbit -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>如果需要设置用户名和密码，则使用这条命令（初学尽量别设置密码）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER&#x3D;user -e RABBITMQ_DEFAULT_PASS&#x3D;password -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>我运行容器时没有设置用户名和密码，所以使用用户名guest，密码guest登录。<a href="http://localhost:15672/">http://localhost:15672/</a></p><p>！！！这里的localhost为你的阿里云主机ip。</p><p>注意！！！这里访问的是阿里云服务器，阿里云服务器对端口有安全限制，这里需要我们解开阿里云的端口权限。如下图：</p><p>工作台–》安全组规则–》手动添加两个要用的端口，源端口设为0.0.0.0（全开放）</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722184210280.png" alt="image-20210722184210280"></p><p>设置完成后登录上边提供网址登陆验证。</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722185554046.png" alt="image-20210722185554046"></p><p>登陆成功样子如图：</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20210722184604421.png" alt="image-20210722184604421"></p><h3 id="服务生产者和服务消费者"><a href="#服务生产者和服务消费者" class="headerlink" title="服务生产者和服务消费者"></a>服务生产者和服务消费者</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello_service.py发布服务，服务名称为“hello_service”</span><br><span class="line"></span><br><span class="line">from nameko.rpc import rpc</span><br><span class="line"></span><br><span class="line">class hello_service:</span><br><span class="line">    name &#x3D; &quot;hello_service&quot;</span><br><span class="line"></span><br><span class="line">    @rpc</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>service.py调用服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from nameko.standalone.rpc import ClusterRpcProxy</span><br><span class="line"></span><br><span class="line">CONFIG &#x3D; &#123;&#39;AMQP_URI&#39;: &quot;amqp:&#x2F;&#x2F;guest:guest@192.168.110.129&quot;&#125;</span><br><span class="line"></span><br><span class="line">def compute():</span><br><span class="line">    with ClusterRpcProxy(CONFIG) as rpc:</span><br><span class="line">        rpc.hello_service.hello()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    compute()</span><br></pre></td></tr></table></figure><h2 id="启动微服务"><a href="#启动微服务" class="headerlink" title="启动微服务"></a>启动微服务</h2><p>使用nameko框架的run命令启动微服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameko run hello_service --broker amqp:&#x2F;&#x2F;guest:guest@192.168.110.129</span><br></pre></td></tr></table></figure><p>如果现实信息如下则表示服务成功启动</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191029230557246.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhZ2xldW5pdmVyc2l0eWV5ZQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>运行service.py调用服务后在命令行打印出“hello world”，服务被成功调用</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191029230604559.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhZ2xldW5pdmVyc2l0eWV5ZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>需要先运行起来然后才能查看！！！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210717120444453.png" alt="在这里插入图片描述"></p><p>ubuntu下载东西一般不用yum（纠结了好久！！！！） 下载命令为sudo apt-get</p><p>docker: Error response from daemon: driver failed programming external connectivity on endpoint … (…): Bind for 0.0.0.0:8080 failed: port is already allocated.</p><p>查看进程，发现相关的容器并没有在运行，而 docker-proxy 却依然绑定着端口：<br>$ docker ps<br>$ ps -aux | grep -v grep | grep docker-proxy</p><p>停止 doker 进程，删除所有容器，然后删除 local-kv.db 这个文件，再启动 docker 就可以了。<br>$ sudo service docker stop<br>$ docker rm $(docker ps -aq)（这里删除不了就把用户组改变了，从根用户变为普通用户，后边就没再执行，可参考）。<a href="https://blog.csdn.net/weixin_47758362/article/details/108050348">Docker权限问题可参考网站</a></p><p>$ sudo rm /var/lib/docker/network/files/local-kv.db<br>$ sudo systemctl restart docker</p><p><a href="https://blog.csdn.net/weixin_45496075/article/details/109123709">docker有关的命令都会报错可参考</a></p><p>编程前要有pip python 等环境的准备。<a href="https://zhuanlan.zhihu.com/p/137114974">如何在 Ubuntu 20.04 上安装 Python Pip - 知乎 (zhihu.com)</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RESTFUL_API</title>
    <link href="http://example.com/posts/47217/"/>
    <id>http://example.com/posts/47217/</id>
    <published>2021-07-25T11:17:01.000Z</published>
    <updated>2021-07-25T11:18:29.065Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><h3 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API"></a>什么是API</h3><p>api就是一种请求和交付的过程，比如去买汉堡，去肯德基发出要汉堡的请求，肯德基给你汉堡，至于怎么做汉堡那就是肯德基的事情了。api这里可以理解为肯德基。</p><h3 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h3><p>REST描述的是在网络中client和server的一种交互的形式，REST不是一种协议本身没有太大的作用，实用的是如何设计 RESTful API(REST风格的接口)</p><h3 id="RESTful结构"><a href="#RESTful结构" class="headerlink" title="RESTful结构"></a>RESTful结构</h3><p>网站即软件，是一种新型的软件形式。<br> 　这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。<br> 　网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，<strong>现在我们必须考虑，如何开发在互联网环境中使用的软件。</strong></p><p><strong>RESTful架构</strong>就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><h4 id="RESTFUL结构要解决的问题"><a href="#RESTFUL结构要解决的问题" class="headerlink" title="RESTFUL结构要解决的问题"></a>RESTFUL结构要解决的问题</h4><p><a href="http://en.wikipedia.org/wiki/Roy_Fielding">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">博士论文</a>中提出的。论文内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本文研究计算机科学两大前沿----软件和网络----的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。</span><br></pre></td></tr></table></figure><p><strong>我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。</strong></p><p>可以得出结论：本结构的提出明确指出网络变成同软件编程一样操作的初衷。</p><h3 id="名称由来"><a href="#名称由来" class="headerlink" title="名称由来"></a>名称由来</h3><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是&quot;表现层状态转化&quot;。</span><br><span class="line"></span><br><span class="line">&gt; 如果一个架构符合REST原则，就称它为RESTful架构。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p></blockquote></blockquote><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。<strong>所谓”资源”，就是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源标识符）指向它，<strong>每种资源对应一个特定的URI</strong>。要获取这个资源，访问它的URI就可以，<strong>因此URI就成了每一个资源的地址或独一无二的识别符</strong>。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">附：</span><br><span class="line">URI：Uniform Resource Identifier，统一资源标识符</span><br><span class="line">URL：Uniform Resource Location统一资源定位符</span><br></pre></td></tr></table></figure><h3 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a><strong>表现层</strong></h3><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p><blockquote><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p></blockquote><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h3 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h3><blockquote><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p></blockquote><blockquote><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p></blockquote><blockquote><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>（1）每一个URI代表一种资源；</strong><br><strong>（2）客户端和服务器之间，传递这种资源的某种表现层；</strong><br><strong>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</strong></p><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>RESTful架构有一些典型的设计误区。<br> 　<strong>最常见的一种设计错误，就是URI包含动词。</strong>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。<br> 　举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。<br> 　如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;accounts&#x2F;1&#x2F;transfer&#x2F;500&#x2F;to&#x2F;2</span><br></pre></td></tr></table></figure><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">POST /transaction HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="keyword">from</span>=<span class="number">1</span>&amp;to=<span class="number">2</span>&amp;amount=<span class="number">500.00</span></span><br></pre></td></tr></table></figure><p><strong>另一个设计误区，就是在URI中加入版本号</strong>：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.0/foo</span></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.1/foo</span></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/2.0/foo</span></span><br></pre></td></tr></table></figure><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460">Versioning REST Services</a>）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: vnd.example-com.foo+json; version&#x3D;1.0</span><br><span class="line"> Accept: vnd.example-com.foo+json; version&#x3D;1.1</span><br><span class="line"> Accept: vnd.example-com.foo+json; version&#x3D;2.0</span><br></pre></td></tr></table></figure><h2 id="RESTful-API设计指南"><a href="#RESTful-API设计指南" class="headerlink" title="RESTful API设计指南"></a>RESTful API设计指南</h2><p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。</p><p>　因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现<a href="http://www.google.com.hk/search?q=API+first">“API First”</a>的设计思想。<a href="http://en.wikipedia.org/wiki/Representational_state_transfer">RESTful API</a>是目前比较成熟的一套互联网应用程序的API设计理论。<br> 　介绍RESTful API的设计细节，探讨如何设计一套合理、好用的API。</p><p><strong>一、协议</strong></p><p>API与用户的通信协议，总是使用<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">HTTPs协议</a>。</p><p><strong>二、域名</strong></p><p>应该尽量将API部署在专用域名之下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com</span></span><br></pre></td></tr></table></figure><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//example.org/api/</span></span><br></pre></td></tr></table></figure><p><strong>三、版本（Versioning）</strong></p><p>应该将API的版本号放入URL。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">　　https:<span class="comment">//api.example.com/v1/</span></span><br></pre></td></tr></table></figure><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version">Github</a>采用这种做法。</p><p><strong>四、路径（Endpoint）</strong></p><p>路径又称”终点”（endpoint），表示API的具体网址。</p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//api.example.com/v1/zoos</span></span><br><span class="line">https:<span class="comment">//api.example.com/v1/animals</span></span><br><span class="line">https:<span class="comment">//api.example.com/v1/employees</span></span><br></pre></td></tr></table></figure><p><strong>五、HTTP动词</strong></p><p>对于资源的具体操作类型，由HTTP动词表示。<br> 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br></pre></td></tr></table></figure><p>还有两个不常用的HTTP动词。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD：获取资源的元数据。</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br></pre></td></tr></table></figure><p>下面是一些例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;zoos：列出所有动物园</span><br><span class="line">POST &#x2F;zoos：新建一个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID：获取某个指定动物园的信息</span><br><span class="line">PUT &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID：删除某个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID&#x2F;animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID&#x2F;animals&#x2F;ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><p><strong>六、过滤信息（Filtering）</strong></p><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br> 下面是一些常见的参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">limit</span>=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><p><strong>七、状态码（Status Codes）</strong></p><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">200 <span class="selector-tag">OK</span> <span class="selector-tag">-</span> <span class="selector-attr">[GET]</span>：服务器成功返回用户请求的数据，该操作是幂等的（<span class="selector-tag">Idempotent</span>）。</span><br><span class="line">201 <span class="selector-tag">CREATED</span> <span class="selector-tag">-</span> <span class="selector-attr">[POST/PUT/PATCH]</span>：用户新建或修改数据成功。</span><br><span class="line">202 <span class="selector-tag">Accepted</span> <span class="selector-tag">-</span> <span class="selector-attr">[*]</span>：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 <span class="selector-tag">NO</span> <span class="selector-tag">CONTENT</span> <span class="selector-tag">-</span> <span class="selector-attr">[DELETE]</span>：用户删除数据成功。</span><br><span class="line">400 <span class="selector-tag">INVALID</span> <span class="selector-tag">REQUEST</span> <span class="selector-tag">-</span> <span class="selector-attr">[POST/PUT/PATCH]</span>：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 <span class="selector-tag">Unauthorized</span> <span class="selector-tag">-</span> <span class="selector-attr">[*]</span>：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 <span class="selector-tag">Forbidden</span> <span class="selector-tag">-</span> <span class="selector-attr">[*]</span> 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 <span class="selector-tag">NOT</span> <span class="selector-tag">FOUND</span> <span class="selector-tag">-</span> <span class="selector-attr">[*]</span>：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 <span class="selector-tag">Not</span> <span class="selector-tag">Acceptable</span> <span class="selector-tag">-</span> <span class="selector-attr">[GET]</span>：用户请求的格式不可得（比如用户请求<span class="selector-tag">JSON</span>格式，但是只有<span class="selector-tag">XML</span>格式）。</span><br><span class="line">410 <span class="selector-tag">Gone</span> <span class="selector-tag">-</span><span class="selector-attr">[GET]</span>：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 <span class="selector-tag">Unprocesable</span> <span class="selector-tag">entity</span> <span class="selector-tag">-</span> <span class="selector-attr">[POST/PUT/PATCH]</span> 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 <span class="selector-tag">INTERNAL</span> <span class="selector-tag">SERVER</span> <span class="selector-tag">ERROR</span> <span class="selector-tag">-</span> <span class="selector-attr">[*]</span>：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure><p>状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">这里</a>。</p><p><strong>八、错误处理（Error handling）</strong></p><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><p>{<br> error: “Invalid API key”<br> }</p><p><strong>九、返回结果</strong></p><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;collection：返回资源对象的列表（数组）</span><br><span class="line">GET &#x2F;collection&#x2F;resource：返回单个资源对象</span><br><span class="line">POST &#x2F;collection：返回新生成的资源对象</span><br><span class="line">PUT &#x2F;collection&#x2F;resource：返回完整的资源对象</span><br><span class="line">PATCH &#x2F;collection&#x2F;resource：返回完整的资源对象</span><br><span class="line">DELETE &#x2F;collection&#x2F;resource：返回一个空文档</span><br></pre></td></tr></table></figure><p><strong>十、Hypermedia API</strong></p><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br> 　比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;link&quot;</span>: &#123; </span><br><span class="line">  <span class="attr">&quot;rel&quot;</span>:   <span class="string">&quot;collection https://www.example.com/zoos&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;href&quot;</span>:  <span class="string">&quot;https://api.example.com/zoos&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;List of zoos&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>:  <span class="string">&quot;application/vnd.yourformat+json&quot;</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br> 　Hypermedia API的设计被称为<a href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>。Github的API就是这种设计，访问<a href="https://api.github.com/">api.github.com</a>会得到一个所有可用API的网址列表。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;current_user_url&quot;</span>: <span class="string">&quot;https://api.github.com/user&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;authorizations_url&quot;</span>: <span class="string">&quot;https://api.github.com/authorizations&quot;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href="https://api.github.com/user">api.github.com/user</a>，然后就得到了下面结果。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Requires authentication&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;documentation_url&quot;</span>: <span class="string">&quot;https://developer.github.com/v3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><p><strong>十一、其他</strong></p><p>（1）API的身份认证应该使用<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">OAuth 2.0</a>框架。<br> （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">文章引用</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>卡特兰数</title>
    <link href="http://example.com/posts/54838/"/>
    <id>http://example.com/posts/54838/</id>
    <published>2021-07-24T11:28:19.000Z</published>
    <updated>2021-07-25T11:18:29.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构进阶</title>
    <link href="http://example.com/posts/10218/"/>
    <id>http://example.com/posts/10218/</id>
    <published>2021-05-07T13:11:02.000Z</published>
    <updated>2021-07-25T11:18:29.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本次主要总结主要在树上的数据结构．<br>主要有并查集，树状数组，线段树，二分查找树，平衡树．同时还有分块和点分治这两种与数据结构密切相关的思想．</p><h3 id="基于树的结构"><a href="#基于树的结构" class="headerlink" title="基于树的结构"></a>基于树的结构</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>特点: 擅长动态维护许多具有传递性的关系．</p><p>路径压缩优化的操作.</p><ol><li><p>并查集的存储<br>使用一个数组fa保存父节点（根的父节点设为自己）<br>int fa{size};//这里用中括号</p></li><li><p>并查集的初始化<br>设有ｎ个元素，起初所有元素各自构成一个独立的集合，即有ｎ棵１个节点的树．<br>for(int i = 1; i ＜＝ n; i++) fa{i} = i;</p></li><li><p>并查集的Get操作<br>若x是树根，则ｘ就是集合代表，否则递归访问fa{x}直至根节点.</p></li></ol><p>int get(int x){<br>    if(x == fa{x}) return x;<br>    return fa{x} = get(fa{x}); //路径压缩，fa直接赋值为代表元素．<br>}</p><ol start="4"><li>并查集的Merge操作<br>合并元素x和元素y所在的集合，等价于让x的树根作为y的树根的子节点．<br>void merge(int x, int y){<br> fa{get(x)} = get(y);<br>}</li></ol><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><h4 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h4><h4 id="二分查找树与平衡树"><a href="#二分查找树与平衡树" class="headerlink" title="二分查找树与平衡树"></a>二分查找树与平衡树</h4><h3 id="分块点分治"><a href="#分块点分治" class="headerlink" title="分块点分治"></a>分块点分治</h3><h4 id="离线分治算法"><a href="#离线分治算法" class="headerlink" title="离线分治算法"></a>离线分治算法</h4><h4 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++刷题常用函数汇总</title>
    <link href="http://example.com/posts/46413/"/>
    <id>http://example.com/posts/46413/</id>
    <published>2021-04-30T09:39:08.000Z</published>
    <updated>2021-07-25T11:18:29.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/TCP/HTTPS协议/高并发之NIO底层原理详解</title>
    <link href="http://example.com/posts/47384/"/>
    <id>http://example.com/posts/47384/</id>
    <published>2021-04-23T23:28:16.000Z</published>
    <updated>2021-04-24T04:05:16.758Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTTP和TCP之前已经写过，这里只是做一个简单的查漏补缺和总结概括．</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTPS协议的由来"><a href="#HTTPS协议的由来" class="headerlink" title="HTTPS协议的由来"></a>HTTPS协议的由来</h4><p>由于HTTP天生”明文”的特点，整个传输过程完全透明，任何人都能够在链路中获取，修改或者伪造请求/响应报文，数据不具有可信性．<br>使用HTTPS时，所有的HTTP请求和响应在发送到网络之前，都要进行加密.</p><p>HTTP裸奔协议: 最直观的感受在访问某些网站的时候，本来是没有广告，访问之后却显示了广告，很可能是响应报文被篡改了．<br>如果用HTTP协议完成银行转账，如果请求报文被篡改了，肯定是非常的不安全的．</p><p>HTTPS协议就是在HTTP协议的基础上加了一个安全层SSL/TSL<br>　　　　　　　　　　　　　　　　　　　HTTP<br>应用层　　　　　　　HTTP　　　　　　　SSL/TSL<br>传输层　　　　　　　TCP　　　　　　　　TCP<br>网络层　　　　　　　IP　　　　　　　　IP<br>数据链路层　　　　　网络接口　　　　　网络接口</p><p>第二列为HTTP协议, HTTP直接和TCP建立交互<br>第三列为HTTPS协议（HTTP + SSL/TSL），HTTP直接和安全层交互，安全层再和TCP层进行直接交互.正向为加密过程，反向则为解密过程．</p><h4 id="SSL-TLS来由"><a href="#SSL-TLS来由" class="headerlink" title="SSL/TLS来由"></a>SSL/TLS来由</h4><p>SSL即安全套接层(Secure Socket Layer),由网景公司于1994年发明，IETF在1999年把它改名为TLS(传输层安全，Transport Layer Security),正式标准化，到今天TLS已经发展出了主流的三个版本，分别是2006年的1.1,2008年的1.2,2018年的1.3,每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准.</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p>摘要算法能够把任意长度的数据”压缩”成固定长度，而且独一无二的摘要字符串，好像是给这段数据生成了一个数字”指纹”．任意微小的数据差异，都可以完成不同的摘要．所以可以通过把明文信息的摘要和明文一起加密进行传输，数据传输到对方之后再进行解密，重新对数据进行摘要，在对比就能发现数据有没有被篡改．这样就保证了数据的完整性.<br>一个定长串映射成一个长串，定长串经过微小变动，长串会发生明显　变化．<br>比如　abcd——hash　function—&gt;KLFGDFGHOO<br>　　　abce——hash　function—&gt;PLDGDFFHEA　　　</p><p>常用的摘要算法:<br>    1. md5<br>    2. sha1<br>    3. sha2<br>    4. sha1 256</p><h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>对称秘钥加密算法: 编解码使用形同秘钥的算法,如(AES,RC$,ChaCha20).</p><p>经典对称加密实例: XOR(抑或操作)<br>1110101010111010 原文<br>0101101101010101 秘钥</p><p>1011000111101111　秘文<br>0101101101010101 秘钥</p><p>原文和秘钥进行异或运算得到秘文<br>秘文和秘钥进行异或运算得到原文</p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>非对称秘钥加密算法: 他有两个秘钥，一个叫公钥，一个叫秘钥，两个秘钥是不同的，公钥可以公开给任何人使用，而私钥必须严格保密．非对称加密可以解决”秘钥交换”的问题．网站秘密保管私钥，在网上任意发布公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密．而黑客因为没有私钥，所以就无法破解密文．非对称秘钥加密系统通常需要大量的数学运算，比较慢．如(DH,DSA,RSA,ECC).</p><p>非对称两种方式:<br>    1. 使用公钥加密　使用私钥解密<br>    2. 使用私钥加密　使用公钥解密</p><p>公钥加密和私钥解密相对来说是比较安全地，应为公钥是公有的，私钥只有自己能用，如果用公钥解密，容易被破解掉.</p><h4 id="TLS详解"><a href="#TLS详解" class="headerlink" title="TLS详解"></a>TLS详解</h4><p>TLS里使用的混合加密方式，即把对称加密和非对称加密结合起来．两者互相取长补短，即能高效地加密解密，又能安全地秘钥交换，大致流程如下:<br>    1. 通信开始的时候使用非对称算法如RSA,RCDHE先解决秘钥交换的问题．<br>    2.<br>    3. </p><h5 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h5><p>首先Client和Server端完成三次握手，完成握手之后，然后client会对Server端发送一个请求，请求的是加密套件列表{散列算法－对称加密算法－非对称加密算法}．这些加密套件是Client端支持的加密套件比如支持哪些散列算法哪些对称加密算法哪些非对称加密算法等等．在进行加密的时候client 和Server都必须都能支持才能实现加解密，所以服务端先看一下本地的实现，查看是否client端提供的是否服务端都支持，如果支持的话，然后选择一种最安全的方法，这时客户端把选择的信息反馈给client端，比如（从客户端支持的加密套件列表中选择一个加密套件，公钥数字证书）．并且服务端也会公钥传给客户端，然后客户端会验证证书，然后生成一个随机秘钥，（这里的秘钥用于对称加密秘钥）并且会用公钥（服务器端给到的公钥数字证书里边存在）进行加密．然后服务端再用私钥解密，获取秘钥，最后使用对称秘钥加密算法进行秘钥双向传输.</p><p>公钥数字证书组成:<br>    ca信息，公钥用户信息，公钥，权威机构的签名，有效期．</p><p>问题来了，在建立三次握手的时候有个前提，就是拿到服务器的ip,这里的安全如何保证?如果DNS的信息被劫持，改成黑客的IP地址，是不是就直接可黑客的服务器完成信息通信，后果不堪设想!!<br>解决办法: DNS返回后，验证是不是我要访问的那个服务器，而不是黑客的服务器呢?<br>这里就是服务端给客户端返回的是公钥数字证书，这里边有相关的信息，通过验证证书来完成指定服务器的正确与否.</p><h5 id="身份验证-数字证书"><a href="#身份验证-数字证书" class="headerlink" title="身份验证(数字证书)"></a>身份验证(数字证书)</h5><p>图: https流程.png<br>数字证书组成: ca信息，　公钥用户信息，公钥，权威机构的签名，有效期.</p><p>数字证书的作用:<br>    1. 通过数字证书向浏览器验证身份,<br>    2. 数字证书里面包含了公钥.</p><p>数字证书的申请和验证<br>如何申请:<br>    1. 生成自己的公钥和私钥，服务器自己保留私钥.<br>    2. 向CA机构提交公钥，公司，域名信息等待认证．（最简单的域名和IP的匹配）<br>    3. CA机构通过线上，线下多种途径验证你提交信息的真实性，合法性．<br>    4. 信息审核通过，CA机构则会向你签发认证的数字证书，包含了公钥，组织信息，CA信息，有效时间，证书序列号，同时生成一个签名；<br>    签名步骤: hash(你用于申请证书所提交的明文信息)＝信息摘要；CA在使用私钥对信息摘要进行加密，密文就是证书的数字签名．</p><p>公钥数字证书又由谁来验证呢?<br>颁发证书的机构，CA机构来进行验证，根证书不能再数字证书里边的，他在浏览器或者操作系统里边保存的，</p><p>证书验证细节:<br>    首先把证书名的信息取出来，以及涉及到的算法（hash算法），把明文信息通过hash算法得到一个摘要(一段信息)，然后拿着CA给的公钥(加密是CA给的私钥加密的)进行解密得到解密得到的摘要，两个摘要对比如果一直就说明证书是正确的没有被改动．这就是浏览器对服务器端发送的证书认证的过程，</p><p>问题又来了，谁能保证CA机构是正确的或者是可信任的呢? 如果CA机构信息是伪造的也是不安全的.这里就是由根证书来验证．</p><p>证书是一个证书链，有每层的证书，最高的是根证书，这个不会发给客户端，这个证书是浏览器或者操作系统里边内置的．</p><h3 id="深入分析3大linux-io内核模型（一共有五大）"><a href="#深入分析3大linux-io内核模型（一共有五大）" class="headerlink" title="深入分析3大linux io内核模型（一共有五大）"></a>深入分析3大linux io内核模型（一共有五大）</h3><p>什么是io模型？<br>取决于应用如何调用内核的io函数（阻塞，非阻塞；同步，异步）．</p><p>linux内核IO模型:<br>　　　　　　io模型　　　　　　　　　　　　　同步异步　　　　阻塞非阻塞<br>    1. 阻塞IO　　　　　　　　　　　　　　　　同步　　　　　　阻塞<br>    2. 非阻塞io　　　　　　　　　　　　　　　同步　　　　　　非<br>    3. IO多路复用　　　　　　　　　　　　　　同步　　　　　　非<br>    4. 信号驱动　　　　　　　　　　　　　　　同步　　　　　　非<br>    5. 异步IO　　　　　　　　　　　　　　　　异步　　　　　　非</p><h4 id="同步异步阻塞非阻塞的定义"><a href="#同步异步阻塞非阻塞的定义" class="headerlink" title="同步异步阻塞非阻塞的定义"></a>同步异步阻塞非阻塞的定义</h4><p>同步异步: 强调结果返回的形式；<br>以借东西为例: (计算机层面计应用和内核)<br>同步:     比如你跟你同学去借钱，你走到他面前他把钱借给你了，你拿着钱走了，这里直接给你了就是同步，系统调用就是给系统一个需求或者调用一个接口，系统返回给一个结果</p><p>异步:<br>比如你跟你同学借钱，你走到他面前当时他没钱，你就说等你有钱了，你再来给我．这里没有直接拿到结果的就是异步．系统调用等同.</p><p>阻塞非阻塞: 强调对调用端的影响（服务端和客户端）<br>还是以借钱为例:<br>阻塞:  两个人同时找你借钱，一个人来借钱，这时你采取服务一个人在服务另一个人的方式处理借钱这件事情，在处理一个人的时候，另一个人只能阻塞在一旁．</p><p>非阻塞:<br>两个人同时找你借钱，你两个人同时处理．</p><p>非阻塞IO只是一种概念上的，现实如果实现会出现问题，这里用到了IO多路给他进行优化，这里BIO指的是阻塞IO,NIO一般说指的是非阻塞IO,严格意义上来说是一种new io,它包含了非阻塞IO和IO多路复用的优化．</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>强制类型转换与内存对齐问题</title>
    <link href="http://example.com/posts/6688/"/>
    <id>http://example.com/posts/6688/</id>
    <published>2021-04-23T15:48:03.000Z</published>
    <updated>2021-04-23T15:58:24.910Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>天行健，菜鸟以自强不息!!</p><h3 id="语言强制类型转换"><a href="#语言强制类型转换" class="headerlink" title="语言强制类型转换  "></a>语言强制类型转换  </h3><p> <br>理解：不论是什么类型，在内存中存储的都是二进制，所以之间可以相互转换，而每个内存单元为一个字节，所以强制类型转换就是在分配这些字节。<br>概要：</p><p>C语言中，任何一个变量都必须占有一个地址，而这个地址空间内的0-1代码就是这个变量的值。不同的数据类型占有的空间大小不一，但是他们都必须有个地址，而这个地址就是硬件访问的依据，而名字只是提供给程序员的一种记住这个地址的方便一点的方法。但是，不同的变量在机器中都是0-1代码，所以，我们不能简单的通过检查一个值的位来判断它的类型。</p><p>例如，定义如下：</p><p>int a;</p><p> float b;</p><p>double c;</p><p> long double d;</p><p>(假设它们所占的字节分别是4、8、8、10，而且连续存储于某个地址空间，起始地址是100，则我们可以得到如下内存分布)</p><p>a变量就是由以地址100开始到103结束的4个字节内存空间内的0-1代码组成。b变量则是由以地址104开始到112结束的8个字节内存空间内的0-1代码组成。而在机器中，这些内存都是连续的0-1代码，机器并不知道100<del>103是整型而104</del>111是float型，所有这些类型都是编译器告知的。当我们用a时，由于前面把a定义为int型，则编译器知道从a的地址开始向后取4个字节再把它解释成int型。那么(float)a，就是先按照int类型取出该数值，再将该数值按照int to float的规则转换成float型。所以强制类型转换就是按照某个变量的类型取出该变量的值，再按照**<em>to**</em>的规则进行强制转转换。如果是(类型名)常数，则是将该常数按照常数to类型 的规则进行强制转换。</p><p>指针也是一个变量，它自己占据一个4个字节的地址空间（由于程序的寻址空间是2^32次方，即4GB，所以用4个字节表示指针就已经能指向任何程序能够寻址到的空间了，所以指针的大小为4字节），他的值是另一个东西的地址，这个东西可以是普通变量，结构体，还可以是个函数等等。由于，指针的大小是4字节，所以，我们可以将指针强制转换成int型或者其他类型。同样，我们也可以将任何一个常数转换成int型再赋值给指针。所有的指针所占的空间大小都是4字节，他们只是声明的类型不同，他们的值都是地址指向某个东西，他们对于机器来说没有本质差别，他们之间可以进行强制类型转换。<br>指针 to 指针的强制类型转换是指将指针所指的内容的类型由原先的类型转换为后面的类型。</p><p> </p><p>int a = 1;</p><p>int *p = &a;</p><p>float <em>p1 = (float</em>)p;</p><p>则p和p1的值都是&amp;a，但是<em>p是将&amp;a地址中的值按照int型变量进行解释，而</em>p1则是将&amp;a地址中的值按照float型变量进行解释。</p><p>鉴于指针之间这种灵活的强制类型转换的需求和出于简化代码的考虑，ANSI C引入了空指针即void*。void指针又名万能指针，在现在的很多程序中，当参数不确定时就用万能指针代替，这一类的指针在线程\进程函数里特别常见。</p><p>ANSI C规定，void指针可以复制给其他任意类型的指针，其他任意类型的指针也可以复制给void指针，他们之间复制不需要强制类型转换。当然任何地址也可以复制给void型指针。我们在《网络编程》中经常会看到accept(socket, (struct sockaddr *)&amp;saddr_c, &amp;lenth)之类的语句在&amp;saddr_c之前需要增加代码(struct sockaddr <em>)是因为当此函数被设计的时候ANSI C还没有提出void</em>的概念。所有的地址统一用struct sockaddr类型标识，该函数的第二个参数也是指向struct sockaddr类型的指针，此处是强制类型转换。</p><p>当然，在某些编译器中不同类型的指针也可以进行直接赋值，但一般情况下会给出类型不匹配的警告。要求程序员显示的给出指针强制类型转换可以提醒程序员小心使用指针，对于明确程序目的具有一定的好处。</p><ol><li>指针类型强制转换</li></ol><p>int m;</p><p>int *pm = &m;</p><p>char *cp = (char *)&m;</p><p>pm指向一个整型，cp指向整型数的第一个字节</p><ol start="2"><li>结构体之间的强制转换</li></ol><p>struct str1 a;</p><p> </p><p>struct str2 b;</p><p>a=(struct str1) b;                  //this is wrong</p><p>a=<em>((struct str1</em>)&amp;b);         //this is correct</p><p> </p><ol start="3"><li>关于一个程序的解释</li></ol><p> </p><p>int main(void)</p><p>{</p><pre><code>    int a［4] = &#123;1, 2, 3, 4&#125;;    int *ptr1=(int *)(&amp;a+1);    int *ptr2=(int *)((int)a+1);    int *c = *(a + 1);    printf(&quot;%x, %x,%x\n&quot;, ptr1[-1], *ptr2,*c);    return 0;</code></pre><p>}</p><p>输出分别为4 和2000000,2 </p><p>式子&amp;a+1表示的是指针加法运算，而不是普通的数值加法运算</p><ol><li>&amp;a+1</li></ol><p>   &amp;a表示数组指针，&amp;a+1表示指向下一个数组，强制转换为int型指针，减一即指向a［3]=4;在前面两篇文章中有详细解释。而ptr1［-1]= <em>(ptr1 - 1) 由于ptr1是指针，指向数组a后面的下一个元素，而ptr1-1就是ptr1这个指针往前移动一个单位，移动之后这个指针指向了数组a的最后一个元素。所以就有</em>(ptr1-1)=4。</p><ol start="2"><li>(int *)((int)a+1)</li></ol><p>       指针ptr2的处理是把数组名a强制转换成整型变量，然后再加1，然后再强制转换成整型指针，即是让ptr2指向a[0]的第二个字节，此时打印的内容就是ptr2所指向的往后4个字节的内容，也就是a{0}的后三个字节和a[1]的第一个字节上面的图没有画出里面的内容。此时需要考虑大小端问题。</p><p>    </p><p>    字节序分两种，大端字节序(big-endian) ，小端字节序(little-endian)   </p><p>    1、所谓大端(big-endian)序，就是高优先位对应高有效位。就是读取或者存放数据时，最低位 对应高地址 。</p><p>    2、所谓小端(little-endian)序，就是高优先位对应低有效位 。就是读取或者存放数据时，最低 位对应低地址 。</p><p>       由于x86平台是小端序的，因此将会打印出0200 0000，如果题目中没有说明在x86平台，那答案是不确定的，取决于具体的平台，例如ARM平台就是大端序的。 </p><ol start="3"><li>*(a + 1)  </li></ol><p>      *(a + 1)  此时的a已经是一个常指针了，这个表达式计算出a所指向元素后面的第2个元素的地址，然后对它解引用得到相应的值。这个表达式等价于int last = a［1]</p><p>结构体类型的强制类型转换</p><p>结构体和int等类型一样，都是数据类型。其他类型怎么转换，结构体就怎么转换，没有什么特殊的地方。<br>楼主可能想知道的不是结构体怎样强制转换这个问题吧，猜测，楼主想知道如下几个问题：<br>如果将一个结构体强制类型转换为另一个结构体（或者类型），那这个结构体的成员会怎样了？<br>如果将一个结构体强制类型转换为另一个结构体（或者类型），那么这个结构体成员的数值又会是什么了？<br>解答：</p><ol><li>结构体的本质是：我们和C语言约定了一段内存空间的长短，及其内容的安排。假设下面两个结构体：<br>struct A1<br>{<br>     int a;<br>     char b;</li></ol><p>};</p><p>struct A2<br>{<br>        char a;<br>        int b;</p><p>};<br>接着，用struct A1和struct A2定义变量，并赋初值：<br>struct A1 x = {10, ‘A’};<br>struct A2 y = {‘A’, 10};<br>现在最重要的是，要知道x和y的内存情况：<br>x的内存安排是：前4B，后1B；<br>y的内存安排是：前1B，后4B。<br>如果有struct A2 z;<br>z.a = ((struct A2)x).a;<br>那么，C语言会对x的空间，按照struct A2的格局进行解释:</p><pre><code>也就是说，将x的第一个字节看成第一个成员，且按ASCII码处理数据，而将后面的4B看成第二个成员，并按补码格式解释数据。内存对齐小结：在C语言面试和考试中经常会遇到内存字节对齐的问题。今天就来对字节对齐的知识进行小结一下。首先说说为什么要对齐。为了提高效率，计算机从内存中取数据是按照一个固定长度的。以32位机为例，它每次取32个位，也就是4个字节（每字节8个位，计算机基础知识，别说不知道）。字节对齐有什么好处？以int型数据为例，如果它在内存中存放的位置按4字节对齐，也就是说1个int的数据全部落在计算机一次取数的区间内，那么只需要取一次就可以了。如图a-1. 1. 如果不对齐，很不巧，这个int数据刚好跨越了取数的边界，这样就需要取两次才能把这个int的数据全部取到，这样效率也就降低了。                        </code></pre><p>                                    </p><pre><code>内存对齐是会浪费一些空间的。但是这种空间上得浪费却可以减少取数的时间。这是典型的一种以空间换时间的做法。空间与时间孰优孰略这个每个人都有自己的看法，但是C语言既然采取了这种以空间换时间的策略，就必然有它的道理。况且，在存储器越来越便宜的今天，这一点点的空间上的浪费就不算什么了。需要说明的是，字节对齐不同的编译器可能会采用不同的优化策略，以下以GCC为例讲解结构体的对齐.一、原则：1. 结构体内成员按自身按自身长度自对齐。自身长度，如char=1，short=2，int=4，double=8,。所谓自对齐，指的是该成员的起始位置的内存地址必须是它自身长度的整数倍。如int只能以0,4,8这类的地址开始2. 结构体的总大小为结构体的有效对齐值的整数倍结构体的有效对齐值的确定：1）当未明确指定时，以结构体中最长的成员的长度为其有效值2）当用#pragma pack(n)指定时，以n和结构体中最长的成员的长度中较小者为其值。3）当用__attribute__ ((__packed__))指定长度时，强制按照此值为结构体的有效对齐值二、例子1. struct AA&#123;        char a;        int b;        char c; &#125;aa结果，sizeof（aa）=12何解？首先假设结构体内存起始地址为0，那么地址的分布如下0  a1  234  b5  b6  b7  b8  c91011char的字对齐长度为1，所以可以在任何地址开始，但是，int自对齐长度为4，必须以4的倍数地址开始。所以，尽管1-3空着，但b也只能从4开始。再加上c后，整个结构体的总长度为9，结构体的有效对齐值为其中最大的成员即int的长度4，所以，结构体的大小向上扩展到12，即9-11的地址空着。2. struct AA&#123;        char a;    char c;         int b;    &#125;aasizeof（aa）=8，为什么呢0  a1  c234  b5  b6  b7  b因为c为char类型，字对齐长度为1，所以可以有效的利用1-3间的空格。看见了吧，变量定义的位置的不同时有可能影响结构体的大小的哦！3. #pragma pack(2)struct AA&#123;        char a;        int b;        char c; &#125;aasizeof（aa）=10,为什么呢？a到c只占9字节长度，因为结构体的有效对齐长度在pack指定的2和int的4中取较小的值2。故取2的倍数10。如果当pack指定为8呢?那就仍然按4来对齐，结果仍然是12。 4. </code></pre><p>struct AA{</p><pre><code>    char a;    int b;    char c; </code></pre><p>}<strong>attribute</strong>((<strong>8</strong>))aa</p><p>sizeof(aa)=16,）</p><p>为咩？其实a到c仍然只占9字节长度，但结构体以8对齐，故取8的倍数16.</p><p>如果其指定2，则结果为10</p><p>如果pragma pack和<strong>attribute</strong> 同时指定呢？以<strong>attribute</strong> 的为准。</p><p>需要说明的是，不管pragma pack和__attribute__如何指定，结构体内部成员的自对齐仍然按照其自身的对齐值。</p><p> 另外，不同的编译器可能会对内存的分布进行优化，</p><p> 例如有些编译器会把立体1中的程序优化成例题2的样子。但这属于编译器的问题，</p><p> 这里不做详细讨论。如果要作为编程的参考的话，最好当做编译器不会做优化，</p><p> 尽量在保持代码清晰的情况下，自己手动将例题1优化成例题2的样子。</p><p> 如果是做题的话，按照以上原则做就可以了，不用考虑不同编译器的特性。</p><p>(参考老K的代码world)[<a href="https://blog.csdn.net/qq_33366098/article/details/78137422]">https://blog.csdn.net/qq_33366098/article/details/78137422]</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c/c++" scheme="http://example.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>均匀的生成随机数</title>
    <link href="http://example.com/posts/37274/"/>
    <id>http://example.com/posts/37274/</id>
    <published>2021-04-23T13:28:11.000Z</published>
    <updated>2021-04-23T14:44:47.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>艰难困苦　玉如于成　！！</p><p>假设已知rand2()可以均匀的生成［1,2]的随机数，现在想均匀的生成{1,4]的随机数，该如何考虑？<br>第一次接触这个问题，那么很可能会这么考虑——令两个rand2()相加，再做一些必要的边角处理。如下：<br>rand2() + rand2() = ? ==＞{2,4]<br>   1    +   1     = 2<br>   1    +   2     = 3<br>   2    +   1     = 3<br>   2    +   2     = 4<br>出现概率:<br>1: 1/4;<br>2: 2/4 = 1/2<br>3: 1/4<br>结论是概率出现次数并不均等，所以说不能作为随机数的最终结果.<br>下边先得出我们想要的范围，然后再考虑去重的问题．</p><p>为了把生成随机数的范围规约成{1,n]，于是在上一步的结果后减1<br>(rand2()-1) + rand2() = ? ==＞ {1,3]<br>   0       +   1     = 1<br>   0       +   2     = 2<br>   1       +   1     = 2<br>   1       +   2     = 3<br>可以看到，使用这种方法处理的结果，最致命的点在于——其生成的结果不是等概率的。在这个简单的例子中，产生2的概率是50%，而产生1和3的概率则分别是25%。原因当然也很好理解，由于某些值会有多种组合，因此仅靠简单的相加处理会导致结果不是等概率的。</p><p>因此，我们需要考虑其他的方法了。</p><p>仔细观察上面的例子，我们尝试对 (rand2()-1) 这部分乘以 2，改动后如下：</p><p>(rand2()-1) × 2 + rand2() = ? ==＞ ［1,3]<br>   0            +   1     = 1<br>   0            +   2     = 2<br>   2            +   1     = 3<br>   2            +   2     = 4<br>神奇的事情发生了，奇怪的知识增加了。通过这样的处理，得到的结果恰是［1,4]的范围，并且每个数都是等概率取到的。因此，使用这种方法，可以通过rand2()实现rand4()。</p><p>也许这么处理只是我运气好，而不具有普适性？那就多来尝试几个例子。比如：</p><p>(rand9()-1) × 7 + rand7() = result<br>     a               b</p><p>可以看到，这个例子可以等概率的生成［1,63]范围的随机数。再提炼一下，可以得到这样一个规律：</p><p>已知 rand_N() 可以等概率的生成[1, N]范围的随机数<br>那么：<br>(rand_X() - 1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数<br>即实现了 rand_XY()</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>那么想到通过rand4()来实现rand2()呢？这个就很简单了，已知rand4()会均匀产生[1,4]的随机数，通过取余，再加1就可以了。如下所示，结果也是等概率的。</p><p>rand4() % 2 + 1 = ?<br>   1 % 2    + 1 = 2<br>   2 % 2    + 1 = 1<br>   3 % 2    + 1 = 2<br>   4 % 2    + 1 = 1<br>事实上，只要rand_N()中N是2的倍数，就都可以用来实现rand2()，反之，若N不是2的倍数，则产生的结果不是等概率的。比如：</p><p>rand6() % 2 + 1 = ?<br>   1 % 2    + 1 = 2<br>   2 % 2    + 1 = 1<br>   3 % 2    + 1 = 2<br>   4 % 2    + 1 = 1<br>   5 % 2    + 1 = 2<br>   6 % 2    + 1 = 1</p><p>rand5() % 2 + 1 = ?<br>   1 % 2    + 1 = 2<br>   2 % 2    + 1 = 1<br>   3 % 2    + 1 = 2<br>   4 % 2    + 1 = 1<br>   5 % 2    + 1 = 2</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>ok，现在回到本题中。已知rand7()，要求通过rand7()来实现rand10()。</p><p>有了前面的分析，要实现rand10()，就需要先实现rand_N()，并且保证N大于10且是10的倍数。这样再通过rand_N() % 10 + 1 就可以得到[1,10]范围的随机数了。</p><p>而实现rand_N()，我们可以通过part 1中所讲的方法对rand7()进行改造，如下：</p><p>(rand7()-1) × 7 + rand7()  ==&gt; rand49()<br>但是这样实现的N不是10的倍数啊！这该怎么处理？这里就涉及到了“拒绝采样”的知识了，也就是说，如果某个采样结果不在要求的范围内，则丢弃它。基于上面的这些分析，再回头看下面的代码，想必是不难理解了。</p><p>class Solution extends SolBase {<br>    public int rand10() {<br>        while(true) {<br>            int num = (rand7() - 1) * 7 + rand7(); // 等概率生成[1,49]范围的随机数<br>            if(num &lt;= 40) return num % 10 + 1; // 拒绝采样，并返回[1,10]范围的随机数<br>        }<br>    }<br>}</p><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p>这部分具体的代码是参考官方题解的，不过是我自己在理解了part 1和part 2之后才看懂的，一开始看真不知道为什么（/(ㄒoㄒ)/~~…</p><p>根据part 1的分析，我们已经知道(rand7() - 1) * 7 + rand7() 等概率生成[1,49]范围的随机数。而由于我们需要的是10的倍数，因此，不得不舍弃掉[41, 49]这9个数。优化的点就始于——我们能否利用这些范围外的数字，以减少丢弃的值，提高命中率总而提高随机数生成效率。</p><p>class Solution extends SolBase {<br>    public int rand10() {<br>        while(true) {<br>            int a = rand7();<br>            int b = rand7();<br>            int num = (a-1)*7 + b; // rand 49<br>            if(num &lt;= 40) return num % 10 + 1; // 拒绝采样</p><pre><code>        a = num - 40; // rand 9        b = rand7();        num = (a-1)*7 + b; // rand 63        if(num &lt;= 60) return num % 10 + 1;        a = num - 60; // rand 3        b = rand7();        num = (a-1)*7 + b; // rand 21        if(num &lt;= 20) return num % 10 + 1;    &#125;&#125;</code></pre><p>}<br>分析一下<br>第一个if:<br>    范围: 1~49<br>    49个数每个数字的出现概率都是1/49</p><p>第二个if:<br>    范围: 1~60<br>    60个数每个数的出现概率都是1/60</p><p>第三个if:<br>    范围: 1~20<br>    20个数每个数的出现概率都是1/20</p><p>每一部分都采取了拒绝采样处理: 避免掉了%10之后数字分配不均的问题．这样就做到了１０以内每个数字出现在每个if都是等概率的．<br>验证代码需要大数据求次数，可以说近似平均,</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="随机数" scheme="http://example.com/categories/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
    
    <category term="随机数" scheme="http://example.com/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++多态虚函数表详解及多重继承和多继承情况</title>
    <link href="http://example.com/posts/46373/"/>
    <id>http://example.com/posts/46373/</id>
    <published>2021-04-17T12:15:07.000Z</published>
    <updated>2021-04-18T13:30:35.578Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>该部分由于没办法传入图手写的有些出入，可看源码．<br>主要涉及的知识: C++ 多态 多继承 多重继承 虚函数表 虚函数指针 动态绑定</p><p>概述：C++相对其他面向对象语言来说，之所以灵活、高效。很大程度的占比在于其多态技术和模板技术。C++虚函数表是支撑C++多态的重要技术，它是C++动态绑定技术的核心。</p><h3 id="多态内存分布"><a href="#多态内存分布" class="headerlink" title="多态内存分布"></a>多态内存分布</h3><p>假设有一个基类ClassA，一个继承了该基类的派生类ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。<br>我们在代码中运用多态这个特性时，通常以两种方式起手: </p><ol><li>ClassA *a = new ClassB();</li><li>ClassB b; ClassA *a = &b;<br>以上两种方式都是用基类指针去指向一个派生类实例，区别在于第1个用了new关键字而分配在堆上，第2个分配在栈上.<br>————————————————</li></ol><p>详谈内存分配:<br>—————-ClassA *a = new ClassB();]————————————————-ClassB b, ClassA *a = &b;<br>———————————————————————————]————————————————–]<br>———-栈区——:–ClassA *a;————————————————]——ClassB实例————-(1) ClassA指针指向—<br>———————————————————————————]——虚函数表指针———–ClassB栈上对象实例—<br>———————————————————————————]——其他成员————————————<br>———————————————————————————]————————————————–]<br>—-虚地址空间——:———–(1)注释: ClassA指针指向ClassB堆上对象实例.——-]————————————————–<br>———————————————————————————]————————————————–]<br>———————–ClassB实例————————————————]————————————————–<br>——-堆区———:–虚函数表指针———————————————-]————————————————–<br>———————–其他成员————————————————–]————————————————–<br>———————————————————————————]————————————————-]<br>–未初始化全局区—-:-(.bss)—-(2)注释:-vptr指向ClassB类的虚函数表————–]————————————————-<br>———————————————————————————]————————————————-]<br>–已初始化全局区—-:-(.data)—————————————————-]————————————————–<br>———————————————————————————]————————————————-]<br>———————-ClassB类的虚函数表—————————————–]ClassB类的虚函数表——–(2)vptr指向————<br>只读数据段(.rodata)-:-虚函数指针01———————————————–]虚函数指针01———–ClassB类的虚函数表——–<br>———————-虚函数指针02———————————————–]虚函数指针02————————————-<br>———————-0———————————————————-]——-0—————————————–<br>———————————————————————————]————————————————-]<br>———————-非虚函数—————————————————]非虚函数—————-(3)ClassB类的虚函数指针指向<br>—-代码段(.text)—:-虚函数—-(3)ClassB类的虚函数指针指向Class类的虚函数代码段.]虚函数———————ClassB类的虚函数代码段<br>———————————————————————————]————————————————–<br>———————————————————————————]————————————————-]</p><p>注解:<br>    第一列: (三个箭头)<br>        箭头1: 栈区指向堆区         (1)所示<br>        箭头2: 堆区指向只读代码段   (2)所示<br>        箭头3: 只读代码段指向代码段 (3)所示<br>    第二列: (三个箭头)<br>        箭头1: ClassA *a 指向ClassB实例 (1)所示<br>        箭头2: 虚函数表指针指向虚函数01 (2)所示<br>        箭头3: 虚函数指针指向虚函数     (3)所示</p><p>请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。<br>以左图为例，ClassA *a是一个栈上的指针。<br>该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向**该类的虚函数表(这里是类ClassB)**的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。</p><h3 id="类的虚函数表与类实例的虚函数指针"><a href="#类的虚函数表与类实例的虚函数指针" class="headerlink" title="类的虚函数表与类实例的虚函数指针"></a>类的虚函数表与类实例的虚函数指针</h3><p>首先不考虑继承的情况。如果一个类中有虚函数，那么该类就有一个虚函数表。<br>这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。<br>从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。</p><p>看图分析:<br>    ClassA类的实例01<br>    —————-            [类ClassA的虚函数表          类ClassA的虚函数<br>    虚函数表指针————–&gt; [虚函数指针01      ——–&gt; ClassA::vfun10<br>    成员变量01           -  &gt;   [虚函数指针02      ——–&gt; ClassA::vfun20<br>    普通函数指针      -         […                         …<br>                   -            [0<br>                -<br>     ClassA类的实例02                                        ClassA的普通函数<br>    —————–　　　　　　　　　　　　　　　　　　　——————-<br>     虚函数表指针                                            ClassA::func10<br>     成员变量01                                              ClassA::func20<br>     普通函数指针                                            …</p><h3 id="多态代码及多重继承情况"><a href="#多态代码及多重继承情况" class="headerlink" title="多态代码及多重继承情况"></a>多态代码及多重继承情况</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassA() &#123; cout &lt;&lt; &quot;ClassA::ClassA()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassA() &#123; cout &lt;&lt; &quot;ClassA::~ClassA()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassA::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">void func2() &#123; cout &lt;&lt; &quot;ClassA::func2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassA::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassA::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int aData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassB : public ClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassB() &#123; cout &lt;&lt; &quot;ClassB::ClassB()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassB() &#123; cout &lt;&lt; &quot;ClassB::~ClassB()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassB::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassB::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int bData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassC : public ClassB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassC() &#123; cout &lt;&lt; &quot;ClassC::ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassC() &#123; cout &lt;&lt; &quot;ClassC::~ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func2() &#123; cout &lt;&lt; &quot;ClassC::func2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassC::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">    int cData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在第二部分中，我们讨论了在没有继承的情况下，虚函数表的逻辑结构。<br>那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。<br>请看上面代码</p><ol><li><p>ClassA是基类, 有普通函数: func1() func2() 。虚函数: vfunc1() vfunc2() ~ClassA()</p></li><li><p> ClassB继承ClassA, 有普通函数: func1()。虚函数: vfunc1() ~ClassB()</p></li><li><p>ClassC继承ClassB, 有普通函数: func2()。虚函数: vfunc2() ~ClassB()<br>基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份.</p><pre><code>   a-----------------&gt; ClassA类的实例01              类ClassA的虚函数表               类ClassA的虚函数 </code></pre><p>ClassA *a = new ClassA();     ClassA的虚函数表指针  ——-&gt;虚函数指针01  ——————&gt;ClassA::vfunc10</p><pre><code>                       ClassA::aData                 虚函数指针02  ------------------&gt;ClassA::vfunc20                       ClassA::func10                ...                              ...                       ClassA::func20                0                                                       ...</code></pre></li></ol><hr><p>a                            ClassB类的实例01               类ClassB的虚函数表               类ClassB的虚函数<br>ClassA *a = new ClassB()—-&gt;ClassB的虚函数表指针           虚函数指针01                     ClassB::vfunc10<br>                             ClassA::aData                  虚函数指针02                     ClassA::vfunc20<br>                             ClassA::func10                 …                              …<br>                             ClassA::func20                 0<br>                             …<br>                            —————————<br>                             ClassB:bData<br>                             ClassB:func10<br>                             …</p><hr><p>ClassB继承与ClassA，其虚函数表是在ClassA虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassA *a &#x3D; new ClassB();</span><br><span class="line">a-&gt;func1();                    &#x2F;&#x2F; &quot;ClassA::func1()&quot;   隐藏了ClassB的func1()</span><br><span class="line">a-&gt;func2();                    &#x2F;&#x2F; &quot;ClassA::func2()&quot;</span><br><span class="line">a-&gt;vfunc1();                   &#x2F;&#x2F; &quot;ClassB::vfunc1()&quot;  重写了ClassA的vfunc1()</span><br><span class="line">a-&gt;vfunc2();                   &#x2F;&#x2F; &quot;ClassA::vfunc2()&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结果不难想象，看上图，ClassA类型的指针a能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同<br>这个结果已经说明了C++的隐藏、重写(覆盖)特性。</p><p>同理，也就不难推导出ClassC的逻辑结构图了<br>类的继承情况是: ClassC继承ClassB，ClassB继承ClassA<br>这是一个多次单继承的情况。(多重继承)</p><pre><code>                                    ClassC类的实例01                    ClassC的虚函数表        类ClassC的虚函数</code></pre><p>ClassA *a = new ClassC();————-&gt;[ClassC的虚函数表指针                虚函数指针01            ClassB::vfunc1()<br>ClassB *b = new ClassC();————-&gt;[                                    虚函数指针02            ClassC::vfunc2()<br>                                         ClassA::aData                      …                     …<br>                                         ClassA::func1()                    0<br>                                         ClassA::func2()<br>                                         …<br>                                         ——————–<br>                                         ClassB::bData<br>                                         ClassB::func1()<br>                                         …<br>                                         ——————–<br>                                         ClassC::cData<br>                                         ClassC::func20()<br>                                         …<br>                                         ——————–</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassA* a &#x3D; new ClassC;</span><br><span class="line">a-&gt;func1();          &#x2F;&#x2F; &quot;ClassA::func1()&quot;   隐藏ClassB::func1()               </span><br><span class="line">a-&gt;func2();          &#x2F;&#x2F; &quot;ClassA::func2()&quot;隐藏ClassC::func2()</span><br><span class="line">a-&gt;vfunc1();     &#x2F;&#x2F; &quot;ClassB::vfunc1()&quot;ClassB把ClassA::vfunc1()覆盖了</span><br><span class="line">a-&gt;vfunc2();     &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;ClassC把ClassA::vfunc2()覆盖了</span><br><span class="line"></span><br><span class="line">ClassB* b &#x3D; new ClassC;</span><br><span class="line">b-&gt;func1();&#x2F;&#x2F; &quot;ClassB::func1()&quot;有权限操作时，子类优先</span><br><span class="line">b-&gt;func2();&#x2F;&#x2F; &quot;ClassA::func2()&quot;隐藏ClassC::func2()</span><br><span class="line">b-&gt;vfunc1();&#x2F;&#x2F; &quot;ClassB::vfunc1()&quot;ClassB把ClassA::vfunc1()覆盖了</span><br><span class="line">b-&gt;vfunc2();&#x2F;&#x2F; &quot;ClassB::vfunc2()&quot;ClassC把ClassA::vfunc2()覆盖了</span><br></pre></td></tr></table></figure><h3 id="多继承下的虚函数表-同时继承多个基类"><a href="#多继承下的虚函数表-同时继承多个基类" class="headerlink" title="多继承下的虚函数表 (同时继承多个基类)"></a>多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassA1() &#123; cout &lt;&lt; &quot;ClassA1::ClassA1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassA1() &#123; cout &lt;&lt; &quot;ClassA1::~ClassA1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassA1::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassA1::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassA1::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int a1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassA2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassA2() &#123; cout &lt;&lt; &quot;ClassA2::ClassA2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassA2() &#123; cout &lt;&lt; &quot;ClassA2::~ClassA2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassA2::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassA2::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassA2::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc4() &#123; cout &lt;&lt; &quot;ClassA2::vfunc4()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">private:</span><br><span class="line">int a2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ClassC : public ClassA1, public ClassA2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">ClassC() &#123; cout &lt;&lt; &quot;ClassC::ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual ~ClassC() &#123; cout &lt;&lt; &quot;ClassC::~ClassC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">void func1() &#123; cout &lt;&lt; &quot;ClassC::func1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">virtual void vfunc1() &#123; cout &lt;&lt; &quot;ClassC::vfunc1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc2() &#123; cout &lt;&lt; &quot;ClassC::vfunc2()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">virtual void vfunc3() &#123; cout &lt;&lt; &quot;ClassC::vfunc3()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ClassA1是第一个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()。<br>ClassA2是第二个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()，vfunc4()。<br>ClassC依次继承ClassA1、ClassA2。普通函数func1(),虚函数vfunc1() vfunc2() vfunc3()。</p><pre><code>                             ClassC类的实例01               类ClassC的虚函数表01    类ClassC的虚函数</code></pre><p>ClassA1 *a1 = new ClassC();      ClassC的虚函数表指针01         虚函数指针01———-&gt; ClassC::vfun1()<br>ClassA2 *a2 = new ClassC();      ClassC的虚函数表指针02         虚函数指针02———-&gt; ClassC::vfun2()<br>                                 ClassA1::a1Data                虚函数指针03———-&gt; ClassC::vfun3()<br>                                 ClassA1::func1()               *<br>                                 …                            (上边以classA1为基础)<br>                                 ClassA2::a2Data                类ClassC的虚函数表02    类ClassC的虚函数<br>                                 ClassA2::func1()               虚函数指针01———-&gt; ClassC::vfun1()<br>                                 …                            虚函数指针02———-&gt; ClassC::vfun2()<br>                                 ClassC::cData                  虚函数指针03———-&gt; ClassA2::func4()<br>                                 ClassC::func1()                0                       …<br>                                 …                            (上边以classA2为基础)<br>注意:<br>    1. 父类没有而子类有的,添加到第一个表中<br>    2. 父类有而子类没有的,不覆盖.</p><p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。<br>如图，虚函数表指针01指向的虚函数表是以ClassA1的虚函数表为基础的，子类的ClassC::vfunc1(),和vfunc2()的函数指针覆盖了虚函数表01中的虚函数指针01的位置、02位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。<br>当有多个虚函数表时，虚函数表的结果是0代表没有下一个虚函数表。” * “号位置在不同操作系统中实现不同，代表有下一个虚函数表。<br>注意: </p><ol><li>子类虚函数会覆盖每一个父类的每一个同名虚函数。</li><li>父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。</li><li>父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。</li></ol><p>最后给出代码和结果:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   ClassA1 *a1 &#x3D; new ClassC;</span><br><span class="line">a1-&gt;func1();               &#x2F;&#x2F; &quot;ClassA1::func1()&quot;    隐藏子类同名函数</span><br><span class="line">a1-&gt;vfunc1();              &#x2F;&#x2F; &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA1虚函数</span><br><span class="line">a1-&gt;vfunc2();              &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA1虚函数</span><br><span class="line">没有a1-&gt;vfunc3()，父类没有这个虚函数</span><br><span class="line"></span><br><span class="line">ClassA2 *a2 &#x3D; new ClassC;</span><br><span class="line">a2-&gt;func1();               &#x2F;&#x2F; &quot;ClassA2::func1()&quot;    隐藏子类同名函数</span><br><span class="line">a2-&gt;vfunc1();              &#x2F;&#x2F; &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA2虚函数</span><br><span class="line">a2-&gt;vfunc2();              &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA2虚函数</span><br><span class="line">a2-&gt;vfunc4();              &#x2F;&#x2F; &quot;ClassA2::vfunc4()&quot;   未被子类重写的父类虚函数</span><br><span class="line"></span><br><span class="line">ClassC *c &#x3D; new ClassC;</span><br><span class="line">c-&gt;func1();                &#x2F;&#x2F; &quot;ClassC::func1()&quot;</span><br><span class="line">c-&gt;vfunc1();               &#x2F;&#x2F; &quot;ClassC::vfunc1()&quot;</span><br><span class="line">c-&gt;vfunc2();               &#x2F;&#x2F; &quot;ClassC::vfunc2()&quot;</span><br><span class="line">c-&gt;vfunc3();               &#x2F;&#x2F; &quot;ClassC::vfunc3()&quot;</span><br><span class="line">c-&gt;vfunc4();               &#x2F;&#x2F; &quot;ClassA2::func4()&quot; </span><br></pre></td></tr></table></figure></p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">&#x2F;&#x2F;函数占位参数如下</span><br><span class="line">    &#x2F;&#x2F; void se(int)-</span><br><span class="line">&#x2F;&#x2F;函数重载，允许函数名重复，但是参数数量不同</span><br><span class="line">&#x2F;&#x2F;函数重载条件</span><br><span class="line">    &#x2F;&#x2F;1.同一个作用下</span><br><span class="line">    &#x2F;&#x2F;2.函数名相同</span><br><span class="line">    &#x2F;&#x2F;3.函数参数类型不同，或者参数个数或顺序不一样。 </span><br><span class="line">    &#x2F;&#x2F;函数返回值不可以作为函数重载的条件 </span><br><span class="line">using namespace std;</span><br><span class="line">int func(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125; </span><br><span class="line">int func(int a, int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b+c;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F;因为函数参数个数不用而进行的函数重载</span><br><span class="line">int  </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; func(5,6) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; func(5,6,7) &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么要重载？：<br>       C++为了致力于简化编程，能通过函数重名来打到简化编程的目的。 C++允许在同一范围中声明几个功能类似的同名函数。可以提高开发效率，增加可读性。</p><p>对于不同的数据类型取绝对值，需要定义不同的函数</p><p>int iabs(int a)<br>{<br>    return a&gt;0 ? a：-a;<br>}</p><p>double fabs(doule a)<br>{<br>    return a&gt;0 ? a：-a;<br>}<br>重载规则：<br>       1、函数名相同</p><p>       2、函数形参个数、顺序、类型不同</p><p>同时符合以上两个条件可构成重载，返回值不同不可以构成重载。</p><p>底层实现：<br>       C++利用命名倾轧（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p><p>C++定义同名重载函数：<br>#include<iostream><br>using namespace std;<br>int func(int a, double b){<br>    return ((a) + (b));<br>}<br>int func(double a, float){<br>    return ((a) + (b));<br>}<br>int func(float a, int b){<br>    return ((a) + (b));<br>}<br>int main(){<br>    return 0;<br>}</p><p>底层实现：用nm命令查看目标文件的符号清单</p><p>00000000000000a7 t_GLOBAL_sub_I_Z4funcid<br>000000000000005e T main<br>0000000000000069 t _Z41_static_iniyialization_and_destruction_0ii<br>0000000000000020 T _Z4funcdf (这里d为double的简化,f为float的简化)<br>000000000000003e T _Z4funcfi (这里f为float的简化,i为int的简化)<br>0000000000000000 T _Z4funcid ()</p><p><a href="https://blog.csdn.net/qq_36359022/article/details/81870219">参考网站可跳转</a></p><hr><p>ad代表double，f代表float，i代表int，加上参数首字母以区分同名函数。</p><p>extern “C”：<br>       C++要实现对C语言的完全兼容。首先要语法兼容，其次是C库兼容。</p><p>       C++编写的代码，若去调用C编出来的库，是行不通的，因为C代码编译并不会发生命名倾轧行为，而C++代码编译会产生命名倾轧行为，所以函数名不匹配，则无法调用到C库中的函数。</p><p>       消除倾轧的方法，在C++代码包含C库的头文件，加入extern “C”。可在linux中自行编译一个C库，C++代码去调用，来证明无法链接到库函数。</p><p>extern “C”{//让里面的内容不发生倾轧行为<br>          ……//例如：#include “head1.h”<br>          }</p><p>       总之一句话，倾轧是C++为了实现函数重载而设计的，不倾轧的extern “C”则是为了兼容C而后实现的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划入门</title>
    <link href="http://example.com/posts/10547/"/>
    <id>http://example.com/posts/10547/</id>
    <published>2021-04-07T03:47:55.000Z</published>
    <updated>2021-04-08T03:51:46.554Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>春雨随广，不润无根之草．<br>佛门随宽，不渡无缘之客.</p><p>线性结构的特点是什么？非线性结构的特点是什么?: </p><p>线性结构元素之间的关系是一对一的，在线性结构中只有一个开始结点和一个终端结点，其他的每一个结点有且仅有一个前驱和一个后继结点。而非线性结构则没有这个特点，元素之间的关系可以是一对多的或多对多的。</p><p>基本思想:<br>    1. 状态:<br>        1. 最优子结构<br>        2. 无后效性<br>    2. 转移方程:<br>        1. 分类讨论<br>        2. 细心枚举</p><h4 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h4><p>动态规划主要分为两个核心部分，一是确定DP状态，二是确定DP方程.</p><p>DP状态两大原则:<br>    1. 最优子结构<br>    2. 无后效性</p><h5 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h5><p>什么是最优子结构？<br>  将原有问题划分为一个个子问题，即为子结构。而对于每一个子问题，即为子结构。而对每一个子问题，其最优值均由【更小规模的子问题的最优值】推导而来，即为最优子结构.<br>  因此DP状态设置之前，需要将原有问题划分成一个个子问题，且需要确保子问题的最优值由【更小规模子问题的最优值】推出，此时子问题的最优值即为【DP状态】的定义.</p><h5 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h5><p>就是我们只关心子问题的最优值，不关心子问题的最优值是怎么得到的.<br>简明来说就是，就是我们不关心当前子问题是哪一个子问题得来的，（多做题慢慢体会就会发现，就是不用记录哪个问题得来的，能得出来就可.</p><p>最后概括一下:<br>    最优子结构就是DP状态最优值由更小规模的DP状态最优值推出，此处DP状态即为子问题，而无后效性就是无论DP状态是如何得到的，都不会影响后续DP状态的取值.</p><h4 id="线性DP概述"><a href="#线性DP概述" class="headerlink" title="线性DP概述"></a>线性DP概述</h4><p>DP总而言之将原问题划分成多个子问题，且大规模子问题的最优解只与小规模子问题的最优解有关，与小规模子问题最优解是如何得到的无关，最后我们发现，首先弄一个结构存储最优解，如何得到的是我们需要实现的使我们要思考的这个就是DP的精髓所在。（也就是问题变换的精髓）。</p><h4 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h4><h5 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h5><p>子序列:<br>    1. 可以不连续<br>    2. 相对位置不变</p><p>模型讲解:<br>    求一个无序数组的最长上升子序列，如果是第一次见到这样的问题，那肯定没有什么思路，这个时候采取惯用的思路—-减少长度(从局部到全部),从小规模的问题着手思考.</p><p>如果长度为１呢???? 答案显然为1.</p><p>如果长度为2呢???? 这时需要考虑第二个数是否比第一个数大，如果比第一个数大，则答案为2,否则为1.</p><p>如果长度为3呢????<br>那么我们需要枚举第三个数是否比第二个数或者第一个数大，如果比它大，则可以直接从第二个或第一个数的答案直接转移而来。因此我们可以如下订制【DP状态】,f{i}仅考虑前i个数，以第i个数为结尾的最长上升子序列的最大长度.</p><p>由此推导出转移方程: 如何得到的使我们需要考虑的，状态不要涉及.<br>    f｛i｝= max(1, f{j} + 1); a{j} ＜ a{i}, j ＜i.</p><p>模型分析:<br>    该模型【DP状态】的关键在于固定了最后一个数字，而这样做的原因在于对一个最长上升序列，我们只需要注意它最后一个数字，对于其前面的数字我们并不关心。<br>    该模型的时间复杂度为O(n^2), 其中n为数组的长度，另外该模型可用二分优化到O(nlogn).自行了解.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    int sz &#x3D; nums.size(), ans &#x3D; 0;</span><br><span class="line">    vector&lt;int&gt; f(sz, 0);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; sz; i++)&#123;</span><br><span class="line">        int temp &#x3D; 1;</span><br><span class="line">        for(int j &#x3D; i - 1; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">            if(nums[i] &gt; nums[j])</span><br><span class="line">            temp &#x3D; max(temp, f[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] &#x3D; temp;</span><br><span class="line">        ans &#x3D; max(ans, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h5><p>给定两个字符串text1和text2,返回和两个字符串的最长公共子序列的长度。</p><p>一个字符串的【子序列】是指这样一个新的字符串:<br>    他是由原字符串在不改变字符的相对顺序的情况下删除某个字符串(也可以不删除任何字符)后组成的新字符串。</p><p>例如, ace是abcde的子序列, aec不是abcde的子序列。两个字符串的【公共子序列】是这两个字符串所共同拥有的子序列。　若这两个字符串没有公共子序列，则返回0;</p><p>与LIS模型不同的是，最长公共子序列涉及到了两个字符数组，不再是基于单数组的问题。</p><p>根据LIS模型【DP状态】设置的经验，以及【线性DP】的核心特点，即DP状态沿着各个维度线性增长，我们可以如下制定【DP状态】，f[i][j]表示第一个串的前i个字符与第二个字符的前j个字符的最长公共子序列的长度.</p><p>该状态的转移方程没有上一个模型那么直接，因此我们需要分类讨论.</p><ol><li><p>假如text[i] != text[j], 即text1[i]无法与text2[j]匹配，因此f[i][j] = max(f[i][j - 1], f[i - 1][j]);</p></li><li><p>text1[i] == text2[j], 则text1[i]可以和text2[j]完成匹配，因此我们可以增加一种转移方式，f[i][j] = d[i - 1][j - 1] + 1.</p></li></ol><p>时间复杂度O(nm),n m 分别是text1,text2串的长度.</p><pre><code>             1. f[i - 1][j]</code></pre><p>方程: f[i][j] =  2. f[i][j - 1]<br>                 3. d[i - 1][j - 1] + 1, text1[i] = text2[j];</p><p>代码实现:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int longestCommand(text1, text2)&#123;</span><br><span class="line">    int n &#x3D; text1.size(), m &#x3D; text2().size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;f(n + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; m; j++)&#123;</span><br><span class="line">            f[i][j] &#x3D; max(f[i - 1][j], f[i][j - 1]);</span><br><span class="line">            if(text1[i - 1] &#x3D;&#x3D; test2[j - 1])</span><br><span class="line">            f[i][j] &#x3D; f[i - 1][j - 1] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h5 id="最长公共上升子序列-LCIS"><a href="#最长公共上升子序列-LCIS" class="headerlink" title="最长公共上升子序列(LCIS)"></a>最长公共上升子序列(LCIS)</h5><h5 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h5><p>题目描述:<br>    给定一个三角形，找出自顶向下的最小路径和，每一步只能移动到下一行中相邻的结带点上。</p><pre><code>相邻的节点在这里指的是下标与上一层结点下标相同或者等于上层节点下标＋1的两个节点.(就是正上方节点，和正上方节点右边节点.比如５就是３和４。　   2 3   4</code></pre><p>   6   5   7<br>4    1    8   3</p><p>自顶向下的最小路径和为11即 2 + 3 + 5 + 1 = 11.</p><p>说明:<br>    如果只用O(n)的额外空间(n 为三角形的总行数)来解决这个问题，那么你的算法很加分.</p><p>模型详解:<br>    该模型即为【线性DP】基础模型之一: 数字三角形， 即最常见的二维坐标系【DP模型】。<br>    考虑到【线性DP】中DP状态沿着各个维度线性增长的这一特点，以及本题所求的从上到下的最小路径和，不难得出状态f[i][j]表示从顶点出发到达第i行第j列这个点时的最小路径和.</p><p>由于题目中限制(i, j)只能由(i - 1, j - 1)和(i - 1, j)两个点到达，因此我们可以得到如下【DP方程】:<br>    f[i][j] = triange[i][j] + min(f[i - 1][j - 1],f[i - 1][j]);</p><p>书写代码时需要注意边界的处理,如对于特定的(i, j)来说，数字三角形中不存在(i - 1, j - 1) 或 (i - 1, j).</p><p>这个模型我们可以得到:<br>    二维坐标系中也可以进行线性DP的，而且我们可以直接根据坐标点设置DP状态．</p><p>代码实现:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int minnum(vector&lt;vector&lt;int&gt;&gt;&amp; trangle)&#123;</span><br><span class="line">    int n &#x3D; trangle.size(), ans &#x3D; INT_MAX;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; trangle.size(); j++)&#123;</span><br><span class="line">            if(j &#x3D;&#x3D; trangle[i].size() - 1)&#123;</span><br><span class="line">                f[i + 1][j + 1] &#x3D; trangle[i][j] + f[i][j];</span><br><span class="line">            &#125;else if(j &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                f[i + 1][j + 1] &#x3D; trangle[i][j] + f[i][j + 1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                f[i + 1][j + 1] &#x3D; trangle[i][j] + min(f[i][j + 1], f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>滚动数组优化:</p><p>上述【DP转移方程】的时间复杂度为O(n^2)。空间复杂度也为O(n^2),但根据题目中的提示，本题是可以优化至O(n)空间复杂度.</p><p>这种优化方法称为【滚动数组优化】，在【DP问题】中非常常见，主要适用于f[i][j]仅由f[i - 1][k]转移而来的情况.</p><p>例如本题中，【DP转移方程】如下:<br>    f[i][j] = trangle[i][j] + min(f[i - 1][j - 1], f[i - 1][j]);</p><p>不难发现, f[i][j] 仅由f[i - 1][j - 1]和f[i - 1][j]所决定，因此对于一个固定的i,我们可以从n到1倒叙枚举j,由此可以优化至如下转移方程:<br>    f[j] = trangle[i][j] + min(f[i - 1], f[j])<br>因为顺序会把前边的数据覆盖掉，从后往前（因为从上到下取最优子结构）所以避免了覆盖，可以依然从上往下取最优子结构。</p><p>完整代码:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int minnum(vector&lt;vector&lt;int&gt;&gt;&amp; trangle)&#123;</span><br><span class="line">    int n &#x3D; trangle.size(), ans &#x3D; INT_MAX;</span><br><span class="line">    vector&lt;int&gt; f(n + 1, 0);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; trangle[i].size() - 1; j &gt;&#x3D; 0; j--)&#123;</span><br><span class="line">            if(j &#x3D;&#x3D; trangle[i].size() - 1)&#123;</span><br><span class="line">                f[j + 1] &#x3D; trangle[i][j] + f[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else if(j &#x3D;&#x3D; 0)</span><br><span class="line">                f[j + 1] &#x3D; trangle[i][j] + f[j + 1];</span><br><span class="line">            else</span><br><span class="line">                f[j + 1] &#x3D; trangle[i][j] + min(f[j + 1], f[j]);</span><br><span class="line">            if(i &#x3D;&#x3D; n - 1)</span><br><span class="line">            ans &#x3D; min(ans, f[j + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>总结:<br>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p><ol><li>如何识别这是一道线性DP的问题????     (满足线性增长，部分线性增长)。</li><li>DP状态是如何设置?????                (状态的定义)</li><li>如何根据DP状态得到DP转移方程????     (动态转移方程书写)</li></ol><h5 id="DP思路在深入总结"><a href="#DP思路在深入总结" class="headerlink" title="DP思路在深入总结!!!!"></a>DP思路在深入总结!!!!</h5><ol><li><p>DP状态的确定有两个原则，一是最优子结构，二是无后效性，简要概括就是将原问题划分为多个子问题，且大规模问题最优值仅与小规模子问题最优值有关.</p></li><li><p>此处的大规模与小规模，就是DP问题的关键所在，也是DP问题分类的重要标准。 </p></li><li><p>确定完DP状态后，只需要分类讨论，细心枚举各种情况，即可得到DP转移方程。</p></li></ol><h5 id="线性DP特点回顾"><a href="#线性DP特点回顾" class="headerlink" title="线性DP特点回顾"></a>线性DP特点回顾</h5><p>线性划分DP规模的动态规划算法被统称为线性DP。在线性DP中，DP状态从小规模转移到大规模的同时，DP状态沿着各个维度线性增长。</p><h5 id="背包-第四种DP模型"><a href="#背包-第四种DP模型" class="headerlink" title="背包(第四种DP模型)"></a>背包(第四种DP模型)</h5><h6 id="01背包-滚动数组"><a href="#01背包-滚动数组" class="headerlink" title="01背包(滚动数组)"></a>01背包(滚动数组)</h6><p>01背包的基本模型如下:<br>一共有N个物品，其中第i个物品的体积为Vi, 价值为Wi。现要求选择一些物品放入一个容积为M的背包中，使得物品总体积不超过M的前提下,物品总价值最大。</p><p>现在我们来思考下如何根据线性DP的知识来解决这个问题?</p><p>线性DP的特点是DP状态沿着各个维度线性增长。而本问题中只有三个参数，分别是物品编号，物品体积以及物品价值。由于我们要求的是物品价值最大，因此不难想到DP状态为f[i][j],表示仅考虑前i个物品，所选物品总体积为j时的最大物品总价值。</p><p>确定DP状态后，我们来考虑DP转移方程是什么???</p><p>对于第i个物品来说，它只有两种状态，即要么取，要么不取。如果不取第i个物品，则f[i][j] = f[i - 1][j]; 如果取第i个物品，则f[i][j] = f[i - 1][j - vi] + wi,因此我们能得到如下DP转移方程:<br>    f[i][j] = max(f[i - 1][j], f[i - 1][j - vi] + wi);<br>其中初值f[0][0] = 0, f[0][i] 为负无穷，其中i 属于[1, M], 最终答案为max{f[N][j]},j属于[0, M],代码如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[0][i] &#x3D; INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0][0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt;&#x3D; M; j++)&#123;</span><br><span class="line">            if(j &gt;&#x3D; v[i])</span><br><span class="line">               f[i][j] &#x3D; max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);</span><br><span class="line">            else </span><br><span class="line">               f[i][j] &#x3D; f[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; M; i++)</span><br><span class="line">    ans &#x3D; max(ans, f[N][i]);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察上述代码不难发现,f[i][j]仅由f[i - 1][j]和法f[i - 1][j - v[i]]决定，这就给了我们一个思考角度，能否将二维数组f的第一维去掉????</p><p>答案显然是可以的，我们可以倒序枚举j，使得更新f[j]时f[j - v[i]]还未被更新，即f[j - v[i]]代表的实际是f[i - 1][j - v[i]]的值,看一下优化后的代码:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;</span><br><span class="line">        f[j] &#x3D; INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; M; j &gt;&#x3D; v[i]; j--)&#123;</span><br><span class="line">            f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>根据这段代码不难发现，第i轮，更新到f[j]时，f[j]与f[j - v[i]]代表的是i - 1轮的值，即f[i - 1][j] 与 f[i - 1][j - v[i]].而我们更新完f[j]后，f[j]的值即变为f[i][j]的值，由此我们大大降低了该算法的空间开销，这种优化方法叫做滚动数组.</p><h6 id="完全背包-二进制拆分"><a href="#完全背包-二进制拆分" class="headerlink" title="完全背包(二进制拆分)"></a>完全背包(二进制拆分)</h6><p>了解完01背包模型后，我们继续介绍完全背包模型，其基本问题如下:<br>    一共有N类物品，其中第i类物品的体积为vi,价值为Wi,且每类物品可以选无数个，现要求选择一些物品放入一个容积为M的背包中，使得物品的总体积不超过M的前提下，物品总价值最大.</p><pre><code>不难发现,完全背包和01背包最大的差别就在于每一类物品可以选多少个,其中完全背包每一类物品可以选无数个,而01背包中每一类物品只能选一个.了解完模型之后我们继续思考如何解决该问题.与01背包模型比较类似,本问题也只有三个参数,分别是物品编号,物品体积以及物品价值.因此我们按照01背包的DP状态,即f[i][j]表示仅考虑前i类物品,所选物品总体积为j时的最大物品总价值.由于每一类物品可以选无数次,因此对于f[i][j]来说,如果不可取     f[i][j] = f[i - 1][j],如果取一个则   f[i][j] = f[i - 1][j - v[i]] + w[i],如果取两个则   f[i][j] = f[i - 1][j - 2 * v[i]] + 2*w[i],如果是x个则    f[i][j] = f[i - 1][j - x * v[i]] + x * w[i].因此可以得到  f[i][j] = max(f[i - 1][j], f[i - 1][j - x * v[i]] + x * w[i]), x &gt;= 0;但这样我们需要不断的遍历x导致时间复杂度过高,我们还需继续优化.(这里的x只是一个参数)f[i][j] = max(f[i - 1][j], f[i - 1][(j - v[i]) - x * v[i]] + w[i] + x * w[i]) ,x &gt;= 0;又因为f[i][j - v[i]] = max(f[i - 1][(j - v[i]) - x * v[i] + x * w[i]]), x &gt;= 0.因此只需正序遍历j,即保证求取f[i][j]时,f[i][j - v[i]]已经得到,DP转移方程就可以优化为:f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i]);对于01背包中f[i][j] = f[i - 1][j - v[i]] + w[i],完全背包中每个物品可以取多次,因此转移方程变为f[i][j] = f[i][j - v[i]] + w[i];</code></pre><p>代码如下:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[0][j] &#x3D; IN_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0][0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt;&#x3D; M; j++)&#123;</span><br><span class="line">            if(j &gt;&#x3D; v[i])</span><br><span class="line">                f[i][j] &#x3D; max(f[i - 1][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">            else </span><br><span class="line">                f[i][j] &#x3D; f[i - 1][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int  i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[N][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    滚动数组优化:<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[0][j] &#x3D; IN_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0][0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int j &#x3D; v[i]; j &lt;&#x3D; M; j++)&#123;</span><br><span class="line">                f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int  i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[N][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h6 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h6><p>多重背包模型,基本问题如下所示:<br>    一共有N类物品,其中第i类物品的体积为V[i],价值为W{i},且每类物品只有C[i]个(c[i] &gt;= 0),现要求选择一些物品放入一个容积为M的背包中,使得物品的总体积不超过M的前提下,物品总价值最大.</p><pre><code>将该问题与01背包模型进行对比,可以发现唯一差别在于01背包中每一类物品的c[i] = 1, 因此我们可以将多重背包换成01背包进行求解.首先比较容易想到的是,我们可以进行暴力拆分,即将一类物品拆分为c[i]个,总物品数量从N变为(求和符号)(1- N) c[i]()就是把每个物品变成一个新的物品来计算,,因此我们可以直接用01背包模型来进行求解.具体代码如下:     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DP()&#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        f[i] &#x3D; INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    f[0] &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        for(int k &#x3D; 1; k &lt;&#x3D; c[i]; k++)&#123;</span><br><span class="line">            for(int j &#x3D; M; j  &gt;&#x3D; v[i]; j--)&#123;</span><br><span class="line">                f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; M; i++)&#123;</span><br><span class="line">        ans &#x3D; max(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>    直接暴力拆分使问题变得简单,但是时间复杂度却显著提高为 O(M *c[i](i = 1 ~n 求累加和))．我们还需继续优化!!!!!    直接暴力拆分使得该问题变得简单，但是时间复杂度却显著增加，为 图片。于是我们需要思考有没有什么方法可以对该问题进行优化？</code></pre><p>考虑二进制的思想，我们考虑把第  种物品换成若干件物品，使得原问题中第  种物品可取的每种策略——取  件——均能等价于取若干件代换以后的物品。另外，取超过  件的策略必不能出现。方法是：将第  种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为  ，且  是满足  的最大整数。例如，如果  为 13，就将这种物品分成系数分别为 1, 2, 4, 6 的 4 件物品。分成的这几件物品的系数和为  ，表明不可能取多于  件的第  种物品。另外这种方法也能保证对于  间的每一个整数，均可以用若干个系数的和表示，这个证明可以分  和  两段来分别讨论得出，并不难，希望题主自己思考尝试一下。这样就将第  种物品分成了  种物品，将原问题转化为了复杂度为  的 01 背包问题，是很大的改进。</p><p>二进制优化：</p><p>二进制优化的思想还是很巧妙的，根据c【i】得到一组这样的数 2^0,2^1,2^2,2^3…..2^(k-1) , c-2^k+1  其中k是满足2^k小于c的最大值，就像c=7=111，2^k=100=4  ;</p><p> c=9=1001, 2^k=1000=8  ;  c=8=1000  2^k=0100=4   </p><p>得到这组数的目的是什么呢，</p><p>1到c之间的所有数都可以由这组数组合得到（选取相加），而从这组数里任意选任意个（每个数最多只能选一次）加在一起得到的数也必定是1~c这个闭区间内的</p><p>例如14=1110   他对应的这组数为：1，2，4，7  可以试一试，通过前三个组合可以得到1<del>7之间的所有数，而加上7就可以得到8</del>14之间的所有数，因此可以得到1~14之间的任何数，所以我们可以只对这组数逐一进行01背包，而不用从1到c都要01背包一次，算是把O（c）的部分优化成了O（logc）</p><p> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void erjinzhi()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,k,m;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(k&#x3D;1;(k&lt;&lt;1)&lt;&#x3D;c[i];k&lt;&lt;&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">for(j&#x3D;V;j&gt;&#x3D;k*v[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]&#x3D;max(dp[j],dp[j-k*v[i]]+k*w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m&#x3D;c[i]-k+1;</span><br><span class="line">for(j&#x3D;V;j&gt;&#x3D;m*v[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]&#x3D;max(dp[j],dp[j-m*v[i]]+m*w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单调队列优化</p><p> </p><p>参考了这篇博客的思想 <a href="http://blog.csdn.net/flyinghearts/article/details/5898183">http://blog.csdn.net/flyinghearts/article/details/5898183</a>  以及k爷的代码<a href="http://blog.csdn.net/lxy767087094/article/details/54730613%EF%BC%8C%E5%8A%A0%E4%B8%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3">http://blog.csdn.net/lxy767087094/article/details/54730613，加上自己的理解</a></p><p>那篇博客大体思想讲的很好，实现过程是用了两个队列，一个辅佐队列，不易理解</p><p> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int num,value;</span><br><span class="line">&#125;que[100000];</span><br><span class="line">int tail,head;</span><br><span class="line">void push(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">while(tail&gt;head&amp;&amp;que[tail-1].value&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">que[tail].num&#x3D;x;</span><br><span class="line">que[tail++].value&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">void singlequeue()</span><br><span class="line">&#123;</span><br><span class="line">int i,d,j;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]&#x3D;min(c[i],V&#x2F;v[i]);</span><br><span class="line">for(d&#x3D;0;d&lt;v[i];d++)</span><br><span class="line">&#123;</span><br><span class="line">head&#x3D;tail&#x3D;0;</span><br><span class="line">for(j&#x3D;0;j&lt;&#x3D;(V-d)&#x2F;v[i];j++)</span><br><span class="line">&#123;</span><br><span class="line">push(j,dp[j*v[i]+d]-j*w[i]);</span><br><span class="line">while(que[head].num&lt;j-c[i]&amp;&amp;tail&gt;head)</span><br><span class="line">head++;</span><br><span class="line">dp[j*v[i]+d]&#x3D;que[head].value+j*w[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结!!!!!!:<br>    背包问题特点</p><p>至此我们介绍完了三大常见的背包模型，分别是「0/1 背包」、「完全背包」、「多重背包」，其区别仅仅在于每一类物品可以选多少个。其中「0/1 背包」是每一类物品只能选一个，「完全背包」则是每一类物品可以选无数个，而「多重背包」则是第 i 类物品最多可以选 图片个。<br>因此我们可以归纳「背包问题」的特点：有 N 类物品，每类物品可以选 1 个、无数个或 图片个，问是否存在一种选取方案，使其满足某种条件。或者是否存在一种选取方案，使其满足某种条件的同时，得到某种参数的最值。<br>这样归纳可能还是过于抽象，因此我们将在下文「习题练习」中讲解一些具体的题型来帮助大家理解。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="动态规划" scheme="http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>链表和树</title>
    <link href="http://example.com/posts/8091/"/>
    <id>http://example.com/posts/8091/</id>
    <published>2021-04-01T11:36:29.000Z</published>
    <updated>2021-04-08T03:23:11.349Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x), next(NULL)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>结构定义:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(0), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>海量数据和bit_map</title>
    <link href="http://example.com/posts/56260/"/>
    <id>http://example.com/posts/56260/</id>
    <published>2021-03-26T07:35:50.000Z</published>
    <updated>2021-03-26T09:16:10.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="道海量数据处理"><a href="#道海量数据处理" class="headerlink" title="道海量数据处理"></a>道海量数据处理</h3><h4 id="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"><a href="#给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？" class="headerlink" title="给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？"></a>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</h4><p>方案1; 可以估计每个文件安的大小为50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p><ol><li>历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为,这里漏写个了a1）中。这样每个小文件的大约为300M。</li><li>遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</li><li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li></ol><p>方案2:<br>    如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</p><p>    读者反馈@crowgns：</p><p>hash后要判断每个文件大小，如果hash分的不均衡有文件较大，还应继续hash分文件，换个hash算法第二次再分较大的文件，一直分到没有较大的文件为止。这样文件标号可以用A1-2表示（第一次hash编号为1，文件较大所以参加第二次hash，编号为2）<br>由于1存在，第一次hash如果有大文件，不能用直接set的方法。建议对每个文件都先用字符串自然顺序排序，然后具有相同hash编号的（如都是1-3，而不能a编号是1，b编号是1-1和1-2），可以直接从头到尾比较一遍。对于层级不一致的，如a1，b有1-1，1-2-1，1-2-2，层级浅的要和层级深的每个文件都比较一次，才能确认每个相同的uri。</p><h4 id="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"><a href="#有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。" class="headerlink" title="有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。"></a>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。</h4><p>方案1:<br>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。<br>找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（,此处有误，更正为b0,b1,b2,b9）。<br>对这10个文件进行归并排序（内排序与外排序相结合）。</p><p>方案2: 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了</p><p>    （读者反馈@店小二：原文第二个例子中：“找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。”由于query会重复，作为key的话，应该使用hash_multimap 。hash_map 不允许key重复。@hywangw:店小二所述的肯定是错的，hash_map(query,query_count)是用来统计每个query的出现次数 又不是存储他们的值 出现一次 把count+1 就行了 用multimap干什么？多谢hywangw）。</p><p>方案3:<br>    与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。</p><h4 id="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"><a href="#有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。" class="headerlink" title="有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。"></a>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</h4><p>方案1:<br>顺序读文件中，对于每个词x，取，然后按照该值存到5000个小文件（记为）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。</p><h4 id="海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>海量日志数据，提取出某日访问百度次数最多的那个IP。</h4><p>方案1: 首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p><h4 id="在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。"><a href="#在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。" class="headerlink" title="在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。"></a>在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。</h4><p>方案1: 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32*2bit=1GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p><p>方案2: 也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h4 id="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h4><p>方案1:<br>在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大。<br>求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。<br>（更多可以参考：第三章、寻找最小的k个数，以及第三章续、Top K算法问题的实现）</p><p>    读者反馈@QinLeopard：</p><p>第6题的方法中，是不是不能保证每个电脑上的前十条，肯定包含最后频率最高的前十条呢？<br>比如说第一个文件中：A(4), B(5), C(6), D(3)<br>第二个文件中：A(4),B(5),C(3),D(6)<br>第三个文件中: A(6), B(5), C(4), D(3)<br>如果要选Top(1), 选出来的结果是A，但结果应该是B。</p><p>    @July：我想，这位读者可能没有明确提议。本题目中的TOP10是指最大的10个数，而不是指出现频率最多的10个数。但如果说，现在有另外一提，要你求频率最多的 10个，相当于求访问次数最多的10个IP地址那道题，即是本文中上面的第4题。特此说明。</p><h4 id="7-怎么在海量数据中找出重复次数最多的一个？"><a href="#7-怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="7. 怎么在海量数据中找出重复次数最多的一个？"></a>7. 怎么在海量数据中找出重复次数最多的一个？</h4><p>方案1: 先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h4 id="8-上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"><a href="#8-上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。" class="headerlink" title="8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。"></a>8. 上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。</h4><p>方案1<br>上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成。</p><h4 id="9-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"><a href="#9-1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？" class="headerlink" title="9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？"></a>9. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</h4><p>方案1:<br>这题用trie树比较合适，hash_map也应该能行。</p><h4 id="10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"><a href="#10-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。" class="headerlink" title="10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。"></a>10. 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</h4><p>方案1:<br>    这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n</em>lg10)。所以总的时间复杂度，是O(n<em>le)与O(n</em>lg10)中较大的哪一个。</p><h4 id="11-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"><a href="#11-一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。" class="headerlink" title="11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。"></a>11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。</h4><p>方案1: 首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。</p><h4 id="12-100w个数中找出最大的100个数。"><a href="#12-100w个数中找出最大的100个数。" class="headerlink" title="12. 100w个数中找出最大的100个数。"></a>12. 100w个数中找出最大的100个数。</h4><p>方案1: 采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w<em>100)。<br>方案2:采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w</em>100)。<br>方案3: 在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。</p><h4 id="13-寻找热门查询："><a href="#13-寻找热门查询：" class="headerlink" title="13. 寻找热门查询："></a>13. 寻找热门查询：</h4><p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p><ol><li><p>请描述你解决这个问题的思路；</p></li><li><p>请给出主要的处理流程，算法，以及算法的复杂度。</p></li></ol><p>方案1: 采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p><p>    关于此问题的详细解答，请参考此文的第3.1节：第三章续、Top K算法问题的实现。</p><h4 id="14-一共有N个机器，每个机器上有N个数。每个机器最多存O-N-个数并对它们操作。如何找到N-2个数中的中数？"><a href="#14-一共有N个机器，每个机器上有N个数。每个机器最多存O-N-个数并对它们操作。如何找到N-2个数中的中数？" class="headerlink" title="14. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数中的中数？"></a>14. 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数中的中数？</h4><p>方案1: 先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有2^32个）。我们把0到2^32-1的整数划分为N个范围段，每个段包含（2^32）/N个整数。比如，第一个段位0到2^32/N-1，第二段为（2^32）/N到（2^32）/N-1，…，第N个段为（2^32）（N-1）/N到2^32-1。然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于（N^2）/2，而在第k-1个机器上的累加数小于（N^2）/2，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第（N^2）/2-x位。然后我们对第k个机器的数排序，并找出第（N^2）/2-x个数，即为所求的中位数的复杂度是O（N^2）的。</p><p>方案2: 先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第（N^2）/2个便是所求。复杂度是O（N^2*lgN^2）的。</p><h4 id="15-最大间隙问题"><a href="#15-最大间隙问题" class="headerlink" title="15. 最大间隙问题"></a>15. 最大间隙问题</h4><p>给定n个实数，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。</p><p>方案1:<br>最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：</p><p>找到n个数据中最大和最小数据max和min。<br>用n-2个点等分区间[min, max]，即将[min, max]等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为，且桶i 的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为：。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为），且认为将min放入第一个桶，将max放入第n-1个桶。<br>将n个数放入n-1个桶中：将每个元素x[i] 分配到某个桶（编号为index），其中（这括号里多了个“+”），并求出分到每个桶的最大最小数据。<br>最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶i的上界和桶j的下界之间产生j&gt;=i+1。一遍扫描即可完成。</p><h4 id="16-将多个集合合并成没有交集的集合"><a href="#16-将多个集合合并成没有交集的集合" class="headerlink" title="16. 将多个集合合并成没有交集的集合"></a>16. 将多个集合合并成没有交集的集合</h4><p>    给定一个字符串的集合，格式如：。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出。</p><p>(1) 请描述你解决这个问题的思路；</p><p>(2) 给出主要的处理流程，算法，以及算法的复杂度；</p><p>(3) 请描述可能的改进。</p><p>方案17:<br>采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于，首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。</p><h4 id="17-最大子序列与最大子矩阵问题"><a href="#17-最大子序列与最大子矩阵问题" class="headerlink" title="17. 最大子序列与最大子矩阵问题"></a>17. 最大子序列与最大子矩阵问题</h4><p>数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。</p><p>方案1:<br>    这个问题可以动态规划的思想解决。设b[i]表示以第i个元素a[i]结尾的最大子序列，那么显然。基于这一点可以很快用代码实现。</p><p>最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。</p><p>方案2: 可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。</p><p> </p><h3 id="第二部分、海量数据处理之Bti-map详解"><a href="#第二部分、海量数据处理之Bti-map详解" class="headerlink" title="第二部分、海量数据处理之Bti-map详解"></a>第二部分、海量数据处理之Bti-map详解</h3><p>    Bloom Filter已在上一篇文章海量数据处理之Bloom Filter详解中予以详细阐述，本文接下来着重阐述Bit-map。有任何问题，欢迎不吝指正。</p><p>什么是Bit-map<br>    所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>    如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：)</p><p>    然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0×01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一（如下图）：</p><p>      </p><p>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：</p><p>然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。下面的代码给出了一个BitMap的用法：排序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义每个Byte中有8个Bit位</span><br><span class="line">#include ＜memory.h＞</span><br><span class="line">#define BYTESIZE 8</span><br><span class="line">void SetBit(char *p, int posi)</span><br><span class="line">&#123;</span><br><span class="line">for(int i&#x3D;0; i ＜ (posi&#x2F;BYTESIZE); i++)</span><br><span class="line">&#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">*p &#x3D; *p|(0x01＜＜(posi%BYTESIZE));&#x2F;&#x2F;将该Bit位赋值1</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void BitMapSortDemo()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;为了简单起见，我们不考虑负数</span><br><span class="line">int num[] &#x3D; &#123;3,5,2,10,6,12,8,14,9&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;BufferLen这个值是根据待排序的数据中最大值确定的</span><br><span class="line">&#x2F;&#x2F;待排序中的最大值是14，因此只需要2个Bytes(16个Bit)</span><br><span class="line">&#x2F;&#x2F;就可以了。</span><br><span class="line">const int BufferLen &#x3D; 2;</span><br><span class="line">char *pBuffer &#x3D; new char[BufferLen];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;要将所有的Bit位置为0，否则结果不可预知。</span><br><span class="line">memset(pBuffer,0,BufferLen);</span><br><span class="line">for(int i&#x3D;0;i＜9;i++)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;首先将相应Bit位上置为1</span><br><span class="line">SetBit(pBuffer,num[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;输出排序结果</span><br><span class="line">for(int i&#x3D;0;i＜BufferLen;i++)&#x2F;&#x2F;每次处理一个字节(Byte)</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;0;j＜BYTESIZE;j++)&#x2F;&#x2F;处理该字节中的每个Bit位</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;判断该位上是否是1，进行输出，这里的判断比较笨。</span><br><span class="line">&#x2F;&#x2F;首先得到该第j位的掩码（0x01＜＜j），将内存区中的</span><br><span class="line">&#x2F;&#x2F;位和此掩码作与操作。最后判断掩码是否和处理后的</span><br><span class="line">&#x2F;&#x2F;结果相同</span><br><span class="line">if((*pBuffer&amp;(0x01＜＜j)) &#x3D;&#x3D; (0x01＜＜j))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,i*BYTESIZE + j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pBuffer++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">BitMapSortDemo();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p><p>基本原理及要点<br>使用bit数组来表示某些元素是否存在，比如8位电话号码</p><p>扩展<br>Bloom filter可以看做是对bit-map的扩展（关于Bloom filter，请参见：海量数据处理之Bloom filter详解）。</p><p>问题实例<br>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</p><p>    8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）</p><p>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p><p>    将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p><p>参考：</p><p><a href="http://www.cnblogs.com/youwang/archive/2010/07/20/1781431.html%E3%80%82">http://www.cnblogs.com/youwang/archive/2010/07/20/1781431.html。</a><br><a href="http://blog.redfox66.com/post/2010/09/26/mass-data-4-bitmap.aspx%E3%80%82">http://blog.redfox66.com/post/2010/09/26/mass-data-4-bitmap.aspx。</a><br>完。</p><p>版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明.<br>原文链接：<a href="https://blog.csdn.net/v_july_v/article/details/6685962">https://blog.csdn.net/v_july_v/article/details/6685962</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大数据" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="大数据" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>支持亿级io底层基石epoll实战揭秘</title>
    <link href="http://example.com/posts/36817/"/>
    <id>http://example.com/posts/36817/</id>
    <published>2021-03-24T06:19:34.000Z</published>
    <updated>2021-03-24T11:18:47.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>绝大部分linux服务器，基本上会用到epoll.</p><h3 id="epoll是什么"><a href="#epoll是什么" class="headerlink" title="epoll是什么?"></a>epoll是什么?</h3><ol><li>io管理组件.</li><li>高性能.是select/poll的升级版本.</li><li>epoll用在什么地方?</li><li>和ntyco协程框架有什么关联?<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4>只要客户端对服务器进行一次tcp连接，就会产生一次io,如果十万个客户端同时对服务端建立连接，服务端就会产生十万socket，没连接一次就会产生一个io,就会产生十万个io,这时候就需要有个东西来管理它(十万个io)，(比如我怎么知道他来了数据呢?)<br>例子: 比如收快递用的蜂巢，当小哥把快递放到蜂巢，蜂巢就是统一管理快递的组件，所以说每个快递就好比一个io,蜂巢对应的就是管理io的组件,当蜂巢收到一个快递的时候，蜂巢就会通知用户来取这个快递，io的管理跟这个功能相似（io管理用来存fd的）.io多路复用，说明不只是你一个io，而是管理多个io.</li></ol><h4 id="epoll的产生-解决什么问题"><a href="#epoll的产生-解决什么问题" class="headerlink" title="epoll的产生(解决什么问题)"></a>epoll的产生(解决什么问题)</h4><p>如果没有多线程没有io管理，我们如何做一个服务器????</p><p>最初采用信号: 数据到达通过发送一个信号通知我们(这个信号-＞sigio现在还在沿用).性能极低，一两个客户端是没有问题的，一般用udp(因为udp以一个服务器为主)。</p><p>后来产生了线程:(几百个几千个服务端也是可用的，写代码非常简单)<br>    如果有线程没有io管理的情况该怎么做????<br>    一请求一线程: 当每一个accept来的时候(accept出现返回值的时候)就创建一个线程.当客户端退出的时候，这个线程也随之关闭，非常简单。每个线程读一个(是同步的).</p><p>有没有一些web服务器在用呢??<br>Apache服务器在用一请求一线程这种方式.</p><p>这种方式的弊端在哪里???<br>注定做不了很大的用户量，一个线程占用8MB的内存。吃内存.所以是不行的.</p><p>还有一种方式类似，是一请求一进程的方式:(叫做CGI)随着用户量多起来，并不好管理.</p><p>后续出现了select(io统一的管理)<br>select(maxfd. rset, wset, eset, timeout);</p><ol><li>maxfd表示最大的fd比如1,2,3,4,5 表示5, 比如2, 3, 4, 5, 6表示6.</li><li>rset是否可读</li><li>wset是否可写</li><li>eset是否有错误</li><li>timeout多长时间轮循一次.(多长时间检查一次)</li></ol><p>poll跟select类似。</p><p>现在来到了epoll跟蜂巢的概念一模一样的，</p><p>epoll真的能支持亿级并发吗?<br>epoll_creat(EPOLL_SIZE); EPOLL_SIZE只有零和一的区别，写10000也是和一同样的功能.<br>为零，表示什么用都没，不为零就能正常创建epoll.</p><p>epoll_wait(epoll_fd, events, EPOLL_SIZE, -1);<br>相当于蜂巢工作人员收快递，events相当于那个袋子,多长时间去一次，-1不是毫秒也不是啥，就不是一个准确的时间，表示有io才去取，没有io就一直阻塞.等于零表示一直没有，没有就直接过，如果大于零，随便一个数表示等待send.</p><p>水平触发和边沿触发问题????谁在什么时候触发????</p><p>触发: 是由tcp协议栈触发的,</p><ol><li>一次性触发。</li><li>一个事件没处理完一直触发.</li><li>对应的是水平触发: </li><li>对应的是边沿触发:<br>这里和长连接和短连接没有什么关系.</li></ol><p>问题: accept发生在epoll_wait之后吗?</p><p>当epoll_wait阻塞在一个地方的时候，如何解除阻塞的呢?<br>通过回调函数，协议栈通过epoll这个模块，通过调用回调函数来解除epoll_wait,这里tcp通过回调，这个回调叫做colback，回调到哪里呢?回调到epoll里边，来解除epoll_wait的阻塞状态.<br>所以上边的问题，是对的，只有epoll_wait被触发之后，才能进行数据的收取.这样才能判断fd是listen的还是我们程序本身的.</p><p>以下四种对epoll的做法都是不一样的，所以对应的方式也是不一样的.</p><ol><li>单线程可不可以做epoll? -&gt; redis.</li><li>多线程可不可以做epoll? -&gt; nattyserver(服务器的框架).</li><li>多核做epoll? -&gt; ntyco</li><li>多进程做epoll? -&gt; nginx</li></ol><p>redis单线程为何这么快?<br>redis:<br>    1. 纯内存的操作.(没有那些io,本身就很快).<F5><br>    2. 单线程是说的一个线程里边才有epoll,别的线程没有，也就是说没有线程之间的切换，加锁等操作.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++函数对象-sort排序规则</title>
    <link href="http://example.com/posts/53699/"/>
    <id>http://example.com/posts/53699/</id>
    <published>2021-03-23T03:21:48.000Z</published>
    <updated>2021-03-23T12:53:04.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="函数对象类由来"><a href="#函数对象类由来" class="headerlink" title="函数对象类由来"></a>函数对象类由来</h3><p>如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名.</p><p>函数对象的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class CAverage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    double operator()(int a1, int a2, int a3)</span><br><span class="line">    &#123;  &#x2F;&#x2F;重载()运算符</span><br><span class="line">        return (double)(a1 + a2 + a3) &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CAverage average;  &#x2F;&#x2F;能够求三个整数平均数的函数对象</span><br><span class="line">    cout &lt;&lt; average(3, 2, 3);  &#x2F;&#x2F;等价于 cout &lt;&lt; average.operator(3, 2, 3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">程序的输出结果是：</span><br><span class="line">2. 66667</span><br><span class="line"></span><br><span class="line">()是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</span><br><span class="line"></span><br><span class="line">average 是一个对象，average(3, 2, 3) 实际上就是 average.operator(3, 2, 3)，这使得 average 看上去像函数的名字，故称其为函数对象。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="函数对象应用实例1-在-accumulate-算法中的应用"><a href="#函数对象应用实例1-在-accumulate-算法中的应用" class="headerlink" title="函数对象应用实例1:在 accumulate 算法中的应用"></a>函数对象应用实例1:在 accumulate 算法中的应用</h3><p>STL 中有以下实现“累加”功能的算法(函数模板):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template &lt;class InIt, class T, class Pred&gt;</span><br><span class="line">T accumulate(InIt first, InIt last, T val, Pred op);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下：该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev C++ 中，numeric 头文件中 accumulate 的源代码如下:                                                                                                             </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class InIt, class T, class Pred&gt;</span><br><span class="line">T accumulate(InIt first, Init last, T init, Pred op)</span><br><span class="line">&#123;</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此模板被实例化后，op(init, *first)必须要有定义，则 op 只能是函数指针或者函数对象。因此调用该 accmulate 模板时，形参 op 对应的实参只能是函数名、函数指针或者函数对象。</p><p>下面的程序通过 accumulate 模板求一个 vector 中元素的平方和，其中用到了函数对象。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;numeric&gt; &#x2F;&#x2F;accumulate 在此头文件定义</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintInterval(T first, T last)</span><br><span class="line">&#123; &#x2F;&#x2F;输出区间[first,last)中的元素</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int SumSquares(int total, int value)</span><br><span class="line">&#123;</span><br><span class="line">    return total + value * value;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class SumPowers</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int power;</span><br><span class="line">public:</span><br><span class="line">    SumPowers(int p) :power(p) &#123; &#125;</span><br><span class="line">    const T operator() (const T &amp; total, const T &amp; value)</span><br><span class="line">    &#123; &#x2F;&#x2F;计算 value的power次方，加到total上</span><br><span class="line">        T v &#x3D; value;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; power - 1; ++i)</span><br><span class="line">            v &#x3D; v * value;</span><br><span class="line">        return total + v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int SIZE &#x3D; 10;</span><br><span class="line">    int a1[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;</span><br><span class="line">    vector&lt;int&gt; v(a1, a1 + SIZE);</span><br><span class="line">    cout &lt;&lt; &quot;1) &quot;; PrintInterval(v.begin(), v.end());</span><br><span class="line">    int result &#x3D; accumulate(v.begin(), v.end(), 0, SumSquares);</span><br><span class="line">    cout &lt;&lt; &quot;2) 平方和：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    result &#x3D; accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(3));</span><br><span class="line">    cout &lt;&lt; &quot;3) 立方和：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    result &#x3D; accumulate(v.begin(), v.end(), 0, SumPowers&lt;int&gt;(4));</span><br><span class="line">    cout &lt;&lt; &quot;4) 4次方和：&quot; &lt;&lt; result;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">1)1 2 3 4 5 6 7 8 9 10</span><br><span class="line">2)平方和:385</span><br><span class="line">3)立方和3025</span><br><span class="line">4)4次方和:25333</span><br></pre></td></tr></table></figure><p>上述函数的倒数第八行，第四个参数是 SumSquares 函数的名字。函数名字的类型是函数指针，因此本行将 accumulate 模板实例化后得到的模板函数定义如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int accumulate(vector &lt;int&gt;::iterator first, vector &lt;int&gt;::iterator last, int init, int(*op)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">for (; first !&#x3D; last; ++first)</span><br><span class="line">    init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure><p>形参 op 是一个函数指针，而op(init, *first)就调用了指针 op 指向的函数，在第 37 行的情况下就是函数 SumSquares。</p><p>第 39 行，第四个参数是 SumPowers<int>(3)。SumPowers 是类模板的名字，SumPowers<int> 就是类的名字。类的名字后面跟着构造函数的参数列表，就代表一个临时对象。因此 SumPowers<int>(3) 就是一个 SumPowers<int> 类的临时对象。</p><p>编译器在编译此行时，会将 accumulate 模板实例化成以下函数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int accumulate(vector&lt;int&gt;::iterator first, vector&lt;int&gt;::iterator last, int init, SumPowers&lt;int&gt; op)</span><br><span class="line">&#123;</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        init &#x3D; op(init, *first);</span><br><span class="line">    return init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参 op 是一个函数对象，而op(init, *first)等价于：<br>op.operator()(init, *first);</p><p>即调用了 SumPowers<int> 类的 operator() 成员函数。</p><p>对比 SumPowers 和 SumSquares 可以发现，函数对象的 operator() 成员函数可以根据对象内部的不同状态执行不同操作，而普通函数就无法做到这一点。因此函数对象的功能比普通函数更强大。</p><h3 id="函数对象应用实例2：在sort算法中的应用"><a href="#函数对象应用实例2：在sort算法中的应用" class="headerlink" title="函数对象应用实例2：在sort算法中的应用"></a>函数对象应用实例2：在sort算法中的应用</h3><p>STL 中的排序模板 sort 能将区间从小到大排序。sort 算法有两个版本。第一个版本的原型如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class_Randlt&gt;</span><br><span class="line">void sort(_Randlt first, _RandIt last);</span><br></pre></td></tr></table></figure><p>该模板可以用来将区间 [first, last) 中的元素从小到大排序，要求 first、last 是随机访问迭代器。元素比较大小是用&lt;进行的。如果表达式a&lt;b的值为 true，则 a 排在 b 前面；如果a&lt;b的值为 false，则 b 未必排在 a 前面，还要看b&lt;a是否成立，成立的话 b 才排在 a 前面。要使用这个版本的 sort 算法，待排序的对象必须能用&lt;运算符进行比较。</p><p>sort 算法第二个版本的原型如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class_Randlt, class Pred&gt;</span><br><span class="line">void sort(_Randlt first, _RandIt last, Pred op);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个版本和第一个版本的差别在于，元素 a、b 比较大小是通过表达式op(a, b)进行的。如果该表达式的值为 true，则 a 比 b 小；如果该表达式的值为 false，也不能认为 b 比 a 小，还要看op(b, a)的值。总之，op 定义了元素比较大小的规则。下面是一个使用 sort 算法的例子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;  &#x2F;&#x2F;sort算法在此头文件中定义</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Printlnterva1(T first, T last)</span><br><span class="line">&#123;  &#x2F;&#x2F;用以输出 [first, last) 区间中的元素</span><br><span class="line">    for (; first !&#x3D; last; ++first)</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int v;</span><br><span class="line">    A(int n) : v(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool operator &lt; (const A &amp; a1, const A &amp; a2)</span><br><span class="line">&#123;  &#x2F;&#x2F;重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错</span><br><span class="line">    return a1.v &lt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line">bool GreaterA(const A &amp; a1, const A &amp; a2)</span><br><span class="line">&#123;  &#x2F;&#x2F;v值大的元素作为较小的数</span><br><span class="line">    return a1.v &gt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line">struct LessA</span><br><span class="line">&#123;</span><br><span class="line">    bool operator() (const A &amp; a1, const A &amp; a2)</span><br><span class="line">    &#123;  &#x2F;&#x2F;v的个位数小的元素就作为较小的数</span><br><span class="line">        return (a1.v % 10) &lt; (a2.v % 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; operator &lt;&lt; (ostream &amp; o, const A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    o &lt;&lt; a.v;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a1[4] &#x3D; &#123; 5, 2, 4, 1 &#125;;</span><br><span class="line">    A a2[5] &#x3D; &#123; 13, 12, 9, 8, 16 &#125;;</span><br><span class="line">    sort(a1, a1 + 4);</span><br><span class="line">    cout &lt;&lt; &quot;1)&quot;; Printlnterva1(a1, a1 + 4);  &#x2F;&#x2F;输出 1)1 2 4 5</span><br><span class="line">    sort(a2, a2 + 5);  &#x2F;&#x2F;按v的值从小到大排序</span><br><span class="line">    cout &lt;&lt; &quot;2)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 2)8 9 12 13 16</span><br><span class="line">    sort(a2, a2 + 5, GreaterA);  &#x2F;&#x2F;按v的值从大到小排序</span><br><span class="line">    cout &lt;&lt; &quot;3)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 3)16 13 12 9 8</span><br><span class="line">    sort(a2, a2 + 5, LessA());  &#x2F;&#x2F;按v的个位数从小到大排序</span><br><span class="line">    cout &lt;&lt; &quot;4)&quot;; Printlnterva1(a2, a2 + 5);  &#x2F;&#x2F;输出 4)12 13 16 8 9</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译至第 45 行时，编译器将 sort 实例化得到的函数原型如下：<br>void sort(A* first, A* last, bool (*op)(const A &amp;, const A &amp;) );</p><p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中 op 指向 GreaterA,因此就用 GreaterA 定义的规则来比较大小。</p><p>编译至第 47 行时，编译器将 sort 实例化得到的函数原型如下：<br>void sort( A* first, A* last, LessA op);</p><p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中，op(a, b) 等价于 op.opeartor(a, b)，因此就用 LessA 定义的规则来比较大小。</p><p>STL 中定义了一些函数对象类模板，都位于头文件 functional 中。例如，greater 模板的源代码如下：<br>template <class T><br>struct greater<br>{<br>    bool operator()(const T&amp; x, const T&amp; y) const{<br>        return x &gt; y;<br>    }<br>};<br>假设有以下数组：<br>int a[4] = {3, 5, 34, 8};</p><p>要将该数组从大到小排序，则只需写：<br>sort( a, a+4, greater<int>() );</p><p>要使用 greater 模板，须确保&gt;运算符本来就有定义，或经过了适当的重载。</p><p>list 容器的 sort 成员能将元素从小到大排序。它也有两个版本：一个是没有参数的函数，比较大小用&lt;运算符；另一个是函数模板，原型如下：<br>template <class Pred><br>void sort(Pred op);</p><p>sort 函数允许自定义比较大小的规则，即 op(x, y) 为真就认为 x 比 y 小。例如，假设有：<br>list<int> lst;</p><p>如果希望将 lst 中的元素按其整数数值从大到小排序，只需写：<br>lst.sort( greater<int>() );</p><p>在使用关联容器和许多算法时，都可以用函数对象来定义比较大小的规则，以及其他一些规则和操作。</p><h3 id="STL-中的函数对象类模板"><a href="#STL-中的函数对象类模板" class="headerlink" title="STL 中的函数对象类模板"></a>STL 中的函数对象类模板</h3><p>函数对象类模板    成员函数 T operator ( const T &amp; x, const T &amp; y) 的功能<br>plus <T>    return x + y;<br>minus &lt; &gt;    return x - y;<br>multiplies <T>    return x * y;<br>divides <T>    return x / y;<br>modulus <T>    return x % y;<br>     成员函数 bool operator( const T &amp; x, const T &amp; y) 的功能<br>equal_to <T>    return x == y;<br>not_equal_to <T>    return x! = y;<br>greater <T>    return x &gt; y;<br>less <T>    return x &lt; y;<br>greater_equal <T>    return x &gt; = y;<br>less_equal <T>    return x &lt;= y;<br>logical_and <T>    return x &amp;&amp; y;<br>logical_or <T>    return x || y;<br>     成员函数 T operator( const T &amp; x) 的功能<br>negate <T>    return - x;<br>     成员函数 bool operator( const T &amp; x) 的功能<br>logical_not <T>    return ! x;<br>例如，如果要求两个 double 型变量 x、y 的乘积，可以写：<br>multiplies<double> () (x, y)</p><p>less 是 STL 中最常用的函数对象类模板，其定义如下：<br>template <class_Tp><br>struct less<br>{<br>    bool operator() (const_Tp &amp; __x, const_Tp &amp; __y) const<br>    { return __x &lt; __y; }<br>};<br>要判断两个 int 变量 x、y 中 x 是否比 y 小，可以写：<br>if( less<int>()(x, y) ) { … }</p><p>引入函数对象后 STL 中的“大”、“小”和“相等”概念<br>前面提到过，默认情况下，STL 中的容器和算法比较元素的大小是通过&lt;运算符进行的。通过 10.3.4 节可知，sort 和 list::sort 都可以通过一个函数对象或函数自定义比较元素大小的规则。例如以下的 sort 版本：<br>template &lt;class_RandIt, class Pred&gt;<br>void sort(_RandIt first, _RandIt last, Pred op);</p><p>实际调用 sort 时，和 op 对应的实参可以是一个函数对象或者函数的名字。sort 在执行过程中用 op(x, y) 比较 x 和 y 的大小，因此可以将 op 称为自定义的“比较器”。</p><p>关联容器中的元素是从小到大排序的。使用关联容器时，也可以用自定义的比较器取代&lt;运算符，以规定元素之间的大小关系。STL 中还有许多算法都可以自定义比较器。在自定义比较器 op 的情况下，以下三种说法是等价的：<br>x 小于 y。<br>op(x, y) 的返回值为 true。<br>y 大于 x。</p><p>重点:<br>经过自己的测试，每两个数要比较两次<br>A 与 B 比较 return true 说明A比B小 A 排在B的前面<br>B 与 A 比较 return true 说明B比A小 B 排在A的前面<br>so 这就是问题 到底是A大还是B大？？</p><p>我以前一直这样记忆：<br>return true ==== 说明第一个参数排在第二个参数前面<br>return false ==== 说明第一个参数排在第二个参数后面<br>其实这样记忆没有错 but<br>sort函数的潜规则就是：<br>如果两个数相等 必须返回false<br>————————————————</p><h3 id="STL-sort-函数实现详解"><a href="#STL-sort-函数实现详解" class="headerlink" title="STL sort 函数实现详解"></a>STL sort 函数实现详解</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>#include <algorithm></p><p>template&lt; class RandomIt &gt;<br>void sort( RandomIt first, RandomIt last );</p><p>template&lt; class RandomIt, class Compare &gt;<br>void sort( RandomIt first, RandomIt last, Compare comp );<br>使用方法非常简单，STL提供了两种调用方式，一种是使用默认的&lt;操作符比较，一种可以自定义比较函数。可是为什么它通常比我们自己写的排序要快那么多呢？</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>原来，STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。</p><p>普通的快速排序<br>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p><p>如果S中的元素只有0个或1个，结束。<br>取S中的任何一个元素作为枢轴pivot。<br>将S分割为L、R两端，使L内的元素都小于等于pivot，R内的元素都大于等于pivot。<br>对L、R递归执行上述过程。<br>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称为median-of-three，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p><p>分割的方法通常采用两个迭代器head和tail，head从头端往尾端移动，tail从尾端往头端移动，当head遇到大于等于pivot的元素就停下来，tail遇到小于等于pivot的元素也停下来，若head迭代器仍然小于tail迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p><p>看一张来自维基百科上关于快速排序的动态图片，帮助理解。</p><p>内省式排序 Introsort<br>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 O(n2)。David R.Musser于1996年提出一种混合式排序算法：Introspective Sorting（内省式排序），简称IntroSort，其行为大部分与上面所说的median-of-three Quick Sort完全相同，但是当分割行为有恶化为二次方的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 O(nlgn)，又比一开始就使用堆排序来得好。</p><p>代码分析<br>下面是完整的SGI STL sort()源码（使用默认&lt;操作符版）</p><p>template <class _RandomAccessIter><br>inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {<br>  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);<br>  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,<br>                 _LessThanComparable);<br>  if (__first != __last) {<br>    __introsort_loop(__first, __last,<br>                     __VALUE_TYPE(__first),<br>                     __lg(__last - __first) * 2);<br>    __final_insertion_sort(__first, __last);<br>  }<br>}<br>其中，__introsort_loop便是上面介绍的内省式排序，其第三个参数中所调用的函数__lg()便是用来控制分割恶化情况，代码如下：</p><p>template <class Size><br>inline Size __lg(Size n) {<br>    Size k;<br>    for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;<br>    return k;<br>}<br>即求lg(n)（取下整），意味着快速排序的递归调用最多 2*lg(n) 层。</p><p>内省式排序算法如下：</p><p>template &lt;class _RandomAccessIter, class _Tp, class _Size&gt;<br>void __introsort_loop(_RandomAccessIter __first,<br>                      _RandomAccessIter __last, _Tp*,<br>                      _Size __depth_limit)<br>{<br>  while (__last - __first &gt; __stl_threshold) {<br>    if (__depth_limit == 0) {<br>      partial_sort(__first, __last, __last);<br>      return;<br>    }<br>    –__depth_limit;<br>    _RandomAccessIter __cut =<br>      __unguarded_partition(__first, __last,<br>                            _Tp(__median(*__first,<br>                                         <em>(__first + (__last - __first)/2),<br>                                         *(__last - 1))));<br>    __introsort_loop(__cut, __last, (_Tp</em>) 0, __depth_limit);<br>    __last = __cut;<br>  }<br>}</p><ol><li>首先判断元素规模是否大于阀值__stl_threshold，__stl_threshold是一个常整形的全局变量，值为16，表示若元素规模小于等于16，则结束内省式排序算法，返回sort函数，改用插入排序。</li><li>若元素规模大于__stl_threshold，则判断递归调用深度是否超过限制。若已经到达最大限制层次的递归调用，则改用堆排序。代码中的partial_sort即用堆排序实现。</li><li>若没有超过递归调用深度，则调用函数__unguarded_partition()对当前元素做一趟快速排序，并返回枢轴位置。__unguarded_partition()函数采用的便是上面所讲的使用两个迭代器的方法，代码如下：<br>template &lt;class _RandomAccessIter, class _Tp&gt;<br>_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, <pre><code>                                 _RandomAccessIter __last,                                  _Tp __pivot) </code></pre>{<br> while (true) {<pre><code> while (*__first &lt; __pivot)     ++__first; --__last; while (__pivot &lt; *__last)     --__last; if (!(__first &lt; __last))     return __first; iter_swap(__first, __last); ++__first;</code></pre> }<br>}</li><li>经过一趟快速排序后，再递归对右半部分调用内省式排序算法。然后回到while循环，对左半部分进行排序。源码写法和我们一般的写法不同，但原理是一样的，需要注意。<br>递归上述过程，直到元素规模小于__stl_threshold，然后返回sort函数，对整个元素序列调用一次插入排序，此时序列中的元素已基本有序，所以插入排序也很快。至此，整个sort函数运行结束。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lambda</title>
    <link href="http://example.com/posts/65250/"/>
    <id>http://example.com/posts/65250/</id>
    <published>2021-03-21T06:53:13.000Z</published>
    <updated>2021-03-21T08:03:48.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="由来（要解决什么问题）"><a href="#由来（要解决什么问题）" class="headerlink" title="由来（要解决什么问题）"></a>由来（要解决什么问题）</h3><p>使用STL时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。<br>对于只使用一次的函数对象类，能否直接在使用它的地方定义呢？Lambda表达式能够解决这个问题。使用Lambda表达式可以减少程序中函数对象类的数量，使得程序更加优雅。</p><h3 id="lambda表达式的定义形式如下"><a href="#lambda表达式的定义形式如下" class="headerlink" title="lambda表达式的定义形式如下"></a>lambda表达式的定义形式如下</h3><p>[部变量访问方式说明符] (参数表) -&gt; 返回值类型<br>{<br>   语句块<br>}</p><p>下面是一个合法的Lambda表达式：<br>[=] (int x, int y) -&gt; bool {return x%10 ＜ y%10;}</p><p>Lambda 表达式实际上是一个函数，只是它没有名字。下面的程序段使用了上面的 Lambda 表达式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[4] &#x3D; &#123;11, 2, 33, 4&#125;;</span><br><span class="line">sort(a, a+4, [&#x3D;](int x, int y) -&gt; bool &#123; return x%10 &lt; y%10; &#125; ); &#x2F;&#x2F; 带-&gt;函数返回值的</span><br><span class="line">for_each(a, a+4, [&#x3D;](int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125; ); &#x2F;&#x2F; 省略-&gt;函数返回值的。</span><br><span class="line"></span><br><span class="line">这段程的输出结果是：</span><br><span class="line">11 2 33 4</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ol><li>程序第 2 行使得数组 a 按个位数从小到大排序。具体的原理是：sort 在执行过程中，需要判断两个元素 x、y 的大小时，会以 x、y 作为参数，调用 Lambda 表达式所代表的函数，并根据返回值来判断 x、y 的大小。这样，就不用专门编写一个函数对象类了。这里的外部传入的x， y<br>不能被改变，否则编译报错的.</li><li>for_each 的第 3 个参数是一个 Lambda 表达式。for_each 执行过程中会依次以每个元素作为参数调用它，因此每个元素都被输出。这里的x也不允许被改变的.</li></ol><h4 id="外部变量访问方式说明符"><a href="#外部变量访问方式说明符" class="headerlink" title="[外部变量访问方式说明符]"></a>[外部变量访问方式说明符]</h4><p>外部变量: 一般指定义在{}作用域外边的变量，参数的话跟正常函数一样，传引用和传值的区别.<br>“外部变量访问方式说明符”可以是=或&amp;，表示{}中用到的、定义在{}外面的变量在{}中是否允许被改变。=表示不允许，&amp;表示允许。当然，在{}中也可以不使用定义在外面的变量。</p><p>实际上，“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。例如：</p><ol><li>[=, &amp;x, &amp;y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；</li><li>[&amp;, x, y]表示除 x、y 以外的外部变量，值都可以被修改。</li></ol><h4 id="参数表"><a href="#参数表" class="headerlink" title="(参数表)"></a>(参数表)</h4><p>跟普通的函数参数的形式一样。</p><h4 id="gt-返回值类型"><a href="#gt-返回值类型" class="headerlink" title="-&gt;返回值类型"></a>-&gt;返回值类型</h4><p>“-&gt; 返回值类型”可以省略。</p><h4 id="语句块"><a href="#语句块" class="headerlink" title="{语句块}"></a>{语句块}</h4><p>正常函数书写形式一样。</p><h4 id="用到外部变量-外部变量改变"><a href="#用到外部变量-外部变量改变" class="headerlink" title="用到外部变量(外部变量改变)"></a>用到外部变量(外部变量改变)</h4><p>程序</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[4] &#x3D; &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">    int total &#x3D; 0;</span><br><span class="line">    for_each(a, a + 4, [&amp;](int &amp; x) &#123; total +&#x3D; x; x *&#x3D; 2; &#125;);</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; endl;  &#x2F;&#x2F;输出 10</span><br><span class="line">    for_each(a, a + 4, [&#x3D;](int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">10</span><br><span class="line">2 4 6 8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[&amp;]表示该 Lambda 表达式中用到的外部变量 total 是传引用的，其值可以在表达式执行过程中被改变（如果使用[=]，编译无法通过）。该 Lambda 表达式每次被 for_each 执行时，都将 a 中的一个元素累加到 total 上，然后将该元素加倍。</p><h4 id="最终程序"><a href="#最终程序" class="headerlink" title="最终程序"></a>最终程序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;   </span><br><span class="line">    int x &#x3D; 100,y&#x3D;200,z&#x3D;300;</span><br><span class="line">    auto ff  &#x3D; [&#x3D;,&amp;y,&amp;z](int n) &#123;</span><br><span class="line">        cout &lt;&lt;x &lt;&lt; endl;</span><br><span class="line">        y++; z++;</span><br><span class="line">        return n*n;</span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; ff(15) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; &quot;,&quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的输出结果如下：</span><br><span class="line">100</span><br><span class="line">225</span><br><span class="line">201, 301</span><br></pre></td></tr></table></figure><p>定义了一个变量 ff，ff 的类型是 auto，表示由编译器自动判断其类型（这也是 C++11 的新特性）。本行将一个 Lambda 表达式赋值给 ff，以后就可以通过 ff 来调用该 Lambda 表达式了。<br>通过 ff，以 15 作为参数 n 调用上面的 Lambda 表达式。该 Lambda 表达式指明，对于外部变量 y、z，可以修改其值；对于其他外部变量，例如 x，不能修改其值。因此在该表达式执行时，可以修改外部变量 y、z 的值，但如果出现试图修改 x 值的语句，就会编译出错。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++" scheme="http://example.com/categories/c/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>algorithm-实现</title>
    <link href="http://example.com/posts/4524/"/>
    <id>http://example.com/posts/4524/</id>
    <published>2020-12-31T06:56:51.000Z</published>
    <updated>2021-01-25T12:13:38.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STL库剖析</title>
    <link href="http://example.com/posts/4515/"/>
    <id>http://example.com/posts/4515/</id>
    <published>2020-12-31T05:07:27.000Z</published>
    <updated>2021-01-25T12:13:38.777Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cnblogs.com/Rane/p/12635027.html">先参考网站</a></p><h3 id="STL标准模板类库"><a href="#STL标准模板类库" class="headerlink" title="STL标准模板类库"></a>STL标准模板类库</h3><p>分为三部分:<br>    1. 容器: 对数据结构的封装<br>    2. 算法:<br>    3. 迭代器</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="STL库" scheme="http://example.com/categories/STL%E5%BA%93/"/>
    
    
    <category term="STL库" scheme="http://example.com/tags/STL%E5%BA%93/"/>
    
  </entry>
  
</feed>

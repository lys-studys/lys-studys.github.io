<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌上花开缓缓归</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-30T15:26:15.988Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lys-studys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql</title>
    <link href="http://example.com/posts/16097/"/>
    <id>http://example.com/posts/16097/</id>
    <published>2020-10-27T05:25:31.000Z</published>
    <updated>2020-10-30T15:26:15.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/203622688">大佬笔记入口</a><br><a href="https://www.nowcoder.com/discuss/389444">同上</a></p><h3 id="1-事务四大特性"><a href="#1-事务四大特性" class="headerlink" title="1.事务四大特性"></a>1.事务四大特性</h3><p>事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</p><ol><li><p>原子性:<br>最小的执行单元： 要么全执行，要么全不执行</p></li><li><p>隔离性：<br>所有操作全部执行完以前其它会话不能看到过程</p></li><li><p>一致性：<br>事务前后，数据总额一致</p></li><li><p>持久性:<br> 一旦事务提交，对数据的改变就是永久的</p></li></ol><h3 id="隔离操作"><a href="#隔离操作" class="headerlink" title="隔离操作"></a>隔离操作</h3><h4 id="并行事物的四大问题"><a href="#并行事物的四大问题" class="headerlink" title="并行事物的四大问题"></a>并行事物的四大问题</h4><ol><li><p>更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）</p></li><li><p>脏读：读到别的事务未提交的数据。（万一回滚，数据就是脏的无效的了）</p></li><li><p>不可重复读：两次读之间有别的事务修改。</p></li><li><p>幻读：两次读之间有别的事务增删。</p><h4 id="对应隔离级别"><a href="#对应隔离级别" class="headerlink" title="对应隔离级别"></a>对应隔离级别</h4></li><li><p>READ UNCOMMITTED：读未提交，不处理。</p></li><li><p>READ COMMITTED：读已提交，只读提交的数据，无脏读；</p></li><li><p>REPEATABLE READ：可重复读，加行锁，两次读之间不会有修改，无脏读无重复读；</p></li><li><p>SERIALIZABLE: 串行化，加表锁，全部串行，无所有问题。<br>详细解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. READ UNCIMMITTED（未提交读）</span><br><span class="line">　　      事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读。</span><br><span class="line"></span><br><span class="line">2. READ COMMITTED（提交读）</span><br><span class="line">　　      首先大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象</span><br><span class="line"></span><br><span class="line">3. REPEATABLE READ（可重复读）</span><br><span class="line"> 　　     REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻行，顾名思义就是突然蹦出来的行数据。</span><br><span class="line">          指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。</span><br><span class="line"></span><br><span class="line">4. SERIALIZABLE（可串行化）</span><br><span class="line">          　　      SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，</span><br><span class="line">                   因此性能会比较低下，在需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四中隔离原理"><a href="#四中隔离原理" class="headerlink" title="四中隔离原理"></a>四中隔离原理</h4></li><li><p>READ_UNCOMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据不加锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。</span><br><span class="line">下面分别对应上面1，2产生的表现：</span><br><span class="line"></span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>READ_COMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>REPEATABLE READ 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1，事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SERIALIZABLE 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</span><br><span class="line">2，事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line">2，事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="数据库涉及的锁"><a href="#数据库涉及的锁" class="headerlink" title="数据库涉及的锁"></a>数据库涉及的锁</h4><p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，<br>MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）。<br>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。<br>所有的锁都是绑定在数据库的索引机制上的！！！</p><p>首先锁可以分为： </p><ol><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ol><p>而除了粒度，锁根据模式分为：</p><ol><li><p>共享锁(S)：发生在数据查找之前，多个事务的共享锁之间可以共存</p></li><li><p>排他锁(X)：发生在数据更新之前，排他锁是一个独占锁，与其他锁都不兼容</p></li><li><p>更新锁(U)：发生在更新语句中，更新锁用来查找数据，当查找的数据不是要更新的数据时转化为S锁，当是要更新的数据时转化为X锁</p></li><li><p>意向锁：发生在较低粒度级别的资源获取之前，表示对该资源下低粒度的资源添加对应的锁，意向锁有分为：<br>　　　　意向共享锁(IS) ，意向排他锁(IX)，意向更新锁(IU)，共享意向排他锁(SIX)，共享意向更新锁(SIU)，更新意向排他锁(UIX)</p></li></ol><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><ol><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ol><p>共享锁／排他锁／更新锁一般作用在较低级别上，例如数据行或数据页，意向锁一般作用在较高的级别上，例如数据表或数据。锁是有层级结构的，若在数据行上持有排他锁的时候，则会在所在的数据页上持有意向排他锁. 在一个事务中，可能由于锁持有的时间太长或个数太多，出于节约资源的考虑，会造成锁升级；</p><p>我理解的就以最后一个SERIALIZABLE来说，开始时是设置的表级共享锁，分为表级别的而且是共享锁，表级别就是作用于整个表，不是行级别！而共享锁，则说明了其他事务也是共享锁的情况下可以共享这个表！虽然仅限于读，但这样也可能存在脏读等情况的存在，而如果换成表级排它锁，那么第一个事务在使用了这个锁之后，那其他事务连这个表的读的权限也没有，从根本上避免了各种可能的问题。</p><h5 id="各个索引引擎的情况"><a href="#各个索引引擎的情况" class="headerlink" title="各个索引引擎的情况"></a>各个索引引擎的情况</h5><ol><li><p>InnoDB（MySQL默认存储引擎 从版本5.5.5开始）<br>支持事务，行级锁，以及外键，拥有高并发处理能力。但是在创建索引和加载数据时，比MyISAM慢。默认的隔离级别是Repeatable Read（可重复读）</p></li><li><p>MyISAM<br>不支持事务和行级锁。所以速度很快，性能优秀。可以对整张表加锁，支持并发插入，支持全文索引。</p></li><li><p>MEMORY<br>支持Hash索引，内存表，Memory引擎将数据存储在内存中，表结构不是存储在内存中的，查询时不需要执行磁盘I/O操作，所以要比MyISAM和InnoDB快很多倍，<br>但是数据库断电或是重启后，表中的数据将会丢失，表结构不会丢失。</p></li></ol><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h4><p>在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，乐观锁和悲观锁，可以在一定程度上解决并发访问。</p><h4 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h4><p>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>其他知识点</p><p>悲观锁主要是共享锁或排他锁<br>共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><h4 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h4><p>是应用系统层面和数据的业务逻辑层次上的（实际上并没有加锁，只是一种锁思想），利用程序处理并发， 它假定当某一个用户去读取某一个数据的时候，其他的用户不会来访问修改这个数据，但是在最后进行事务的提交的时候会进行数据的检查，以判断在该用户的操作过程中，没有其他用户修改了这个数据。乐观锁的实现大部分都是基于版本控制实现的， 除此之外，还有CAS操作实现</p><p>其他知识点</p><p>实现乐观锁一般来说有以下2种方式：</p><p>使用版本号<br>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><p>使用时间戳<br>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p><h4 id="悲观锁与乐观锁区别与联系？"><a href="#悲观锁与乐观锁区别与联系？" class="headerlink" title="悲观锁与乐观锁区别与联系？"></a>悲观锁与乐观锁区别与联系？</h4><h4 id="悲观锁与乐观锁的使用场景？"><a href="#悲观锁与乐观锁的使用场景？" class="headerlink" title="悲观锁与乐观锁的使用场景？"></a>悲观锁与乐观锁的使用场景？</h4><p>悲观锁</p><p>比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p><p>乐观锁</p><p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p><h3 id="innodbe-和-myisim掌握"><a href="#innodbe-和-myisim掌握" class="headerlink" title="innodbe 和 myisim掌握"></a>innodbe 和 myisim掌握</h3><h3 id="三个特性-双次写，插入缓存，自适应"><a href="#三个特性-双次写，插入缓存，自适应" class="headerlink" title="三个特性(双次写，插入缓存，自适应)"></a>三个特性(双次写，插入缓存，自适应)</h3><p>InnoDB存储引擎的关键特性包括插入缓冲、两次写（double write）、自适应哈希索引（adaptive hash index）。这些特性为InnoDB存储引擎带来了更好的性能和更高的可靠性。</p><p><a href="https://blog.csdn.net/ilovemilk/article/details/80024789">详细解释跳转</a></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="mvcc-乐观锁，悲观锁"><a href="#mvcc-乐观锁，悲观锁" class="headerlink" title="mvcc(乐观锁，悲观锁)"></a>mvcc(乐观锁，悲观锁)</h4><h4 id="行锁-行锁，零件锁，间隙锁"><a href="#行锁-行锁，零件锁，间隙锁" class="headerlink" title="行锁(行锁，零件锁，间隙锁)"></a>行锁(行锁，零件锁，间隙锁)</h4><h4 id="表锁mZ"><a href="#表锁mZ" class="headerlink" title="表锁mZ"></a>表锁mZ</h4><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="数据结构（B-树，B树，Hash索引，全文本索引）"><a href="#数据结构（B-树，B树，Hash索引，全文本索引）" class="headerlink" title="数据结构（B+树，B树，Hash索引，全文本索引）"></a>数据结构（B+树，B树，Hash索引，全文本索引）</h4><h4 id="逻辑索引-主键，唯一，前缀，覆盖，联合，普通"><a href="#逻辑索引-主键，唯一，前缀，覆盖，联合，普通" class="headerlink" title="逻辑索引(主键，唯一，前缀，覆盖，联合，普通)"></a>逻辑索引(主键，唯一，前缀，覆盖，联合，普通)</h4><h4 id="存储结构-聚集索引-innodbe-排序索引-myisim"><a href="#存储结构-聚集索引-innodbe-排序索引-myisim" class="headerlink" title="存储结构(聚集索引(innodbe),排序索引(myisim))"></a>存储结构(聚集索引(innodbe),排序索引(myisim))</h4><h4 id="索引失效，索引优化，索引下推，索引回表．"><a href="#索引失效，索引优化，索引下推，索引回表．" class="headerlink" title="索引失效，索引优化，索引下推，索引回表．"></a>索引失效，索引优化，索引下推，索引回表．</h4><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h3 id="分区分库分表，主从复制．"><a href="#分区分库分表，主从复制．" class="headerlink" title="分区分库分表，主从复制．"></a>分区分库分表，主从复制．</h3><h3 id="2-数据库隔离级别"><a href="#2-数据库隔离级别" class="headerlink" title="2.数据库隔离级别"></a>2.数据库隔离级别</h3><h3 id="3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"><a href="#3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景" class="headerlink" title="3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"></a>3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</h3><h3 id="4-索引有B-索引和hash索引"><a href="#4-索引有B-索引和hash索引" class="headerlink" title="4.索引有B+索引和hash索引"></a>4.索引有B+索引和hash索引</h3><h3 id="5-聚集索引和非聚集索引"><a href="#5-聚集索引和非聚集索引" class="headerlink" title="5.聚集索引和非聚集索引"></a>5.聚集索引和非聚集索引</h3><h3 id="6-索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#6-索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="6.索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>6.索引的优缺点，什么时候使用索引，什么时候不能使用索引</h3><h3 id="7-InnoDB索引和MyISAM索引的区别"><a href="#7-InnoDB索引和MyISAM索引的区别" class="headerlink" title="7.InnoDB索引和MyISAM索引的区别"></a>7.InnoDB索引和MyISAM索引的区别</h3><h3 id="8-索引的底层实现（B-树，为何不采用红黑树，B树）重点"><a href="#8-索引的底层实现（B-树，为何不采用红黑树，B树）重点" class="headerlink" title="8.索引的底层实现（B+树，为何不采用红黑树，B树）重点"></a>8.索引的底层实现（B+树，为何不采用红黑树，B树）重点</h3><h3 id="9-B-树的实现"><a href="#9-B-树的实现" class="headerlink" title="9.B+树的实现"></a>9.B+树的实现</h3><h3 id="10-为什么使用B-Tree"><a href="#10-为什么使用B-Tree" class="headerlink" title="10.为什么使用B+Tree"></a>10.为什么使用B+Tree</h3><h3 id="11-Sql的优化"><a href="#11-Sql的优化" class="headerlink" title="11.Sql的优化"></a>11.Sql的优化</h3><h3 id="12-索引最左前缀问题"><a href="#12-索引最左前缀问题" class="headerlink" title="12.索引最左前缀问题"></a>12.索引最左前缀问题</h3><h3 id="13-索引分类，索引失效条件"><a href="#13-索引分类，索引失效条件" class="headerlink" title="13.索引分类，索引失效条件"></a>13.索引分类，索引失效条件</h3><h3 id="14-数据库的主从复制"><a href="#14-数据库的主从复制" class="headerlink" title="14.数据库的主从复制"></a>14.数据库的主从复制</h3><h3 id="15-long-query怎么解决"><a href="#15-long-query怎么解决" class="headerlink" title="15.long_query怎么解决"></a>15.long_query怎么解决</h3><h3 id="16-varchar和char的使用场景"><a href="#16-varchar和char的使用场景" class="headerlink" title="16.varchar和char的使用场景"></a>16.varchar和char的使用场景</h3><h3 id="17-数据库连接池的作用"><a href="#17-数据库连接池的作用" class="headerlink" title="17.数据库连接池的作用"></a>17.数据库连接池的作用</h3><h3 id="19-分库分表，主从复制，读写分离"><a href="#19-分库分表，主从复制，读写分离" class="headerlink" title="19.分库分表，主从复制，读写分离"></a>19.分库分表，主从复制，读写分离</h3><h3 id="20-数据库三范式"><a href="#20-数据库三范式" class="headerlink" title="20.数据库三范式"></a>20.数据库三范式</h3><h3 id="21-关系型数据库和非关系型数据库区别"><a href="#21-关系型数据库和非关系型数据库区别" class="headerlink" title="21.关系型数据库和非关系型数据库区别"></a>21.关系型数据库和非关系型数据库区别</h3><h3 id="22-数据库中join的left-join-inner-join-cross-join"><a href="#22-数据库中join的left-join-inner-join-cross-join" class="headerlink" title="22.数据库中join的left join , inner join, cross join"></a>22.数据库中join的left join , inner join, cross join</h3><h3 id="23-有哪些锁-select时怎么加排它锁"><a href="#23-有哪些锁-select时怎么加排它锁" class="headerlink" title="23.有哪些锁,select时怎么加排它锁"></a>23.有哪些锁,select时怎么加排它锁</h3><h3 id="24-死锁怎么解决"><a href="#24-死锁怎么解决" class="headerlink" title="24.死锁怎么解决"></a>24.死锁怎么解决</h3><h3 id="25-最左匹配原则"><a href="#25-最左匹配原则" class="headerlink" title="25.最左匹配原则"></a>25.最左匹配原则</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="经典题" scheme="http://example.com/categories/%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>balance-tree</title>
    <link href="http://example.com/posts/26821/"/>
    <id>http://example.com/posts/26821/</id>
    <published>2020-10-24T06:06:20.000Z</published>
    <updated>2020-10-27T02:06:58.973Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在绝望的时候才会尽最大的努力!</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B_tree"></a>B_tree</h3><p>全名为balance_tree(平衡多路查找树)，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而B_tree有多条路，即父节点有多个子节点。</p><h4 id="B-树用途"><a href="#B-树用途" class="headerlink" title="B-树用途"></a>B-树用途</h4><p>使用B_tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。</p><h4 id="B-tree定义及结构"><a href="#B-tree定义及结构" class="headerlink" title="B_tree定义及结构"></a>B_tree定义及结构</h4><h4 id="B-tree定义"><a href="#B-tree定义" class="headerlink" title="B_tree定义"></a>B_tree定义</h4><ol><li>树中每个节点至多有m棵子树(m表示树的阶数)</li><li>根前节点不是叶子节点,则至少有两棵子树(根节点必须俩儿子).</li><li>除根节点之外的所有非叶子节点至少有p个子节点([m/2] &lt;= p &lt;= m,[m/2]向上取整).或者[(m+1)/2].</li><li>所有的非叶子结点中包含以下数据：（n，A0，K1，A1，K2，…，Kn，An）<br>其中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ki（i&#x3D;1,2,…,n）为关键码，且Ki&lt;Ki+1（注：ki是真实数据，存放在线性表当中，且从左至右升序排列）</span><br><span class="line"></span><br><span class="line">Ai 为指向儿子的指针(i&#x3D;0,1,…,n)，且指针Ai-1 所指子树中所有结点的关键码均小于Ki (i&#x3D;1,2,…,n)，An 所指子树中所有结点的            关键码均大于Kn。（注：每个ki数据两旁各安放了一个指针，即Ai-1和Ai，左边的子树数据统统小于ki，右边子树的数据统             统大于ki）（注：总体来看指针数量比数据数量多1）</span><br><span class="line"></span><br><span class="line"> n 为关键码的个数（[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m - 1）。</span><br></pre></td></tr></table></figure></li><li>所有的叶子结点都出现在同一层次上，即所有叶节点具有相同的深度，等于树高度。并且不带信息（可以看作是外部结点或查找失<br>败的结点，实际上这些结点不存在，指向这些结点的指针为空）。</li></ol><h4 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h4><ol><li>B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</li></ol><h4 id="B-tree和二叉树和红黑树的不同点"><a href="#B-tree和二叉树和红黑树的不同点" class="headerlink" title="B_tree和二叉树和红黑树的不同点"></a>B_tree和二叉树和红黑树的不同点</h4><p>与二叉树:</p><ol><li><p>二叉树节点中保存的数据只有一个，而B_树得节点中保存的是线性表，真实数据数据不止一个有很多。由于表中的指针和子节点一一对应，而子节点个数又有限定([m/2] &lt;= p &lt;= m,[m/2]向上取整)，又因为真实数据数量又比指针少一个所以真实数据也就有了限定（\left \lceil m/2 \right \rceil-1\leqslant n\leqslant m-1）。</p></li><li><p>二叉树至多有两个儿子节点，而B-树至多有m个节点（m为树的阶）</p></li></ol><p>与红黑树:<br>    不同在于：B树的节点可以有很多子女，从几个到几万个不等，<br>    相同：一颗含有n个节点的B树高度和红黑树是一样的，都是O（lgn）。</p><h4 id="B-tree和B-tree结构操作"><a href="#B-tree和B-tree结构操作" class="headerlink" title="B_tree和B+tree结构操作"></a>B_tree和B+tree结构操作</h4><p>小编传不了图片,但是我找到了一个特别全很牛逼的网站，作为歉意！<br><a href="https://www.bilibili.com/video/BV1vQ4y1N79m?p=1">简述构造树遵循的规则</a>：<br>以五叉BTree为例，key的数量公式推导<br>ceil(m/2)-1 &lt;= n &lt;= m-1,所以2 &lt;= n &lt;= 4,当n &gt; 4时，中间节点上升进入父节点，两边节点裂开．</p><ol><li><p>插入字母C,N,G,A,H,K.Q.M.F,W,L,T,Z,D,P,R,X,Y,S数据为例．<br>注意每组元素下边都有一组数组.length()+1个下标.<br>插入前四个字母: [A,C,G,H]</p></li><li><p>插入H,n&gt;4,中间元素G字母向上分裂到新的节点(晋升为父节点)<br>　　[G]<br>[A|C]　[H|N]</p></li><li><p>插入E,K,Q不需要分裂　<br>　　　[G]<br>[A|C|E]　[H|K|N|Q]</p></li><li><p>插入M,中间元素M字母向上分裂到父节点G　<br>　　　　[G|M]<br>[A|C|E]　[H|K]　 [NQ]</p></li><li><p>插入F,W,L,T不需要分裂<br>　　　　　[G|M]<br>[A|C|E|F]　[H|K|L]　[N|Q|T|W]</p></li><li><p>插入Z,中间元素T先上分裂到父节点中</p></li></ol><p>　　　　　　　[G|M|T]<br>[A|C|E|F]　[H|K|L]　[N|Q]　[W|Z]</p><p>以此类推最后建成.</p><p><a href="https://www.cnblogs.com/guohai-stronger/p/9225057.html">结构和各种操作</a></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h3 id="M阶B-数特点"><a href="#M阶B-数特点" class="headerlink" title="M阶B+数特点"></a>M阶B+数特点</h3><p>在mysql中增加了叶子节点前后指针(进行了B+tree的优化).提高区间访问的效率)</p><ol><li>有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成一个链表）。</li><li>所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</li><li>同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</li></ol><h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><ol><li>所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li><li>b+树的中间节点不保存数据，能容纳更多节点元素。</li></ol><h4 id="B-树的时间复杂度"><a href="#B-树的时间复杂度" class="headerlink" title="B+树的时间复杂度"></a>B+树的时间复杂度</h4><h3 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h3><ol><li><p>B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。</p></li><li><p>B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</p></li><li><p>B树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m-1%5D">m/2(向上取整)-1,m-1</a>，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m%5D">m/2(向上取整),m</a>，具有n个关键字的节点包含（n）棵子树。</p></li><li><p>B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。</p></li></ol><h3 id="B树和B-树的共同优点"><a href="#B树和B-树的共同优点" class="headerlink" title="B树和B+树的共同优点"></a>B树和B+树的共同优点</h3><p>考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Data_Sturctures" scheme="http://example.com/tags/Data-Sturctures/"/>
    
  </entry>
  
  <entry>
    <title>bug</title>
    <link href="http://example.com/posts/42182/"/>
    <id>http://example.com/posts/42182/</id>
    <published>2020-10-14T03:38:06.000Z</published>
    <updated>2020-10-14T04:15:50.162Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有的人走错一步就回来,有的人一直错,——–子弹上膛（小庄）<br>由于python2不能导入request包,所以升级为python3.</p><p>Ubuntu下将python从2.7.12升级到3.5.2</p><p>１．我们在Ubuntu中使用Ctrl+Alt+T  快捷键 调出 终端窗口。然后在终端中输入Python,查看当前版本.<br>２．在上面的步骤中，我们看到我们的Python版本是2.7.12 这是Ubuntu中默认安装的Python版本 。接下来我们执行 sudo apt-get install python3 命令 这时候 终端会提示我们需要管理员密码 输入即可。<br>３．稍等片刻 我们的Python3 已经安装完成了 ，但是如果这时候我们输入Python并且回车 我们会发现 我们的Python版本仍然是2.7.12 这个时候我们需要切换Python的版本。</p><p>我们在终端中输入 alias python=python3  回车  </p><p>然后我们再输入Python 这个时候的版本就已经变成Python3了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python环境问题" scheme="http://example.com/categories/python%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider2</title>
    <link href="http://example.com/posts/40133/"/>
    <id>http://example.com/posts/40133/</id>
    <published>2020-10-13T13:57:29.000Z</published>
    <updated>2020-10-14T08:00:33.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>精神,唯一的财富,其它都是虚的。——袁朗．<br>爬虫实战应用<br><a href="https://blog.csdn.net/qq_21933615/article/details/81171951">Python中BeautifulSoup库的用法</a></p><p><a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/">官方文档</a><br>以上都是爬虫的预备知识，掌握了之后就可以写代码去爬取我们想要爬的网站了。</p><p>Python提供了许多网络请求的库，比如Requests、urllib等，这里只说一下requests库</p><p>Requests库.</p><p>安装：pip(3) install requests</p><p>基本使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 发送 GET 请求获取响应</span><br><span class="line">response &#x3D; requests.get(url)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response常用属性：</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line">response.text 返回响应内容，响应内容为 str 类型</span><br><span class="line">respones.content 返回响应内容,响应内容为 bytes 类型</span><br><span class="line">response.status_code 返回响应状态码</span><br><span class="line">response.request.headers 返回请求头</span><br><span class="line">response.headers 返回响应头</span><br><span class="line">response.cookies 返回响应的 RequestsCookieJar 对象</span><br><span class="line"># 获取字节数据</span><br><span class="line">content &#x3D; response.content</span><br><span class="line"># 转换成字符串类型</span><br><span class="line">html &#x3D; content.decode(&#39;utf-8&#39;)</span><br></pre></td></tr></table></figure><p>自定义请求头.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 发送自定义请求头</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送Get请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 GET 请求参数</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 GET 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,params&#x3D;params)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送POST请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义post请求参数</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.post(url,headers&#x3D;headers,data&#x3D;data)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>为什么使用代理：1、让服务器以为请求是从多个客户端发出的。2、防止暴露我们的真实地址<br>代理作为中间量简介链接客户端和服务器.</p><p>使用方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 代理服务器</span><br><span class="line">proxies &#x3D; &#123;</span><br><span class="line">    &quot;http&quot;:&quot;http:&#x2F;&#x2F;IP地址:端口号&quot;,</span><br><span class="line">    &quot;https&quot;:&quot;https:&#x2F;&#x2F;IP地址:端口号&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,proxies&#x3D;proxies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求中携带cookie</p><p>作用：有些网站需要登录，这时候cookie就是记录了你的用户信息</p><p>方式：</p><p>直接在自定义请求头中携带</p><p>通过请求参数携带cookie</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line">    # 方式一：直接在请求头中携带Cookie内容</span><br><span class="line">    &quot;Cookie&quot;: &quot;Cookie值&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 方式二：定义 cookies 值</span><br><span class="line">cookies &#x3D; &#123;</span><br><span class="line">    &quot;xx&quot;:&quot;yy&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,cookies&#x3D;cookies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据提取</p><p>作用：从爬虫获取的数据中提取出我们想要的数据</p><p>方式：<br>json模块提取<br>xpath提取<br>正则提取<br>beautifulsoup<br>１．json.<br>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式<br>json.loads json字符串 转 Python数据类型<br>json.dumps Python数据类型 转 json字符串<br>json.load json文件 转 Python数据类型<br>json.dump Python数据类型 转 json文件<br>ensure_ascii=False 实现让中文写入的时候保持为中文<br>indent=空格数 通过空格的数量进行缩紧<br>２．xpath.<br>XPath 全称： XML Path Language，是一门在 XML 文档中查找信息的语言。<br>XPath 可用来在 XML 文档中对元素和属性进行遍历。<br>安装：pip(3) install lxml</p><p>常用规则：<br>表达式———–描述——–<br>nodename——–选取此节点的所有子节点<br>/—————-从当前节点选取直接子节点<br>//—————从当前节点选取子孙节点<br>.—————-选取当前节点<br>..—————选取当前节点的父节点<br>@—————-选取属性</p><p>正则；</p><p>Python中通过正则表达对字符串进行匹配是，可以使用re模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入re模块</span><br><span class="line">import re</span><br><span class="line"># 使用match方法进行匹配操作</span><br><span class="line">result &#x3D; re.match(正则表达式,要匹配的字符串)</span><br><span class="line"># 如果上一步匹配到数据的话，可以使用group方法来提取数据</span><br><span class="line">result.group()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/116509288">常用语法：</a></p><p><em>————-匹配前一个字符0次或无限次，例abc</em>,能匹配字符abccccc,<br>+————-匹配前一个字符1次或无限次，例abc+,能匹配字符abccccc,<br>?————-匹配前一个字符0次或一次，例abc?,能匹配字符abc或ab,<br>{m}————-匹配前一个字符m次，例ab{2}c,能匹配字符abbc,<br>\d————-说明:数字[0-9]</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫实战应用" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider1</title>
    <link href="http://example.com/posts/40325/"/>
    <id>http://example.com/posts/40325/</id>
    <published>2020-10-13T12:20:14.000Z</published>
    <updated>2020-10-14T02:55:03.194Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好好活就是做有意义的事,有意义的事就是好好活。 —–送给短暂渺茫的你（许三多）</p><p>爬虫思路</p><p>1：什么是爬虫</p><p>爬虫(spider，又网络爬虫)，是指向网站/网络发起请求，获取资源后分析并提取有用数据的程序。</p><p>从技术层面来说就是 通过程序模拟浏览器请求站点的行为.</p><p>把站点返回的HTML代码/JSON数据/二进制数据（图片、视频） 爬到本地，进而提取自己需要的数据，存放起来使用。</p><p>2：入门爬虫的干货</p><p>2.1： 爬虫的基本思路</p><p>通过URL或者文件获取网页，<br>分析要爬取的目标内容所在的位置<br>用元素选择器快速提取(Raw) 目标内容<br>处理提取出来的目标内容 （ 通常整理合成一个 Json）<br>存储处理好的目标内容 （比如放到 MongoDB 之类的数据库，或者写进文件里。）<br>爬虫流程:<br>发送请求-&gt;获取响应内容-&gt;解析内容-&gt;保存数据</p><p>robots协议：</p><p>网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，但它仅仅是道德层面上的约束</p><p>爬虫的用途：</p><p>1、12306抢票<br>2、短信轰炸<br>3、网络投票<br>4、监控数据<br>5、下载图片、小说、视频、音乐等</p><p>Http和Https：<br>发送请求，获取响应的过程其实就是发送Http或者Https请求和响应的过程。<br>HTTP</p><p>超文本传输协议<br>默认端口号:80<br>HTTPS</p><p>HTTP + SSL(安全套接字层)，即带有安全套接字层的超本文传输协议<br>默认端口号：443</p><p>作用：在传输过程中对数据进行加密，防止被窜改</p><p>区别：http因不需要加密，所以性能更高，但安全性差。</p><p>https安全性高，但是占用服务器资源</p><p>但是Https是未来的主流，比如小程序、ios、android客户端的接口都需要Https接口支持.</p><p>Http请求报文和状态码：参考上一个博客.<br>常见的HTTP状态码：<br>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它 URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p><p>常见请求头：</p><p>Cookie——————–作用—–Cookie<br>User-Agent—————-作用—–浏览器名称<br>Referer——————-作用—–页面跳转处<br>Host———————-作用—–主机和端口号<br>Connection—————-作用—–链接类型<br>Upgrade-Insecure-Requests-作用—–升级为HTTPS<br>Accept——————–作用—–传输文件类型<br>Accept-Encoding———–作用—–文件编解码格式<br>x-Requests-with:XMLHttpRequest作用ajax请求</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web_spider</title>
    <link href="http://example.com/posts/50097/"/>
    <id>http://example.com/posts/50097/</id>
    <published>2020-10-13T04:18:51.000Z</published>
    <updated>2020-10-13T08:03:26.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>高成：我酒量一斤，陪你二斤吧．<br>袁朗: 我酒量二两，陪你喝舍命!</p><p>爬虫技术基础<br>—–替代繁琐的操作，程序化实现.<br><a href="https://www.cnblogs.com/ranyonsue/p/5984001.html">参考网站</a><br><a href="https://www.cnblogs.com/an-wen/p/11180076.html">参考网站</a></p><h3 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h3><p>(非重点)<br>历史有兴趣可看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</span><br><span class="line"></span><br><span class="line">HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</span><br><span class="line"></span><br><span class="line">2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP&#x2F;2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP&#x2F;2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</span><br></pre></td></tr></table></figure><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><h3 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h3><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B/S及C/S模式。</p><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤：</p><p>１．客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.luffycity.com./">http://www.luffycity.com。</a></p><p>２．发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>３．服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>４．释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>５．客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><p>1.浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2.解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5.释放 TCP连接;<br>6.浏览器将该 html 文本并显示内容; 　</p><h4 id="http协议是基于TCP-IP协议之上的应用层协议。"><a href="#http协议是基于TCP-IP协议之上的应用层协议。" class="headerlink" title="http协议是基于TCP/IP协议之上的应用层协议。"></a>http协议是基于TCP/IP协议之上的应用层协议。</h4><h4 id="基于-请求-响应-的模式"><a href="#基于-请求-响应-的模式" class="headerlink" title="基于 请求-响应 的模式"></a>基于 请求-响应 的模式</h4><p>　　HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应</p><h4 id="无状态保存"><a href="#无状态保存" class="headerlink" title="无状态保存"></a>无状态保存</h4><p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。<br>　　　　使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。有关Cookie的详细内容稍后讲解。</p><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><p>GET<br>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p><p>HEAD<br>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p><p>POST<br>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><p>PUT<br>向指定资源位置上传其最新内容。</p><p>DELETE<br>请求服务器删除Request-URI所标识的资源。</p><p>TRACE<br>回显服务器收到的请求，主要用于测试或诊断。</p><p>OPTIONS<br>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p><p>CONNECT<br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。<br>注意事项：<br>1.方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。<br>2.HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源。<br>请求方式: get与post请求（通过form表单我们自己写写看）</p><p>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中.</p><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>GET与POST请求在服务端获取请求数据方式不同，就是我们自己在服务端取请求数据的时候的方式不同了，这句废话昂</p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><p>1.-1xx消息——请求已被服务器接收，继续处理<br>2.-2xx成功——请求已成功被服务器接收、理解、并接受<br>3.-3xx重定向——需要后续操作才能完成这一请求<br>4.-4xx请求错误——请求含有词法错误或者无法被执行<br>5.-5xx服务器错误——服务器在处理某个正确请求时发生错误<br>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p><h4 id="URL-基本解释"><a href="#URL-基本解释" class="headerlink" title="URL(基本解释)"></a>URL(基本解释)</h4><p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p><p>传送协议。<br>层级URL标记符号(为[//],固定不变)<br>访问资源需要的凭证信息（可省略）<br>服务器。（通常为域名，有时为IP地址）<br>端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）<br>路径。（以“/”字符区别路径中的每一个目录名称）<br>查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）<br>片段。以“#”字符为起点<br>以<a href="http://www.luffycity.com/news/index.html?id=250&amp;page=1">http://www.luffycity.com:80/news/index.html?id=250&amp;page=1</a> 为例, 其中：</p><p>http，是协议；<br><a href="http://www.luffycity.com,是服务器;/">www.luffycity.com，是服务器；</a><br>80，是服务器上的默认网络端口号，默认不显示；<br>/news/index.html，是路径（URI：直接定位到对应的资源）；<br>?id=250&amp;page=1，是查询。<br>大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（<a href="http://www.luffycity.com/news/index.html?id=250&amp;page=1%EF%BC%89%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">www.luffycity.com:80/news/index.html?id=250&amp;page=1）就可以了。</a></p><p>由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务。</p><h4 id="URL划分部分解释"><a href="#URL划分部分解释" class="headerlink" title="URL划分部分解释"></a>URL划分部分解释</h4><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p><p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a><br>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p><p>2.域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></p><p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p><p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p><p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p><p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p><p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p><p>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p><h4 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h4><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br><a href="https://www.cnblogs.com/an-wen/p/11180076.html">HTTP请求格式(请求协议)</a></p><h4 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h4><p>GET请求<br>GET /books/?sex=man&amp;name=Professional HTTP/1.1<br>Host: <a href="http://www.wrox.com/">www.wrox.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Connection: Keep-Alive<br>注意最后一行是空行</p><p>POST请求<br>POST / HTTP/1.1<br>Host: <a href="http://www.wrox.com/">www.wrox.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 40<br>Connection: Keep-Alive</p><p>name=Professional%20Ajax&amp;publisher=Wiley<br>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p><p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p><p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变<br>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p><p>而在实际开发中存在的限制主要有：</p><p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p><p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p><p>POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p><p>3、安全性</p><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p><p>4、Http get,post,soap协议都是在http上运行的</p><p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p><p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p><p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><p>我们看看GET和POST的区别</p><p>１．GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p><p>２．GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>３．GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p><p>４．GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>mysql1</title>
    <link href="http://example.com/posts/15411/"/>
    <id>http://example.com/posts/15411/</id>
    <published>2020-10-13T02:46:27.000Z</published>
    <updated>2020-10-30T11:37:56.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果你想拥有你从未有过的东西，那么你必须去做你从未做过的事情。－－－向羽．</p><p>数据库底层请看B+树</p><p>首先引荐一个挺全的<a href="https://www.cnblogs.com/cainiao-chuanqi/p/11191647.html">数据库基础知识</a><br>书写顺序:<br>    select (distinct])<br>    from<br>    join（如left join）<br>    on<br>    where<br>    group by<br>    having<br>    union<br>    order by<br>    limit<br>执行顺序:<br>    from<br>    on<br>    join<br>    where<br>    group by<br>    having<br>    select<br>    distinct<br>    union<br>    order by </p><h3 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h3><ol><li>持久化数据库到本地</li><li>可以实现结构化查询，方便管理.</li></ol><h3 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h3><p>DB:</p><p>数据库(database); 存储数据的”仓库”，它保存了一系列有组织的数据的容器.</p><p>DBMS:</p><p>数据库管理系统(database Management System),数据库通过DBMS创建和操作的容器．管理DB中的数据.</p><p>SQL:</p><p>结构化查询语言(Structure Query Language):专门用于数据库通信的语言.</p><p>SQL的优点:<br>    1. 不是某个特定数据库供应商专有的语言，几乎所有的DBMS都支持SQL.<br>    2. 简单<br>    3. 可以进行非常复杂和高级的数据库操作．</p><p>数据库存储数据的特点:<br>    1. 将数据放到表中，表再放到库中．<br>    2. 一个数据库有多个表，每个表都有一个名字，用来标识自己，表名具有唯一性．<br>    3. 表具有一些特征，这些特性定义了数据在表中如何存储，类似类的设计．<br>    4. 表由列组成，我们也称为字段，所有表都是由一个或多个列组成，每一列相当于java中的属性.<br>    5. 表中的数据是按行存储的，每一行类似于java中的”对象”．</p><h3 id="数据库相关配置和环境暂时略"><a href="#数据库相关配置和环境暂时略" class="headerlink" title="数据库相关配置和环境暂时略"></a>数据库相关配置和环境暂时略</h3><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><ol><li><p>查看当前所有的数据库<br>show database;</p></li><li><p>打开指定的库<br>use 库名</p></li><li><p>查看当前库的所有表<br>show tables;</p></li><li><p>查看其库的所有表<br>show tables from 库名;</p></li><li><p>创建表<br>create table 表名{<br>　　列名　列类型;<br>　　列名　列类型;<br>};</p></li><li><p>查看表结构<br>desc 表名;</p></li><li><p>查看服务器的版本</p></li></ol><p>方式一: 登录到mysql服务器<br>select version();<br>方式二:没有登录到mysql服务器</p><p>mysql –version/ –V</p><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><ol><li>不区分大小写,建议关键字大写表，表名列名小写．</li><li>每条命令最好用分号结尾．</li><li>每条命令根据需要，可以进行缩进或换行．</li><li>注释　<br>单行注释：＃注释文字或者－－空格注释文字．<br>多行注释：/<em>注释文字</em>/</li></ol><h3 id="MySQL基础表的介绍"><a href="#MySQL基础表的介绍" class="headerlink" title="MySQL基础表的介绍"></a>MySQL基础表的介绍</h3><h3 id="基础查询介绍"><a href="#基础查询介绍" class="headerlink" title="基础查询介绍"></a>基础查询介绍</h3><p>select 查询列表　from 表明;<br>类似java中: System.out.println(打印东西);<br>特点：</p><ol><li>查询列表可以使：表中的字段，常量值，表达式，函数.</li><li>查询的结果是一个虚拟的表格.<h4 id="预操作"><a href="#预操作" class="headerlink" title="预操作"></a>预操作</h4>建议在查询操作之前添加所操作的库．<br>use myemployess;<br>类似C++的作用域;</li></ol><p>#``(着重号)<br>用来区分是关键字和字段,不添加也可以.</p><h4 id="查询单个字段"><a href="#查询单个字段" class="headerlink" title="查询单个字段"></a>查询单个字段</h4><p>select lastname from employess;</p><p>查询表中的多个字段<br>注意：最后没有逗号，顺序跟原来的表格可以不同.<br>select lastname,salary,email from employess;</p><h4 id="查询表中的所有字段"><a href="#查询表中的所有字段" class="headerlink" title="查询表中的所有字段"></a>查询表中的所有字段</h4><p>方式一．<br>select 可以双击点击表中的字段 from employess;</p><p>或者</p><p>方式二<br>#select (*) from employess;</p><h4 id="查询常量值"><a href="#查询常量值" class="headerlink" title="查询常量值"></a>查询常量值</h4><p>select 100;</p><p>查询字符字符串一个形式．<br>select ‘john’;</p><h4 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h4><p>直接返回的是结果.<br>select 100*99;</p><h4 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h4><p>调用该函数，显示返回值．<br>select version();</p><h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><ol><li>起别名容易读取，易读．</li><li>如果要查询的字段有重名的情况，可用别名可以区分开来．</li></ol><p>方式一：<br>select 100 * 98 as 结果；</p><p>罗列出来的表，列属性的名字直接替换为姓．<br>select lastname as 姓，firstname as 名 from employess;</p><p>方式二：</p><p>直接把as省略掉.<br>select lastname 姓，firstname 名 from employess;</p><p>例如：查询salary,显示结果为out put</p><p>取别名的时候，如果有特殊字符如空格，就加上双引号或者单引号．<br>select salary as “out put” from employess;</p><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>案例：查询员工表中涉及到的所有的部门编号．</p><p>去重关键字: distinct.</p><p>select distinct departmentid from employess;</p><h4 id="的作用域"><a href="#的作用域" class="headerlink" title="+的作用域"></a>+的作用域</h4><p>java 中:</p><ol><li>运算符，表示操作数都是数值型．</li><li>连接符，只要有一个操作数为字符串．</li></ol><p>MySQL中的加号:<br>    只有一个功能：运算符，</p><ol><li>两个操作室都是数值型，就做加法运算．</li><li>其中一方为字符型，就将字符型转换为数值型，如果转换成功就做加法运算．转换失败就将字符型转换为0;接着拿0和后边数进行加法运算.</li><li>其中一方为NULL,则结果就为NULL;</li></ol><p>案例：查询员工名和姓连接成一个字段，并显示为姓名．</p><p>这个样子是不对的．<br>select lastname + firstname as 姓名<br>from  employess; </p><p>改正样子:<br>    concat表示字符串链接功能，相当于一列和另一列结合．然后属性取了别名．<br>　　select concat(‘lastname’,’firstname’) as 姓名<br>　　from employess;</p><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>案例：显示表departments的结构，并查询其中的全部数据.<br>关键字　desc;<br>desc departments;<br>select * from departments;</p><p>显示出表employess中的全部job_id(不重复)<br>select distinct job_id from employess;</p><p>显示出表employess的全部列，各个列之间用逗号连接，列头显示成OUT_PUT</p><p>第一部分表示如果lastname 如果为NULL，就显示成0,改名为奖金率<br>所以选出了两列，一个是更名的，一个是没有更名的．</p><p>select IFNILL(lastname, 0) as 奖金率,<br>       lastname<br>from<br>       employess;</p><p>select<br>       concat(firstname,’,’,lastname) as OUT_PUT<br>from<br>       employess;</p><p>改正后　：</p><p>select<br>       concat(firstname,’,’,IFNILL(lastname,0))<br>from<br>       employess;</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>where 相当于 if.</p><p>语法：<br>select<br>　　　　查询列表<br>from<br>　　　　表名<br>where<br>　　　　筛选条件;</p><p>语法执行顺序:</p><ol><li>表名．</li><li>筛选条件．</li><li>查询列表．</li></ol><p>分类：</p><ol><li><p>按条件表达式筛选<br>条件运算符:&gt;,&lt;,=(类似==),&lt;&gt;(类似!=),&gt;=,&lt;=.</p></li><li><p>按逻辑表达式筛选</p></li></ol><p>java中：逻辑运算符: &amp;&amp;, \,!(与,或,非)<br>MySQL: and, or, not.</p><p>3.模糊查询</p><ol><li>like </li><li>between</li><li>in</li><li>is null</li></ol><h4 id="按条件表达式筛选"><a href="#按条件表达式筛选" class="headerlink" title="按条件表达式筛选"></a>按条件表达式筛选</h4><p>案例一: 查询工资&gt;12000的员工信息．<br>select  *<br>from employess<br>where salary &gt; 12000;</p><p>案例二: 查询部门编号不等于90号的员工名和部门编号.<br>的后边是谁select后边就是谁.</p><p>select lastname, departmentid<br>from employess<br>where departmentid ＜＞90;<br>或者　前者建议使用<br>where departmentid != 90;</p><h4 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h4><p>案例一：查询工资在10000到20000之间的员工名，工资以及奖金.</p><p>select lastname,salary,commissionpct<br>from employess<br>where salary&gt;=10000<br>and salary＜＝20000</p><p>案例二:查询部门编号不是在90到110间,或者工资高于15000的员工信息</p><p>select *<br>from employess</p><p>where not(departmentid＞＝90 and departmentid＜＝110) or salary&gt;15000;<br>或者<br>where departmentid&lt;90 or departmentid&gt;110 or salary&gt;15000;</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><h5 id="like一般和通配符使用"><a href="#like一般和通配符使用" class="headerlink" title="like一般和通配符使用"></a>like一般和通配符使用</h5><p>通配符:<br>    %表示任意多个字符包含零个字符<br>    _表示任意单个字符<br>    表示通配符的时候用\进行转义.</p><p>案例一: 查询员工名中包含字符的员工信息<br>like前字符型的值必须加单引号.<br>%表示通配符，若干个．<br>select * from employess where lastname like ‘%a% ‘</p><p>案例二:查询员工名中第三个字符为e,第五个字符为a的员工名和工资．<br>select lastname,salary from employess where lastname like ‘__e_a%’;</p><p>案例三：查询员工名中第二个字符为（下划线）的员工名．注释：没办法打出来．<br>用转义<br>select lastname from employess where lastname like ‘<em>\</em>%’;<br>_<br>定义转义符号<br>重新弄个符号定义为转义符，关键字　escape.<br>select lastname from employess where lastname like ‘<em>$</em>%’ escape ‘$’;</p><h5 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h5><ol><li>使用between and 可以提高语句的简洁度．</li><li>包含临界值</li><li>两个值不可以交换顺序．</li></ol><p>案例一: 查询员工编号在100到120之间的所有员工信息．</p><p>select * from employess </p><p>where employessid &gt;= 100 and employess_id &lt;= 120;<br>或者<br>where employessid between 100 and 120;<br>完全等价以　&gt;= 和　&lt;= </p><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>判断某字段的值是否属于in列表中的某一项</p><ol><li>使用in提高语句的简洁渡.</li><li>in列表中的类型必须一致或者兼容．(‘123’) 和123 ，’123’可以转换成123.</li><li>in的列表不能是省略的形式，比如%12%这样的.</li></ol><p>案例:查询员工的工种编号 IT_PROG,AD_VP,AD_PRES中的一个员工和工种编号．<br>select<br>      lastname,<br>      job_id<br>from </p><p>job_id = ‘IT_PROG’ or job_id = ‘AD_VP’ or job_id = ‘AD_PRES’;<br>或者<br>job_id in(‘IT_PROG’,’AD_VP’,’AD_PRES’);</p><h5 id="is-NULL"><a href="#is-NULL" class="headerlink" title="is NULL"></a>is NULL</h5><ol><li>=或&lt;&gt;不能用于判断NULL值<br>is null 或　is not null 可以判断NULL值.</li></ol><p>实例: 查询没有奖金的员工名和奖金率．<br>select lastname,<br>       commissionpct<br>from   employess</p><p>where commissionpct = NULL; 注意＝不能判断NULL;<br>改正<br>where commissionpct is NULL;<br>如果是有奖金<br>where commissionpct is not NULL;</p><p>安全等于 &lt;=&gt; 即可判断NULL 也可判断普通值.</p><p>面试题:<br>访问select * from employess 和<br>select * from employess where commissionpct like ‘%%’ and lastname like ‘%%’;<br>有什么不同，说明原因.<br>答案：<br>是不一样，<br>如果判断的字段有null值的化，第二种情况就不对了，第二种%表示有不表示空．</p><p>改正，前提如果两个属性对应的位置不存在全为NULL 的情况就可以下边方式更改．<br>select * from employess where commissionpct like ‘%%’ 或 lastname like ‘%%’;</p><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法:</p><ol><li>select 查询列表</li><li>from 表</li><li>[where 筛选条件]</li><li>order by 排序列表　asc\desc (升序或降序)</li></ol><p>执行顺序2,3,1,4</p><ol><li>asc代表是升序，desc 代表降序，若果不写默认是升序．</li><li>order by 子句中可以支持单个字段，多个字段，表达式，函数别名．</li><li>order by 子句一般放在查询语句的最后．limit子句更为靠后,</li></ol><p>案例一:查询员工信息，要求工资从高到低排序<br>select * from employess order by salary desc;<br>select * from employess order by salary ;　//升序</p><p>案例二:查询部门编号&gt;= 90的员工信息，按入职时间的先后进行．(添加筛选条件)<br>select * from employess where dapartment_id &gt;= 90 order by hiredata asc;</p><p>案例三: 按年薪的高低显示员工的信息和年薪［按表达式排序］<br>select *,salary * 12 *(1 + IFNILL(commissionpct, 0)) 年薪<br>from employess<br>order by salary * 12 *(1 + IFNILL(commissionpct, 0)) desc；</p><p>案例四: 按年薪的高低显示员工的信息和年薪［按别名排序］</p><p>select *, salary * 12 * (1 + IFNILL(commissionpct, 0)) 年薪<br>from employess<br>order by 年薪　desc;</p><p>案例四：　按姓名的长度来显示员工的姓名和工资［按函数排序］<br>select LENGTH(“john”);  //LENGTH 表示输出长度的函数　</p><p>答案:</p><p>select LENGTH (lastname) 字节长度，lastname,salary<br>from employess<br>order by LENGTH(lastname) desc;</p><p>案例六：查询员工信息，要求按工资升序排序，再按员工编号降序排序[按多个字段排序]</p><p>select * from employess order by salary asc, employess_id desc;</p><p>解释: 就是先按照工资排序，工资一样按员工编号排序．</p><h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><p>概念: 类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名<br>好处: </p><ol><li>隐藏了实现细节．</li><li>提高了代码的重用性．</li></ol><p>调用: select 函数名（实参列表）［from 表］；　［中若有from表就写若没有就不写］</p><p>特点:<br>    1. 函数名字<br>    2. 函数功能</p><p>分类:<br>    1. 单行函数<br>    如: concat, length, IFNILL等<br>    2. 分组函数<br>    功能:做统计使用.又称为统计函数，聚合函数，组函数．</p><h5 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h5><p>额外的知识:<br>    utf8 字符占用一个字节<br>    汉字三个字节<br>    ｊｄｋ汉字是两个字节．</p><ol><li><p>length函数获取参数的字节个数．<br>select LENGTH(‘john’); 返回4<br>select LENGTH(‘哈哈哈’)；　utf8为9.</p></li><li><p>concat拼接字符</p></li></ol><p>select concat(lastname,’__’,firstname) from employess;<br>_为中间字符进行了拼接.<br>3. upper,lower<br>大小写变换<br>select upper(‘john’);<br>select lower(‘john’);</p><p>示例: 将姓变大写，名变小写，然后拼接．<br>select concat(upper(lastname),lower(firstname)) 名字　from employess;</p><ol start="4"><li>substr,substring .<br>注意；索引从１开始<br>返回陆展元<br>select substr(‘李莫愁爱上陆展元’,7) OUT_PUT;截取从⑦开始的所有字符</li></ol><p>返回李莫愁；</p><p>select substr(‘李莫愁爱上陆展元’,1, 3) OUT_PUT;截取开始位置及长度．</p><p>案例:姓名中的首字符大写，然后用下划线进行链接．<br>select concat(upper(substr(lastname, 1, 1)),’_ ‘,lower(substr(lastname, 2))) from employess;<br>_</p><ol start="5"><li>instr</li></ol><p>instr(‘杨不悔爱上了殷六侠’，＇殷六侠＇) as OUT_PUT ；//返回子串在父串中首次出现的的下标索引值．如果没有即为０．</p><ol start="6"><li>trim</li></ol><p>select LENGTH(trim(‘    张翠山　　　‘)) as OUT_PUT;</p><p>去掉前后空格，不去中间．</p><p>select trim(‘a’ from ‘aaaa蛋蛋aaaa蛋蛋aaaa’) as OUT_PUT;</p><p>输出蛋蛋aaaa蛋蛋．</p><ol start="7"><li>lpad 用指定的字符实现左填充指定长度．超了就截取．</li></ol><p>select lpad (‘殷素素’,10,’*’) as OUT_PUT;</p><p>不够十个左边用*填充;</p><p>8.rpad 用指定的字符实现右填充指定长度</p><ol start="9"><li>replace(‘张无忌爱上周芷若’，’周芷若’，’赵敏’)　as OUT_PUT;<br>周芷若替换成赵敏.全部替换</li></ol><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><ol><li>round 四舍五入<br>select round(-1.55); //绝对值进行四舍五入然后加上符号．<br>select round(1.567,2); 小数点后两位．</li></ol><ol start="2"><li>ceil 向上取整向上返回&gt;=该参数的最小整数</li></ol><p>select ceil (1,00);</p><ol start="3"><li><p>floar向下取整,返回&lt;= 该参数的最大整数.<br>select floar(-9.99); -9</p></li><li><p>truncate 截断<br>select truncate (1.6999999,1);<br>小数点后一位.</p></li></ol><ol start="5"><li>mod取余<br>mod (a, b) : a - a/b * b;<br>正负数带入就好.<br>select mod (10 ,-3)</li></ol><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>now：返回当前系统日期+时间</p><p>curdate：返回当前系统日期，不包含时间</p><p>curtime：返回当前时间，不包含日期</p><p>可以获取指定的部分，年、月、日、小时、分钟、秒</p><p>SELECT<br>  YEAR(hiredate) 年<br>FROM<br>    employees ;</p><p>str_to_date：将日期格式的字符转换成指定格式的日期</p><p>  SELECT<br>    STR_TO_DATE(‘1998-3-2’, ‘%Y-%c-%d’) AS output ;</p><p>  查询入职日期为1992-4-3的员工信息</p><p>  SELECT<br>    *<br>    FROM<br>      employees<br>      WHERE hiredate = STR_TO_DATE(‘4-3 1992’, ‘%c-%d %Y’) ;</p><p>date_format：将日期转换成字符串</p><p>SELECT<br>  DATE_FORMAT(NOW(), ‘%y年%m月%d日)’) AS output ;<br>  查询有奖金的员工名和入职日期（xx月/xx日 xx年）</p><p>  SELECT<br>    last_name,<br>      DATE_FORMAT(hiredate, ‘%m月/%d日 %y年’) AS 入职日期<br>      FROM<br>        employees<br>        WHERE commission_pct IS NOT NULL ;<br>        datediff：返回两个日期相差的天数</p><pre><code>    monthname：以英文形式返回月</code></pre><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>SELECT VERSION();<br>当前数据库服务器的版本<br>SELECT DATABASE();<br>当前打开的数据库<br>SELECT USER();</p><p>当前用户<br>password(‘字符’);<br>流程控制函数</p><p>if函数：if else的效果</p><p>SELECT<br>  last_name,<br>  commission_pct,<br>  IF(<br>    commission_pct IS NULL,<br>    ‘没奖金，呵呵’,<br>    ‘有奖金，嘻嘻’<br>  ) 备注<br>FROM<br>  employees ;</p><p>case函数的使用1：switch case的效果</p><p>语法：</p><p>case 要判断的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量2 then 要显示的值2或语句2;<br>…<br>else 要显示的值n或语句n;<br>end</p><p>查询员工的工资，要求：</p><p>部门号=30，显示的工资为1.1倍</p><p>部门号=40，显示的工资为1.2倍</p><p>部门号=50，显示的工资为1.3倍</p><p>其他部门，显示的工资为原工资</p><p>SELECT<br>  salary AS 原始工资,<br>  department_id,<br>  CASE<br>    department_id<br>    WHEN 30<br>    THEN salary * 1.1<br>    WHEN 40<br>    THEN salary * 1.2<br>    WHEN 50<br>    THEN salary * 1.3<br>    ELSE salary<br>  END AS 新工资<br>FROM<br>  employees ;</p><p>case函数的使用2：类似于多重if</p><p>case<br>when 条件1 then 要显示的值1或语句1<br>when 条件2 then 要显示的值2或语句2<br>…<br>else 要显示的值n或语句n<br>end</p><p>查询员工的工资情况</p><p>如果工资&gt;20000，显示A级别</p><p>如果工资&gt;15000，显示B级别</p><p>如果工资&gt;10000，显示C级别</p><p>否则，显示D级别</p><p>SELECT<br>  salary,<br>  CASE<br>    WHEN salary &gt; 20000<br>    THEN ‘A’<br>    WHEN salary &gt; 15000<br>    THEN ‘B’<br>    WHEN salary &gt; 10000<br>    THEN ‘C’<br>    ELSE ‘D’<br>  END AS 工资级别<br>FROM<br>  employees ;</p><p>测试题</p><p>显示系统时间（日期+时间）</p><p>SELECT NOW();<br>1<br>查询员工号，姓名，工资，以及工资提高20%后的结果（new salary）</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  salary,<br>  salary * 1.2 AS “new salary”<br>FROM<br>  employees ;</p><p>将员工的姓名按首字母排序，并写出姓名的长度（length）</p><p>SELECT<br>  last_name,<br>  LENGTH(last_name)<br>FROM<br>  employees<br>ORDER BY SUBSTR(last_name, 1, 1) ;</p><p>做一个查询</p><p>SELECT<br>  CONCAT(<br>    last_name,<br>    ‘ earns ‘,<br>    salary,<br>    ‘ monthly but wants ‘,<br>    salary * 3<br>  ) AS “Dream Salary”<br>FROM<br>  employees ;</p><p>case-when训练</p><p>SELECT<br>  last_name,<br>  job_id AS job,<br>  CASE<br>    job_id<br>    WHEN ‘AD_PRES’<br>    THEN ‘A’<br>    WHEN ‘ST_MAN’<br>    THEN ‘B’<br>    WHEN ‘IT_PROG’<br>    THEN ‘C’<br>    WHEN ‘SA_PRE’<br>    THEN ‘D’<br>    WHEN ‘ST_CLERK’<br>    THEN ‘E’<br>  END AS Grade<br>FROM<br>  employees<br>WHERE job_id = ‘AD_PRES’ ;</p><h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><p>功能：用作统计使用，又称为聚合函数或统计函数或组函数</p><p>分类：sum 求和、avg 平均值、max 最大值、min 最小值、count 计数（非空）</p><p>SELECT SUM(salary) FROM employees;</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>sum、avg一般用于处理数值型数据</li><li>max、min、count可以处理任何类型数据</li><li>以上分组函数都忽略null值</li><li>可以和distinct搭配实现去重的运算</li></ol><p><a href="https://blog.csdn.net/qq_39729527/article/details/82377925">count</a><br>_<br>SELECT<br>  SUM(DISTINCT salary),<br>  SUM(salary)<br>FROM<br>  employees ;</p><p>SELECT<br>  COUNT(DISTINCT salary),<br>  COUNT(salary)<br>FROM<br>  employees ;</p><h5 id="count函数的单独介绍"><a href="#count函数的单独介绍" class="headerlink" title="count函数的单独介绍"></a>count函数的单独介绍</h5><p>效率</p><p>MYISAM存储引擎下，count(<em>)的效率高<br>INNODB存储引擎下，count(</em>)和count(1)效率差不多，比count(字段)要高一些<br>使用count(*) 统计一共有多少行</p><p>SELECT COUNT(salary) FROM employees;<br>SELECT COUNT(*) FROM employees;//对行数进行统计<br>SELECT COUNT(1) FROM employees;//  对表中第一列的值的函数进行计算，忽略countNULL列.</p><p>count(列名字)对表中特定的列的值的行数进行计算，不包括null;</p><ol start="5"><li>和分组函数一同查询的字段有限制，要求是group by后的字段</li></ol><p>训练题</p><p>查询公司员工工资的最大值，最小值，平均值，总和</p><p>SELECT<br>  MAX(salary),<br>  MIN(salary),<br>  AVG(salary),<br>  SUM(salary)<br>FROM<br>  employees ;</p><p>查询员工表中的最大入职时间和最小入职时间的相差天数（difference）</p><p>SELECT<br>  DATEDIFF(MAX(hiredate), MIN(hiredate)) DIFFERENCE<br>FROM<br>  employees ;</p><p>查询部门编号为90的员工个数</p><p>SELECT<br>  COUNT(*)<br>FROM<br>  employees<br>WHERE department_id = 90 ;</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>select 分组函数，列（要求出现在group by的后面）</p><p>from 表</p><p>【where 筛选条件】</p><p>group by 分组的列表</p><p>【having 分组后的筛选】</p><p>【order by 子句】</p><p>注意：查询列表比较特殊，要求是分组函数和group by后出现的字段</p><p>特点：</p><p>分组查询中的筛选条件分为两类：<br>　　　　　　数据源 　　　　位置 　　　　　　　　关键字</p><p>分组前筛选 原始表 　　group by子句的前面 　　　　where</p><p>分组后筛选 分组后的结果集 group by子句的后面 　　having</p><p>分组函数做条件肯定是放在having子句中</p><p>能用分组前筛选的，就优先考虑使用分组前筛选</p><p>group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开没有顺序要求），表达式或函数（用得较少）</p><p>也可以添加排序（排序放在整个分组查询最后位置）</p><p>查询每个工种的最高工资</p><p>SELECT<br>  MAX(salary),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id ;</p><p>查询每个位置上的部门个数</p><p>SELECT<br>  COUNT(*),<br>  location_id<br>FROM<br>  departments<br>GROUP BY location_id ;</p><p>查询邮箱中包含a字符的，每个部门的平均工资</p><p>SELECT<br>  AVG(salary),<br>  department_id<br>FROM<br>  employees<br>WHERE email LIKE ‘%a%’<br>GROUP BY department_id ;</p><p>查询有奖金的每个领导手下员工的最高工资</p><p>SELECT<br>  MAX(salary),<br>  manager_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY manager_id ;</p><p>查询那个部门的员工个数&gt;2</p><p>查询每个部门的员工个数</p><p>SELECT<br>  COUNT(*) AS 员工个数,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id ;</p><p>根据上面的结果进行筛选，查询哪个部门的员工个数＞2</p><p>SELECT<br>  COUNT(*) AS 员工个数,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING 员工个数 &gt; 2 ;</p><p>添加分组后的筛选用having，分组前的用where</p><p>查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p><ol><li>查询每个工种有奖金的员工的最高工资</li></ol><p>SELECT<br>  MAX(salary),<br>  job_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id ;</p><ol start="2"><li>根据上面的结果继续筛选，最高工资&gt;12000</li></ol><p>SELECT<br>  MAX(salary) AS 最高工资,<br>  job_id<br>FROM<br>  employees<br>WHERE commission_pct IS NOT NULL<br>GROUP BY job_id<br>HAVING 最高工资 &gt; 12000 ;</p><p>查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及其最低工资</p><p>SELECT<br>  MIN(salary) AS 最低工资,<br>  manager_id<br>FROM<br>  employees<br>WHERE manager_id &gt; 102<br>GROUP BY manager_id<br>HAVING 最低工资 &gt; 5000 ;</p><p>按表达式或函数分组</p><p>按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些</p><ol><li>查询每个长度的员工个数</li></ol><p>SELECT<br>  COUNT(*) 员工个数,<br>  LENGTH(last_name) 姓名长度<br>FROM<br>  employees<br>GROUP BY 姓名长度 ;</p><ol start="2"><li>添加筛选条件</li></ol><p>SELECT<br>  COUNT(*) 员工个数,<br>  LENGTH(last_name) 姓名长度<br>FROM<br>  employees<br>GROUP BY 姓名长度<br>HAVING 员工个数 &gt; 5 ;</p><ol start="3"><li>按多个字段分组</li></ol><p>查询每个部门每个工种的员工的平均工资</p><p>SELECT<br>  AVG(salary),<br>  department_id,<br>  job_id<br>FROM<br>  employees<br>GROUP BY department_id,<br>  job_id ;//这两个一样才能划分为一组.</p><p>添加排序</p><p>查询每个部门每个工种的员工的平均工资，并按平均工资的高低显示</p><p>SELECT<br>  AVG(salary) AS 平均工资,<br>  department_id,<br>  job_id<br>FROM<br>  employees<br>GROUP BY department_id,<br>  job_id<br>ORDER BY 平均工资 DESC ;</p><p>练习题</p><p>查询各job_id的员工工资的最大值、最小值、平均值，总和，并按job_id升序</p><p>SELECT<br>  MAX(salary),<br>  MIN(salary),<br>  AVG(salary),<br>  SUM(salary),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id<br>ORDER BY job_id ;</p><p>查询员工最高工资和最低工资的差距（DIFFERENCE）</p><p>SELECT<br>  MAX(salary) - MIN(salary) AS DIFFERENCE<br>FROM<br>  employees ;</p><p>查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内</p><p>SELECT<br>  MIN(salary) AS 最低工资<br>FROM<br>  employees<br>WHERE manager_id IS NOT NULL<br>GROUP BY manager_id<br>HAVING 最低工资 &gt;= 6000 ;</p><p>查询所有部门的编号，员工数量和工资平均值，并按平均工资降序</p><p>SELECT<br>  department_id,<br>  COUNT(*) AS 员工数量,<br>  AVG(salary) AS 工资平均值<br>FROM<br>  employees<br>GROUP BY department_id<br>ORDER BY 工资平均值 DESC ;</p><p>查询具有各个job_id的员工人数</p><p>SELECT<br>  COUNT(*),<br>  job_id<br>FROM<br>  employees<br>GROUP BY job_id ;</p><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p><p>笛卡尔乘积现象：表1有m行，表2有n行，结果=m*n</p><p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件<br>分类：</p><p>按年代分类：<br>sql92标准：仅仅支持内连接<br>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接<br>按功能分类：<br>内连接:<br>  等值连接<br>  非等值连接<br>  自连接<br>外连接:<br>  左外连接<br>  右外连接<br>  全外连接（mysql不支持）<br>交叉连接:</p><h5 id="sql92标准"><a href="#sql92标准" class="headerlink" title="sql92标准"></a>sql92标准</h5><h6 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h6><p>多表等值连接的结果为多表的交集部分</p><p>n表连接，至少需要n-1个连接条件</p><p>多表的顺序没有要求</p><p>一般需要为表起别名</p><p>可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p><p>查询女神名和对应的男神名：</p><p>SELECT<br>  NAME,<br>  boyname<br>FROM<br>  boys,<br>  beauty<br>WHERE beauty.boyfriend_id = boys.id ;</p><p>查询员工名和对应的部门名</p><p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees,<br>  departments<br>WHERE employees.<code>department_id</code> = departments.<code>department_id</code> ;</p><p>为表起别名</p><p>提高语句的简洁度</p><p>区分多个重名的字段</p><p>注意：如果为表起了别名，则查询 的字段就不能使用原始的表明去限定</p><p>查询员工名、工种号、工种名</p><p>SELECT<br>  last_name,<br>  e.<code>job_id</code>,<br>  job_title<br>FROM<br>  employees e,<br>  jobs j<br>WHERE e.<code>job_id</code> = j.<code>job_id</code> ;</p><p>两个表的顺序是否可以调换</p><p>查询员工名、工种号、工种名</p><p>SELECT<br>  last_name,<br>  e.<code>job_id</code>,<br>  job_title<br>FROM<br>  jobs j ,<br>  employees e<br>WHERE e.<code>job_id</code> = j.<code>job_id</code> ;</p><p>可以加筛选</p><p>查询有奖金的员工名、部门名</p><p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees AS e,<br>  departments AS d<br>WHERE e.<code>department_id</code> = d.<code>department_id</code><br>  AND e.<code>commission_pct</code> IS NOT NULL ;</p><p>查询城市名中第二个字符为o的部门名和城市名</p><p>SELECT<br>  department_name,<br>  city<br>FROM<br>  departments d,<br>  locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>  AND city LIKE ‘_o%’ ;</p><p>可以加分组</p><p>查询每个城市的部门个数</p><p>SELECT<br>  COUNT(*) 个数,<br>  city<br>FROM<br>  departments d,<br>  locations l<br>WHERE d.<code>location_id</code> = l.<code>location_id</code><br>GROUP BY city ;</p><p>查询有将近的每个部门的部门名和部门的领导编号和该部门的最低工资</p><p>SELECT<br>  department_name,<br>  d.manager_id,<br>  MIN(salary)<br>FROM<br>  departments d,<br>  employees e<br>WHERE d.<code>department_id</code> = e.<code>department_id</code><br>  AND commission_pct IS NOT NULL<br>GROUP BY department_name,<br>  d.manager_id ;</p><p>可以加排序</p><p>查询每个工种的工种名和员工的个数，并且按员工个数降序</p><p>SELECT<br>  job_title,<br>  COUNT(*) AS 个数<br>FROM<br>  employees e,<br>  jobs j<br>WHERE e.<code>job_id</code> = j.<code>job_id</code><br>GROUP BY job_title<br>ORDER BY 个数 DESC ;</p><p>可是实现三表连接：</p><p>查询员工名、部门名和所在的城市</p><p>SELECT<br>  last_name,<br>  department_name,<br>  city<br>FROM<br>  employees e,<br>  departments d,<br>  locations l<br>WHERE e.<code>department_id</code> = d.<code>department_id</code><br>  AND d.<code>location_id</code> = l.<code>location_id</code> ;</p><h6 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h6><p>查询员工的工资和工资级别</p><p>SELECT<br>  salary,<br>  grade_level<br>FROM<br>  employees e,<br>  job_grades g<br>WHERE salary BETWEEN g.lowest_sal<br>  AND g.highest_sal ;</p><p>自连接</p><p>查询 员工名和上级的名称</p><p>SELECT<br>  e.employee_id,<br>  e.last_name,<br>  m.employee_id,<br>  m.last_name<br>FROM<br>  employees e,<br>  employees m<br>WHERE e.<code>manager_id</code> = m.<code>employee_id</code> ;</p><p>测试题：</p><p>显示员工表的最大工资，工资平均值</p><p>SELECT<br>  MAX(salary),<br>  AVG(salary)<br>FROM<br>  employees ;</p><p>查询员工表的employee_id，job_id，last_name，按department_id降序，salary升序</p><p>SELECT<br>  employee_id,<br>  job_id,<br>  last_name<br>FROM<br>  employees<br>ORDER BY department_id DESC,<br>  salary ASC ;</p><p>查询员工表的job_id中包含a和e的，并且a在e的前面</p><p>SELECT<br>  job_id<br>FROM<br>  employees<br>WHERE job_id LIKE ‘%a%e%’ ;</p><p>显示当前日期，以及去前后空格，截取子字符串的函数</p><p>select now();<br>select trim();<br>select substr(str, startIndex, [length])</p><p>sql99语法</p><p>语法：</p><p>select 查询列表</p><p>from 表1 别名 【连接类型】</p><p>join 表2 别名</p><p>on 连接条件</p><p>【where 筛选条件】</p><p>【group by 分组】</p><p>【having 筛选条件】</p><p>【order by 排序列表】</p><p>内连接（同上）：连接类型是inner</p><h6 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h6><p>左外：left 【outer】<br>右外：right【outer】<br>全外：full 【outer】<br>交叉连接：cross</p><p>内连接：</p><p>语法：</p><p>select 查询列表</p><p>from 表1 别名</p><p>inner join 表2 别名</p><p>on 连接条件</p><p>…</p><p>分类：</p><p>等值连接</p><p>非等值连接</p><p>自连接</p><p>特点：</p><p>添加排序、分组、筛选<br>inner可以省略<br>筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p><ol><li>等值连接：</li></ol><p>查询员工名、部门名</p><p>SELECT<br>  last_name,<br>  department_name<br>FROM<br>  employees e<br>  INNER JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code> ;</p><p>查询名字中包含e的给员工名和工种名</p><p>SELECT<br>  last_name,<br>  job_title<br>FROM<br>  employees e<br>  INNER JOIN jobs j<br>    ON e.<code>job_id</code> = j.<code>job_id</code><br>WHERE last_name LIKE “%e%” ;</p><p>查询部门个数&gt;3的城市名和部门个数</p><p>SELECT<br>  city,<br>  COUNT(*) 部门个数<br>FROM<br>  departments d<br>  INNER JOIN locations l<br>    ON d.<code>location_id</code> = l.<code>location_id</code><br>GROUP BY city<br>HAVING 部门个数 &gt; 3 ;</p><p>查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按个数降序排序</p><p>SELECT<br>  department_name,<br>  COUNT(*) 员工个数<br>FROM<br>  departments d<br>  INNER JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>GROUP BY d.<code>department_id</code><br>HAVING 员工个数 &gt; 3<br>ORDER BY 员工个数 DESC ;</p><p>查询员工名、部门名、工种名，并按部门名降序.三表连接（有连接条件能连就可以）<br>SELECT<br>  last_name,<br>  department_name,<br>  job_title<br>FROM<br>  employees e<br>  INNER JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code><br>  INNER JOIN jobs j<br>    ON e.<code>job_id</code> = j.<code>job_id</code><br>ORDER BY d.<code>department_id</code> DESC ;</p><p>2, 非等值连接</p><p>查询员工的工资级别</p><p>SELECT<br>  salary,<br>  grade_level<br>FROM<br>  employees e<br>  INNER JOIN job_grades g<br>    ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p><p>查询每个工资级别&gt;20的个数，并且按工资级别降序</p><p>SELECT<br>  COUNT(<em>),<br>  grade_level<br>FROM<br>  employees e<br>  INNER JOIN job_grades g<br>    ON e.<code>salary</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code><br>GROUP BY grade_level<br>HAVING COUNT(</em>) &gt; 20<br>ORDER BY grade_level DESC ;</p><ol start="3"><li>自连接</li></ol><p>把一张表当成两张表使用.</p><p>查询员工的名字、上级的名字</p><p>SELECT<br>  e.last_name,<br>  m.last_name<br>FROM<br>  employees e<br>  INNER JOIN employees m<br>    ON e.<code>manager_id</code> = m.<code>employee_id</code> ;</p><p>查询姓名中包含字符k的员工的名字、上级的名字</p><p>SELECT<br>  e.last_name,<br>  m.last_name<br>FROM<br>  employees e<br>  INNER JOIN employees m<br>    ON e.<code>manager_id</code> = m.<code>employee_id</code><br>WHERE e.<code>last_name</code> LIKE “%k%” ;</p><p>外连接</p><p>应用场景：用于查询一个表中有，另一个表没有的记录</p><p>特点：</p><p>外连接的查询结果为主表中的所有记录，如果从表中有和它匹配的，则显示匹配的值，如果从表中没有和它匹配的，则显示null<br>外连接查询结果=内连接结果+主表中有而从表中没有的记录<br>左外连接：left join左边的是主表<br>右外连接：right join右边的是主表<br>左外和右外交换两个表的顺序，可以实现同样的效果<br>圈外链接=内连接的结果+表1中有但表2中没有的+表2中有但表1中没有的</p><p>查询没有男朋友的女神名</p><p>SELECT<br>  b.name,<br>  bo.*<br>FROM<br>  beauty b<br>  LEFT JOIN boys bo<br>    ON b.boyfriend_id = bo.id<br>WHERE bo.<code>id</code> IS NULL ;</p><p>查询哪个部门没有员工</p><p>左外：</p><p>SELECT<br>  d.*,<br>  e.employee_id<br>FROM<br>  departments d<br>  LEFT OUTER JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE e.<code>employee_id</code> IS NULL ;</p><p>右外：</p><p>SELECT<br>  d.*,<br>  e.employee_id<br>FROM<br>  employees e<br>  RIGHT OUTER JOIN departments d<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE e.<code>employee_id</code> IS NULL ;</p><p>全外连接</p><p>mysql不支持</p><p>案例：</p><p>SELECT<br>  b.<em>,<br>  bo.</em><br>FROM<br>  beauty b FULL<br>  OUTER JOIN boys bo<br>    ON b.<code>boyfriend_id</code> = bo.id ;</p><p>交叉连接（也就是笛卡尔乘积）</p><p>案例：</p><p>SELECT<br>  b.<em>,<br>  bo.</em><br>FROM<br>  beauty b<br>  CROSS JOIN boys bo ;</p><p>sql92 和 sql99 pk</p><p>功能：sql99支持的较多<br>可读性：sql99实现连接条件和筛选条件的分离，可读性较高<br>练习：</p><p>查询编号&gt;3的女神的男朋友信息，如果有则列出详细信息，如果没有，则用null填充</p><p>SELECT<br>  a.id,<br>  a.name,<br>  b.*<br>FROM<br>  beauty a<br>  LEFT JOIN boys b<br>    ON a.<code>boyfriend_id</code> = b.<code>id</code><br>WHERE a.<code>id</code> &gt; 3 ;</p><p>查询哪个城市没有部门</p><p>SELECT<br>  city,<br>  d.*<br>FROM<br>  departments d<br>  RIGHT JOIN locations l<br>    ON d.location_id = l.location_id<br>WHERE d.department_id IS NULL ;</p><p>查询部门名为SAL或IT的员工信息</p><p>SELECT<br>  d.<code>department_name</code>,<br>  e.*<br>FROM<br>  departments d<br>  LEFT JOIN employees e<br>    ON d.<code>department_id</code> = e.<code>department_id</code><br>WHERE d.<code>department_name</code> = ‘SAL’<br>  OR d.<code>department_name</code> = ‘IT’ ;</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>含义：出现在其他语句中的select语句，称为子查询或内查询；外部的查询语句，称为主查询或外查询</p><p>嵌套在其他语句内部的select语句成为子查询或内查询</p><p>外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多</p><p>外面如果为select语句，则此语句称为外查询或主查询</p><p>分类：</p><p>按子查询出现的位置：<br>select后面：仅仅支持标量子查询<br>from后面：支持表子查询<br>where或having后面：支持标量子查询，列子查询，行子查询（较少）<br>exists后面（相关子查询）：支持表子查询<br>按功能、结果集的行列数不同：<br>标量子查询（结果集只有一行一列）<br>列子查询（结果集只有一列多行）<br>行子查询（结果集有一行多列）<br>表子查询（结果集一般为多行多列）</p><p>where或having后面</p><ol><li><p>标量子查询（单行子查询）</p></li><li><p>列子查询（多行子查询）</p></li><li><p>行子查询（多列多行）</p></li></ol><p>特点：</p><p>子查询放在小括号内<br>子查询一般放在条件的右侧，where，having<br>标量子查询，一般搭配着单行操作符使用（&gt; &lt; &gt;= &lt;= = &lt;&gt;）<br>列子查询，一般搭配着多行操作符使用（IN、ANY/SOME、ALL）<br>子查询的执行优选与主查询执行，主查询的条件用到了子查询的结果<br>标量子查询<br>案例1：谁的工资比Abel高？</p><p>SELECT<br>  salary<br>FROM<br>  employees<br>WHERE last_name = ‘Abel’ ;</p><p>案例2：返回job_id与141号员工相同，salary比143员工多的员工，姓名，job_id，工资</p><p>SELECT<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE job_id =<br>  (  SELECT<br>      job_id<br>     FROM<br>      employees<br>      WHERE employee_id = 141)<br>  AND salary &gt;<br>  (   SELECT<br>       salary<br>      FROM<br>       employees<br>       WHERE employee_id = 143) ;</p><p>案例3：返回公司工资最少的员工的last_name, job_id和salary</p><p>SELECT<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary =<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees) ;</p><p>案例4：查询最低工资大于50号部门的最低工资的部门id和其最低工资</p><p>SELECT<br>  MIN(salary),<br>  e.<code>department_id</code><br>FROM<br>  employees e<br>GROUP BY e.<code>department_id</code><br>HAVING MIN(salary) &gt;<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees<br>  WHERE department_id = 50) ;</p><p>列子查询<br>（多行子查询）</p><p>多行比较操作符：</p><p>IN/NOT IN：等于列表中的任意一个</p><p>ANY|SOME：和子查询返回的某一个值比较，用的较少</p><p>ALL：和子查询返回的所有值比较</p><p>案例1：返回location_id是1400或1700的部门中的所有员工姓名</p><p>SELECT<br>  last_name<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    departments<br>  WHERE location_id IN (1400, 1700)) ;</p><p>案例2：返回其他工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id以及salary</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt; ANY<br>  (SELECT DISTINCT<br>    salary<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>或者用max代替any</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt;<br>  (SELECT<br>    MAX(salary)<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>案例3：返回其他工种中比job_id为‘IT_PROG’工种所有工资都低的员工的员工号、姓名、job_id以及salary</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt; ALL<br>  (SELECT DISTINCT<br>    salary<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>或者用min代替all</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  job_id,<br>  salary<br>FROM<br>  employees<br>WHERE salary &lt;<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees<br>  WHERE job_id = ‘IT_PROG’)<br>  AND job_id &lt;&gt; ‘IT_PROG’ ;</p><p>行子查询<br>结果集一行多列或多行多列</p><p>案例1：查询员工编号最少并且工资最高的员工信息<br>把两个合在一起一起查询.<br>SELECT </p><ul><li>FROM<br>employees<br>WHERE (employee_id, salary) =<br>(SELECT<br>MIN(employee_id),<br>MAX(salary)<br>FROM<br>employees) ;</li></ul><p>select后面<br>仅仅支持标量子查询</p><p>案例1：查询每个部门的员工个数</p><p>SELECT<br>  d.<em>,<br>  (SELECT<br>    COUNT(</em>)<br>  FROM<br>    employees e<br>  WHERE e.department_id = d.department_Id) 个数<br>FROM<br>  departments d ;</p><p>案例2：查询员工号=102的部门名</p><p>SELECT<br>  (SELECT<br>    department_name<br>  FROM<br>    departments d<br>    INNER JOIN employees e<br>      ON d.department_id = e.department_id<br>  WHERE e.employee_id = 102) 部门名 ;</p><p>from后面<br>将子查询结果充当一张表，要求必须起别名</p><p>案例1：查询每个部门的平均工资的工资等级</p><p>SELECT<br>  ag_dep.*,<br>  g.<code>grade_level</code><br>FROM<br>  (SELECT<br>    AVG(salary) ag,<br>    department_id<br>  FROM<br>    employees<br>  GROUP BY department_id) ag_dep<br>  INNER JOIN job_grades g<br>    ON ag_dep.ag BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p><p>exists后面<br>相关子查询</p><p>语法：exists（完整的查询语句）</p><p>结果：1或0</p><p>案例1：查询有员工的部门名</p><p>SELECT<br>  department_name<br>FROM<br>  departments d<br>WHERE EXISTS<br>  (SELECT<br>    *<br>  FROM<br>    employees e<br>  WHERE d.<code>department_id</code> = e.<code>department_id</code>) ;</p><p>用in更简单</p><p>SELECT<br>  department_name<br>FROM<br>  departments d<br>WHERE d.<code>department_id</code> IN<br>  (SELECT<br>    department_id<br>  FROM<br>    employees e) ;</p><p>习题集</p><p>查询和zlotkey相同部门的员工姓名和工资</p><p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE department_id =<br>  (SELECT<br>    department_id<br>  FROM<br>    employees e<br>  WHERE e.<code>last_name</code> = ‘Zlotkey’) ;</p><p>查询工资比公司平均工资高的员工的员工号，姓名和工资</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  salary<br>FROM<br>  employees e<br>WHERE e.<code>salary</code> &gt;<br>  (SELECT<br>    AVG(salary)<br>  FROM<br>    employees) ;</p><p>查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资</p><p>SELECT<br>  employee_id,<br>  last_name,<br>  salary<br>FROM<br>  employees e<br>  INNER JOIN<br>    (SELECT<br>      AVG(salary) ag,<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id) nt<br>    ON nt.department_id = e.department_id<br>WHERE salary &gt; ag ;</p><p>查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</p><p>SELECT<br>  employee_id,<br>  last_name<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    employees<br>  WHERE last_name LIKE ‘%u%’) ;</p><p>查询在部门的location_id为1700的部门工作的员工的员工号</p><p>SELECT<br>  employee_id<br>FROM<br>  employees<br>WHERE department_id IN<br>  (SELECT DISTINCT<br>    department_id<br>  FROM<br>    departments<br>  WHERE location_id = 1700) ;</p><p>查询管理者是King的员工姓名和工资</p><p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE manager_id IN<br>  (SELECT<br>    employee_id<br>  FROM<br>    employees<br>  WHERE last_name = ‘K_ing’) ;</p><p>查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名</p><p>SELECT<br>  CONCAT(nt.first_name, nt.last_name) “姓.名”<br>FROM<br>  (SELECT<br>    first_name,<br>    last_name<br>  FROM<br>    employees<br>  WHERE salary =<br>    (SELECT<br>      MAX(salary)<br>    FROM<br>      employees)) nt ;</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p><p>语法：</p><p>select 查询列表</p><p>from 表</p><p>【join type】 join 表2</p><p>on 连接条件</p><p>where 筛选条件</p><p>group by 分组字段</p><p>having 分组后的筛选</p><p>order by 排序的字段】</p><p>limit offset，size；</p><p>offset：要显示条目的起始索引（从0开始）</p><p>size：要显示的条目个数</p><p>特点：</p><p>limit语句放在查询语句的最后</p><p>公式：</p><p>要显示的页数page，每页的条目数size</p><p>select 查询列表</p><p>from 表</p><p>limit （page - 1）* size， size；</p><p>案例1：查询前5条员工信息</p><p>SELECT * FROM employees LIMIT 0, 5;<br>或者<br>SELECT * FROM employees LIMIT 5;</p><p>案例2：查询第11条-第25条</p><p>SELECT * FROM employees LIMIT 10, 15;<br>1<br>案例3：有奖金的员工信息，并且工资较高的前10名显示出来</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE commission_pct IS NOT NULL<br>ORDER BY salary DESC<br>LIMIT 10 ;</li></ul><p>经典案例1：</p><p>查询工资最低的员工信息：last_name, salary</p><p>SELECT<br>  last_name,<br>  salary<br>FROM<br>  employees<br>WHERE salary =<br>  (SELECT<br>    MIN(salary)<br>  FROM<br>    employees) ;</p><p>查询平均工资最低的部门信息</p><p>SELECT </p><ul><li>FROM<br>departments<br>WHERE department_id =<br>(SELECT<br>department_id<br>FROM<br>employees<br>GROUP BY department_id<br>ORDER BY AVG(salary) ASC<br>LIMIT 1) ;</li></ul><p>查询平均工资最低的部门信息和该部门的平均工资</p><p>SELECT<br>  d.*,<br>  dd.ag<br>FROM<br>  departments d<br>  INNER JOIN<br>    (SELECT<br>      AVG(salary) ag,<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id<br>    ORDER BY ag<br>    LIMIT 1) dd<br>    ON d.<code>department_id</code> = dd.department_id ;</p><p>查询平均工资最高的job信息</p><p>SELECT </p><ul><li>FROM<br>jobs j<br>WHERE j.<code>job_id</code> =<br>(SELECT<br>job_id<br>FROM<br>employees<br>GROUP BY job_id<br>ORDER BY AVG(salary) DESC<br>LIMIT 1) ;</li></ul><p>查询平均工资高于公司平均工资的部门有哪些</p><p>SELECT<br>  AVG(salary) ag,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING ag &gt;<br>  (SELECT<br>    AVG(salary)<br>  FROM<br>    employees) ;</p><p>查询出公司中所有manager的详细信息</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE employee_id IN<br>(SELECT DISTINCT<br>manager_id<br>FROM<br>employees<br>WHERE manager_id IS NOT NULL) ;</li></ul><p>各个部门中，最高工资中，最低的那个部门的最低工资是多少</p><p>SELECT<br>  MIN(salary)<br>FROM<br>  employees<br>WHERE department_id =<br>  (SELECT<br>    department_id<br>  FROM<br>    employees<br>  GROUP BY department_id<br>  ORDER BY MAX(salary) ASC<br>  LIMIT 1) ;</p><p>查询平均工资最高的部门的manager的详细信息</p><p>SELECT<br>  last_name,<br>  department_id,<br>  email,<br>  salary<br>FROM<br>  employees<br>WHERE employee_id =<br>  (SELECT DISTINCT<br>    manager_id<br>  FROM<br>    employees<br>  WHERE department_id =<br>    (SELECT<br>      department_id<br>    FROM<br>      employees<br>    GROUP BY department_id<br>    ORDER BY AVG(salary) DESC<br>    LIMIT 1)<br>    AND manager_id IS NOT NULL) ;</p><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>union：联合，合并，将多条查询语句的结果合并成一个结果</p><p>引入案例：查询部门编号&gt;90或邮箱包含a的员工信息</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE email LIKE “%a%”<br>OR department_id &gt; 90 ;</li></ul><p>用联合查询为：</p><p>SELECT </p><ul><li>FROM<br>employees<br>WHERE email LIKE “%a%”<br>UNION<br>SELECT </li><li>FROM<br>employees<br>WHERE department_id &gt; 90;</li></ul><p>语法：</p><p>查询语句1</p><p>union 【ALL】</p><p>查询语句2</p><p>union 【ALL】</p><p>…</p><p>应用场景：要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致</p><p>特点：</p><p>要求多条查询语句的查询列数是一致的<br>要求多条查询语句的查询的每一列的类型和顺序最好是一致的<br>union关键字默认去重，如果使用union all可以包含重复项</p><h4 id="查询总结"><a href="#查询总结" class="headerlink" title="查询总结"></a>查询总结</h4><p>语法：</p><p>select 查询列表 7</p><p>from 表1 别名 1</p><p>连接类型 join 表2 2</p><p>on 连接条件 3</p><p>where 筛选 4</p><p>group by 分组列表 5</p><p>having 筛选 6</p><p>order by 排序列表 8</p><p>limit 排序列表 9</p><h3 id="DML（Data-Manipulation-Language）数据操作语言"><a href="#DML（Data-Manipulation-Language）数据操作语言" class="headerlink" title="DML（Data Manipulation Language）数据操作语言"></a>DML（Data Manipulation Language）数据操作语言</h3><p>涉mZ到数据的<br>插入：insert<br>修改：update<br>删除：delete</p><h4 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h4><p>方式1：</p><p>语法：insert into 表名（列名，…） values（值1，…）</p><p>示例1：插入的值的类型要与列的类型一致或兼容</p><p>INSERT INTO beauty (<br>  id,<br>  NAME,<br>  sex,<br>  borndate,<br>  phone,<br>  photo,<br>  boyfriend_id<br>)<br>VALUES<br>  (<br>    13,<br>    ‘唐艺昕’,<br>    ‘女’,<br>    ‘1990-4-23’,<br>    ‘18934531234’,<br>    NULL,<br>    2<br>  );</p><p>示例2：不可以为null的列必须插入值。可以为null的列如何插入值？</p><p>方式1：字段的值写null<br>方式2：不写该字段</p><p>示例3：列的顺序是否可以调换</p><p>INSERT INTO beauty(NAME, sex, id, phone)<br>VALUES(‘蒋欣’, ‘女’, 16, ‘110’);</p><p>示例4：列数和值的个数必须一致</p><p>示例5：可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</p><p>INSERT INTO beauty<br>VALUES(18, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL);<br>1<br>2<br>方式2：</p><p>语法：insert into 表名 set 列名=值，列名=值，…</p><p>INSERT INTO beauty SET id = 19,<br>NAME = ‘刘涛’,<br>phone = ‘999’ ;</p><p>两种方式大pk</p><p>方式1支持插入多行，但是方式2不支持</p><p>INSERT INTO beauty<br>VALUES<br>(20, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL),<br>(21, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL),<br>(22, ‘李易峰’, ‘男’, NULL, ‘19’, NULL, NULL);</p><p>方式1支持子查询，方式2不支持</p><p>INSERT INTO beauty(id, NAME, phone)<br>SELECT 26, ‘送钱’, ‘12341234’;</p><ol start="2"><li>修改语句<br>语法：</li></ol><p>修改单表的记录</p><p>update 表名</p><p>set 列=新值，列=新值…</p><p>where 筛选条件；</p><p>修改多表的记录</p><p>sql92语法</p><p>update 表1 别名，表2 别名</p><p>set 列=值…</p><p>where 筛选条件</p><p>and 筛选条件；</p><p>sql99语法：</p><p>update 表1 别名</p><p>inner | left | right join 表2 别名</p><p>on 连接条件</p><p>set 列=值，…</p><p>where 筛选条件；</p><p>修改单表的记录<br>案例1：修改beauty表中姓唐的女神电话为109090909</p><p>UPDATE<br>  beauty<br>SET<br>  phone = ‘109090909’<br>WHERE NAME LIKE ‘唐%’ ;</p><p>案例2：修改boys表中id号位2的名称为张飞，魅力值为10</p><p>UPDATE<br>  boys<br>SET<br>  boyname = ‘张飞’,<br>  usercp = 10<br>WHERE id = 2 ;</p><p>修改多表的记录<br>案例1：修改张无忌的女朋友的手机号为114</p><p>UPDATE<br>  boys b<br>  INNER JOIN beauty be<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code> SET be.<code>phone</code> = ‘114’<br>WHERE b.<code>boyName</code> = ‘张无忌’ ;</p><p>案例2：修改没有男朋友的女神的男朋友编号都为 2号</p><p>UPDATE<br>  boys b<br>  RIGHT JOIN beauty be<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code> SET be.<code>boyfriend_id</code> = 2<br>WHERE be.<code>boyfriend_id</code> IS NULL ;</p><ol start="3"><li>删除语句<br>方式1：delete</li></ol><p>语法</p><p>单表的删除</p><p>delete from 表名 where 筛选条件</p><p>多表的删除</p><p>sql92语法</p><p>delete 别名（要删哪个表就写哪个表的别名，都删就都写）</p><p>from 表1 别名，表2 别名</p><p>where 连接条件</p><p>and 筛选条件</p><p>limit 条目数；</p><p>sql99语法</p><p>delete 别名（要删哪个表就写哪个表的别名，都删就都写）</p><p>from 表1 别名</p><p>inner | left | right join 表2 别名 on 连接条件</p><p>where 筛选条件</p><p>limit 条目数；</p><p>案例1：删除手机号以9结尾的女神信息</p><p>DELETE<br>FROM<br>  beauty<br>WHERE phone LIKE ‘%9’ ;</p><p>案例2：删除张无忌的女朋友的信息</p><p>DELETE<br>  be<br>FROM<br>  beauty be<br>  INNER JOIN boys b<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code><br>WHERE b.<code>boyName</code> = ‘张无忌’ ;</p><p>案例3：删除黄晓明的信息以及他女朋友的信息</p><p>DELETE<br>  b,<br>  be<br>FROM<br>  beauty be<br>  INNER JOIN boys b<br>    ON b.<code>id</code> = be.<code>boyfriend_id</code><br>WHERE b.<code>boyName</code> = ‘黄晓明’ ;</p><p>方式2：truncate</p><p>语法</p><p>truncate table 表名；</p><p>truncate语句中不许加where</p><p>一删全删</p><p>TRUNCATE TABLE boyes ;<br>1<br>delete pk truncate</p><p>delete可以加where条件，truncate不可以<br>truncate删除效率高一些<br>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。<br>truncate删除没有返回值，delete删除有返回值<br>truncate删除不能回滚，delete删除可以回滚<br>DDL（Data Definition Language）数据定义语言<br>库和表的管理<br>库的管理：创建、修改、删除<br>标的管理：创建、修改、删除<br>创建：create<br>修改：alter<br>删除：frop</p><ol><li>库的管理<br>库的创建</li></ol><p>语法：create database [if not exists] 库名 [character set 字符集名]；</p><p>案例：创建库book</p><p>CREATE DATABASE IF NOT EXISTS books;<br>1<br>库的修改</p><p>修改库名的语句【已停用】</p><p>RENAME DATABASE books TO new_books;<br>1<br>更改库的字符集</p><p>ALTER DATABASE books CHARACTER SET gbk;<br>1<br>库的删除</p><p>DROP DATABASE IF EXISTS books;<br>1</p><h4 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h4><p>表的创建</p><p>语法：<br>create table 【if not exists】 表名(</p><p>​ 列名 列的类型【（长度） 约束】，</p><p>​ 列名 列的类型【（长度） 约束】，</p><p>​ …</p><p>)</p><p>案例1：创建表 book</p><p>CREATE TABLE book (<br>  id INT,<br>  bname VARCHAR (20),<br>  price DOUBLE,<br>  authorid INT,<br>  publishdate DATETIME<br>) ;</p><p>案例2：创建表author</p><p>CREATE TABLE author (<br>  id INT,<br>  au_name VARCHAR (20),<br>  nation VARCHAR (10)<br>) ;</p><p>案例3：查看创建的表</p><p>DESC author;<br>1<br>表的修改</p><p>语法：alter table 表名 add | drop | modify | change column 列名 【列类型 约束】；</p><p>添加列：alter table 表名 add column 列名 类型 【first | after 字段名】；</p><p>修改列的类型或约束：alter table 表名 modify column 列名 新类型 【新约束】；</p><p>修改列名：alter table 表名 change column 旧列名 新列名 类型；</p><p>删除列：alter table 表名 drop column 列名；</p><p>修改表名：alter table 表名 rename 【to】 新表名；</p><p>修改列名</p><p>ALTER TABLE book<br>  CHANGE COLUMN publishdate pubdate DATETIME ;</p><p>修改列的类型或约束</p><p>ALTER TABLE book<br>  MODIFY COLUMN pubdate TIMESTAMP ;</p><p>添加新列</p><p>ALTER TABLE author<br>  ADD COLUMN annual DOUBLE ;</p><p>删除列</p><p>ALTER TABLE author<br>  DROP COLUMN annual ;</p><p>修改表名</p><p>ALTER TABLE author<br>  RENAME TO book_author ;</p><p>表的删除</p><p>语法：drop table if exists 表名；</p><p>查看有哪些表：show tables；</p><p>if exists 只能在库，表的创建和删除的时候使用，列的操作不能使用。</p><p>通用的写法：</p><p>DROP DATABASE IF EXISTS 旧库名;<br>CREATE DATABASE 新库名;</p><p>DROP TABLE IF EXISTS 旧表名;<br>CREATE TABLE 表名();</p><p>表的复制</p><p>仅仅复制表的结构</p><p>CREATE TABLE copy LIKE book_author ;<br>1<br>复制表的结构+数据</p><p>CREATE TABLE copy2<br>SELECT </p><ul><li>FROM<br>book_author ;</li></ul><p>只复制部分数据</p><p>CREATE TABLE copy3<br>SELECT<br>  id,<br>  au_name<br>FROM<br>  book_author<br>WHERE nation = ‘中国’ ;</p><p>仅仅复制某些字段（部分结构）：设置where不满足，那么就没有数据</p><p>CREATE TABLE copy4<br>SELECT<br>  id,<br>  au_name<br>FROM<br>  book_author<br>WHERE 0 ;</p><p>习题集</p><p>创建表dept1</p><p>USE myemployees;<br>CREATE TABLE dept1 (id INT (7), NAME VARCHAR (25)) ;</p><p>将表departments中的数据插入新表dept2中</p><p>CREATE TABLE dept2<br>SELECT<br>  department_id,<br>  department_name<br>FROM<br>  departments ;</p><p>创建表emp5</p><p>CREATE TABLE emp5 (<br>  id INT (7),<br>  first_name VARCHAR (25),<br>  last_name VARCHAR (25),<br>  dept_id INT (7)<br>) ;</p><p>将last_name的长度修改为50</p><p>ALTER TABLE emp5 MODIFY COLUMN last_name VARCHAR(50);<br>1<br>根据表employees创建employee2</p><p>CREATE TABLE employee2 LIKE employees ;<br>1<br>删除表emp5</p><p>DROP TABLE IF EXISTS emp5;<br>1<br>将表empoyees2重命名为emp5</p><p>ALTER TABLE employee2<br>  RENAME TO emp5 ;</p><p>在表dept和emp5中添加新列test_column，并检查所做的操作</p><p>ALTER TABLE emp5<br>  ADD COLUMN test_column INT ;<br>DESC emp5;</p><p>直接删除表emp5中的列dept_id</p><p>ALTER TABLE emp5<br>  DROP COLUMN dept_id ;</p><h4 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h4><p>数值型：<br>整型<br>浮点型<br>定点数<br>浮点数<br>字符型：<br>较短的文本：char、varchar<br>较长的文本：text、blob（较长的二进制数据）<br>日期型：<br>整型<br>分类：Tinyint、Smallint、Mediumint、int/integer、bigint<br>特点<br>如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值<br>如果不设置长度，会有默认的长度，长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用，并且默认变为无符号的整型！</p><p>小数<br>分类<br>浮点型<br>float（M，D）<br>double（M，D）<br>定点型<br>dec（M，D）<br>decimal（M，D）<br>特点<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值<br>M和D都可以省略，如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度<br>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用定点型<br>原则：所选择的类型越简单越好，能保存数值的类型越小越好</p><p>字符型<br>较短的文本：char、varchar<br>较长的文本：text，blob<br>特点：<br>写法 M的意思 特点 空间耗费 效率<br>char char(M) 最大的字符数，可以省略，默认为1 固定长度的字符 比较耗费 高<br>varchar varchar(M) 最大的字符数，不可以省略 可变长度的字符 比较节省 低</p><p>其他类型<br>binary和varbinary用于保存较短的二进制<br>enum：枚举，eg. enum(‘男’, ‘女’)<br>set：集合，eg. set(‘a’, ‘b’, ‘c’, ‘d’)<br>日期型<br>分类：<br>date：只保存日期<br>time：值保存时间<br>year：值保存年<br>datetime：保存日期+时间<br>timestamp：保存日期+时间，更能反映真实时间<br>特点：<br>​ 字节 范围 时区等的影响<br>datetime 8 1000-9999 不受<br>timestamp 4 1970-2038 受</p><h4 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h4><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><p>分类：六大约束</p><p>not null：非空，用于保证该字段的值不能为空。比如姓名、学号等。<br>default：默认，用于保证该字段有默认值。比如性别。<br>primary key：主键，用于保证该字段的值具有唯一性，并且非空。比如学号、员工编号等。<br>unique：唯一，用于保证该字段的值具有唯一性，可以为空。比如座位号。<br>check：检查约束【mysql中不支持】。不日年龄、性别。<br>foreign key：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。在从表添加外键约束，用于应用主表中某列的值。比如学生表的专业编号，员工表的部门编号，员工表的工种编号。<br>添加约束的时机：</p><p>创建表时<br>修改表时<br>约束添加的分类：</p><p>列级约束：六大约束语法上都支持，但外键约束没有效果</p><p>表级约束：除了非空、默认，其他的都支持</p><p>位置    支持的约束类型    是否可以起约束名<br>列级约束    列的后面    语法都支持，但外键没有效果    不可以<br>表级约束    所有列的下面    默认和非空不支持，其他支持    可以（主键没有效果）<br>创建表时添加约束<br>添加列级约束</p><p>CREATE DATABASE students;<br>USE students;</p><p>CREATE TABLE stuinfo (<br>  id INT PRIMARY KEY,<br>  stuname VARCHAR (20) NOT NULL,    # 非空<br>  gender CHAR(1) CHECK (gender = ‘男’<br>    OR gender = ‘女’),<br>  seat INT UNIQUE,    # 唯一<br>  age INT DEFAULT 18,    # 默认<br>  majorID INT REFERENCES major (id)<br>) ;</p><p>CREATE TABLE major (<br>  id INT PRIMARY KEY,<br>  majorName VARCHAR (20)<br>) ;</p><p>DESC stuinfo;<br>SHOW INDEX FROM stuinfo;</p><p>语法：直接在字段名和类型后面追加约束类型即可。<br>只支持：默认、非空、主键、唯一（除了外键都支持）<br>添加表级约束</p><p>DROP TABLE IF EXISTS stuinfo ;</p><p>CREATE TABLE stuinfo(<br>id INT,<br>stuname VARCHAR(20),<br>gender CHAR(1),<br>seat INT,<br>age INT,<br>majorid INT,</p><p>CONSTRAINT pk PRIMARY KEY(id),<br>CONSTRAINT uq UNIQUE(seat),<br>CONSTRAINT ck CHECK(gender=’男’ OR gender=’女’),<br>CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)<br>);</p><p>SHOW INDEX FROM stuinfo;</p><p>语法：在各个字段的最下面</p><p>【constraint 约束名】 约束类型（字段名）</p><p>除了非空、默认，其他的都支持</p><p>通用的写法：</p><p>CREATE TABLE IF NOT EXISTS stuinfo (<br>  id INT PRIMARY KEY,<br>  stuname VARCHAR (20) NOT NULL,<br>  gender CHAR(1),<br>  seat INT UNIQUE,<br>  age INT DEFAULT 18,<br>  majorID INT,<br>  CONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major (id)<br>) ;</p><p>表级约束pk列级约束</p><p>支持类型    可以起约束名与否<br>列级约束    除了外键    不可以<br>表级约束    除了非空和默认    可以，但对主键无效<br>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p><p>主键和唯一的大对比</p><pre><code>   保证唯一性    是否允许为空    一个表中可以有多少个    是否允许组合</code></pre><p>1<br>主键 √ × 至多有1个 √，但不推荐<br>唯一 √ √ 可以有多个 √，但不推荐<br>外键特点</p><p>要求在从表设置外键关系</p><p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p><p>主表的关联列必须是一个key（一般是主键或唯一）</p><p>插入数据时，先插入主表，再插入从表</p><p>删除数据时，先删除从表，再删除主表</p><p>方式1：级联删除</p><p>ALTER TABLE stuinfo ad CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;<br>1<br>删除的时候，主表和从表对应的行都删了。</p><p>方式2：级联置空</p><p>ALTER TABLE stuinfo ad CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;<br>1<br>删除的时候，主表对应的行被删除了，从表引入的地方变为空值null。</p><p>修改表时添加约束<br>添加列级约束：alter table 表名 modify column 字段名 字段类型 新约束；</p><p>添加表级约束：alter table 表名 add 【constraint 约束名】 约束类型（字段名）【外键的引用】；</p><p>添加非空约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL;<br>1<br>添加默认约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;<br>1<br>添加主键</p><h4 id="列级约束的写法"><a href="#列级约束的写法" class="headerlink" title="列级约束的写法"></a>列级约束的写法</h4><p>ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</p><h5 id="表级约束的写法"><a href="#表级约束的写法" class="headerlink" title="表级约束的写法"></a>表级约束的写法</h5><p>ALTER TABLE stuinfo ADD PRIMARY KEY(id);</p><p>添加唯一</p><h5 id="列级约束的写法-1"><a href="#列级约束的写法-1" class="headerlink" title="列级约束的写法"></a>列级约束的写法</h5><p>ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</p><h5 id="表级约束的写法-1"><a href="#表级约束的写法-1" class="headerlink" title="表级约束的写法"></a>表级约束的写法</h5><p>ALTER TABLE stuinfo ADD UNIQUE(seat);</p><p>添加外键</p><p>ALTER TABLE (CONSTRAINT fk_stuinfo_major) stuinfo ADD FOREIGN KEY(majorid) REFERENCES major(id);<br>1<br>修改表时删除约束<br>删除非空约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;<br>1<br>删除默认约束</p><p>ALTER TABLE stuinfo MODIFY COLUMN age INT;<br>1<br>删除主键</p><p>ALTER TABLE stuinfo DROP PRIMARY KEY;<br>1<br>删除唯一</p><p>ALTER TABLE stuinfo DROP INDEX seat;<br>1<br>删除外键</p><p>ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;<br>1<br>总结</p><p>非空</p><p>添加非空：alter table 表名 modify column 字段名 字段类型 not null；</p><p>删除非空：alter table 表名 modify column 字段名 字段类型；</p><p>默认</p><p>添加默认：alter table 表名 modify column 字段名 字段类型 default；</p><p>删除默认：alter table 表名 modify column 字段名 字段类型；</p><p>主键</p><p>添加主键：alter table 表名 add 【constraint 约束名】 primary key（字段名）；</p><p>删除主键：alter table 表名 drop primary key；</p><p>唯一</p><p>添加唯一：alter table 表名 add 【constraint 约束名】unique（字段名）；</p><p>删除唯一：alter table 表名 drop index 索引名；</p><p>外键</p><p>添加外键：alter table 表名 add 【constraint 约束名】foreign key（字段名） references 主表（被引用列）；</p><p>删除唯一：alter table 表名 drop foreign key 约束名；</p><h4 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h4><p>又称为自增长列</p><p>含义：可以不用手动的插入值，系统提供默认的序列值</p><p>特点：</p><p>标识列必须和主键搭配吗？不一定，但要求是一个key。<br>一个表可以有几个标识列？至多一个。<br>标识列的类型？只能是数值型（int（一般是int），float，double）<br>标识列可以通过**SET auto_increment_increment = 1;**设置步长；可以通过手动插入值设置起始值。<br>创建表时设置表时列</p><p>create table 表（</p><p>​ 字段名 字段类型 约束 auto_increment</p><p>）</p><p>CREATE TABLE tab_identity (<br>  id INT PRIMARY KEY AUTO_INCREMENT,<br>  NAME varcahr (20)<br>) ;</p><p>设置表时列的步长</p><p>SHOW VARIABLES LIKE ‘%auto_increment%’;<br>SET auto_increment_increment = 3;<br>1<br>2<br>设置表时列的起始值：想在什么地方更改自增长列的值，则手动插入值（不手动的时候，值是null）。</p><p>修改表时设置标识列</p><p>alter table 表 modify column 字段名 字段类型 约束 auto_increment</p><p>ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;<br>1<br>修改表时删除标识列</p><p>alter table 表 modify column 字段名 字段类型 约束</p><p>ALTER TABLE tab_identity MODIFY COLUMN id INT;<br>1</p><h3 id="TCL（Transaction-Control-Language）事务控制语言"><a href="#TCL（Transaction-Control-Language）事务控制语言" class="headerlink" title="TCL（Transaction Control Language）事务控制语言"></a>TCL（Transaction Control Language）事务控制语言</h3><p>事务的含义：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p><p>存储引擎：在mysql中的数据用各种不同的技术存储在文件（或内存）中。</p><p>通过show engines来查看mysql支持的存储引擎。<br>在mysql中用的最多的存储引擎有：innodb、myisam、memory等。其中innodb支持事务，而myisam、memory等不支持事务。<br>事务的ACID属性</p><p>原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。<br>隔离性（Isolation）：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。<br>事务的创建</p><p>隐式事务：事务没有明显的开启和结束的标记。比如insert、update、delete语句</p><p>显式事务：事务具有明显的开启和结束的标记</p><p>前提：必须先设置自动提交功能为禁用</p><p>SET autocommit=0;<br>1<br>步骤1：开启事务</p><p>SET autocommit=0;<br>START TRANSACTION;（可选）<br>2<br>步骤2：编写事务中的sql语句(select insert update delete，只有增删改查，不包括DDL语言)</p><p>语句1；</p><p>语句2；</p><p>…</p><p>步骤3：结束事务</p><p>commit；提交事务</p><p>rollback；回滚事务</p><p>savepoint 结点名：设置保存点</p><p>SET autocommit = 0 ;</p><p>START TRANSACTION;<br>DELETE FROM account WHERE id=25;<br>SAVEPOINT a;<br>DELETE FROM accound WHERE id=28;<br>ROLLBACK TO a;</p><p>delete和truncate在事务使用时的区别</p><p>delete删除后支持回滚<br>SET autocommit = 0 ;<br>START TRANSACTION;<br>DELETE FROM account;<br>ROLLBACK;</p><p>truncate删除后不支持回滚<br>SET autocommit = 0 ;<br>START TRANSACTION;<br>TRUNCATE TABLE account;<br>ROLLBACK;</p><p>数据库的隔离级别</p><p>对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：<br>脏读：对于两个事务T1，T2。T1读取了已经被T2更新但还没有被提交的字段之后，若T2回滚，T1读取的内容就是临时且无效的。主要是其他事务更新的数据<br>不可重复读：对于两个事务T1，T2。T1读取了一个字段，然后T2更新了该字段之后，T1再次读取同一个字段，值就不同了。<br>幻读：对于两个事务T1，T2。T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行之后，如果T1再次读取同一个表，就会多出几行。主要是其他事务插入的数据<br>数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。<br><strong>一个事务与其他事务隔离的程度称为隔离级别。</strong>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性弱。<br>数据库提供的4种事务隔离级别：img<br>Oracle支持2种事务隔离级别：READ COMMITED，SERIALIZABLE。Oracle默认的事务隔离级别是：READ COMMITED。<br>Mysql支持4种事务隔离级别。Mysql默认的事务隔离级别为：REPEATABLE READ。<br>每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前事务隔离级别。<br>查看当前的隔离级别：select @@tx_isolation;<br>设置当前mysql连接的隔离级别：set transaction isolation level read committed;<br>设置数据库系统的全局的隔离级别：set global transaction isolation level read committed;</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>含义：虚拟表，和普通表一样使用。并且使用视图时动态生成的，值保存了sql逻辑，不保存成查询结果。</p><p>mysql5.1版本出现的新特性，是通过表动态生成的数据</p><p>应用场景：</p><p>多个地方用到同样的查询结果<br>该查询结果使用的sql语句较复杂<br>案例1：查询姓张的学生名和专业名</p><p>普通写法<br>SELECT<br>  stuname,<br>  majorname<br>FROM<br>  suinfo s<br>  INNER JOIN major m<br>    ON s.majorid = m.<code>id</code><br>WHERE s.stuname LIKE ‘张%’ ;</p><p>视图写法<br>CREATE VIEW v1 AS<br>SELECT<br>  stuname,<br>  majorname<br>FROM<br>  suinfo s<br>  INNER JOIN major m<br>    ON s.majorid = m.<code>id</code> ;</p><p>SELECT </p><ul><li>FROM<br>v1<br>WHERE stuname LIKE ‘张%’ ;</li></ul><p>创建视图</p><p>语法：</p><p>create view 视图名 as 查询语句；</p><p>视图的好处：</p><p>重用sql语句<br>简化复杂的sql操作，不必知道它的查询细节<br>保护数据，提高安全性<br>练习题：</p><p>习题1：查询姓名中包含a字符的员工名、部门名和工种信息</p><p>CREATE VIEW myv1 AS<br>SELECT<br>  last_name,<br>  department_name,<br>  job_title<br>FROM<br>  employees e<br>  JOIN departments d<br>    ON e.<code>department_id</code> = d.<code>department_id</code><br>  JOIN jobs j<br>    ON j.<code>job_id</code> = e.<code>job_id</code> ;</p><p>SELECT </p><ul><li>FROM<br>myv1<br>WHERE last_name LIKE ‘%a%’ ;</li></ul><p>习题2：查询各部门的平均工资级别</p><h5 id="创建视图查看每个部门的平均工资"><a href="#创建视图查看每个部门的平均工资" class="headerlink" title="创建视图查看每个部门的平均工资"></a>创建视图查看每个部门的平均工资</h5><p>CREATE VIEW myv2 AS<br>SELECT<br>  AVG(salary) ag,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id ;</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>SELECT<br>  myv2.<code>ag</code>,<br>  g.grade_level<br>FROM<br>  myv2<br>  JOIN job_grades g<br>    ON myv2.<code>ag</code> BETWEEN g.<code>lowest_sal</code><br>    AND g.<code>highest_sal</code> ;</p><p>习题3：查询平均工资最低的部门信息</p><h5 id="用习题2的视图myv2"><a href="#用习题2的视图myv2" class="headerlink" title="用习题2的视图myv2"></a>用习题2的视图myv2</h5><p>SELECT </p><ul><li>FROM<br>myv2<br>ORDER BY ag<br>LIMIT 1 ;</li></ul><p>习题4：查询平均工资最低的部门名和工资</p><p>CREATE VIEW myv3 AS<br>SELECT </p><ul><li>FROM<br>myv2<br>ORDER BY ag LIMIT 1 ;</li></ul><p>SELECT<br>  d.*,<br>  m.<code>ag</code><br>FROM<br>  myv3 m<br>  JOIN departments d<br>    ON m.<code>department_id</code> = d.<code>department_id</code> ;</p><p>视图的修改</p><p>方式1：create or replace view 视图名 as 查询语句；<br>方式2：alter view 视图名 as 查询语句；<br>删除视图</p><p>语法：drop view 视图名，视图名，…；<br>查看视图</p><p>语法：</p><p>show create view 视图名；</p><p>desc 视图名；</p><p>案例1：创建一个视图emp_v1，要求查询电话号码以‘011’开头的员工姓名和工资、邮箱</p><p>CREATE OR REPLACE VIEW emp_v1 AS<br>SELECT<br>  last_name,<br>  salary,<br>  email<br>FROM<br>  employees<br>WHERE phone_number LIKE ‘011%’ ;</p><p>案例2：创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息</p><p>CREATE OR REPLACE VIEW emp_v2 AS<br>SELECT<br>  MAX(salary) mx,<br>  department_id<br>FROM<br>  employees<br>GROUP BY department_id<br>HAVING MAX(salary) &gt; 12000 ;</p><p>SELECT </p><ul><li>FROM<br>emp_v2 ;</li></ul><p>SELECT<br>  d.*,<br>  m.mx<br>FROM<br>  departments d<br>  JOIN emp_v2 m<br>    ON m.department_id = d.<code>department_id</code> ;</p><p>视图的更新</p><p>增、删、改（视图基于的表也会发生更改）</p><p>CREATE OR REPLACE VIEW myv1 AS<br>SELECT<br>  last_name,<br>  email<br>FROM<br>  employees;</p><p>SELECT * FROM myv1;</p><h5 id="mZ插入"><a href="#mZ插入" class="headerlink" title="mZ插入"></a>mZ插入</h5><p>INSERT INTO myv1 VALUES(‘张飞’, ‘zhangfei’);</p><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>UPDATE myv1 SET last_name=’张无忌’ WHERE last_name = ‘张飞’;</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>DELETE FROM myv1 WHERE last_name=’张无忌’;</p><p>视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的。（注意：视图一般用于查询，而不是更新。）</p><p>包含以下关键字的sql语句：分组函数、distinct、group by、having、union或union all<br>常量视图<br>select中包含子查询<br>join<br>from 一个不能更新的视图<br>where子句的子查询应用了from子句中的表<br>视图和表的对比</p><p>创建语法的关键字    是否实际占用物理空间    使用<br>视图    create view    只是保存了sql逻辑    增删改查，一般不能增删改<br>表    create table    保存了实际的数据    增删改查<br>测试题</p><p>题1：创建表</p><p>CREATE TABLE book (<br>  bid INT PRIMARY KEY,<br>  bname VARCHAR (20) UNIQUE nut NULL,<br>  price FLOAT DEFAULT 10,<br>  btypeid INT,<br>  FOREIGN KEY (btypeid) REFERENCES booktype (id)<br>) ;</p><p>题2：开启事务，向表中插入1行数据，并结束</p><p>SET autocommit = 0 ;<br>INSERT INTO book(bid, bname, price, btypeid)<br>VALUES(1, ‘小李飞刀’, 100, 1);<br>COMMIT;</p><p>题3：创建视图，实现查询价格大于100的书名和类型名</p><p>CREATE VIEW myv1 AS<br>SELECT<br>  bname,<br>  NAME<br>FROM<br>  book b<br>  INNER JOIN booktype t<br>    ON b.btypeid = t.id<br>WHERE price &gt; 100 ;</p><p>题4：修改视图，实现查询价格在90-120之间的书名和价格</p><p>CREATE OR REPLACE VIEW myv1 AS<br>SELECT<br>  bname,<br>  price<br>FROM<br>  book<br>WHERE price BETWEEN 90<br>  AND 120 ;</p><p>题5：删除刚才创建的视图</p><p>DROP VIEW myv1;<br>1</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>系统变量</p><p>说明：变量由系统提供，不是用户定义，属于服务器层面</p><p>注意：如果是全局级别，则需要加global；如果是会话级别，则需要加session；如果不写，则默认session</p><p>使用的语法：</p><p>查看所有的系统变量</p><p>SHOW GLOBAL|【SESSION】 VARIABLES;<br>1<br>查看满足条件的部分系统变量</p><p>SHOW GLOBAL|【SESSION】 VARIABLES LIKE ‘%char%’;<br>1<br>查看指定的某个系统变量的值</p><p>SELECT @@GLOBAL|【SESSION】.系统变量名;<br>1<br>为某个系统变量赋值</p><p>方式一</p><p>set GLOBAL|【SESSION】 系统变量名 = 值;<br>1<br>方式二</p><p>set @@GLOBAL|【SESSION】.系统变量名 = 值;<br>1<br>分类：</p><p>全局变量</p><p>服务器层面上的，必须拥有super权限才能为系统变量赋值。</p><p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启。</p><p>查看所有的全局变量</p><p>SHOW GLOBAL VARIABLES;</p><ul><li>查看部分的全局变量</li></ul><p>SHOW GLOBAL VARIABLES LIKE ‘%char%’;</p><ul><li>查看指定的全局变量的值</li></ul><p>SELECT @@global.autocommit;<br>SELECT @@global.tx_isolation;</p><ul><li><p>为某个指定的全局变量赋值</p></li><li><p>方式1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li><li><p>方式2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@global.autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li></ul><p>会话变量</p><p>服务器为每一个连接的客户端都提供了系统变量。</p><p>作用域：仅仅针对于当前会话（连接）有效。</p><p>查看所有的会话变量</p><p>SHOW 【SESSION】 VARIABLES;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查看部分的会话变量</span><br><span class="line"></span><br><span class="line">SHOW 【SESSION】 VARIABLES LIKE ‘%char%’;</span><br></pre></td></tr></table></figure><p>查看指定的某个会话变量</p><p>SELECT @@【SESSION.】autocommit;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">为某个会话变量赋值</span><br><span class="line"></span><br><span class="line">方式1：</span><br><span class="line"></span><br><span class="line">set session autocommit&#x3D;0;</span><br></pre></td></tr></table></figure><ul><li><p>方式2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET @@【session.】autocommit&#x3D;0;</span><br></pre></td></tr></table></figure></li></ul><p>自定义变量</p><p>变量是用户自定义的，不是由系统定义的</p><p>使用步骤：声明 赋值 使用（查看、比较、运算等）</p><p>分类</p><p>用户变量</p><p>作用域：针对于当前会话（连接）有效，等同于会话变量的作用域<br>应用在任何地方，也就是begin end里面或begin end的外面<br>声明并初始化（三种方式）</p><p>set @用户变量名=值；<br>set @用户变量名:=值；（推荐）<br>select @用户变量名:=值；</p><p>赋值（更新用户变量的值）</p><p>方式1：通过set或select（同上）</p><p>set @用户变量名=值；<br>set @用户变量名:=值；（推荐）<br>select @用户变量名:=值；</p><p>案例1：</p><p>SET @name=’John’;<br>SET @name=100;</p><p>方式2：通过select into</p><p>select 字段 into 变量名<br>from 表；</p><p>案例1：</p><p>SELECT<br>  COUNT(*) INTO @count<br>FROM<br>  employees ;</p><p>使用（查看用户变量的值）</p><p>select @用户变量名；</p><p>局部变量</p><p>作用域：仅仅在定义它的begin end中有效<br>应用在begin end中的第一句话<br>声明</p><p>declare 变量名 类型；</p><p>declare 变量名 类型 default 值；</p><p>赋值</p><p>方式1：通过set或select（同上）</p><p>set 局部变量名=值；<br>set 局部变量名:=值；（推荐）<br>select @局部变量名:=值；</p><p>方式2：通过select into</p><p>select 字段 into 局部变量名<br>from 表；</p><p>使用</p><p>select 局部变量名；</p><p>对比用户变量和局部变量：</p><p>作用域    定义和使用的位置    语法<br>用户变量    当前会话    会话中的任何地方    必须加@符号，不用限定类型<br>局部变量    begin end中    只能在begin end中，且为第一句话    一般不用加@符号，需要限定类型<br>案例1：声明两个变量并赋初始值，求和，并打印</p><p>用户变量</p><p>SET @m=1;<br>SET @n=2;<br>SET @sum=@m+@n;<br>SELECT @sum;</p><p>局部变量</p><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>DECLARE m INT DEFAULT 1;<br>DECLARE n INT DEFAULT 2;<br>DECLARE SUM INT;<br>SET SUM=m+n;<br>SELECT SUM;</p><h4 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h4><p>类似于java中的方法<br>好处：<br>提高代码的重用性<br>简化操作</p><h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><p>含义：一组预先编译好的sql语句的集合，理解成批处理语句</p><p>好处：</p><p>提高代码的重用性<br>简化操作<br>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>语法：</p><p>创建语法</p><p>CREATE PROCEDURE 存储过程名(参数列表)<br>BEGIN<br>    存储过程体(一组合法的SQL语句)<br>END</p><p>注意</p><p>参数列表包含三部分：参数模式，参数名，参数类型</p><p>举例：in stuname varchar(20)<br>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>out：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又需要返回值<br>如果存储过程体仅仅只有一句话，begin end可以省略</p><p>存储过程体中的每条SQL语句的结尾要求必须加分号</p><p>存储过程的结尾可以使用 DELIMITER 重新设置</p><p>语法：DELIMITER 结束标记</p><p>案例：</p><p>DELIMITER $<br>1<br>调用语法</p><p>call 存储过程名(实参列表)；<br>空参列表</p><p>案例1：插入到admin表中五条记录</p><p>SELECT * FROM admin;<br>DELIMITER $</p><p>CREATE PROCEDURE myp1()<br>BEGIN<br>INSERT INTO admin(username, <code>password</code>)<br>VALUES<br>(‘john1’, ‘0000’),<br>(‘asd’, ‘0000’),<br>(‘joqqhn1’, ‘0000’),<br>(‘qa’, ‘0000’),<br>(‘ww’, ‘0000’);<br>END $</p><p>CALL myp1()$</p><p>创建带in模式参数的存储过程</p><p>案例1：创建存储过程实现：根据女神名，查询对应的男神信息</p><p>CREATE PROCEDURE myp2(IN beautyname VARCHAR(20))<br>BEGIN<br>SELECT bo.*<br>FROM boys bo<br>RIGHT JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL myp2(‘柳岩’)$<br>CALL myp2(‘王语嫣’)$</p><p>案例2：创建存储过程实现，用户是否登录成功</p><p>CREATE PROCEDURE myp4(IN username VARCHAR(20), IN passward VARCHAR(20))<br>BEGIN<br>DECLARE result INT DEFAULT 0;    # 声明并初始化</p><p>SELECT COUNT(*) INTO result    # 赋值<br>FROM admin<br>WHERE admin.username = username<br>AND admin.password = PASSWORD;</p><p>SELECT IF(result&gt;0, ‘成功！’, ‘失败！’); # 使用<br>END $</p><p>CALL myp4(‘张飞’, ‘8888’)$</p><p>创建带out模式的存储过程</p><p>案例1：根据女神名，返回对应的男神名</p><p>CREATE PROCEDURE myp5(IN beautyname VARCHAR(20), OUT boyname VARCHAR(20))<br>BEGIN<br>SELECT bo.boyname INTO boyname<br>FROM boys bo<br>INNER JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL myp5(‘王语嫣’, @bname)$<br>SELECT @bname$</p><p>案例2：根据女神名，返回对应的男神名和男神魅力值</p><p>CREATE PROCEDURE myp6(IN beautyname VARCHAR(20), OUT boyname VARCHAR(20), OUT usercp INT)<br>BEGIN<br>SELECT bo.boyname, bo.usercp INTO boyname, usercp<br>FROM boys bo<br>INNER JOIN beauty b ON bo.id = b.boyfriend_id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL myp6(‘王语嫣’, @bname, @usercp)$<br>SELECT @bname, @usercp$</p><p>创建带inout模式参数的存储过程</p><p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p><p>CREATE PROCEDURE myp8(INOUT a INT, INOUT b INT)<br>BEGIN<br>SET a=a<em>2;<br>SET b=b</em>2;<br>END $</p><p>SET @m=10$<br>SET @n=20$<br>CALL myp8(@m,@n)$<br>SELECT @m,@n$</p><p>练习题</p><p>习题1：创建存储过程实现传入用户名和密码，插入到admin表中</p><p>CREATE PROCEDURE test_pro1(IN username VARCHAR(20), IN loginpwd VARCHAR(20))<br>BEGIN<br>INSERT INTO admin(admin.<code>username</code>, PASSWORD)<br>VALUES(username, loginpwd);<br>END $</p><p>CALL test_pro1(‘litian’, ‘1234’)$<br>SELECT * FROM admin$</p><p>习题2：创建存储过程实现传入女神编号，返回女神名称和女神电话</p><p>CREATE PROCEDURE test_pro2(IN id INT, OUT NAME VARCHAR(20), OUT phone VARCHAR(20))<br>BEGIN<br>SELECT b.name, b.phone INTO NAME, phone<br>FROM beauty b<br>WHERE b.id=id;<br>END $</p><p>SET @n=’’$<br>SET @m=’’$<br>CALL test_pro2(1, @n, @m)$<br>SELECT @m,@n$</p><p>习题3：创建存储过程来实现传入两个女神生日，返回大小</p><p>CREATE PROCEDURE test_pro3(IN birth1 DATETIME, IN birth2 DATETIME, OUT result INT)<br>BEGIN<br>SELECT DATEDIFF(birth1, birth2) INTO result;<br>END $</p><p>CALL test_pro3(‘1990-2-3’, NOW(), @result)$<br>SELECT @result$</p><p>存储过程的删除</p><p>语法：drop procedure 存储过程名</p><p>DROP PROCEDURE myp1;<br>1<br>不能同时删除多个存储过程</p><p>查看存储过程的信息</p><p>语法：show create procedure 存储过程名</p><p>SHOW CREATE PROCEDURE myp2;<br>1<br>不能修改存储过程中的语句，需要修改的话，就删了重写。</p><p>练习题</p><p>练习题1：创建存储过程实现传入一个日期，格式化成xx年xx月xx日并返回</p><p>CREATE PROCEDURE test_pro4(IN mydate DATETIME, OUT strdate VARCHAR(20))<br>BEGIN<br>SELECT DATE_FORMAT(mydate, ‘%y年%m月%d天’) INTO strdate;<br>END $</p><p>CALL test_pro4(NOW(), @str)$<br>SELECT @str $</p><p>练习题2：创建存储过程实现传入女神名称，返回：女神 and 男神 格式的字符串</p><p>CREATE PROCEDURE test_pro5(IN beautyname VARCHAR(20), OUT str VARCHAR(50))<br>BEGIN<br>SELECT CONCAT(beautyname, ‘ and ‘, IFNULL(boyname, ‘null’)) INTO str<br>FROM boys bo<br>RIGHT JOIN beauty b<br>ON b.boyfriend_id=bo.id<br>WHERE b.name=beautyname;<br>END $</p><p>CALL test_pro5(‘王语嫣’, @result)$<br>SELECT @result$</p><p>练习题3：创建存储过程，根据传入的起始索引和条目数，查询beauty表的记录</p><p>CREATE PROCEDURE test_pro6(IN startindex INT, IN size INT)<br>BEGIN<br>SELECT * FROM beauty LIMIT startindex, size;<br>END $</p><p>CALL test_pro6(3, 3)$</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>好处：</p><p>提高代码的重用性<br>简化操作<br>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率<br>与存储过程的区别：</p><p>存储过程：可以有0个返回，也可以有多个返回（适合做批量插入、更新）<br>函数：有且仅有1个返回（适合处理数据后返回一个结果）<br>创建语法：</p><p>create function 函数名（参数列表） returns 返回类型</p><p>begin</p><p>函数体</p><p>end</p><p>注意事项：<br>参数列表：包含两部分：参数名 参数类型，注意：没有in，out，inout这种模式了<br>函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议<br>函数体中仅有一句话，则可以省略begin end<br>使用delimiter语句设置结束标记<br>调用语法：select 函数名(参数列表)</p><p>无参有返回</p><p>案例1：返回公司的员工个数</p><p>CREATE FUNCTION myf1() RETURNS INT<br>BEGIN<br>DECLARE c INT DEFAULT 0;# 定义变量<br>SELECT COUNT(*) INTO c# 赋值<br>FROM employees;<br>RETURN c;<br>END $</p><p>SELECT myf1()$</p><p>有参有返回</p><p>案例1：根据员工名，返回他的工资</p><p>CREATE FUNCTION myf2(empname VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>SET @sal=0;<br>定义用户变量<br>SELECT salary INTO @sal# 赋值<br>FROM employees<br>WHERE last_name = empname;<br>RETURN @sal;<br>END $</p><p>SELECT myf2(‘kochhar’)$</p><p>案例2：根据部门名，返回该部门的平均工资</p><p>CREATE FUNCTION myf3(deptname VARCHAR(20)) RETURNS DOUBLE<br>BEGIN<br>DECLARE sal DOUBLE;<br>SELECT AVG(salary) INTO sal<br>FROM employees e<br>JOIN departments d ON e.department_id = d.department_id<br>WHERE d.department_name=deptname;</p><p>RETURN sal;<br>END $</p><p>SELECT myf3(‘IT’)$</p><p>查看函数：</p><p>SHOW CREATE FUNCTION myf3;<br>1<br>删除函数：</p><p>DROP FUNCTION myf3;<br>1<br>案例1：创建函数，实现传入两个float，返回二者之和</p><p>CREATE FUNCTION test_fun1(num1 FLOAT, num2 FLOAT) RETURNS FLOAT<br>BEGIN<br>DECLARE SUM FLOAT DEFAULT 0;<br>SET SUM=num1+num2;<br>RETURN SUM;<br>END $</p><p>SELECT test_fun1(1,2)$</p><p>流程控制结构<br>分类</p><p>顺序结构：结构从上往下依次执行<br>分支结构：程序从两条或多条路径中选择一条去执行<br>循环结构：程序在满足一定条件的基础上，重复执行一段代码<br>分支结构</p><p>if函数</p><p>功能：实现简单的双分支</p><p>语法：</p><p>select if(表达式1，表达式2，表达式3)</p><p>执行顺序：</p><p>如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值</p><p>应用环境：任何地方</p><p>case结构</p><p>情况1：类似于java中的switch语句，一般用于实现等值判断</p><p>语法：</p><p>case 变量|表达式|字段</p><p>when 要判断的值 then 返回的值1或语句1；</p><p>when 要判断的值 then 返回的值2或语句2；</p><p>…</p><p>else 要返回的值n或语句n；</p><p>end case；</p><p>情况2：类似于java中的多重if语句，一般用于实现区间判断</p><p>语法：</p><p>case</p><p>when 要判断的条件1 then 返回的值1或语句1；</p><p>when 要判断的条件2 then 返回的值2或语句2；</p><p>…</p><p>else 要返回的值n或语句n；</p><p>end case；</p><p>特点：</p><p>可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end 中，或 begin end 的外面<br>也可以作为独立的语句去使用，只能放在begin end 中<br>如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case<br>如果都不满足，则执行else中的语句或值<br>else可以省略，如果else省略了，并且所有的when条件都不满足，则返回null<br>img</p><p>img</p><p>案例1：创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：90-100，显示A；80-90：显示B；60-80：显示C；否则显示D</p><p>CREATE PROCEDURE test_case(IN score INT)<br>BEGIN<br>CASE<br>WHEN score &gt;= 90 AND score &lt;= 100 THEN SELECT ‘A’;<br>WHEN score &gt;=80 THEN SELECT ‘B’;<br>WHEN score &gt;= 60 THEN SELECT ‘C’;<br>ELSE SELECT ‘D’;<br>END CASE;<br>END $</p><p>CALL test_case(95)$</p><p>if结构</p><p>功能：实现多重分支</p><p>语法：</p><p>if 条件1 then 语句1；</p><p>elseif 条件2 then 语句2；</p><p>…</p><p>【else 语句n；】</p><p>end if；</p><p>应用场合：应用在begin end中</p><p>案例2：创建存储过程，根据传入的成绩，来返回等级，比如传入的成绩：90-100，返回A；80-90：返回B；60-80：返回C；否则返回D</p><p>CREATE FUNCTION test_if(score INT) RETURNS CHAR<br>BEGIN<br>IF score &gt;= 90 AND score &lt;= 100 THEN RETURN ‘A’;<br>ELSEIF score &gt;=80 THEN RETURN ‘B’;<br>ELSEIF score &gt;= 60 THEN RETURN ‘C’;<br>ELSE RETURN ‘D’;<br>END IF;<br>END $</p><p>SELECT test_if(86)$</p><p>循环结构</p><p>分类：while、loop、repeat</p><p>循环控制：</p><p>iterate：类似于continue，继续；结束本次循环，继续下一次<br>leave：类似于break，跳出；结束当前所在循环<br>while</p><p>语法：</p><p>[标签：】while 循环条件 do</p><p>循环体；</p><p>end while 【标签】；</p><p>loop</p><p>语法：</p><p>【标签：】loop</p><p>循环体；</p><p>end loop 【标签】；</p><p>可以用来模拟简单的死循环</p><p>repeat</p><p>语法：</p><p>【标签：】repeat</p><p>循环体；</p><p>until 结束循环的条件</p><p>end repeat【标签】；</p><p>对比：</p><p>这人三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称<br>loop：一般用于实现简单的死循环<br>while：先判断后执行<br>repeat：先执行后判断，无条件至少执行一次<br>案例1：没有添加循环控制语句</p><p>批量插入，根据次数插入到admin表中多条记录</p><p>CREATE PROCEDURE pro_while1(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>WHILE i &lt;= insertcount DO<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘Rose’, i), ‘666’);<br>SET i=i+1;<br>END WHILE;<br>END $</p><p>CALL pro_while1(100)$<br>SELECT * FROM admin;</p><p>案例2：添加leave语句</p><p>批量插入，根据次数插入到admin表中20条记录</p><p>CREATE PROCEDURE test_while1(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;<br>a:WHILE i &lt;= insertcount DO<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘xiaohua’, i), ‘000’);<br>IF i&gt;=20 THEN LEAVE a;<br>END IF;<br>SET i=i+1;<br>END WHILE a;<br>END $</p><p>CALL test_while1(100)$<br>SELECT * FROM admin;</p><p>案例3：添加iterate语句</p><p>批量插入，根据次数插入到admin表中多条记录，只插入偶数次</p><p>CREATE PROCEDURE test_while2(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 0;<br>a:WHILE i &lt;= insertcount DO<br>SET i=i+1;<br>IF MOD(i,2) != 0 THEN ITERATE a;<br>END IF;<br>INSERT INTO admin(username, <code>password</code>) VALUES(CONCAT(‘xiaohua’, i), ‘000’);<br>END WHILE a;<br>END $</p><p>CALL test_while2(100)$<br>SELECT * FROM admin;</p><p>案例4：已知表stringcontent，其中字段id 自增长；content varchar(20)，向该表中插入指定个数的随机的字符串</p><p>USE test;<br>DROP TABLE IF EXISTS stringcontent;<br>CREATE TABLE stringcontent(<br>id INT PRIMARY KEY AUTO_INCREMENT,<br>content VARCHAR(20)<br>);</p><p>DELIMITER $<br>CREATE PROCEDURE test_randstr_insert(IN insertcount INT)<br>BEGIN<br>DECLARE i INT DEFAULT 1;# 定义一个循环变量i，表示插入次数<br>DECLARE str VARCHAR(26) DEFAULT ‘abcdefghijklmnopqrstuvwxyz’;<br>DECLARE startindex INT DEFAULT 1;# 代表起始索引<br>DECLARE len INT DEFAULT 1;# 代表截取的字符的长度<br>WHILE i&lt;=insertcount DO<br>SET len=FLOOR(RAND()*(20-startindex+1)+1);# 产生一个随机的整数，代表截取长度，1-(26-startindex+1)<br>SET startindex=FLOOR(RAND()*26+1);# 产生一个随机的整数，代表起始索引1-26<br>INSERT INTO stringcontent(content) VALUES(SUBSTR(str, startindex, len));<br>SET i=i+1;<br>END WHILE;<br>END $</p><p>CALL test_randstr_insert(10)$<br>SELECT * FROM stringcontent;<br>CALL test_randstr_insert(10)$<br>SELECT * FROM stringcontent;</p><p>返回该字符的密码形式<br>md5()</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c-4</title>
    <link href="http://example.com/posts/39404/"/>
    <id>http://example.com/posts/39404/</id>
    <published>2020-10-11T02:04:42.000Z</published>
    <updated>2020-10-12T05:31:22.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>相关模式.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c-3</title>
    <link href="http://example.com/posts/23469/"/>
    <id>http://example.com/posts/23469/</id>
    <published>2020-10-11T02:04:35.000Z</published>
    <updated>2020-10-17T01:37:10.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从c转变c++,让自己++,以天数为循环累加参数，上不封顶.</p><h3 id="auto"><a href="#auto" class="headerlink" title="auto :"></a>auto :</h3><p>自动存储期变量．<br>可通过赋值表达式推导；<br>long long a = 123;<br>auto b = a; //推导b为long long 类型.省略类型定义.只是代表编译阶段可以确定的类型.</p><p>srand(time(0));//随机函数　</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int my_seed &#x3D; 1;</span><br><span class="line">void my_srand(int seed) &#123;</span><br><span class="line">        my_seed &#x3D; seed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int my_rand() &#123;</span><br><span class="line">        my_seed &#x3D; my_seed * 3 % 101;</span><br><span class="line">        return my_seed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">        my_srand(time(0));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">                cout &lt;&lt; my_rand() &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="nullptr关键字"><a href="#nullptr关键字" class="headerlink" title="nullptr关键字"></a>nullptr关键字</h3><p>c++引入的代替空指针的关键字.<br>什么样的值才能称为空指针常量.<br>c语言中常数0和（void*）0都是空指针常量，c++中常数0是，而(void *)0不是．c++中<br>NULL即使指针也是值.防止重载造成混淆，产生错误，因此引入了nullptr,单纯的是空地址.</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>const意思是运行期不可修改的意思．(运行期常量)<br>cin &gt;&gt; n;<br>const int a = n + 3;<br>constexpr意思编译期常量.(必须在编译期确定)．<br>编译期常量只能用编译期常量赋值，在函数中前面加上constexpr,表明函数是可以返回常量的．（构造函数也是函数哦）</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>对类进行修饰，在类名后边,表示这个类到最后了，不希望被继承了．</p><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>跟virtual(虚函数)子类进行覆盖.给你特定的提示.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++关键字" scheme="http://example.com/categories/c-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c-2</title>
    <link href="http://example.com/posts/39788/"/>
    <id>http://example.com/posts/39788/</id>
    <published>2020-10-10T08:34:46.000Z</published>
    <updated>2020-10-13T02:40:50.832Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>人不可有傲气，但不可无傲骨！</p><h3 id="c-基本思想"><a href="#c-基本思想" class="headerlink" title="c++基本思想"></a>c++基本思想</h3><p>从面向过程转变为面向对象，由操作局部改变为操作整体，c语言就好像指挥单兵作战，每个人员分配都得事必躬亲，c++就是指挥兵团作战，整体布局，指挥的是一个个团体,</p><h3 id="类和对象基础"><a href="#类和对象基础" class="headerlink" title="类和对象基础"></a>类和对象基础</h3><h4 id="类和对象含义"><a href="#类和对象含义" class="headerlink" title="类和对象含义"></a>类和对象含义</h4><p>类是用户定义类型 (C++ 的核心特性，通常被称为用户定义的类型)。<br>类用于指定对象 (指定对象的形式，它包含了数据表示法和用于处理数据的方法)。<br>类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>定义一个类，本质上是定义一个自己想要的数据类型．可以类比结构体，而对象类比结构体变量.<br>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">       public:</span><br><span class="line">          double length;   &#x2F;&#x2F; 盒子的长度</span><br><span class="line">          double breadth;  &#x2F;&#x2F; 盒子的宽度</span><br><span class="line">          double height;   &#x2F;&#x2F; 盒子的高度</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="来直接访问-定义c-对象"><a href="#来直接访问-定义c-对象" class="headerlink" title="来直接访问.定义c++对象"></a>来直接访问.定义c++对象</h4><p>对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box Box1;          &#x2F;&#x2F; 声明 Box1，类型为 Box</span><br><span class="line">Box Box2;          &#x2F;&#x2F; 声明 Box2，类型为 Box</span><br><span class="line">注：对象 Box1 和 Box2 都有它们各自的数据成员。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="访问数据成员"><a href="#访问数据成员" class="headerlink" title="访问数据成员"></a>访问数据成员</h4><p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。<br>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问.</p><h4 id="成员属性与成员方法"><a href="#成员属性与成员方法" class="headerlink" title="!成员属性与成员方法"></a>!成员属性与成员方法</h4><p>类把成员属性和成员方法打包到了一起．<br>成员属性: 类中的各种类型的变量(存储的数据).<br>成员方法:  所定义的这个类所具备的功能，比如狗的类，成员方法可以说叫，跑，啃骨头．</p><p>类方法:　</p><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="!访问权限"></a>!访问权限</h4><p>c++中class和struct等价，不声明权限的默认为公有权限．<br>class中不声明就是private的.<br>public: 公共访问权限<br>private:　私有访问权限:’只有’本类型的方法可以访问.(该类内部的方法可以访问)<br>protected: 受保护访问权限</p><h4 id="this指针"><a href="#this指针" class="headerlink" title="!this指针"></a>!this指针</h4><p>this指针指的是调用该方法的对象(不是类，对象有地址，类没有地址)，所以在构造函数中对成员属性赋值操作不能直接用参数赋值，而是this指针指向的该对象的属性.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void set_xy(int x, int y)&#123;</span><br><span class="line">    this-&gt;x &#x3D; x; b的属性 &#x3D; 传入参数</span><br><span class="line">    this-&gt;y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="!构造和析构"></a>!构造和析构</h3><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数:"></a>默认构造函数:</h4><pre><code>也称为无参构造函数,如果没有自己的构造函数，在定义对象的时候会自动调用默认构造函数.</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h4><pre><code>　构造函数用来初始化对象的，我们自己想初始化对象，可以把构造函数写再构造函数里．</code></pre><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数:"></a>析构函数:</h4><pre><code>通常给系统调用的，不是我们自己调用的．~Car(); 没有返回值.</code></pre><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数:"></a>拷贝构造函数:</h4><pre><code>同类型对象的赋值行为，</code></pre><p>系统的默认实现：调用了每个成员属性的赋值方法．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">A b &#x3D; a;</span><br><span class="line">这里调用了拷贝构造函数.拷贝构造函数参数传的是引用.(const &amp;).</span><br><span class="line">一般加上const</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么拷贝构造函数一定要传引用？不传引用为什么通不过编译?<br>因为拷贝构造函数的参数也是该类的对象，调用该函数会首先给参数进行赋值（调用拷贝构造函数）这里他调用了他自己，会形成一个无限递归，格式不对所以编译不过.是不可行代码.<br>反过来说，如果改成了引用，也就是说当前参数就代表了传入的参数，相当于就是执行参数本身，消除了参数的构造过程．<br>引用（＆）：只是相关变量的别名.</p><h4 id="类型转换构造函数-（有参构造函数中一个参数）"><a href="#类型转换构造函数-（有参构造函数中一个参数）" class="headerlink" title="类型转换构造函数:（有参构造函数中一个参数）"></a>类型转换构造函数:（有参构造函数中一个参数）</h4><p>构造函数只有一个参数．<br>＇在对象定义时＇，可以直接定义对象是传参，也可以用等号赋值.系统根据类型匹配构造函数(跟普通的＝不同的功能).<br>不是在定义时：等于号调用的是赋值运算函数.如果没写赋值运算函数就还是调用的赋值构造函数.<br>有了这个函数就可以在初始化时不用传参传入类，如传入整形就会自动去匹配相关构造函数．</p><h4 id="各个函数的执行顺序"><a href="#各个函数的执行顺序" class="headerlink" title="各个函数的执行顺序"></a>各个函数的执行顺序</h4><p>构造函数1,2,3,析构函数3,2,1<br>原因：栈空间，(无论是全局变量还是局部变量)(按照书写先后顺序)数据/对象压栈的过程，就是构造函数执行的过程，弹出栈的时候，系统会调用相关的析构函数．单数一般的变量没有看不到相关操作但是存在相关过程.<br>举例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car a;</span><br><span class="line">Car b(a)</span><br><span class="line">Car C(b),</span><br><span class="line">若果顺序析构，机会出现如果ｂ需要ａ的信息，就会出现非法访问问题.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="default与delete"><a href="#default与delete" class="headerlink" title="default与delete"></a>default与delete</h4><p>在初始化对象时，先初始化对象相关成员，先调用成员的构造函数，若果成员构造函数为delete,那么该对象构造函数也不能为default,只能为delete.</p><h5 id="default"><a href="#default" class="headerlink" title="default:"></a>default:</h5><pre><code>Car() = default;使用相关构造函数对默认行为,就是什么都不做的初始化.Car(const Car &amp;) = default;是代码更为严禁，更能发现错误．　</code></pre><h5 id="delete"><a href="#delete" class="headerlink" title="delete:"></a>delete:</h5><p>　　相关方法去除操作．如果不想被别人调用，可以变为delete，别人调用就会报错.禁止了一个类的对象产生拷贝行为.<br>　　Car() = delete.<br>　　表示Car()的默认构造函数不存在.</p><h4 id="构造和析构的三五法则"><a href="#构造和析构的三五法则" class="headerlink" title="构造和析构的三五法则"></a>构造和析构的三五法则</h4><p>１．需要析构函数的类也需要拷贝构造函数和拷贝赋值函数。<br>需要析构函数：一般在相关构造函数中开辟了新的存储空间，需要析构函数进行内存空间的释放.(开辟了额外的存储空间)</p><p>需要拷贝构造函数：开辟了新的存储空间的类，需要的＇深拷贝＇<br>所以得到上述结论!</p><p>２．需要拷贝操作的类也需要赋值操作，反之亦然。</p><p>３．析构函数不能是私有的（删除的）<br>析构函数被删除了我们就没办法定义局部变量.(就是在主函数中创建一个类对象，因为系统在用完变量后会调用相应的析构函数，析构函数不存在，便会在编译阶段报错). 自主函数中　Car a;</p><p>但是可以Car *p = new Car();这样动态申请空间．<br>不能调用delete　ｐ因为delete也调用了相关的析构函数.</p><p>４．如果一个类有私有的(删除的)或不可访问的析构函数，那么其默认和拷贝构造函数会被定义为私有的。<br>既然不能删除，那么不能被重复利用的空间，这个类也变得没有什么意义.<br>５．如果一个类有const或引用成员，则不能使用默认（合成的赋值操作）的拷贝赋值操作。<br>合成的赋值操作：就是把赋值构造函数参数设定为一个类，然后进行类与类之间各个属性的赋值操作．<br>赋值操作不能作用在const修饰的变量上，常量不可修改.<br>若何操作const的成员属性，可以使用构造函数的初始化列表修改其值，他调用相关成员的构造函数，而相关的拷贝构造是进行赋值操作.<br>&amp;(引用)是在定义的时候立即绑定对象.&amp;引用的初始化操作也得放在构造函数初始化列表中.</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="!类和对象"></a>!类和对象</h3><h4 id="类属性和类方法"><a href="#类属性和类方法" class="headerlink" title="!类属性和类方法"></a>!类属性和类方法</h4><h5 id="成员属性："><a href="#成员属性：" class="headerlink" title="成员属性："></a>成员属性：</h5><p>类中每一个成员都决定着该类的一个属性.比如人的体重.而且呢每个对象都有有个特定值值.</p><p>注！只有在成员方法中能访问到this指针.</p><h5 id="成员方法："><a href="#成员方法：" class="headerlink" title="成员方法："></a>成员方法：</h5><p>就是类的行为动作．</p><p>类属型类方法，就是在对应的属性和方法前加上static关键字.</p><h5 id="类属型："><a href="#类属型：" class="headerlink" title="类属型："></a>类属型：</h5><p>类中的变量可以说是声明.<br>类属型的定义:写到类外边．</p><p>所有对象访问的时候访问的是一个值，成员属性是每个对象都有一个.<br>１．可以通过 对象访问（不同对象访问的类属型值是一样的）<br>２．可以通过命名空间去访问.[std::] 类名也是命名空间.</p><h5 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h5><p>全局只有一个方法，访问不到this指针的.<br>访问方式同类属型.</p><h5 id="const类型的方法"><a href="#const类型的方法" class="headerlink" title="const类型的方法"></a>const类型的方法</h5><p>这个方法不去修改任何属性的值.</p><p>对象与引用<br>等同于变量和变量的引用.<br>也可以在main也可以定义cosnt Car().<br>常量的对象，非常量方法无法访问．所以说const类型的对象只能调用const类型的方法.<br>在const方法中修改成员属性，需要在类中的对应属性前加上mutable关键字.</p><h5 id="类和类属型"><a href="#类和类属型" class="headerlink" title="类和类属型"></a>类和类属型</h5><p>构造顺序：先构造成员在构造类<br>析构顺序：先析构类后析构类成员</p><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>浅拷贝：每一个成员属性依次的进行赋值操作.(主要就是数组的拷贝（传入的是首地址）)浅拷贝中改变拷贝后得值会影响拷贝原版的值．深拷贝解决这次问题．<br>系统自带的拷贝就是浅拷贝<br>深拷贝：比浅拷贝多了一个申请内存空间的过程，解决了浅拷贝中所出现的（更改连带问题）．</p><h3 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h3><p>对象初始化顺序：　开辟存储区-&gt;匹配(拷贝)构造函数-&gt;完成构造.<br>函数返回时存在匿名变量，再由匿名变量拷贝给对象，所以说匿名变量的消除是第一个优化.<br>就只剩下一次默认构造一次拷贝构造.<br>第二步优化消除拷贝构造(可以理解为引用的操作)<br>最后剩下一次默认构造.<br>编译过程：加上　-fno-elide-constructors 参数即可关闭返回值优化.<br>注意：关闭优化前在函数返回的时候存在一个匿名变量<br>通过匿名变量给a拷贝<br>A a(func);<br>相关优化一般基于相关的编译系统，比如微软的就进行了一次优化.</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>继承语法:</p><p>class Cat : public Animal{//公有继承</p><p>};<br>相关继承权限:<br>１．对于子类的权限<br>使用public 和 protected和 private均能访问到父类中的public,protected相关属性和方法．</p><p>２．子类继承过来的属性和方法这些继承完对外的权限<br>公有继承　public-&gt;public | protected-&gt;protected<br>保护继承  public-&gt;protected | protected-&gt;protected<br>私有继承　public-&gt;private | protected-&gt;private<br>不能存在私有继承<br>不让外界访问让子类访问设置成受保护的<br>都不让访问设置成私有的</p><h4 id="继承下的构造"><a href="#继承下的构造" class="headerlink" title="继承下的构造"></a>继承下的构造</h4><p>子类在进行构造之前先让父类进行构造再进行子类的构造．<br>那么先调用子类的析构再调用父类的析构函数<br>构造：Cat():Animal(“cat”){} 可以显性调用构造函数否者调用默认构造函数．</p><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>比如Ｂ和Ｃ同时继承于Ａ而Ｄ同时继承于Ｂ和Ｃ那么这种继承就是菱形继承.</p><h4 id="继承下的拷贝构造："><a href="#继承下的拷贝构造：" class="headerlink" title="继承下的拷贝构造："></a>继承下的拷贝构造：</h4><p>子类的对象绑定到父类的引用上(显时的调用父类的拷贝构造函数)，隐式的类型转换.<br>显式的调用父类的赋值运算符函数.<br>即使有些子类的成员属性无法访问但是父类的成员属性在子类中依然是存在的.(sizeof(类)大小会改变).</p><p>子类的存储方式:<br>    子类中先存储父类的相关信息，然后在存储子类的信息.<br>子类对象的首地址也就是父类对象的首地址.所以说子类的地址可以赋值给他父类的相关指针变量的.也可以绑定到相关的父类的应用上.</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>１．在类内部式运算符重载成为他的成员方法.相当于调用了ａ对象的　＋＝　方法，传入对象为３．<br>２．在类外边直接实现运算符重载.bool operator += (a, 3);</p><p>友元函数实现类内部的声明，函数实现在类外，可以通过此改变进行使得函数可以访问类的私有成员</p><h4 id="类外运算符重载"><a href="#类外运算符重载" class="headerlink" title="类外运算符重载:"></a>类外运算符重载:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##### 类内部：</span><br><span class="line"> friend Point operator+(const Point &amp;, const Point &amp;);</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line">int operator()(int num) &#123;</span><br><span class="line">            return this-&gt;x + this-&gt;y + num;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">int operator[](string str) &#123;</span><br><span class="line">            if (str &#x3D;&#x3D; &quot;x&quot;) return this-&gt;x;</span><br><span class="line">            if (str &#x3D;&#x3D; &quot;y&quot;) return this-&gt;y;</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">Point operator-(const Point &amp;a) &#123;</span><br><span class="line">            Point ret;</span><br><span class="line">            ret.x &#x3D; this-&gt;x - a.x;</span><br><span class="line">            ret.y &#x3D; this-&gt;y - a.y;</span><br><span class="line">            return ret;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">返回值为＆应为支持连续&lt;&lt;</span><br><span class="line">ostream &amp;operator&lt;&lt;(ostream &amp;out, const Point &amp;a) &#123;</span><br><span class="line">        out &lt;&lt; &quot;&lt;class Point&gt; (&quot; &lt;&lt; a.x &lt;&lt; &quot;, &quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;;</span><br><span class="line">        return out; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类外部</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line"></span><br><span class="line">const 来确定左值右值问题，后边讲</span><br><span class="line">Point operator+(const Point &amp;a, const Point &amp;b) &#123;</span><br><span class="line">        Point ret;</span><br><span class="line">        ret.x &#x3D; a.x + b.y;</span><br><span class="line">        ret.y &#x3D; a.y + b.y;</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h4><p>virtual 关键字不能修饰　static,因为static只跟着类走.<br>virtual　void run(){};<br>指针和引用调用该方法时，虚函数是跟着对象走，谁调用跟谁走.（可以通过等于进行函数传递）<br>普通函数跟着类走的.跟着普通调用者的类型走的.(定义类的类型中的函数是啥输出哈)</p><p>父类的相关方法是虚函数，子类继承的方法也是虚函数有无关键字都可.</p><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数:"></a>纯虚函数:</h5><pre><code>virtual void run() = 0;若果父类中被声明为纯虚函数，子类中必须实现相关方法.相当于接口的作用.</code></pre><h5 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h5><p>拥有纯虚函数的类叫抽象类(接口类)</p><h5 id="父类的析构函数为啥设置为虚函数"><a href="#父类的析构函数为啥设置为虚函数" class="headerlink" title="父类的析构函数为啥设置为虚函数?"></a>父类的析构函数为啥设置为虚函数?</h5><p>如果父类析构函数在被子类继承后，并且子类定义了相关的类，在析构的时候，这时父类的析构函数为普通成员函数，跟这类走的，所以说只会销毁父类的类，不会销毁相关派生类所产生的类或者说相关内存的开销无法收回.造成内存泄露的问题.</p><h3 id="虚函数和this指针"><a href="#虚函数和this指针" class="headerlink" title="虚函数和this指针"></a>虚函数和this指针</h3><p>虚函数：子类可以不用实现，子类在用到该函数会依次往上找.调用父类的实现,<br>纯虚函数; 则必须要实现的.(接口)．一般在子类实现需要加overide,告诉编译器我在覆盖一个父类的虚函数,若果不存在父类的虚函数该关键字可以报错.<br>不加也可以,但是不严谨，出错难找.</p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>成员方法不占用数据存储空间,sizeof表示的是数据空间的占用.<br>一个类对应一个虚函数表，每个对象都指向同一个虚函数表,<br>每个对象的存储区头部会存在一个地址（八个字节）对应着相对应类的虚函数表首地址，虚函数表存在该类相关的虚函数，所以说虚函数跟着类走.</p><h3 id="this指针-1"><a href="#this指针-1" class="headerlink" title="this指针"></a>this指针</h3><p>this指针是一个隐藏参数.<br>比如 void buy(int x) -&gt; void buy(void *this, int x);</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p><p>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p><p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> </span><br><span class="line"> class A  &#x2F;&#x2F;大小为4</span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">        int a;</span><br><span class="line">        double b;</span><br><span class="line">         </span><br><span class="line">   &#125;;</span><br><span class="line">   &#x2F;&#x2F;在32位环境下,大小为12，变量a,b共8字节，虚基类表指针4;</span><br><span class="line">   &#x2F;&#x2F;在64位环境下，变量a 4个字节，b 4个字节，虚基类表指针8个字节，为了对齐，大小总共24</span><br><span class="line">    class B :virtual public A  </span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">            int b;</span><br><span class="line">        </span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;与B一样</span><br><span class="line">    class C :virtual public A </span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">            int c;</span><br><span class="line">        </span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;在32位环境下,大小为24,变量a,b,c,d共16，B的虚基类指针4，C的虚基类指针</span><br><span class="line">    class D :public B, public C </span><br><span class="line">    &#123;</span><br><span class="line">        public:</span><br><span class="line">            int d;</span><br><span class="line">        </span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">            cout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(C) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(D) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; sizeof(void *) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">            system(&quot;pause&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>+11提供了一种防止继承发生的方法，即在类名后面跟一个关键字final。</p><p>另外，我们也可以在成员函数的后面加final。</p><p>如果我们把某个函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">struct A&#123;</span><br><span class="line">        virtual void f1(int) const;</span><br><span class="line">        virtual void f2();</span><br><span class="line">        void f3;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> struct B1 : A &#123;</span><br><span class="line">         void f1(int) const final;    &#x2F;&#x2F;不允许后续的其他类覆盖f1(int)</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line">  </span><br><span class="line">  struct B2 : B1 &#123;</span><br><span class="line">          void f1(int) const;        &#x2F;&#x2F;错误，B1已经将f1()声明成final</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>泛型编程 + 面向过程编程　= 用模板实现函数过程.<br>泛型编程 + 面向对象编程  = 用模板实现类.<br>模板函数<br>template <typename T> 一个抽象出来的类型　为T<br>T Sa(T a, T b){ //相关一样的类型换成T即可.<br>    return  a * b;<br>}<br>模板类<br>类似模板函数</p><p>模板的变特化：<br>类似于模板函数：就是比如当Ｔ为int类型需要执行　a * b *c的操作<br>就需要写成<br>template&lt;&gt;<br>int Sa(int a,int b){<br>    return a * b * c;<br>}<br>模板类的特化：</p><p>模板的偏特化:<br>就是兼容多种传入类型<br>template <typename T><br>void Sa(T *a, T *b){<br>    cout &lt;&lt; (*a) * (*b);<br>}</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>network-of-computer2</title>
    <link href="http://example.com/posts/35949/"/>
    <id>http://example.com/posts/35949/</id>
    <published>2020-10-10T08:33:53.000Z</published>
    <updated>2020-10-24T04:39:41.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机网络串讲<br>由底层向应用程序的顺序来安排的.<br>如有错误还望不吝赐教.</p><h3 id="网络体系架构"><a href="#网络体系架构" class="headerlink" title="网络体系架构"></a>网络体系架构</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>协议是指计算机通信网络中，两台计算机进行通信，所必须遵循的规定或规则。计算机网络中有各种各样的协议，比如TCP协议、IP协议、HTTP协议、FTP协议等。像这样把与互联网相关联的协议集合起来，就称为TCP/IP协议族。<br>通俗的来说就是以各种协议规则，在对应的层进行数据的封装．对数据的不同层的封装.<br>OSI/RM协议是由ISO(国际标准化组织）制定的，它有三个基本的功能：提供给开发者一个必须的、通用的概念以便开发完善、可以用来解释连接不同系统的框架。</p><h4 id="多层架构"><a href="#多层架构" class="headerlink" title="多层架构"></a>多层架构</h4><h5 id="OSI七层："><a href="#OSI七层：" class="headerlink" title="OSI七层："></a>OSI七层：</h5><pre><code>                 　　应用层：能够产生网络流量，能和用户交互的应用程序                 　　表示层：加密、压缩、开发人员                 　　会话层：服务和客户端建立的会话，如netstat -nb 可以查木马                 　　                 　　传输层：可靠传输建立会话、不可靠传输、流量控制                 　　网络层：IP地址编址、选择最佳路径                 　　数据链路层：输入如何封装、添加物理层地址、MAC                 　　物理层：电压、接口标准                 网络排错：从底层到高层。                 网络安全和OSI参考模型：                 　　物理层安全                 　　数据链路层安全：ADSL、AP密码                 　　网络层安全                 　　应用层安全：SQL注入漏洞、上传漏洞                 前三层开发工程师关心，中间三层网络工程师关心，物理层搞硬件的关心。用分层的思想，去解决问题。)</code></pre><h5 id="TCP-IP协议族的分层管理"><a href="#TCP-IP协议族的分层管理" class="headerlink" title="TCP/IP协议族的分层管理"></a>TCP/IP协议族的分层管理</h5><p>应用层：处理特定应用程序，如FTP、DNS、HTTP、Telnet(远程控制)<br>传输层：提供数据传输，该层有俩协议TCP和UDP<br>网络层：处理网络上流动的数据包，该层协议有IP、ICMP、IGMP<br>数据链路层：处理连接网络的硬件部分，包括操作系统、硬件设备驱动、网卡等<br>IP协议：Internet Protocol，网际协议，位于网络层。作用：把各种数据包传送给对方。如果要保证确定传送到对方那里，则需要满足各类条件，其中最重要的两个条件是IP地址和MAC地址。IP地址：指明了节点被分配到的地址（可以改变）；MAC地址：是指网卡所属的固定地址（基本不改变）；IP地址和MAC地址相互匹配。；ARP协议，用于解析地址，可以根据IP地址反查出对应的MAC地址。<br>TCP协议：Transmission Control Protocol，传输控制协议，位于传输层。作用：提供可靠的字节流服务。TCP通过三次握手策略提供可靠的服务<br>DNS：Domain Name System，域名系统，位于应用层。作用：提供域名到IP地址之间的解析服务</p><h5 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装."></a>数据封装.</h5><p>主机部分：</p><ol><li>应用层:上边三层基本是各种协议HTTP,FTP协议等</li><li>表示层</li><li>会话层</li><li>传输层:代表协议：tcp，udp。</li></ol><p>网络部分：</p><ol><li>网络层:代表设备：路由器，三层交换机，防火墙</li><li>链路层:代表设备：二层交换机，网桥。</li><li>物理层:代表设备：中继器，集线器、网线、HUB(集线器))等。数据单元:bit<br>部分设备的解释<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">（1）物理层</span><br><span class="line"></span><br><span class="line">l  转发器(repeater)：有源转发器将信号解调后再生放大，再调制后传输。</span><br><span class="line"></span><br><span class="line">l  集线器(hub)：实现星形拓扑的以太网，简单转发比特。</span><br><span class="line"></span><br><span class="line">（2）数据链路层</span><br><span class="line"></span><br><span class="line">l  适配器：又称网络接口卡NIC(Network Interface Card)，或网卡。用于计算机和局域网的通信。</span><br><span class="line"></span><br><span class="line">l  网桥(bridge)：用于在数据链路层扩展以太网，根据MAC帧的目的地址对收到的帧进行转发和过滤。含有转发表。它隔离了冲突域，但不隔离广播域。</span><br><span class="line"></span><br><span class="line">l  第二层交换机(layer2 switch)：多接口的网桥，又称以太网交换机或第二层交换机。可实现虚拟局域网VLAN(Virtual LAN)。</span><br><span class="line"></span><br><span class="line">（3）网络层</span><br><span class="line"></span><br><span class="line">l  第三层交换机(layer3 switch)：能进行路由的交换机，具有一部分路由器功能。</span><br><span class="line"></span><br><span class="line">l  路由器(router)：连接因特网中各局域网、广域网的设备。拥有路由选择处理机、交换结构、一组输入端口和一组输出端口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="七层信息封装"><a href="#七层信息封装" class="headerlink" title="七层信息封装"></a>七层信息封装</h6>数据发送:　　　　　　　　DATA｜<br>应用层:　　　　　　　AH+DATA｜AH为应用层协议头.为操作系统或网络应用程序提供访问网络服务的接口,常见的http,FTP,telnet,DNS<br>表示层:　　　　　　PH+AH+DATA｜PH为表示层协议头.解密加密,图片解码编码,数据压缩解压,URL加密,口令加密,图片编解码．<br>会话层:　　　　SH+PH+AH+DATA｜SH为会话协议头.使用校验点但会话在通信失效时从校验点恢复通信,服务器验证用户登录,断点续传.<br>传输层:(数据段)TH+SH+PH+AH+DATA｜TH为传输层协议头.建立连接,处理数据包错误,数据包次序,如tcp,udp,spx,进程,端口(socket).<br>网络层:(数据包)NH+TH+SH+PH+AH+DATA｜NH为网络层协议头.对子网间的数据包进行路由选择,如路由器,多层交换机,防火墙,ip,ipx,rip,OSPF.<br>链路层:(数据帧)DH+NH+TH+SH+PH+AH+DATA｜DH为数据链路层协议头.数据分帧,处理流控制,物理地址寻址,重发等,网卡,网桥,二层交换机等.<br>物理层:　　　　　　比特流传输信息     |网络通信的数据传输介质,由电缆与设备共同构成,中继器(信号扩大),集线器,网线,HUB,RJ-54标准等<br>（由于字数不能再精简了凑合看吧）</li></ol><h6 id="五层信息封装"><a href="#五层信息封装" class="headerlink" title="五层信息封装"></a>五层信息封装</h6><p>应用层：应用数据<br>传输层：tcp/udp头部+应用数据<br>网络层：ip头部+tcp/udp头部+应用程序<br>链路层：以太网头部+ip头部+tcp/udp头部+应用程序+以太网尾部<br>物理层: </p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>1）定义了网络设备的机械特性（如接口标准）、电器特性（如电压工作范围）、功能特性、过程特性<br>2）数据通信常识：数字信号、模拟信号<br>3）如何利用传输介质的带宽：频分多路复用、时分多路复用</p><h4 id="实现计算机的通信"><a href="#实现计算机的通信" class="headerlink" title="实现计算机的通信"></a>实现计算机的通信</h4><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><p>集线器(hub)是属于第一层(物理层)设备</p><p>集线器(HUB)属于数据通信系统中的基础设备，它和双绞线等传输介质一样，是一种不需任何软件支持或只需很少管理软件管理的硬件设备。它被广泛应用到各种场合。集线器工作在局域网(LAN)环境，像网卡一样，应用于OSI参考模型第一层，因此又被称为物理层设备。集线器内部采用了电器互联，当维护LAN的环境是逻辑总线或环型结构时，完全可以用集线器建立一个物理上的星型或树型网络结构。在这方面，集线器所起的作用相当于多端口的中继器。其实，集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。</p><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><p>用一个集线器(HUB)通过双绞线进行与计算机的链接.实现信息的转发.</p><p>原理:<br>    一个计算机发送一个消息给相关的集线器,集线器就会以广播的形式给每个相连接的计算机转发信息,收到转发的信息的计算机自己确定是否是自己如果是给予反馈.</p><p>弊端:<br>如果多台计算机同时发信息给集线器,这时在集线器发送信号的过程中会把两个甚至多个信息合并一起发送出去,主要是由于一根双绞线只能进行一条信息的发送,只能合并信息然后发出去,这样收到信号的计算机不能明确判断出是不是自己所要的信号,不能给予正确的信息反馈.</p><p>解决方法:</p><h5 id="CSMA-CD的引入"><a href="#CSMA-CD的引入" class="headerlink" title="CSMA/CD的引入"></a>CSMA/CD的引入</h5><p>  发送的机器在发送前会进行载波监听,看一看链路上是否有正在发送的数据,确定没有数据发送时在进行信息的发送.<br>最初的网络形式的缺点:<br>    首先进行数据广播阶段,会导致带宽利用率较低.<br>    其次只有一个设备能在链路上发送信息,导致链路的利用率降低.</p><p>集线器只适合小规模的网络并且工作在物理层.</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>1）要解决的三个问题：</p><ol><li>把要传输的数据封装成帧</li><li>发送端和接收端要对转移字符进行加、去，这叫透明封装</li><li>无差错接受（即差错检验）<br>2）点到点线路的数据链路层（使用PPP协议）<br>3）广播信道的数据链路层（CSMA/CD协议）<h4 id="数据链路层功能"><a href="#数据链路层功能" class="headerlink" title="数据链路层功能"></a>数据链路层功能</h4></li></ol><p>数据链路层在物理层提供服务的基础上向网络层提供服务。</p><p>作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路。让它对网络层表现为一条无差错的链路。</p><h4 id="为网络层提供的服务"><a href="#为网络层提供的服务" class="headerlink" title="为网络层提供的服务"></a>为网络层提供的服务</h4><ol><li>无确认的无连接的服务：源机器发送数据帧之前不用先建立链路连接，目的机器收到数据帧后也不要发回确认。</li></ol><p>对丢失的帧，数据链路层不负责重发而交给上层处理，用来实时通信或者误码率较低的通信信道。以太网就是这种机制服务</p><ol start="2"><li>有确认无连接的服务：源机器发送数据帧不需要建立链路连接，但是目的机器收到数据帧后必须发回确认。</li></ol><p>源机器在所规定的时间内没有收到确认信号，就会重新传丢失的帧。用来提高传输的可靠性。这种服务常用在误码率高的通信信道，比如无线通信。</p><ol start="3"><li>有确认的面向连接的服务：帧传输分为三个过程：建立数据链路，传输帧，释放数据链路。</li></ol><p>这种服务用语通信要求，可靠性，实时性较高的情况下。</p><p>注：有连接就一定要有确认</p><h4 id="数据链路层的链路管理"><a href="#数据链路层的链路管理" class="headerlink" title="数据链路层的链路管理"></a>数据链路层的链路管理</h4><ol><li>数据链路层，连接的建立，维持，释放，三个过程叫做链路管理，主要还是面向连接的服务</li></ol><p>两个工作栈之间进行传输信息的时候，必须将网络层的分组（package）封装成帧（Frame），然后用帧的格式进行传送。</p><p>在数据的前后分别加上帧头和帧尾，就构成了帧。</p><ol start="2"><li>帧头和帧尾的作用：确定帧的界限，也就是帧定界。</li></ol><p>HDLC标准帧格式：前后都有标志位F（01111110）</p><p>透明传输：不管所传数据是什么样的比特组合，都可以在连路上传送</p><h4 id="流量控制-传输层也有流量控制"><a href="#流量控制-传输层也有流量控制" class="headerlink" title="流量控制(传输层也有流量控制)"></a>流量控制(传输层也有流量控制)</h4><p>传输层详细解释.<br>由于发送方和接收方的工作速率和缓存空间的差异，可能出现发送方发送能力大于接收方的能力。如果不对链路上的信息流量限制，前面来不及接收的帧就会被后面不断发送的帧淹没，造成帧的丢失而出错。</p><p>流量控制：就是限制发送方的数据流量，使其发送速率不超过接收速率。</p><p>其实流量控制其它层也提供这个功能，只不过控制的对象不同而已。对于数据链路层：控制的是相邻两个节点之间</p><p>的数据链路上的流量。而对于传输层：控制的是从源端口到目的端口的流量。</p><p>流量控制的基本方法：接收方控制发送方发送数据的速率</p><p>常见方式：停止等待协议，滑动窗口协议</p><p>1.3.1、停止等待协议：发送方发送一帧，都要等待接收方得应答信号，才能发送下一帧。同样，接收方每接收一帧，都要反馈一个应答信号，这种传输效率很低。</p><p>1.3.2、滑动窗口协议：任何时刻，发送方都维持一组连续的允许发送的帧的序号，这个叫发送窗口</p><p>同样接收方也维持一组连续的允许接受帧的序号，叫接收窗口。发送窗口用来对发送方进行流量控制。</p><p>可靠传输机制：确认机制，超时重传机制。</p><p>1、多帧滑动窗口-选择重传协议SR</p><p>2、多帧滑动窗口-后退N帧协议GBN</p><p>后退N帧式ARQ中，发送方不需要再收到上一个帧的ACK后才能开始发送下一帧，也就是可以连续发送帧。</p><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>由于信道噪声等因素，帧传输可能出现错误。</p><p>位错：帧的某些位出现了差错，采用循环冗余校验CRC，通过自动重传请求ARQ方式来重传错误的帧</p><p>注：介质访问控制MAC（Medium Access Control）</p><p>信道划分介质访问控制有四种：频分多路复用FDM，时分多路复用TDM，波分多路复用WDM，码分多路复用CDM</p><h4 id="随机访问MAC协议。"><a href="#随机访问MAC协议。" class="headerlink" title="随机访问MAC协议。"></a>随机访问MAC协议。</h4><p>在随机访问协议中，不采用集中控制方式解决信息发送的次序问题。所有用户都可以根据自己的意愿随机发送信息，占用信道全部速率。在总线网中，当有两个或者多个用户同时发送信息的时候，就会产生帧的冲突。这导致所有冲突用户的发送均失败。</p><p>为了解决随机接入发生的碰撞，每个用户需要按照一定的规则反复的重传他的帧。知道帧没有碰撞到通过。</p><p>这些规则就是随机访问MAC协议。<br>重用的协议：ALOHA协议，CSMA协议，CSMA/CD协议，CSMA/CA协议</p><p>这些协议的核心思想都是：胜利者通过争用获得信道，进而获得信息的发送权，所以说随机访问MAC协议，也叫争用型协议。</p><p>MAC采用信道划分机制，那么节点之间的通信，要不就是共享空间，要不就共享时间，要不就两个都共享。</p><p>随机MAC：实质上是一种广播信道转化为点到点信道的行为。</p><p>因为交换机可以转发广播，随机访问MAC，可以将广播转化为point to point </p><h5 id="ALOHA协议：随机接入系统协议"><a href="#ALOHA协议：随机接入系统协议" class="headerlink" title="ALOHA协议：随机接入系统协议"></a>ALOHA协议：随机接入系统协议</h5><h5 id="CSMA协议："><a href="#CSMA协议：" class="headerlink" title="CSMA协议："></a>CSMA协议：</h5><p>如果每个站点在发送前都先侦听一下公用的信道，那么发送信道空闲后再发送，那么将会大大减小冲突的可能。从而提高信道的利用率。</p><p>载波侦听多路访问（Carrier Sense Multiple Access，CSMA）</p><p>CSMA协议对ALOHA协议的一种改进，也就是多了一个载波侦听装置。</p><h5 id="CSMA-CD协议：载波侦听多路访问-碰撞检测"><a href="#CSMA-CD协议：载波侦听多路访问-碰撞检测" class="headerlink" title="CSMA/CD协议：载波侦听多路访问/碰撞检测"></a>CSMA/CD协议：载波侦听多路访问/碰撞检测</h5><p>是对CSMA协议的改进方案，适用于总线型网络或者半双工网络环境</p><p>载波侦听：也就是发送前先侦听，每次发送数据之前都要先检查一下总线上是否有其他站点在发送数据，如果有</p><p>则暂时不要发送数据，等待信道变为空闲的时候再发送。</p><p>碰撞检测：就是一边发送一边侦听，适配器在发送数据的时候变检测信道上的信号电压的变化情况，用来判断自己在发送数据的时候其他站点是否也在发送数据。</p><p>CSMA/CD工作流程：先听后发，边听边发，冲突停发，随机重发</p><p>总线的传播时延对CSMA/CD的影响很大，CSMA/CD中的站不能同时发送和接收</p><p>所以CSMA/CD的以太网是不进行全双工通信，只能进行半双工通信</p><h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h5><p>CSMA/CD协议已经应用在使用有线连接的局域网中，但是要在无线局域网的环境下，却不能用。</p><p>CSMA/CD协议，尤其是碰撞部分，因为无线局域网中，接受信号的强度远远小于发送信号的强度。而且在无线介质上信号强度变化范围很广，要实现碰撞检测，那么在硬件上要花费很大。</p><p>在无线通信中，并非所有的站点都可以侦听到对方，也就是隐蔽站的问题。</p><p>CSMA/CA协议，广泛用于无线局域网。</p><p>把碰撞检测改成了碰撞避免（Collision Avoidance，CA）</p><p>碰撞避免：不是指协议可以完全避免碰撞，而是指协议的设计要尽量减少碰撞的发生概率。</p><p>CSMA/CA采用二进制指数退避算法。通过预约信道，ACK帧，RTS/CTS帧，三种机制来实现碰撞避免</p><p>RTS/CTS帧，主要用来解决无线网的隐蔽站问题。</p><p>预约信道，ACK帧，都是必须要实现的</p><p>预约信道：发送方在发送数据的同时想起他站点通过告知自己传输数据需要的时间长度，方便让其他站点在这段时间内部发送数据，避免碰撞。</p><p>ACK帧：所有站点在正确接收到发送给自己的数据帧后，都需要向发送方应答一个ACK帧。</p><p>总结：<br>CSMA/CA协议的基本思想：发送数据的时候先广播告知其他节点，让其他节点在某个时间段内不要发送数据，避免碰撞。</p><p>CSMA/CD协议的基本思想：发送前先侦听，边发送边侦听，一旦出现碰撞马上停止发送。</p><h4 id="轮询访问MAC：令牌传递协议"><a href="#轮询访问MAC：令牌传递协议" class="headerlink" title="轮询访问MAC：令牌传递协议"></a>轮询访问MAC：令牌传递协议</h4><p>在轮询访问中，用户不能随机的发送信息，是通过集中控制的监控站，以循环的方式轮询每个节点。然后决定信道的分配。</p><p>当某个节点使用信道的时候，其他节点都不能使用信道。典型的轮询MAC协议是令牌传递协议，令牌环局域网。</p><p>令牌传递协议：一个令牌在各个节点以一个固定的次序交换。令牌是个特殊的比特组成的帧，当换上的站希望传递帧的时候，就必须等待令牌，一旦收到令牌，站点就可以启动发送帧。</p><p>轮询MAC适合复杂很高的广播信道，负载很高的信道就是多个节点在同一时刻发送数据概率很大的信道。</p><p>如果 广播信道采用随机MAC，发生冲突的概率很大，而采用轮询MAC则可以更好满足各个节点的要求。</p><p>轮序的实质：不共享时间，空间。实质上就是在随机MAC的基础上，限定了有权利发送数据的节点只能有一个</p><p>即使是广播信道，都可以通过MAC使得广播信道逻辑上变成点对点的信道。所以说数据链路层研究的是点对点之间的通信。</p><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><h5 id="局域网的特点："><a href="#局域网的特点：" class="headerlink" title="局域网的特点："></a>局域网的特点：</h5><ol><li><p>为一个单位所拥有的，地理范围和站点数目有限</p></li><li><p>所有的站共享较高的总带宽，也就是共享较高的数据传输率</p></li><li><p>较低的时延和较低的误码率</p></li><li><p>各站为平等关系而不是主动关系</p></li><li><p>能进行广播和组播</p></li></ol><h5 id="局域网的拓扑结构："><a href="#局域网的拓扑结构：" class="headerlink" title="局域网的拓扑结构："></a>局域网的拓扑结构：</h5><p>星型，环形，总线型，星型+总线型复杂复合</p><h5 id="局域网的传输介质："><a href="#局域网的传输介质：" class="headerlink" title="局域网的传输介质："></a>局域网的传输介质：</h5><p>双绞线，同轴电缆，光纤，其中双绞线是主流</p><h5 id="局域网的介质访问控制方法："><a href="#局域网的介质访问控制方法：" class="headerlink" title="局域网的介质访问控制方法："></a>局域网的介质访问控制方法：</h5><p>CSMA/CD,令牌总线，令牌环</p><p>这是交换机常用于局域网，而局域网接入广域网要用路由器</p><p>CSMA/CD，令牌总线访问控制方法用于总线型网络</p><p>令牌环用于环形局域网</p><h5 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h5><p>使用范围最广的局域网，逻辑拓扑是总线型结构，物理拓扑是星型，或者扩展星型</p><h5 id="令牌环（Token-Ring）："><a href="#令牌环（Token-Ring）：" class="headerlink" title="令牌环（Token Ring）："></a>令牌环（Token Ring）：</h5><p>逻辑拓扑是环形，物理拓扑是双环</p><h5 id="FDDI（光纤分布数字接口）："><a href="#FDDI（光纤分布数字接口）：" class="headerlink" title="FDDI（光纤分布数字接口）："></a>FDDI（光纤分布数字接口）：</h5><p>逻辑拓扑是环形，物理拓扑是双环</p><p>由于以太网在局域网市场中垄断地位，几乎成为局域网的代名词</p><p>LLC子层也叫逻辑链路控制子层，由于他的作用不大，所以现在的网卡只有MAC协议没有LLC协议。</p><p>以太网逻辑上采用总线型拓扑结构，以太网中所有计算机共享同一条总线，信息以广播方式发送。</p><p>以太网简化了通信并且使用了CSMA/CD方式对总线进行访问控制。</p><p>计算机与外界局域网的连接是通过主机里的一块网络适配器（Adapter），也叫网卡NIC</p><p>网卡上有处理器和存储器，他工作在数据链路层的网络组件。</p><p>网卡是局域网连接计算机和传输介质的接口，不仅能实现于局域网传输介质之间的物理连接和电信号匹配</p><p>还涉及帧的发送与接收，帧的封装与拆封，介质访问控制MAC,数据的编码和解码，数据缓存等功能。</p><p>全世界的每一块网卡在出厂的时候都有一个唯一的代码，叫做价值访问控制MAC地址。</p><p>MAC地址用来控制主机在网络上的数据通信。</p><p>数据链路层的设备：网卡，网桥，交换机。</p><p>网桥，交换机都是使用各个网卡的MAC地址。网卡控制着主机对介质的访问，因此网卡也工作在物理层，只关注比特流。</p><p>以太网常用的传输介质：粗缆，细缆，双绞线，光纤</p><h5 id="MAC地址："><a href="#MAC地址：" class="headerlink" title="MAC地址："></a>MAC地址：</h5><p>物理地址，6个10进制数组成。速率达到或者超过100Mb/s的以太网叫高速以太网。</p><h4 id="广域网（Wide-Area-Network-WAN）"><a href="#广域网（Wide-Area-Network-WAN）" class="headerlink" title="广域网（Wide Area Network,WAN）"></a>广域网（Wide Area Network,WAN）</h4><p>广域网是Internet的核心部分，通过长距离运送主机所发送的数据，连接广域网各个节点的交换机的链路都是高速链路</p><p>距离是几千公里的光缆线路。广域网覆盖方位很广，远远超过一个城市。</p><p>广域网的组成：节点交换机+链路</p><p>节点交换机：和路由器一样都是用来转发分组的</p><p>节点交换机实在单个网络中转发分组，路由器是在多个网络构成的互联网转发分组。节点之间都是点到点连接。为了提高网络的可靠性，通常一个节点交换机往往与多个节点交换机相连。</p><h5 id="广域网和局域网的区别很大："><a href="#广域网和局域网的区别很大：" class="headerlink" title="广域网和局域网的区别很大："></a>广域网和局域网的区别很大：</h5><p>局域网使用的协议主要在数据链路层。</p><p>广域网使用的协议主要在网络层。</p><p>也就是说网络中的两个节点要进行数据交换，节点除了要给出数据外，还要给数据包装上一层控制信息，用来实现</p><p>检错纠错的功能。如果这层信息是数据链路层的协议控制信息，就叫做使用了数据链路的协议，如果这层控制信息是在网络层，就是使用了网络层的协议。</p><p>广域网强调：资源共享</p><p>局域网强调：数据传输</p><p>广域网中一个重要问题：路由选择和分组转发</p><p>路由选择协议：负责搜索分组从某个节点到目的节点的最佳路由，以便构成路由表。</p><p>分组转发：从路由表构造出转发分组的转发表。</p><p>PPP协议和HDLC协议是目前最常用的两种广域网数据链路层的面向字节的协议</p><h6 id="PPP协议（Point-to-Point-Protocol）"><a href="#PPP协议（Point-to-Point-Protocol）" class="headerlink" title="PPP协议（Point to Point Protocol）:"></a>PPP协议（Point to Point Protocol）:</h6><pre><code>使用串行线路通信的面向字节的协议，PPP协议应用在直接连接的两个节点的连路上。目的：通过拨号或者专线方式建立点对点的连接放松数据，让它成为各种主机，网桥，路由器之间简单连接的解决方法。PPP协议：在SLIP的基础上发展而来，可以在异步线路上传输，也可以在同步线路上用。不仅用于Modem链路，还可以用于路由器和路由器之间的链路。PPP组成：链路控制协议LCP：用来建立，配置，测试，管理数据链路网络控制协议NCP：由于PPP可以同时用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置。一个将IP数据报封装到串行链路的方法。PPP帧和HDLC帧的格式一样，收尾都是相同的标志字段为7EPPP协议是点对点的，不是总线型，不用CSMA/CD协议。</code></pre><h6 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h6><pre><code>高级数据链路控制（High-level Data Link Control）：面向比特的数据链路层协议。HDLC协议不依赖任何一种字符集编码，数据报文可以透明传输。PPP是面向字节的，HDLC协议是面向比特的TCP/IP协议簇：TCP,IP,ICMP,ARP,RARP,UDP,DNS,FTP,HTTPHDLC,PPP是ISO提出的数据链路层协议，不属于TCP/IP协议簇</code></pre><h4 id="什么是以太网，以太网如何检测冲突、避免冲突"><a href="#什么是以太网，以太网如何检测冲突、避免冲突" class="headerlink" title="什么是以太网，以太网如何检测冲突、避免冲突?"></a>什么是以太网，以太网如何检测冲突、避免冲突?</h4><h5 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">以太网是现实世界中最普遍的一种计算机网络。以太网有两类：第一类是经典以太网，第二类是交换式以太网，使用了一种称为交换机的设备连接不同的计算机。经典以太网是以太网的原始形式，运行速度从3~10 Mbps不等；而交换式以太网正是广泛应用的以太网，可运行在100、1000和10000Mbps那样的高速率，分别以快速以太网、千兆以太网和万兆以太网的形式呈现。 [1] </span><br><span class="line">以太网的标准拓扑结构为总线型拓扑，但目前的快速以太网（100BASE-T、1000BASE-T标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机来进行网络连接和组织。如此一来，以太网的拓扑结构就成了星型；但在逻辑上，以太网仍然使用总线型拓扑和CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection，即载波多重访问&#x2F;碰撞侦测）的总线技术。</span><br><span class="line">以太网实现了网络上无线电系统多个节点发送信息的想法，每个节点必须获取电缆或者信道的才能传送信息，有时也叫作以太（Ether）。（这个名字来源于19世纪的物理学家假设的电磁辐射媒体-光以太。后来的研究证明光以太不存在。） 每一个节点有全球唯一的48位地址也就是制造商分配给网卡的MAC地址，以保证以太网上所有节点能互相鉴别。由于以太网十分普遍，许多制造商把以太网卡直接集成进计算机主板。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="带冲突检测的载波侦听多路访问（CSMA-CD）技术"><a href="#带冲突检测的载波侦听多路访问（CSMA-CD）技术" class="headerlink" title="带冲突检测的载波侦听多路访问（CSMA/CD）技术"></a>带冲突检测的载波侦听多路访问（CSMA/CD）技术</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">带冲突检测的载波侦听多路访问（CSMA&#x2F;CD）技术规定了多台计算机共享一个通道的方法。这项技术最早出现在1960年代由夏威夷大学开发的ALOHAnet，它使用无线电波为载体。这个方法要比令牌环网或者主控制网简单。当某台计算机要发送信息时，在以下行动与状态之间进行转换：</span><br><span class="line">1. 开始- 如果线路空闲，则启动传输，否则跳转到第4步。</span><br><span class="line">2. 发送- 如果检测到冲突，继续发送数据直到达到最小回报时间（min echo receive interval）以确保所有其他转发器和终端检测到冲突，而后跳转到第4步。</span><br><span class="line">3. 成功传输- 向更高层的网络协议报告发送成功，退出传输模式。</span><br><span class="line">4. 线路繁忙- 持续等待直到线路空闲。</span><br><span class="line">5. 线路空闲- 在尚未达到最大尝试次数之前，每隔一段随机时间转到第1步重新尝试。</span><br><span class="line">6. 超过最大尝试传输次数- 向更高层的网络协议报告发送失败，退出传输模式。</span><br><span class="line">  </span><br><span class="line">    因为所有的通信信号都在共享线路上传输，即使信息只是想发给其中的一个终端（destination），却会使用广播的形式，发送给线路上的所有计算机。在正常情况下，网络接口卡会滤掉不是发送给自己的信息，接收到目标地址是自己的信息时才会向CPU发出中断请求，除非网卡处于混杂模式（Promiscuous mode）。这种“一个说，大家听”的特质是共享介质以太网在安全上的弱点，因为以太网上的一个节点可以选择是否监听线路上传输的所有信息。共享电缆也意味着共享带宽，所以在某些情况下以太网的速度可能会非常慢，比如电源故障之后，当所有的网络终端都重新启动时。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）以太网的设备：集线器、网桥、交换机<br>3）百兆、千兆、万兆以太网</p><h4 id="数据链路层的数据形式"><a href="#数据链路层的数据形式" class="headerlink" title="数据链路层的数据形式:"></a>数据链路层的数据形式:</h4><pre><code>数据头+数据部分, 数据头=原mac地址+目的mac地址.mac地址就是我们常说的物理地址.全球唯一(当然想改也是可以的).</code></pre><p>注意:虽然这里提到了物理地址但是用在了链路层!</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机:"></a>交换机:</h4><pre><code>一般的交换机是二成设备.可以进行桥接,与集线器功能类似.</code></pre><h5 id="交换机中的记录表"><a href="#交换机中的记录表" class="headerlink" title="交换机中的记录表:"></a>交换机中的记录表:</h5><pre><code>记录地址------端口(相对应的映射关系);</code></pre><p>实例:一台交换机连接了1,2,3,4,5号机器,对应的是口跟机器号一样的.<br>1号机器给3号机器通信时,1号机器会把信息发给交换机,交换机会在自己所维护的表中寻找mac地址3对应的是三号口,然后交换机会从3号口把信息发送出去.</p><h6 id="进化部分"><a href="#进化部分" class="headerlink" title="进化部分:"></a>进化部分:</h6><p>1 有了自己的表,不用广播寻找,提高了查找效率,<br>    2 采用网线形式(内置八根线,正常情况先维持四根以上的线正常工作).传输效率增加.<br>    3 全双工通信:<br>        比如1号机器在数据发送过程中也能进行数据的接受.</p><h5 id="交换机地址端口表的建立"><a href="#交换机地址端口表的建立" class="headerlink" title="交换机地址端口表的建立:"></a>交换机地址端口表的建立:</h5><p>例如交换机1,4,6号口连接了a,b,c三台机器,假如a给b发送消息,首先将a的mac和对应的接收端口好的对应关系写入表中,然后交换机会查询表中有没有b的mac所对应的发送端口,如果存在就将信息从对应借口发出,如果没有怎会进行广播(对所连接的机器依次发送),等到b机器回复后,集线器会将其mac和端口的对应关系写入表中,再进行消息的发送.<br>交换机替代集线器:<br>    交换机的表大概能存几千个,存储量比较小,如果按照集线器或者没有找目的mac对应的端口就会进行广播方式,从而造成信息洪泛.<br>    所以说在一定范围内或者说较小的局域网,交换机能有一个高效的传出,从而替代了集线器.</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>提供了服务器-&gt;服务器之间的通信.<br>为主机与主机之间提供了逻辑服务.（注意与网络层区别）</p><p>只负责在不同的网络之间尽力转发数据包， 如果丢了，不负责重传以及顺序。<br>路由器是三层设备，它顶多看到网络层的数据。物理层、数据链路层和网络层封装到一起。<br>所以不管物理层、链路层多乱，网络层只要看把数据传到哪个ip就行，其他不用管。<br>比如排查问题时，只要能ping通ip，说明下面三层没问题，就是上面两层的事。</p><p>简单的交换机存储数据,如果表格满了,后进的会把前边的数据顶掉,由于跨网的缘故,产生了路由器(网关),网关是跨网连接的连接点.<br>比如1,2两台机器在一个局域网,3机器在另一个局域网,两个局域网中间由路由器链接.<br>1和3号机器通讯需要经过路由器转发.<br>1和2号机器通讯不用经过路由器,只需要交换机就能完成通讯.</p><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址:"></a>ip地址:</h4><pre><code>标识网络(区分): 划分一个网络区域,区分每台机器在哪个网络下.标识设备(区分): 给该设备分配了相关的网络地址.这个设备属于哪个局域网.(网段)</code></pre><p>实例:<br>    给定一个场景网络1中有一个机器ip为192.168.1.254,网络2有一个机器192.168.0.102 两个机器中链接一个路由器靠近网络1为一号接口192.168.0.52,靠近网络2为2号接口192.168.0.1,</p><h5 id="相关过程"><a href="#相关过程" class="headerlink" title="相关过程:"></a>相关过程:</h5><pre><code>    1. 路由表的建立(路由表中存有网络1和网络2的ip)    2. 根据ip地址可以通过(APR协议)查找相对用应的ip地址对应的mac地址,</code></pre><h6 id="ARP协议简叙"><a href="#ARP协议简叙" class="headerlink" title="ARP协议简叙:"></a>ARP协议简叙:</h6><pre><code>在网络中去广播询问谁的ip是多少,然后相对应的机器会回复,我的mac地址是多少,然后反馈给发出请求的机器.    ip地址不能直接用于网络通讯(因为他是比较抽象的)但是mac地址能直接用于网络通讯.    ARP协议详细解释：        如果知道相关的mac地址，就不需要使用ARP协议了．        第一步：解析计算机的mac地址．        第二步:　发广播找到相关ip的mac地址，交换机把目的地址(mac) 设为全F即为全1(48位二进制),广播给所有连接口发出去.        第三步：相对应的计算机收到，发送方会将反馈的mac地址缓存本地.        第四步: 以后再次发送类似的信息没就不用ARP协议了，直接进行信息的封装即可.                第五步: 跨网需要网关的mac地址，然后发给网关．因为路由器隔绝广播（广播范围在一个网段（局域网）中）．    3. 实际传输用的都是mac地址    数据包 mac地址|ip地址|数据部分    mac地址:原/目的mac地址    ip地址:原/目的ip地址    数据部分:各种地址(tcp或http)+传输的数据.具体内部变化:    1. 192.168.0.102-&gt; 192.168.0,1    ip的原地址 192.168.0.102 目的地址 : 192.168.1.254 (ip传输过程均不会改变).    mac地址原地址:192.168.0.102(对应mac地址) 目的地址: 192.168.0.1(对应的mac地址) 采用的ARP协议    2. 192.168.0.1-&gt;192.168.0.52    ip地址不变    mac地址原地址:192.168.0.1(对应mac地址) 目的地址:192.168.0.52(对应mac地址)    3. 192.168.0.52-&gt;192.168.1.254    ip地址不变    mac地址原地址:192.168.0.1(对应mac地址) 目的地址:192.168.1.254(对应mac地址)</code></pre><p>在NET中ip地址也会进行切换.</p><p>网络层应用层相关协议的关系．</p><p>网络层：tcp||udp<br>－－－－－－－－－－－－－－－－－<br>传输层：ARP || ip || (ICMP||IGMP)<br>－－－－－－－－－－－－－－－－－</p><h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议:"></a>ip协议:</h4><p>从一个网段转发到另一个网段.</p><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议:"></a>ICMP协议:</h4><p>测试网络故障问题.</p><h4 id="传输层的相关协议："><a href="#传输层的相关协议：" class="headerlink" title="传输层的相关协议："></a>传输层的相关协议：</h4><ol><li>ARP与数据链路层相接（探索mac地址）为IP协议提供服务．</li><li>ip协议受(ICMP||IGMP)两个协议提供服务，测试网络故障问题．</li></ol><p>这里说一些网络相关的攻击：(以后封神台打靶会有涉及！)<br>ARP欺骗类型的攻击：</p><ol><li>在收到广播时，返回一个不存在的假的mac地址或者是伪装目的主机的发送自己的的mac.从而造成消息的重复发送或者是发送的监听机器，导致频繁发送数据得不到确认进而机器cpu超负荷运转崩溃，还有一种就是被别人检测发送的消息，信息泄露.<br>相关的软件有：网络执法者等．</li></ol><h4 id="如果被欺骗了，如何的应对？"><a href="#如果被欺骗了，如何的应对？" class="headerlink" title="如果被欺骗了，如何的应对？"></a>如果被欺骗了，如何的应对？</h4><ol><li>通信双方各自绑定对方的mac地址（手动绑定）．</li><li>把命令写入.bat的文件中，放入开机运行目录，即开机启动，方法1的变种(手动绑定).</li><li>使用ARP防火墙.</li></ol><h4 id="ip协议：可以测的网络层的故障．"><a href="#ip协议：可以测的网络层的故障．" class="headerlink" title="ip协议：可以测的网络层的故障．"></a>ip协议：可以测的网络层的故障．</h4><p>ping命令:<br>ping time:查看延时<br>查看命令时会有一个TTL表示的数据包的生存时间，每经过一个路由器就会减一．<br>防止数据包在网络中无限扩散，浪费信道．<br>一般的TTL数量．<br>linux: 64<br>Windows: 128<br>unix: 225<br>可用命令查询相关TTL数据，就可以判断大概是哪种系统了.</p><h4 id="如果网络不太好的情况该如何排查呢？"><a href="#如果网络不太好的情况该如何排查呢？" class="headerlink" title="如果网络不太好的情况该如何排查呢？"></a>如果网络不太好的情况该如何排查呢？</h4><p>依照一下顺序依次判断哪里的故障.</p><ol><li>ping 内网</li><li>ping 外网</li><li>ping DNS 常用DNS两个：(222.222.222.222)(8.8.8.8)</li></ol><h4 id="ICMP协议-1"><a href="#ICMP协议-1" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><p>ICMP协议返回的故障一般是路由器不知道如何走．<br>请求超时一般数据包有去无回的故障．<br>pathping:命令（window命令）主要计算丢包情况．<br>tracent: ip跟踪数据包的路径.<br>tracerout: ip 在路由器上跟踪数据包的路径．</p><h4 id="IGMP协议："><a href="#IGMP协议：" class="headerlink" title="IGMP协议："></a>IGMP协议：</h4><p>首先说一下通信协议：<br>点到点通信：<br>明确知道ip和mac地址，通信双方均知道，直接信息交付．<br>广播：<br>目标mac全置位1,ip全为1.(就是所有二进制位置为1),在网上发布广播(全局域网广播，不可跨路由器).<br>组播：<br>用一地域，多个广播（分为多个广播ip地址），类似于收音机的频道.</p><p>IGMP协议：<br>组播管理协议，配置在路由器接口上的周期性扫描本网段中的那些计算机绑定了多播地址，如果没人绑定则会取消信息的发送，但凡有一台机器绑定了，便还是会接受数据，发送数据给连接的计算机．</p><h4 id="ip数据报："><a href="#ip数据报：" class="headerlink" title="ip数据报："></a>ip数据报：</h4><p>首部+数据部分.<br>首部具体分析：<br>版本：<br>首部长度：<br>区分服务：<br>总长度：<br>标识：<br>标志：<br>片偏移：<br>生存时间：<br>协议：<br>首部检验和：<br>原地址：<br>目的地址：</p><h4 id="数据包分片操作"><a href="#数据包分片操作" class="headerlink" title="数据包分片操作:"></a>数据包分片操作:</h4><p>网络层的数据包比数据链路层的传输单元大了，就会产生分片．<br><a href="https://blog.csdn.net/ITlanyue/article/details/104588619?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-2-104588619.nonecase&utm_term=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%ADppp%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F&spm=1000.2123.3001.4430">相关数据帧跳转</a></p><p>看一下数据的不同层的数据变换：</p><p>应用层：一个完整的数据（就比如一个网页信息）．<br>传输层：数据分成不同的段．<br>网络层：数据段分成不同的包，包的首部添加原目的ip地址.<br>链路层：把包分片封装成帧首部加原目的ip地址，尾部添加FCS.<br>两种情况<br>　　　　　　使用自己的子网掩码，判断自己在哪个网段<br>　　　　　　使用自己的子网掩码，判断目标地址在哪个网段<br>　　　　　　如果是同一个网段，arp协议广播解析目标IP地址的MAC<br>物理层：数据帧以电信号的形式发送给集线器（），再发送给路由器,(中间会夹杂ppp协议，广播等方式)传至接收方.</p><h4 id="数据链路层的帧："><a href="#数据链路层的帧：" class="headerlink" title="数据链路层的帧："></a>数据链路层的帧：</h4><p>进行相关帧的头尾封装　mac1+mac2+数据包+FCS<br>相关大小的定义：<br>以太网的帧有最小和最大字节限制，最小的帧是64字节，数据区的有效载荷长度最小为48字节，当有效载荷较小时，以保障帧的大小达到64字节。<br>最大的帧是1518字节，由于MTU（最大传输单元）的上限为1500，去除首尾数据就只剩下1480字节的数据部分，对于TCP/IP网络常用的较大尺寸是64KB的数据，需要至少44帧来传输。</p><h4 id="攻击方式："><a href="#攻击方式：" class="headerlink" title="攻击方式："></a>攻击方式：</h4><p>可以采用发送损坏的ip包，或者发送重叠的/过大的ip包，攻击tcp/ip的分片重组代码．比如发1,3,最后发送2,或者2干脆不发了，tcp/ip会进行ip重组尽可能大的消耗cpu处理能力.</p><p><a href="https://blog.csdn.net/suyy_hui/article/details/97953308">IP数据报头部信息</a></p><p>ip协议涉及两种(RIP,OSPF)</p><h4 id="更新路由两种方式"><a href="#更新路由两种方式" class="headerlink" title="更新路由两种方式"></a>更新路由两种方式</h4><h5 id="1-静态路由（死板）"><a href="#1-静态路由（死板）" class="headerlink" title="1. 静态路由（死板）"></a>1. 静态路由（死板）</h5><p>需要管理员告诉路由器所有没有直连网络的吓一跳给谁．<br>弊端:使用于小的网络，不能自动调整路由，增加管理员的工作量.</p><h5 id="2-动态路由-配置关联网段即可"><a href="#2-动态路由-配置关联网段即可" class="headerlink" title="2. 动态路由(配置关联网段即可)"></a>2. 动态路由(配置关联网段即可)</h5><p>RIP协议，周期性广播自己的表，别的路由器进行学习，每个路由器会记下每个到每个网段需要几个路由器，优先选择经过路由器数量少的路径即为最优路径，如果更新路由一个周期后还是没有相关路径即为不可达．RIP 周期性广播路由表 跳数 30秒更新一下路由信息 最大跳数 15跳.如果一个理由器坏掉以同样的方式进行广播，路由器最大跳数为十五如果超过15则不可达.</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层：<br>为相互通信的应用(进程)提供了逻辑通信．<br>提供了端到端的之间的服务,面向连接(tcp),面向无连接(udp)的服务.</p><h4 id="tcp建立连接"><a href="#tcp建立连接" class="headerlink" title="tcp建立连接:"></a>tcp建立连接:</h4><p>应用层：　　应用进程<br>－－－－－－端口…..端口－－－－－－<br>运输层：tcp复用，tcp报文段.<br>－－－－－－NSAP－－－－－－－－－－－<br>网络层：ip复用<br>－－－－－－传出－－－－－－－－－－－<br>ip数据报</p><h4 id="NSAP-用协议号标记"><a href="#NSAP-用协议号标记" class="headerlink" title="NSAP : 用协议号标记"></a>NSAP : 用协议号标记</h4><p>例如<br>TCP: 6<br>UDP: 17<br>IGMP: 1</p><p>熟知的端口号:0-1023<br>登记端口:1024-49151<br>客户端口:49152-65535</p><h4 id="TCP主要特点"><a href="#TCP主要特点" class="headerlink" title="TCP主要特点:"></a>TCP主要特点:</h4><ol><li>面向连接的传输协议．</li><li>每一条tcp连接只能有两个端点，每一条tcp连接只能是点对点的．(一对一)．</li><li>tcp提供可靠地交付服务．</li><li>tcp提供全双工通信．(比如ａ向ｂ建立连接ａ向ｂ发送数据,ｂ会给予答复.如ａ：我发信息了，Ｂ：好，ａ：我喜欢你，Ｂ：恩，接着说)．</li><li>面向字节流．</li></ol><h4 id="tcp传输文件的过程-解释了面向字节流通讯"><a href="#tcp传输文件的过程-解释了面向字节流通讯" class="headerlink" title="tcp传输文件的过程(解释了面向字节流通讯)"></a>tcp传输文件的过程(解释了面向字节流通讯)</h4><p>场景两台机器1和2,1号机器有他的文件要发送给机器2.<br>传送文件过程中，有一个tcp缓存，会把部分文件存入机器１的tcp缓存中（内存大小是随机的，不确定）放上头部发送给2号机器，2 号机器收到了相关信息，存入机器2的tcp,去掉头部，现在机器2的内存中有很多信息，机器2会随机大小传给文件进行存储.</p><p>每一个tcp都是有通信两端的两个端点所确定的．</p><h4 id="tcp首部的部分字段："><a href="#tcp首部的部分字段：" class="headerlink" title="tcp首部的部分字段："></a>tcp首部的部分字段：</h4><p>urg：标志比较急、要插队的数据，标记为1，不排队<br>psh：跟psh配合，urg是在发送端，插队到自己的缓存里，psh是数据送到服务端了，在人家的缓存里插队到前面，标记为1，不排队<br>ack：0，确认号无效，1，确认号有效，这个和syn配合用<br>syn：同步，意思是请求要建立连接了，1，表示想建立连接，如下图，第一次握手，syn1、ack0，第二次握手，syn1、ack1，这时就能客户端就能进行第三次握手，但客户端憋着不发，服务端就一直等，就造成DDOS攻击了，这也是下面记得笔记里为啥tcp要三次握手的原因，没三次握手前，全是DDOS哈哈。<br>这种syn+ack的ddos攻击是在第二次握手时的，还有种第一次握手就搞的，就是客户端第一次握手时，把自己ip改成随机的，让服务端进行确认时（第二次握手），找不着这ip，或者找到别人的ip上，这样消耗服务端资源。<br>syn攻击：通过伪造请求的ip，建立tcp连接，导致受害机器一直找那个要回应的ip，占用资源直到死机。这让我想起了著名的DDOS攻击<br>rst：中断的标志，1表示中断连接了，比如在浏览器里，正在请求页面，点了红色的小叉中断请求，就会发rst为1的tcp过去<br>fin：结束标志，传完了，这个值就变为1，代表我tcp的数据传完啦</p><h4 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h4><p>三次握手四次挥手下边链接写的很好很全了.<br><a href="https://blog.csdn.net/ZWE7616175/article/details/80432486">三次握手四次挥手</a></p><h4 id="如何实现可靠通信的？"><a href="#如何实现可靠通信的？" class="headerlink" title="如何实现可靠通信的？"></a>如何实现可靠通信的？</h4><ol><li>确认和重传机制</li></ol><p>建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础</p><p>传输过程中，如果Checksum校验失败、丢包或延时，发送端重传。</p><ol start="2"><li>数据排序</li></ol><p>TCP有专门的序列号SN字段，可提供数据re-order</p><ol start="3"><li>流量控制</li></ol><p>滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。</p><ol start="4"><li>拥塞控制</li></ol><p>TCP的拥塞控制由4个核心算法组成：</p><p>“慢启动”（Slow Start）</p><p>“拥塞避免”（Congestion avoidance）</p><p>“快速重传 ”（Fast Retransmit）</p><p>“快速恢复”（Fast Recovery）</p><p>确认重传机制例子:<br>(两台机器a和b)<br>tcp连接的是两个端点，端点是ip地址+端口，这个端点学名叫－－套接字．</p><ol><li>正常情况　a给b机器发送信息，b机器给予正常的反馈．</li><li>a给b机器发送数据，但消息丢失了，b不会给反馈，过一段时间，a会再次发送信息．</li><li>a给b机器发数据，b没有给予反馈或反馈丢失，ａ会再次发送数据.</li><li>a给b发送完数据后，a没收到反馈，便会再次发送，经过一段时间，b的第一次的反馈信息到达,a机器会忽略反馈.<br>注意: 这里提到的时间大概多于RTT时间,</li></ol><h4 id="RTT"><a href="#RTT" class="headerlink" title="RTT:"></a>RTT:</h4><pre><code>是一个消息的往返时间（RTT）</code></pre><h4 id="ARQ-tcp纠错协议"><a href="#ARQ-tcp纠错协议" class="headerlink" title="ARQ-tcp纠错协议"></a>ARQ-tcp纠错协议</h4><p>自动重传请求(ARQ)是OSI模型中数据链路层的错误纠正协议之一.</p><h5 id="停等式ARQ"><a href="#停等式ARQ" class="headerlink" title="停等式ARQ:"></a>停等式ARQ:</h5><p>发送和接收窗口大小均为1,发送方每发送1帧之后就必须停下来等待接收方的确认返回,仅当接收方确认正确接收后再继续发送下一帧.否则会重传.<br>优缺点:该方法所需要的缓冲存储空间最小,缺点是信道效率很低.</p><h5 id="回退N帧ARQ"><a href="#回退N帧ARQ" class="headerlink" title="回退N帧ARQ:"></a>回退N帧ARQ:</h5><p>发送窗口大于1,接收窗口等于1,允许发送方可以连续发送信息帧,一旦某帧发生错误,必须重新发送该帧及其后的n帧.<br>优缺点:这种方式提高了信道利用率,但是允许已发送有待于确认的帧越多,可能要退回重发的帧越多.</p><h5 id="选择性重传ARQ"><a href="#选择性重传ARQ" class="headerlink" title="选择性重传ARQ:"></a>选择性重传ARQ:</h5><p>发送窗口和接收窗口都大于1,发送方仅重新传输发生错误的帧,并缓存错误帧之后的发送的帧.<br>优缺点:与回退n帧ARQ相比,减少了重传帧的数量开销.</p><p>总结:三种ARQ协议中,复杂性递增,效率递增,除了传统的ARQ,还有混合ARQ.</p><h5 id="混合ARQ"><a href="#混合ARQ" class="headerlink" title="混合ARQ:"></a>混合ARQ:</h5><p>在数据报文传送到接收方之后,即使出错也不丢弃.接受方指示发送方重传出错报文或全部信息,将再次收到的报文信息与上次报文信息进行合并,以回复<br>优缺点: 比较简单,缺点:信道利用率不高,信道远远没有被数据比特填满.</p><p>在现代无线通信中,ARQ主要应用在无线链路层.</p><h4 id="tcp-滑动窗口"><a href="#tcp-滑动窗口" class="headerlink" title="tcp-滑动窗口"></a>tcp-滑动窗口</h4><p>双发窗口的大小可以根据需要动态变化,达到在提高数据传输效率的同时,防止阻塞的发生.<br>一般窗口从左往右移动.不提倡从右往左移动.<br>注意:<br>    1. 发送方不必发送一个全窗口大小的数据<br>    2. 发送方收的一个报文段确认数据并把窗口向右滑动,因为窗口大小是相对于确认序号的.<br>    3. 窗口大小可以减小,到时窗口不能从右向左运动.<br>    4. 接收方在发送一个ACK前不必等待窗口被填满.</p><p>一个例子:<br>普通的做法浪费了信道的利用率.<br>流水线传输：<br>发送方连续发送多个分组，不必每发送一个分组就停顿下来等待对方的确认.<br>连续ARQ协议：<br>就不如连续发送的窗口为5，就连续的发送五个信息，等收到第一个回复后，窗口往后移动一位，第一个数据可以丢掉了．<br>累计确认：<br>就是累计收多若干条数据给予一次回复信息.</p><p>就比如收到的是1235就会回复4，表示我想要第4个信息．<br>收到123,也会回复4，表示我想要第4个信息．</p><h4 id="tcp协议如何进行流量控制"><a href="#tcp协议如何进行流量控制" class="headerlink" title="tcp协议如何进行流量控制?"></a>tcp协议如何进行流量控制?</h4><p>根本问题解决通信两端处理数据速度不一样的问题.<br>就比如：先建立会话接收端给发送端发送ACK = 0, rwnd = 10，说明ACK表示确认号主管确认字段有效无效问题，rwnd = 10,表示我接收窗口是10,你的发送窗口也定为10.<br>如果传来的序列为1-20连续的数据，传来了数据1,2,接收后缓存就会变小，窗口就编程8了．直到传送完毕，反馈信息为ack = 1,rwnd = 0,表示确认字段生效，窗口设置为0,表示我的缓存已满需要进行处理，暂时不要传数据了．<br>处理完毕后再进行两次数据请求的发送，防止一次发送丢失问题，而且在信息处理过程中，发送方还会发送信息来确定窗口的变化，防止接收方发送数据丢失了而我接收方不知道的问题.(避免等待时间过长，减少不必要的等待时间).</p><h4 id="tcp协议如何避免网络拥塞"><a href="#tcp协议如何避免网络拥塞" class="headerlink" title="tcp协议如何避免网络拥塞?"></a>tcp协议如何避免网络拥塞?</h4><p>拥塞避免算法：<br><a href="https://blog.csdn.net/wdscq1234/article/details/52529994">快充传快恢复算法</a><br>快开始：<br>表示指数增长．(2的指数倍增长)．</p><p>慢开始门限值后就＋１增长（加法避大）拥塞避免．<br>网络拥塞后新的门限值为(网络拥塞值)/2.<br>然后再次重新开始.<br>场景机器A,B，机器A给机器B发送消息分别是消息1,2,4,就会紧急回复我想要3在接受到之前会一直回复要3并且收到三次,如果正常传送就是1,2,3,4．B机器回复我想要5.因为出现丢失问题，可能预示着网络即将发生拥堵,如果没有堵就会采用快恢复，如果堵了就会采用慢开始．</p><p>这里为什么是三次呢？<br>因为三次可判断网络是否堵了．</p><p>快重传:　<br>如果收到一个out-of-order的报文段时， TCP需要立刻产生一个ACK，这个ACK不应该被延时，目的在于让对方知道收到一个失序的报文，并告诉对方自己希望收到的报文seq，我们不知道这个重复的ACK的原因，因为还是会等待少量的重复ACK到来，如果连续收到3个或者3个以上的dup ACK，就被判断这个报文被丢失了，于是就需要立即重传丢失的数据段，这个地方不用等待定时器溢出。</p><p>快恢复:<br>　直接从(拥塞值)/2处进行+1操作开始．<br>　门限值改为新的窗口，<br>  丢包重传以及窗口的调整.</p><h4 id="UDP主要特点"><a href="#UDP主要特点" class="headerlink" title="UDP主要特点:"></a>UDP主要特点:</h4><ol><li>是无连接的即发送数据之前不需要建立连接． </li><li>使用最大努力交付，即不保证可靠交付，同时不使用拥塞控制．</li><li>是面向报文的，UDP没有阻塞要求，很适合多媒体通信要求．</li><li>支持一对一，一对多，多对一，多对多的交互通信． </li><li>首部开销小只有八个字节．</li></ol><h5 id="UDP的格式"><a href="#UDP的格式" class="headerlink" title="UDP的格式"></a>UDP的格式</h5><p>应用层：应用层报文<br>传输层：加上了UDP首部．(源端口，目的端口，长度，检验和)每个占用两个字节．<br>网络层：加上了ip首部．</p><h5 id="tcp-ip协议应用"><a href="#tcp-ip协议应用" class="headerlink" title="tcp/ip协议应用:"></a>tcp/ip协议应用:</h5><pre><code>比如在一台机器访问一个web网站的流程(简述)一个数据包65535个大小的字节大概65K,一个网页要划分成很多小的数据包(分片编号).---(这个时候可能出现丢包现象,所以说客户端和服务端要建立会话,确保消息不会丢失,如果丢失了客户端会进行消息的重传(实现消息的可靠传输)).然后传到客户端,客户端进按照序号行网页补全.总结:tcp需要传输文件分段传输,建立会话实现可靠传输,有流量控制功能(发的过快会延缓发送).</code></pre><h5 id="udp协议应用"><a href="#udp协议应用" class="headerlink" title="udp协议应用:"></a>udp协议应用:</h5><pre><code>一个数据包就能完成通讯,客户端和服务端不需要建立会话,不需要流量控制,是不可靠传输.(直接发送数据包)udp 需要把域名解析成网址再访问网站.    1. 向DNS发送请求,这个网端域名为多少,一个文件能搞定这些事,就用udp协议(传输层).    windows下 通过netstat -n/-nb来查询会话,可排查木马.常用的比如qq聊天文字发送,屏幕广播等多播广播.</code></pre><h5 id="讲一下传输层和应用层-下一层-的关系"><a href="#讲一下传输层和应用层-下一层-的关系" class="headerlink" title="讲一下传输层和应用层(下一层)的关系"></a>讲一下传输层和应用层(下一层)的关系</h5><p>   tcp和udp在传输层加上相对应的端口就构成了相对应的应用层的协议.<br>   http = tcp +　80端口　<br>   https = tcp + 443端口<br>   RDP = tcp + 3389端口<br>   FTP = tcp + 21端口<br>   共享文件 = tcp + 445端口<br>   SMTP = tcp + 25端口(发邮件协议)<br>   POP3 = tcp + 110端口(收邮件)<br>   telnet = tcp + 23端口<br>   SQL = tcp + 1433端口<br>   DNS = tcp/udp + 53端口(域名解析协议一般主要用UDP)</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>服务和应用层关系：<br>相关服务会在相关端口进行侦听（服务端）<br>里如<br>Web—&gt;tcp 80端口<br>FTP—&gt;tcp 21端口<br>AMTP–&gt;tcp 25端口<br>POP—&gt;tcp 110端口<br>端口部分带有网卡类似与大门.(可设置相关端口让特定的端口进入).(网络安全常用比如不想让别人访问你的端口，进行端口处理)</p><p>应用层的各种协议，可以看作是tcp+端口组成的服务。</p><h4 id="应用层各种协议"><a href="#应用层各种协议" class="headerlink" title="应用层各种协议"></a>应用层各种协议</h4><p><a href="https://blog.csdn.net/weixin_38569499/article/details/103980865">可参考</a></p><h5 id="域名DNS服务器"><a href="#域名DNS服务器" class="headerlink" title="域名DNS服务器:"></a>域名DNS服务器:</h5><p>nslookupmZe System），域名系统。域指的是自治系统网络，名指的是IP对应的名字。域名系统可以将自治系统不容易记忆的IP，转化为容易记忆的域名，然后在通信的时候，再将域名解析为IP进行通信。<br>域名由点、字母、数字组成，点分割不同的域。例如对于<a href="http://www.taobao.com,com是顶级域,taobao是二级域,www是三级域.当然,还可以继续去分隔四级域、五级域等.顶级域是国际通用的./">www.taobao.com，com是顶级域，taobao是二级域，www是三级域。当然，还可以继续去分隔四级域、五级域等。顶级域是国际通用的。</a></p><p>1.2 顶级域：<br>    1. 国家专用的顶级域，例如cn（中国）、us（美国）、uk（英国）、ca（加拿大）；<br>    2.  通用的顶级域，例如com（商业机构）、net（网络服务器机构）、gov（政府机构）、org（组织）等。<br>    注意，edu是cn下的二级域。<br>1.3  DNS服务器<br>    DNS服务器，也叫域名服务器。只要有外网服务器，就可以搭建一个DNS服务器。</p><pre><code>DNS服务器分为:               1. 根域名服务器：最高等级的服务器，每个国家自行维护，分布在不同的国家，它可以知道所有的顶级域名服务器的地址；2. 顶级域名服务器：主要由不同国家和地区自行维护，用于解析顶级域名；3. 本地域名服务器：主要由各个公司、机构自行维护，用于解析二级、三级等域名。</code></pre><p>如果一个本地域名服务器要查询baidu.com对应的IP，主要流程</p><ol><li>首先要解析顶级域名com，如果它不知道去哪里找相应的顶级域名服务器，就会去查询根域名服务器，以获取到相应的顶级域名服务器的地址；</li><li>本地域名服务器去顶级域名服务器中查询，二级域名baidu应该去查询那个本地域名服务器，顶级域名服务器会告诉本地域名服务器，需要去查询的本地域名服务器的地址是多少；</li><li>本地域名服务器再去查询相应的本地域名服务器，查询baidu.com对应的IP是什么。</li></ol><h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议:"></a>HTTP协议:</h5><pre><code>HTTP（Hyper Text Transfer Protocol），超文本传输协议。超文本指的是，超级文本，即带有超链接的文本，可以有图片、动图、音频、视频等。</code></pre><p> HTTP协议的地址：http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。HTTP默认端口是80，HTTPS默认端口是443.</p><h5 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议:"></a>HTTPS协议:</h5><pre><code>1. HTTP是明文传输，会有信息安全的问题。2. HTTPS的S，表示的是Secure，安全的意思。3. HTTP协议的地址：http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。HTTP默认端口是80，HTTPS默认端口是443。</code></pre><h5 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP:"></a>DHCP:</h5><pre><code>可以动态分配ip，与dns一样，都可以在计算机上配置这个服务使自己电脑提供dns或dhcp服务。</code></pre><p>dhcp是一个逆向的arp，arp是在网络层发广播，问这个ip对应的mac地址是多少，而dhcp是发广播，问我这个mac地址应该被分配一个什么ip。<br>  DHCP为计算机自动获取IP的过程：</p><ol><li>DHCP的监听端口默认是67，主机会使用UDP协议广播DHCP发现报文，通过这个发现报文发现DHCP服务器的位置；</li><li>DHCP服务器收到后，会回复DHCP提供报文，通知对方自己可以提供DHCP服务；</li><li>主机收到DHCP服务器的DHCP提供报文后，会向DHCP服务器发出DHCP请求报文，用于请求IP地址；</li><li>DHCP服务器响应请求，并提供IP地址。<h5 id="FTP-："><a href="#FTP-：" class="headerlink" title="FTP ："></a>FTP ：</h5>如果连不上，要看它是什么模式，如果被动模式访问不了，就是对方限制了端口，这时客户端成主动模式即可</li></ol><h5 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h5><p>　　主动模式：ftp客户端告诉ftp服务器使用什么端口侦听<br>　　　　　　　ftp服务器和ftp客户端的这个端口建立连接  源端口20<br>　　被动模式：ftp服务器打开一个新端口，等待ftp客户端的连接<br>　　ftp服务器端，如果有防火墙，需要在防火墙开21和20端口，使用主动模式进行数据连接</p><p> 通过window组件，可以添加ftp服务，将自己电脑设置为ftp服务器，此时别人连接我时，netstats -n查看，没有20端口，就是被动模式。上传下载文件还是tcp进行的传输，每个文件的传输都建立一个新的会话</p><h5 id="telnet"><a href="#telnet" class="headerlink" title="telnet:"></a>telnet:</h5><pre><code>可以远程调试如路由器、交换机等网络设备；还可以测试端口是否打开</code></pre><h5 id="rdf："><a href="#rdf：" class="headerlink" title="rdf："></a>rdf：</h5><p>远程桌面，跟telnet对应，它是终端命令行，这是桌面，只要网络畅通，在哪都能连上。这个用的是tcp的3389端口<br>mstsc<br>在任务管理器-用户，可以控制当前链接的人。<br>windows Server最多两个人连一台电脑。<br>telnet和rdf都需要本机设置有密码才能用。<br>远程连接其他电脑时，可以直接设置将本地磁盘映射过去，这样就可以直接传文件了。</p><p>http视频有问题，然后就教了如何搭建windows上的网站，感觉跟看毛骗里的做假网站似的。然后又讲了邮箱服务器smtp的搭建，也是在windows上搭建的，随便看看把</p><p>关于http，看了《计算机网络自顶向下》，提到了http不保存客户任何信息，所以它是无状态的，<br>http分为非持续连接、持续连接，即短连接、长连接。http1.1默认长连接，短链接就是连一次就新发http请求，每次的tcp不同，长连接则相同。详情点我参考<br>请求方式：get，post，head（对方只响应，不返对象），put（上传文件），delete（删服务器的内容）<br>用户与服务器交互：cookie，<br>但我们可以用cookie保存客户信息，客户首次请求，服务器可以给它个id并返回给客户端，下次再请求，浏览器会在其请求报文中继续放入首部行cookie：id，这样就可以根据此用户访问过的网页，给他推送相关产品了。</p><h4 id="web缓存服务器："><a href="#web缓存服务器：" class="headerlink" title="web缓存服务器："></a>web缓存服务器：</h4><p>http老请求服务器太慢，比如局域网网速100M，连外网10M，就可以买个缓存服务器，请求的图片、视频，都缓存到缓存服务器上，这样对http的请求响应就快了。比如CDN（内容分发网络），就是干的这件事，cdn公司买很多服务器，根据你的请求，dns服务器给你一个就近的cdn服务器域名，然后返回这个cdn缓存服务器的地址。<br>而ngnix，是针对服务器端而言的，主要用来分散服务器端的请求压力。</p><h4 id="缓存服务器内容同步问题"><a href="#缓存服务器内容同步问题" class="headerlink" title="缓存服务器内容同步问题"></a>缓存服务器内容同步问题</h4><p> 缓存服务器的内容，无法保持与真实服务器实时同步怎么办？http自带条件get方法，通过if-modified-since，来实现更新。<br> 条件get的使用时机是：客户端之前访问过某网站，打算再此访问。（刚才想知道条件get是怎么触发的，结果百度半天搜不到，一谷歌，直接就是我想要的答案，百度有时不太好用）</p><h4 id="客户端访问Web站点大概过程"><a href="#客户端访问Web站点大概过程" class="headerlink" title="客户端访问Web站点大概过程"></a>客户端访问Web站点大概过程</h4><ol><li>传输层<br>进行数据的分包操作，进行相关协议的信息端口信息的填充</li><li>网络层<br>头部添加相关的原/目的ip地址</li><li>数据链路层<br>头部添加原/目的mac地址</li><li>在物理层进行电信号的传递．<br>传递过程会遇到相关的集线器(广播查表)，路由器(ARP协议)进行信息传递．这里传递路由器和集线器一般不会中病毒(因为传递信息是部分信息不能构成应用程序而且停留时间过短)．到到网卡（网关）会区分信息的端口和服务端哪个监听端口匹配来接受该服务，来进行消息的反馈，和之前操作相反回到客户端，进行多个数据包的重组，进行页面的重显．</li></ol><p>总结：</p><ol><li>服务使用TCP和UDP的端口进行侦听客户端请求</li><li>客户端使用ip地址定位服务器，目标端口定位服务．</li><li>可以在服务器网卡上设定只开放必要的端口，实现服务器的网络安全.</li></ol><h3 id="计算机访问网站的全部过程"><a href="#计算机访问网站的全部过程" class="headerlink" title="计算机访问网站的全部过程"></a>计算机访问网站的全部过程</h3><h4 id="第一步和第二步：DNS解析与应答"><a href="#第一步和第二步：DNS解析与应答" class="headerlink" title="第一步和第二步：DNS解析与应答"></a>第一步和第二步：DNS解析与应答</h4><p>客户端拿到域名之后，首先就是将域名解析成ip地址；至于为什么要做解析以及DNS解析原理请<a href="https://www.cnblogs.com/gopark/p/8430916.html">参考链接</a></p><p>当我们查看日志时发现有“UnknowHost”等类似的错误，基本上可以判定是此过程中出问题，可以根据实际情况做进一步测试和验证</p><h5 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h5><p>关于DNS的获取流程：</p><p>DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。<br>具体过程如下：</p><ol><li><p>用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了</p></li><li><p>浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如<br><a href="http://www.baidu.com/">http://www.baidu.com/</a>, 并将这个主机名传送给DNS应用的客户端</p></li><li><p>DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）</p></li><li><p>该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址</p></li><li><p>一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接</p></li></ol><h4 id="第三步：客户端访问负载均衡器"><a href="#第三步：客户端访问负载均衡器" class="headerlink" title="第三步：客户端访问负载均衡器"></a>第三步：客户端访问负载均衡器</h4><p>客户端通过DNS解析拿到目标ip地址后，就会向此地址发起请求，一般来说此地址就是负载均衡器的地址；负载均衡器接收到请求后会根据负载均衡算法（配置）将请求调度到应用服务器。<br>在此做几点说明</p><ol><li>一般来说负载均衡器就是一个网站的公网入口，如果使用https，证书一般就放在负载均衡器上；</li><li>如果是在IDC环境下，可以使用硬件负载均衡器，如F5、A10等，也可以使用软件负载均衡器，如nginx、haproxy、lvs等；</li><li>如果是在公有云环境下，直接使用公有云提供的负载均衡器服务，如阿里云的SLB，AWS的ALB、CLB、NLB</li><li>不管使用哪种类型的负载均衡器，它们都是实现相同的功能：负载均衡–&gt;将请求根据负载均衡算法调度到目标服务器</li><li>关于负载均衡器本身的高可用问题：公有云环境下由公有云保证其高可用，用户无需担心；IDC中的硬件负载均衡器一般都是通过双机热备部署来保证其高可用，IDC中软件负载均衡器一般通过keepalived、heartbeat等管理软件来保证其高可用。</li><li>各种负载均衡器的调度算法都类似，常用的有轮询、一致性hash、加权轮询、最小连接。</li></ol><h4 id="第四步：均衡器将请求调度到目标服务器"><a href="#第四步：均衡器将请求调度到目标服务器" class="headerlink" title="第四步：均衡器将请求调度到目标服务器"></a>第四步：均衡器将请求调度到目标服务器</h4><p>如第三步中所讲，负载均衡器根据自身所配置的算法将请求调度到应用服务器；一般来说会将应用服务器设计成无状态的，便于水平扩展；应用服务器可以是各种编程语言实现的，如java、php、Python、go</p><h4 id="第五步：应用服务器请求缓存、数据库服务器"><a href="#第五步：应用服务器请求缓存、数据库服务器" class="headerlink" title="第五步：应用服务器请求缓存、数据库服务器"></a>第五步：应用服务器请求缓存、数据库服务器</h4><p>应用程序根据业务逻辑会向缓存或者数据库服务器请求数据；</p><h4 id="第六、七、八步：请求结果返回"><a href="#第六、七、八步：请求结果返回" class="headerlink" title="第六、七、八步：请求结果返回"></a>第六、七、八步：请求结果返回</h4><p>如果每个节点都能正常处理请求，则会从数据库开始一级一级向上返回处理结果，最终显示在用户的浏览器或者客户端；如果某个节点出现异常，也会将结果一级级向上返回，最终用户浏览器或客户端看到的不是他想要的；我们可以根据此过程一步步查找；</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux1</title>
    <link href="http://example.com/posts/33723/"/>
    <id>http://example.com/posts/33723/</id>
    <published>2020-10-10T08:31:43.000Z</published>
    <updated>2020-10-10T14:47:02.553Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="vim应用"><a href="#vim应用" class="headerlink" title="vim应用"></a>vim应用</h4><p>用惯了i和鼠标,这次我们也要蜕变一下吧，三多说有意义！</p><h4 id="普通模式下的命令"><a href="#普通模式下的命令" class="headerlink" title="普通模式下的命令"></a>普通模式下的命令</h4><p>注意区分插入模式.</p><h4 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h4><p>ZZ 保存退出<br>ZQ 不保存退出</p><h4 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*字符间：</span><br><span class="line">h：左j：下k：上l：右</span><br><span class="line">#chp跳转# 个指定的字符chp</span><br><span class="line"></span><br><span class="line">*单词间：</span><br><span class="line">w：下一个单词的词首</span><br><span class="line">e：当前或下一单词的词尾</span><br><span class="line">b：当前或前一个单词的词首</span><br><span class="line">#word 跳转# 个单词数</span><br><span class="line"></span><br><span class="line">当前页：</span><br><span class="line">H：页首M：页中间行L：页底</span><br><span class="line">zt：光标所在行移至屏幕顶端</span><br><span class="line">zz：光标所在行移至屏幕中间</span><br><span class="line">zb：光标所在行移至屏幕底部</span><br><span class="line"></span><br><span class="line">*行首行尾：</span><br><span class="line">^跳转至行首的第一个非空白字符</span><br><span class="line">0跳转至行首</span><br><span class="line">$跳转至行尾</span><br><span class="line"></span><br><span class="line">*行间移动：</span><br><span class="line">#G跳转至第# 行，同末行模式下的:#</span><br><span class="line">G最后一行</span><br><span class="line">1G,gg第一行</span><br><span class="line"></span><br><span class="line">句间移动：</span><br><span class="line">)下一句(上一句</span><br><span class="line">&#125;下一段&#123;上一段</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符编辑："><a href="#字符编辑：" class="headerlink" title="字符编辑："></a>字符编辑：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">x删除光标处的字符*</span><br><span class="line">#x删除光标处起始的#个字符*</span><br><span class="line">xp交换光标处所在处的字符及其后面字符的位置*</span><br><span class="line">~转换大小写*</span><br><span class="line">J删除当前行的换行符</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">r只替换光标所在处的一个字符</span><br><span class="line">R切换成REPLACE 模式(在末行出现--REPLACE--提示)，按ESC 回到命令模式</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令:"></a>删除命令:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">d删除命令，可结合光标跳转字符，实现范围删除</span><br><span class="line">d$删除到行尾*</span><br><span class="line">d^删除到非空行首，相对行首*</span><br><span class="line">d0删除到行首，绝对行首*</span><br><span class="line">dw删除单词到行首</span><br><span class="line">de删除单词行尾</span><br><span class="line">db删除光标所在处的前一个字符串？</span><br><span class="line">dd剪切光标所在的行</span><br><span class="line">#dd删除多行，# 表示数字</span><br><span class="line">D从当前光标位置一删除到行尾，等同于d$</span><br><span class="line"></span><br><span class="line">ps：c 按键跟d 按键功能类似，只不过删除后进入插入模式</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令:"></a>复制命令:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">y复制命令，</span><br><span class="line">y$复制到行尾*</span><br><span class="line">y^复制到非空行首，相对行首*</span><br><span class="line">y0复制到行首*</span><br><span class="line">yw复制单词到行首</span><br><span class="line">ye复制单词行尾</span><br><span class="line">yb复制光标所在处的前一个字符串？</span><br><span class="line">yy复制光标所在的行</span><br><span class="line">#yy复制多行，# 表示数字</span><br><span class="line">Y复制整行</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="粘贴命令"><a href="#粘贴命令" class="headerlink" title="粘贴命令:"></a>粘贴命令:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">p 缓冲区存储的如果为整行，则粘帖当前光标所在行的下方，否则，粘帖当前光标所在行的后面</span><br><span class="line">P 缓冲区存储的如果为整行，则粘帖当前光标所在行的上方，否则，粘帖当前光标所在行的前面</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找＊"><a href="#查找＊" class="headerlink" title="查找＊"></a>查找＊</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;PATTERN：从当前光标所在处向文件尾部查找</span><br><span class="line">?PATTERN：从当前光标所在处向文件首部查找</span><br><span class="line">n：与命令同方向</span><br><span class="line">N：与命令反方向</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改:"></a>撤销更改:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u撤销最近的更改，相当于windows中的Ctrl+z</span><br><span class="line">#u撤销之前多次更改</span><br><span class="line">U撤销光标落在此行后所有此行的更改，换行则相对当前行</span><br><span class="line">Ctrl + r重做最后的撤销更改，相当于windows中的Ctrl+y</span><br><span class="line">.重复前一个操作</span><br><span class="line">#.重复前一个操作# 次</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</span><br><span class="line">常见Command：</span><br><span class="line">y:复制d:删除gU:大写gu:小写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">范例</span><br><span class="line"></span><br><span class="line">0y$ :从光标所在行首开始拷贝，拷贝到所在行的最后一个字符</span><br><span class="line">0：起始位置，行头</span><br><span class="line">y：复制</span><br><span class="line">$：行尾</span><br><span class="line"></span><br><span class="line">100idawn[ESC]#粘帖“dawn”100次</span><br><span class="line"></span><br><span class="line">范例</span><br><span class="line"></span><br><span class="line">di&quot;光标在&quot;&quot;之间，则删除&quot;&quot;之间的内容*</span><br><span class="line">yi(光标在()之间，则复制()之间的内容*</span><br><span class="line">vi[光标在[]之间，则选中[]之间的内容*</span><br><span class="line"></span><br><span class="line">dtx 删除字符直到遇见光标之后的第一个x 字符</span><br><span class="line">ytx 复制字符指导遇见光标之后的第一个x 字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>thought</title>
    <link href="http://example.com/posts/53868/"/>
    <id>http://example.com/posts/53868/</id>
    <published>2020-10-09T15:22:17.000Z</published>
    <updated>2020-10-10T05:01:35.118Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>　　　　子时<br>踌躇满志，举步维艰．<br>学思尺寸，进退两难．<br>先背后思，暂得之策．<br>某事在人，成事望天．</p><p>（2020年10月9日,school）</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="though" scheme="http://example.com/tags/though/"/>
    
  </entry>
  
  <entry>
    <title>red_black_tree</title>
    <link href="http://example.com/posts/24504/"/>
    <id>http://example.com/posts/24504/</id>
    <published>2020-10-09T15:13:01.000Z</published>
    <updated>2020-10-10T08:28:44.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><a href="https://zhuanlan.zhihu.com/p/79980618?utm_source=cn.wiz.note">相关红黑树的动态图</a></p><h4 id="四条性质："><a href="#四条性质：" class="headerlink" title="四条性质："></a>四条性质：</h4><pre><code> 红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:１．每个节点都有红色或黑色(非黑即红)２．树的根始终是黑色的 (黑根)３．没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点)(红跟两黑) 　　４．从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点（叶子节点（NULL）为黑，每个边一样黑）.</code></pre><p>红黑树的插入调整：<br>祖父节点作为根节点<br>五中情况依据叔叔节点的颜色，如果为红色，可调整为黑红红或者红黑黑．<br>如果为黑色那么分为左子树的左儿子和左子树的右儿子为冲突节点.引申为四种情况：LL,LR,RL,RR四种类型.<br>红黑树的删除节点调整:<br>从父节点作为根节点<br>先了解二叉树的删除节点操作:<br>    被删除的节点<br>    度为零：直接删除就可.<br>    度为一：直接把被删除的节点上移一位就可.<br>    度为二; 找到该点的前驱和后继替换完之后删除非节点.<br>红黑树：<br>情况一: 红色节点度数为0,1,2的情况.<br>解决方案：因为不影响红黑树的平衡按照二叉树节点删除即可.<br>情况二：黑色节点度为0,1,2的情况.<br>解决方案：<br>删除度为一的节点：把其唯一自孩子加一层黑色(如果为红色则变为黑色，如果为黑的则变为双重黑)．<br>调整操作就是为了消除双重黑节点使其成为正常色．<br>情况一:　父节点为黑，双重黑的兄弟节点和兄弟节点两个子节点都是黑节点.<br>解决办法: 兄弟节点变为红色，双重黑节点降色，父节点增加一层颜色.<br>情况二:  根节点为红色，左子树为双黑节点．右兄弟节点为黑色，兄弟节点孩子左黑右红．<br>RR类型: 以父节点进行左旋（右旋）<br>推理可得兄弟节点左孩子颜色不确定，父节点改为黑的，右兄弟节点改为父亲节点颜色，双重节点颜色减一，兄弟节点右孩子由红变为黑色，再以父节点进行左旋．<br>简单来说：进行大左旋，再进行顶端三角变色调整．<br>情况三：兄弟节点的左儿子为红色节点.<br>RL类型:<br>    兄弟节点变红，兄弟左儿子变黑，再以兄弟节点右旋，变为情况二．</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="字符串系列" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>AVL-tree</title>
    <link href="http://example.com/posts/25345/"/>
    <id>http://example.com/posts/25345/</id>
    <published>2020-10-09T06:31:36.000Z</published>
    <updated>2020-10-09T15:14:43.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="AVL树的简介"><a href="#AVL树的简介" class="headerlink" title="AVL树的简介"></a>AVL树的简介</h3><pre><code>AVL树是一种自平衡的二叉搜索树，一颗典型的二叉搜索树(Binary Search Tree，以下简称BST)应该满足key(左子树)小于key(根节点)小于key(右子树)。</code></pre><h3 id="AVL树特点"><a href="#AVL树特点" class="headerlink" title="AVL树特点"></a>AVL树特点</h3><pre><code>     左子树上所有的键值都小于根节点的键值，右子树上所有的键值均大于根节点的值（左右子树都不为空的话）。也正是因为这种特性，如果对于一般的BST不做任何平衡操作的话，在构建BST的时候左右子树的高度会出现严重不均衡的情况，例如：按照升序（降序）输入序列会造成最极端的不平衡情况.(这就是一个单链).</code></pre><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>树的高度的概念:<br>    从结点x向下到某个叶结点最长简单路径中边的条数.<br>这个相关解释是笔者搜到的: 意思是以边数代替层数.但是通俗用的是下边解释(用点数代表深度层数)<br>通俗的来说就是从x节点向树的下部分找,那条最长边的个数就是该点的深度,树的深度就是把根节点为(x)起始点.一般情况x当前即为1层,然后往后累加计算的.</p><p>树的深度概念:<br>    深度是从根节点往下计算,一般来说根节点为开始就计为1。</p><p>avl树的性质:<br>    注意: (这里用的是按边计算层数)<br>为了解决不平衡的情况平衡的BST概念就应运而生了。其中AVL树是最先发明的自平衡二叉搜索树。自平衡的概念就是在插入、删除的过程中，树会自动平衡自身。在这里我们需要规定一下平衡的概念。一颗平衡二叉树，它的左右子树的高度差不能超过1，这个性质应用到这颗树的任意一个节点都要成立。的高度的概念：从根节点出发，寻找到离它最远的叶节点所经过的路径，如果一个节点为空，它的高度为-1。高度的概念也可以应用到每一个节点.</p><p>相关操作：<br>我自己习惯称之为：局部左旋，局部右旋，左旋，右旋．<br>局部左旋：当前节点的儿子节点进行的左旋<br>左旋：当前节点进行的左旋<br>局部右旋和右旋等价类推.</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>有 n 个节点的完全二叉树的高度（深度）为 | log2 n」（这里以边为高度划分依据的）如果以点为划分依据则是｜log2n｜-1<br>完全二叉树第 n 层上至多 2^(n+1)个节点（这里以边为高度划分依据的）</p><p>我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度（O(log2n)）同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</p><h3 id="AVL树的不同情况"><a href="#AVL树的不同情况" class="headerlink" title="AVL树的不同情况"></a>AVL树的不同情况</h3><p>四种失衡的情况</p><p>LL型：原因为左子树的左儿子的高度比右儿子的高度高超过1层(&gt;= 2)<br>调整策略：</p><p>LR型：原因为左子树的右儿子的高度左儿子的高度高超过1层(&gt;=2)<br>调整策略：</p><p>RR型：原因为右子树的右儿子的高度比左儿子的高度高超过1层(&gt;=2)<br>调整策略：</p><p>RL型：原因为右子树的左儿子的高度比右儿子的高度高超过1层(&gt;=2)<br>调整策略：</p><h3 id="AVL树的伪代码"><a href="#AVL树的伪代码" class="headerlink" title="AVL树的伪代码"></a>AVL树的伪代码</h3><p>左旋：其实局部左旋和左旋本质上是一样的，只是根节点的不同而已.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回节点 left_rotate(传入根节点) &#123;</span><br><span class="line">    中间值节点 &#x3D; 根节点的右儿子;</span><br><span class="line">    根节点右儿子 &#x3D; 根节点右儿子(中间值节点)的左儿子;</span><br><span class="line">    根节点右儿子(中间节点)的左儿子 &#x3D; 传入的根节点;</span><br><span class="line">    升级根节点的高度;</span><br><span class="line">    升级中间值节点的高度;</span><br><span class="line">    返回调整后的根节点（中间值节点）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右旋: 同上左旋．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回节点 right_rotate(传入节点) &#123;</span><br><span class="line">    中间值节点 &#x3D; 根节点的左儿子;</span><br><span class="line">    根节点左儿子 &#x3D; 根节点左儿子(中间值节点)的右儿子;</span><br><span class="line">    根节点左儿子(中间节点)的右儿子 &#x3D; 传入的根节点;</span><br><span class="line">    升级根节点的高度;</span><br><span class="line">    升级中间值节点的高度;</span><br><span class="line">    返回调整后的根节点（中间值节点）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点的更新，和判断出错的部分,进行调整.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回节点 maintain(传入根节点) &#123;</span><br><span class="line">    更新节点高度;(插入的时候调用该函数)</span><br><span class="line">    if (左子树高度-右子树高度 &lt;&#x3D; 1) return 根节点;\\正常情况</span><br><span class="line">    if (左子树高度 &gt; 右子树高度 )&#123;&#x2F;&#x2F;判断第一个是L还是R.该位置为L.</span><br><span class="line">        if (根节点左儿子右子树高度&gt; 根节点左儿子左子树高度 &#123;&#x2F;&#x2F;判断是L还是R,该位置是R</span><br><span class="line">            &#x2F;&#x2F;在左儿子进行局部左旋</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;在外部进行右旋</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;判断为R</span><br><span class="line">        if (根节点右儿子左子树高度 &gt; 根节点右儿子右子树高度 &#123;&#x2F;&#x2F;判断为L还是R,改为L</span><br><span class="line">            根节点右儿子进行局部右旋</span><br><span class="line">        &#125;</span><br><span class="line">        根节点进行左旋.</span><br><span class="line">    &#125;</span><br><span class="line">    返回根节点.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点，不同情况进行操作，最后进行细节的调整，个别值的重新设定，最后进行树的重新调整结构.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回节点 insert(根节点, 插入值) &#123;</span><br><span class="line">    节点为空创建新节点;</span><br><span class="line">    若存在返回根节点;</span><br><span class="line">    和根节点的值进行比较，大于根节点值，插入到右边;</span><br><span class="line">    否则插入到左边;</span><br><span class="line">    返回maintain(根节点);</span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>删除节点操作,待补充！！！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AVL树的相关优化"><a href="#AVL树的相关优化" class="headerlink" title="AVL树的相关优化"></a>AVL树的相关优化</h3><h3 id="AVL树的应用"><a href="#AVL树的应用" class="headerlink" title="AVL树的应用"></a>AVL树的应用</h3><p>一般出现在教科书上.<br>windows对进程地址空间的管理用到了AVL树。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="字符串系列" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>network_of_computer1</title>
    <link href="http://example.com/posts/7734/"/>
    <id>http://example.com/posts/7734/</id>
    <published>2020-10-08T04:58:21.000Z</published>
    <updated>2020-10-08T06:42:56.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="计算机网络—子网划分"><a href="#计算机网络—子网划分" class="headerlink" title="计算机网络—子网划分"></a>计算机网络—子网划分</h3><h4 id="ip地址二级结构"><a href="#ip地址二级结构" class="headerlink" title="ip地址二级结构"></a>ip地址二级结构</h4><p>A 类地址:  {(网络号8位)(主机号24位)}<br>B 类地址:  {(网络号16位)(主机号16位)}<br>C 类地址:  {(网络号24位)(主机号8位)}</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="二级-三级ip地址"><a href="#二级-三级ip地址" class="headerlink" title="二级,三级ip地址"></a>二级,三级ip地址</h3><p>二级ip地址：{(网络号)(—-主机号—-)}<br>三级ip地址：{(网络号)(子网号)(主机号)}</p><h3 id="ip区分"><a href="#ip区分" class="headerlink" title="ip区分"></a>ip区分</h3><h4 id="利用子掩码区分ip等级"><a href="#利用子掩码区分ip等级" class="headerlink" title="利用子掩码区分ip等级"></a>利用子掩码区分ip等级</h4><h5 id="子掩码"><a href="#子掩码" class="headerlink" title="子掩码:"></a>子掩码:</h5><p><a href="https://blog.csdn.net/dyyay521/article/details/94381876">参考网站带图</a><br>    因为子网掩码就是用来区分地址中有没有子网号的，所以都是一串01字符串来表示；网络号和子网号用1表示，主机号用零表示，因此ABC类地址的子网掩码是有默认的：</p><h5 id="区分方法"><a href="#区分方法" class="headerlink" title="区分方法:"></a>区分方法:</h5><p>A类地址(默认子网掩码):255.0.0.0—–&gt;转换为二进制数11111111.00000000.00000000.00000000<br>B类地址(默认子网掩码):255.255.0.0—&gt;转换为二进制数11111111.11111111.00000000.00000000<br>C类地址(默认子网掩码):255.255.255.0-&gt;转换为二进制数11111111.11111111.11111111.00000000<br>说明一下:网络地址用是32位二进制表示,用三个点划分为四部分，每部分就是8位二进制数．</p><h5 id="详细范围"><a href="#详细范围" class="headerlink" title="详细范围"></a>详细范围</h5><p>通俗来说:子网掩码就是用来区分网络地址的模板(也可以说是用来剔除主机号)，通过子网掩码与所要区分的网络地址进行与运算（＆）,一般范围是(划分范围，有些特殊数字有特殊作用)<br>１．A类地址的第一组数字为1～126。注意，数字0和 127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。</p><p>范围：1.0.0.1到126.255.255.254<br>２．B类地址的第一组数字为128～191。</p><p>范围：128.0.0.1到191.255.255.254<br>３．C类地址的第一组数字为192～223。</p><p>范围：192.0.0.1到223.255.255.254</p><p>二进制形式：<br>A类：1.0.0.1～126.255.255.254（0000 0001 0000 0000 0000 0000 0000 0001 ～0111 1111 1110 1111 1111 1111 1111 1110），注意127.x.x.x不能用。<br>B类：128.0.0.1～191.255.255.254（1000 0000 0000 0000 0000 0000 0000 0001 ～1011 1111 1111 1111 1111 1111 1111 1110），注意169.254.x.x被微软买断，用作用户获取不到IP时自动分配的IP地址。<br>C类：192.0.0.1～223.255.255.254（1100 0000 0000 0000 0000 0000 0000 0001 ～1101 1111 1111 1111 1111 1111 1111 1110）<br>D类：224.0.0.1～239.255.255.254（1110 0000 0000 0000 0000 0000 0000 0001 ～1110 1111 1111 1111 1111 1111 1111 1110）<br>E类：240.0.0.1～255.255.255.254（1111 0000 0000 0000 0000 0000 0000 0001 ～1111 1111 1111 1111 1111 1111 1111 1110）</p><p>私有地址<br>A类：10.0.0.0～10.255.255.255<br>B类：172.16.0.0～172.31.255.255<br>C类：192.168.0.0～192.168.255.255</p><h5 id="子掩码用法"><a href="#子掩码用法" class="headerlink" title="子掩码用法"></a>子掩码用法</h5><p>IP地址与子网掩码相与，得出的就是网络地址；</p><h4 id="子网掩码相关应用"><a href="#子网掩码相关应用" class="headerlink" title="子网掩码相关应用"></a><a href="https://blog.csdn.net/dyyay521/article/details/94381876">子网掩码相关应用</a></h4><p>例题讲解很好.<br>其他待补充！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>string-4</title>
    <link href="http://example.com/posts/23956/"/>
    <id>http://example.com/posts/23956/</id>
    <published>2020-10-07T13:46:02.000Z</published>
    <updated>2020-10-08T04:52:47.618Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="字符串-AC自动机"><a href="#字符串-AC自动机" class="headerlink" title="字符串-AC自动机"></a>字符串-AC自动机</h4><p>介绍:<br>    本质就是字典树加上了等价链(fail指针).<br>    解决多模匹配为题:<br>    引入fail指针(类似next数组):节点等价匹配关系.有箭头有方向, 1-&gt;2 说明匹配成功1等价匹配成功2,并不代表匹配成功2就是匹配成功1, <code>(注意)!!</code>有可能在2的时候就是词的结尾. fail指针最后指向根节点.</p><p>   存在next数组,存字典树每个分支(就是不同单词,每条分支表示一个单词)相当于26个字符的每种情况.fail指针更像kmp算法中next数组的作用.<br>   fail指针就是用来指向符合这样的情况的下一个字符(没有符合情况的情况下fail指针指向了根节点间)<br>    树的根节点相当于kmp算法的虚拟头节点位.</p><p>   fail指针的确定方法为一层一层的确定的．</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>假设有N个模式串，平均长度为L；文du章长度为M。 建立Trie树：O(N<em>L) 建立fail指针：O(N</em>L) 模式匹配：O(M*L) 所以，总时间复杂度为:O( (N+M)*L )。</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>字典树所存的是短串的相关结构，进行与长串的相关匹配．</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int insert(Node *root, const char *str) &#123;</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    Node *p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; str[i]; i++) &#123;</span><br><span class="line">        int ind &#x3D; str[i] - BEGIN_LETTER;</span><br><span class="line">        if (p-&gt;next[ind] &#x3D;&#x3D; NULL) p-&gt;next[ind] &#x3D; getNewNode(), ++cnt;&#x2F;&#x2F;如果没有相关的子孩子，便会重新申请子孩子．类似于字典树插入.</span><br><span class="line">        p &#x3D; p-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag &#x3D; 1;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用优先队列进行一层一层的建立，相当于层次遍历．<br>在建立好字典树之后初始化next数组．<br>根本建立思路为，以根节点为基本，以父节点作为tail的生成根本，while语句作为tail所指元素的查找语句.<br>进而以root为根本,汇合各种所要匹配的短串，生成ac自动机所需树的模型.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void build_ac(Node *root, int n) &#123;</span><br><span class="line">    Queue *q &#x3D; init_queue(n + 10);</span><br><span class="line">    root-&gt;fail &#x3D; NULL;</span><br><span class="line">    push(q, root);</span><br><span class="line">    while (!empty(q)) &#123;</span><br><span class="line">        Node *now_node &#x3D; front(q);</span><br><span class="line">        pop(q);</span><br><span class="line">&#x2F;&#x2F;当前节点所有子节点的失败指针</span><br><span class="line">        for (int i &#x3D; 0; i &lt; BASE; i++) &#123;</span><br><span class="line">            if (now_node-&gt;next[i] &#x3D;&#x3D; NULL) continue;&#x2F;&#x2F;如果子节点为空，及不需要失败指针．</span><br><span class="line">            Node *p &#x3D; now_node-&gt;fail;&#x2F;&#x2F;第i个子节点父节点的失败指针，（父节节点指的是fail的上一个节点）</span><br><span class="line">            while (p &amp;&amp; p-&gt;next[i] &#x3D;&#x3D; NULL) p &#x3D; p-&gt;fail;&#x2F;&#x2F;当前节点没有i个子孩子(等价与第i个孩子匹配失败)，便顺着fail去寻找．</span><br><span class="line">            if (p &#x3D;&#x3D; NULL) now_node-&gt;next[i]-&gt;fail &#x3D; root;&#x2F;&#x2F;找到为空的节点，即可指向根节点．</span><br><span class="line">            else now_node-&gt;next[i]-&gt;fail &#x3D; p-&gt;next[i];&#x2F;&#x2F;否则就可以指向p指针所指的节点.</span><br><span class="line">            push(q, now_node-&gt;next[i]);&#x2F;&#x2F;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关结构已完成.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int match(Node *root, const char *str) &#123;</span><br><span class="line">    int cnt &#x3D; 0;</span><br><span class="line">    Node *p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; str[i]; i++) &#123;</span><br><span class="line">        int ind &#x3D; str[i] - BEGIN_LETTER;</span><br><span class="line">        while (p &amp;&amp; p-&gt;next[ind] &#x3D;&#x3D; NULL) p &#x3D; p-&gt;fail;&#x2F;&#x2F;每个节点，如果当前节点存在儿子节点&#39;对应匹配位&#39;为空,及跳转等价位.</span><br><span class="line">失败情况</span><br><span class="line">１．p-&gt;next[ind]不为空即为匹配成功</span><br><span class="line">２．p为空节点(也就是p-&gt;fail断了)</span><br><span class="line">        if (p &#x3D;&#x3D; NULL) p &#x3D; root;&#x2F;&#x2F;为空就指回根节点</span><br><span class="line">        else p &#x3D; p-&gt;next[ind];&#x2F;&#x2F;匹配成功就字符往下指</span><br><span class="line">        Node *q &#x3D; p;</span><br><span class="line">        while (q) cnt +&#x3D; q-&gt;flag, q &#x3D; q-&gt;fail;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>AC自动机 <a href="https://www.seotest.cn/jishu/60166.html">拓扑优化</a></p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>１．由于fail指针不用回溯,所以适合使用流式数据.<br>２．适合用于多模匹配（多模即为多个短字符串同时匹配长串）.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="字符串序列" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>string-3</title>
    <link href="http://example.com/posts/40917/"/>
    <id>http://example.com/posts/40917/</id>
    <published>2020-10-06T05:46:42.000Z</published>
    <updated>2020-10-07T07:56:55.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字典树相关优化-双数组字典树<br>如何进行优化的:<br>字典树如果选取26个字符,那么每个节点均有26个孩子,就是有没有需要都会在该节点下边出现26条边(字典树通过flag判断成不成词).那么这些没用的边会相当多,只需要把这些没用的边进行舍掉就可进行内存空间上的质的飞跃.</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的时间复杂度: 跟字典树一样O(1).</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>该算法不支持动态插入的.支持离线形式.<br>说到双数组字典树就有必要说一下确定性<a href="https://blog.csdn.net/qq_39521554/article/details/79416553">有穷状态自动机了(DFA)</a>,就是指定一种状态和一个变量时,会根据变量的条件从一种状态跳到了另一种确定的状态.<br>两个数组的含义 :</p><p>base数组 : 将字典树边由记录式改为计算式最关键的值<br>base的儿子(child) : 是由本身base<code>[base当前位置代表的值]</code> + 所对应边的值生成的<br>对应边上的字符存在一个对数字的映射.<br>根节点映射到子节点的一种方式base数组作为中间量.</p><p>base值的确定: 用二叉树的层序遍历(队列实现)(节点编号不冲突即可)</p><p>check数组 : 记录每一个子节点真正父节点编号.(check数组表示正负来表示是不是一个词的末尾排除0号数,也就是表示的父节点不能用零来表示)<br>如果为零就表示该位置没有被占用.<br>因为存在一中 多个父节点找到同一个子节点情况.<br>注意:两个数组映射的均是数组下标,下表对应的值代表着对应的还以.</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>注!,双数组字典树依靠成型的字典树,进行树的转换而成,部分代码,整体思路.<br>数据定义</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct DATrie &#123;</span><br><span class="line">        int *base, *check;</span><br><span class="line">        int root, size;</span><br><span class="line"></span><br><span class="line">&#125; DATrie;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化节点(头结点)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATrie *getDATrie(int n) &#123;</span><br><span class="line">        DATrie *tree &#x3D; (DATrie *)calloc(sizeof(DATrie), 1);</span><br><span class="line">        tree-&gt;root &#x3D; 1; &#x2F;&#x2F; 根节点的值</span><br><span class="line">        tree-&gt;size &#x3D; n; &#x2F;&#x2F;数据的多少</span><br><span class="line">        tree-&gt;base &#x3D; (int *)calloc(sizeof(int), n);</span><br><span class="line">        tree-&gt;check &#x3D; (int *)calloc(sizeof(int), n);</span><br><span class="line">        tree-&gt;check[tree-&gt;root] &#x3D; 1;&#x2F;&#x2F;给根节点赋值</span><br><span class="line">        return tree;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取base的值<br>base值的获取: </p><ol><li>递归获取,一个分支递归到底.</li><li>层序遍历获取,一层一层的获取.</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getBaseValue(Node *root, DATrie *tree) &#123;</span><br><span class="line">        int base &#x3D; 0, flag;</span><br><span class="line">    do &#123;</span><br><span class="line">        flag &#x3D; 1;</span><br><span class="line">        base +&#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; BASE; i++) &#123;</span><br><span class="line">            if (root-&gt;next[i] &#x3D;&#x3D; NULL) continue;&#x2F;&#x2F;子孩子为空啥都不用干</span><br><span class="line">            if (tree-&gt;check[base + i] &#x3D;&#x3D; 0) continue;&#x2F;&#x2F;第i个孩子有没有被占用,若没有被占用.</span><br><span class="line">            flag &#x3D; 0;&#x2F;&#x2F;说明base值不合法.</span><br><span class="line">            break;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (!flag);</span><br><span class="line">        return base;&#x2F;&#x2F;找到了合法的base值.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>树的建立</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int buildDATrie(int ind, Node *root, DATrie *tree) &#123;</span><br><span class="line">    int base &#x3D; tree-&gt;base[ind] &#x3D; getBaseValue(root, tree);</span><br><span class="line">    int ans &#x3D; ind;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; BASE; i++) &#123;</span><br><span class="line">        if (root-&gt;next[i] &#x3D;&#x3D; NULL) continue;</span><br><span class="line">        tree-&gt;check[base + i] &#x3D; ind;&#x2F;&#x2F;给check的赋值操作 ind即为所附的值</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; BASE; i++) &#123; &#x2F;&#x2F; 采用递归式建立字典树</span><br><span class="line">        if (root-&gt;next[i] &#x3D;&#x3D; NULL) continue;</span><br><span class="line">        int temp &#x3D; buildDATrie(base + i, root-&gt;next[i], tree);</span><br><span class="line">        if (temp &gt; ans) ans &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root-&gt;flag) tree-&gt;check[ind] &#x3D; -tree-&gt;check[ind];</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码查询<br>这里 采用了和字典树一样的查找方式.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int query(DATrie *tree, const char *str) &#123;</span><br><span class="line">    int p &#x3D; tree-&gt;root;</span><br><span class="line">    for (int i &#x3D; 0; str[i]; i++) &#123;</span><br><span class="line">        int ind &#x3D; str[i] - BEGIN_LETTER;</span><br><span class="line">        if (abs(tree-&gt;check[tree-&gt;base[p] + ind]) !&#x3D; p) return 0;</span><br><span class="line">        p &#x3D; tree-&gt;base[p] + ind;</span><br><span class="line">    &#125;</span><br><span class="line">    return tree-&gt;check[p] &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="相关优化"><a href="#相关优化" class="headerlink" title="相关优化"></a>相关优化</h3><p>待序!!!!!!</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><a href="https://www.cnblogs.com/binyue/p/3771040.html">优化方案选自</a><br>（1） 字符串检索<br>事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。<br>举例：<br>给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。<br>给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。</p><p>（2）字符串最长公共前缀<br>Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。<br>举例：<br>给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？<br>解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。<br>而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：</p><ol><li>利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；</li><li>求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；</li></ol><p>（3）排序</p><p>Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。<br>比如给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。</p><p>（4） 作为其他数据结构和算法的辅助结构<br>如后缀树，AC自动机等</p><p>（5）词频统计<br>trie树在这里的应用类似哈夫曼树，<br>比如词频统计使用哈希表或者堆都可以，但是如果内存有限，就可以用trie树来压缩空间，因为trie树的公共前缀都是用一个节点保存的。</p><p>（6）字符串搜索的前缀匹配<br>trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。<br>Trie树检索的时间复杂度可以做到n，n是要检索单词的长度，<br>如果使用暴力检索，需要指数级O(N2)的时间复杂度。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="字符串系列" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>string-2</title>
    <link href="http://example.com/posts/24340/"/>
    <id>http://example.com/posts/24340/</id>
    <published>2020-10-05T13:03:05.000Z</published>
    <updated>2020-10-06T05:42:02.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Trie-字典树"><a href="#Trie-字典树" class="headerlink" title="Trie-字典树"></a>Trie-字典树</h2><p>也叫单词排序(单词查找)树<br>鉴于比较操作的排序算法最快的nlogn想要变得更快就选择非比较排序算法,故此引入字典树,构造字典树有些繁琐,但是查询速度非常快.<br>字典树是靠边的字符来拼成字符串的,并不是靠点,并且通过点的颜色来判断该点以前是否为完整字符串.注意!!(这里不是红黑树)</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>查询所用的时间复杂度:O(1) 只需要按照字符串进行查找.</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>把相关字符串插入字典树,每条边表示一个字符(重点),每次查询就直接顺着边进行查询,查询完毕后,判断flag是不是构成一个单词.</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct Node &#123;</span><br><span class="line">        int flag;</span><br><span class="line">        struct Node *next[BASE];</span><br><span class="line"></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>插入操作:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void insert(Node *root, char *str) &#123;</span><br><span class="line">        Node *p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; str[i]; i++) &#123;</span><br><span class="line">                if (p-&gt;next[code(str[i])] &#x3D;&#x3D; NULL) p-&gt;next[code(str[i])] &#x3D; getNewNode();</span><br><span class="line">                p &#x3D; p-&gt;next[code(str[i])];</span><br><span class="line">        &#x2F;&#x2F;如果没有进行节点生成</span><br><span class="line">        &#x2F;&#x2F;如果存在就直接以当前字符为边进行指向下一个节点.</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        p-&gt;flag &#x3D; 1;&#x2F;&#x2F;字符串结尾进行字符串收尾操作,划分为一个字符串.</span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    查询操作:<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int query(Node *root, char *str) &#123;</span><br><span class="line">        Node *p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; str[i]; i++) &#123;</span><br><span class="line">                p &#x3D; p-&gt;next[code(str[i])]; &#x2F;&#x2F;以字符串为边进行依次查询</span><br><span class="line">                if (p &#x3D;&#x3D; NULL) return 0;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        return p-&gt;flag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="相关优化"><a href="#相关优化" class="headerlink" title="相关优化"></a>相关优化</h3><p>双数组字典下篇文章</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="字符串系列" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>apotheosis</title>
    <link href="http://example.com/posts/19586/"/>
    <id>http://example.com/posts/19586/</id>
    <published>2020-10-05T01:12:47.000Z</published>
    <updated>2020-10-05T01:15:31.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>笔者完成这些琐事, 一起决战<a href="https://hack.zkaq.cn/">封神台</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="apotheosis" scheme="http://example.com/tags/apotheosis/"/>
    
  </entry>
  
</feed>

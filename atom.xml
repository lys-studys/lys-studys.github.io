<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌上花开缓缓归</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-14T10:29:06.005Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lys-studys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++5</title>
    <link href="http://example.com/posts/43952/"/>
    <id>http://example.com/posts/43952/</id>
    <published>2020-11-14T01:19:42.000Z</published>
    <updated>2020-11-14T10:29:06.005Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="c-里面的同步和互斥怎么实现的"><a href="#c-里面的同步和互斥怎么实现的" class="headerlink" title="c++里面的同步和互斥怎么实现的"></a>c++里面的同步和互斥怎么实现的</h3><h3 id="c-里面的常量怎么定义"><a href="#c-里面的常量怎么定义" class="headerlink" title="c++里面的常量怎么定义"></a>c++里面的常量怎么定义</h3><p>c++中定义常量有两种方法：</p><ol><li>使用#define预处理器</li><li>使用const关键字</li></ol><p>就定义常量说的话： const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。</p><p>就起作用的阶段而言： define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。</p><p>就起作用的方式而言： define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。</p><p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。<br>对于局部对象，常量存放在栈区；<br>对于全局对象，常量存放在全局/静态存储区。<br>对于字面值常量，比如字符串，常量存放在常量存储区。</p><h3 id="c-的智能指针"><a href="#c-的智能指针" class="headerlink" title="c++的智能指针"></a>c++的智能指针</h3><h4 id="智能指针的原理"><a href="#智能指针的原理" class="headerlink" title="智能指针的原理"></a>智能指针的原理</h4><ol><li><p>你知道智能指针吗？智能指针的原理。<br>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放，</p></li><li><p>常用的智能指针。</p></li><li><p>智能指针的实现。</p><h4 id="常用的智能指针"><a href="#常用的智能指针" class="headerlink" title="常用的智能指针"></a>常用的智能指针</h4></li><li><p>td::auto_ptr，有很多问题。不支持复制（拷贝构造函数）和赋值（operator =），但复制或赋值的时候不会提示出错。因为不能被复制，所以不能被放入容器中。</p></li><li><p>C++11引入的unique_ptr， 也不支持复制和赋值，但比auto_ptr好，直接赋值会编译出错。实在想赋值的话，需要使用：std::move。<br>例如：</p><p> std::unique_ptr<int> p1(new int(5));<br> std::unique_ptr<int> p2 = p1; // 编译会出错<br> std::unique_ptr<int> p3 = std::move(p1); // 转移所有权, 现在那块内存归p3所有, p1成为无效的指针.</p></li><li><p>C++11或boost的shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。</p></li></ol><p>创建与赋值:<br>    shared_ptr<int> sp(new int(10));//不推荐，避免使用new,应该采用下面的方法创建与赋值.<br>    shared_ptr<int> sp2 = make_shared<int>(10);//应该用make_shared代替new,这一个shared_ptr的工厂函数.使用new会破坏delete在函数中的对称性．<br>    不要把一个裸指针给多个shared_ptr对象管理，避免多次释放同一个裸指针，第一个shared_ptr参数为裸指针外，其他的都是shared_ptr对象.作为参数.<br>    可以通过加{}来控制析构的位置．</p><ol start="4"><li>C++11或boost的weak_ptr，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。</li></ol><h4 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h4><p>下面是一个基于引用计数的智能指针的实现，需要实现构造，析构，拷贝构造，=操作符重载，重载*-和&gt;操作符。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;构造函数</span><br><span class="line">    SmartPointer(T* p&#x3D;0): _ptr(p), _reference_count(new size_t)&#123;</span><br><span class="line">        if(p)</span><br><span class="line">            *_reference_count &#x3D; 1;</span><br><span class="line">        else</span><br><span class="line">            *_reference_count &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;拷贝构造函数</span><br><span class="line">    SmartPointer(const SmartPointer&amp; src) &#123;</span><br><span class="line">        if(this!&#x3D;&amp;src) &#123;</span><br><span class="line">            _ptr &#x3D; src._ptr;</span><br><span class="line">            _reference_count &#x3D; src._reference_count;</span><br><span class="line">            (*_reference_count)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重载赋值操作符</span><br><span class="line">    SmartPointer&amp; operator&#x3D;(const SmartPointer&amp; src) &#123;</span><br><span class="line">        if(_ptr&#x3D;&#x3D;src._ptr) &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        releaseCount();</span><br><span class="line">        _ptr &#x3D; src._ptr;</span><br><span class="line">        _reference_count &#x3D; src._reference_count;</span><br><span class="line">        (*_reference_count)++;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重载操作符</span><br><span class="line">    T&amp; operator*() &#123;</span><br><span class="line">        if(ptr) &#123;</span><br><span class="line">            return *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;throw exception</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;重载操作符</span><br><span class="line">    T* operator-&gt;() &#123;</span><br><span class="line">        if(ptr) &#123;</span><br><span class="line">            return _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;throw exception</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;析构函数</span><br><span class="line">    ~SmartPointer() &#123;</span><br><span class="line">        if (--(*_reference_count) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            delete _ptr;</span><br><span class="line">            delete _reference_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    T *_ptr;</span><br><span class="line">        size_t *_reference_count;</span><br><span class="line">        void releaseCount() &#123;</span><br><span class="line">        if(_ptr) &#123;</span><br><span class="line">            (*_reference_count)--;</span><br><span class="line">                if((*_reference_count)&#x3D;&#x3D;0) &#123;</span><br><span class="line">                    delete _ptr;</span><br><span class="line">                    delete _reference_count;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    SmartPointer&lt;char&gt; cp1(new char(&#39;a&#39;));</span><br><span class="line">    SmartPointer&lt;char&gt; cp2(cp1);</span><br><span class="line">    SmartPointer&lt;char&gt; cp3;</span><br><span class="line">    cp3 &#x3D; cp2;</span><br><span class="line">    cp3 &#x3D; cp1;</span><br><span class="line">    cp3 &#x3D; cp3;</span><br><span class="line">    SmartPointer&lt;char&gt; cp4(new char(&#39;b&#39;));</span><br><span class="line">    cp3 &#x3D; cp4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="C-虚函数的实现"><a href="#C-虚函数的实现" class="headerlink" title="C++虚函数的实现"></a>C++虚函数的实现</h3><ol><li>虚函数是通过一张虚函数表实现的，有多少个虚函数，就有多少个指针；</li><li>在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题；</li><li>实际上在编译的时候，编译器会自动加上虚表</li><li>虚函数的作用实现动态联编，也就是说在程序运行阶段动态的选择合适的成员函数，在定义了虚函数之后，可以在基类的派生类中对虚函数重新定义。</li><li>虚表的使用方法是如果派生类在自己定义中没有修改基类的虚函数，我们就指向基类的虚函数；如果派生类改写了基类的虚函数，这时续表则将原来指向基类的虚函数的地址替换为指向自身虚函数的指针。注意续表!!!每个类都会有一个自己的表</li><li>必须通过基类类型的引用或指针进行函数调用才会发生多态</li></ol><h3 id="有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。"><a href="#有个变量-i-5-两个线程执行-i-5-次-i-的结果是多少。" class="headerlink" title="有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。"></a>有个变量 i=5,两个线程执行 i++5 次,i 的结果是多少。</h3><p>值为15</p><p>int sum = 0;<br>void Func ()<br>{<br>    for (int i = 0; i &lt; 10; ++i)<br>    sum += 2;</p><p>}<br>这个和一个接一个执行没有区别，并发性只是可能会导致同一时间sum+4，加出来还是40，不会说少加了，也不会说两个线程 分开，一个线程加5次，哪怕减也一样。平时我们遇到的并发性所导致的问题如，写日志的时候，多个线程同时往一个日志文件写数据（很常见），如果不加互斥锁，写出来的数据可能会杂乱无章，失去了数据原应该代表的信息，或者多个线程对一块资源请求的时候，如果每个线程在请求完之后都会改变请求的资源，并发性会导致一系列严重问题.</p><h3 id="epoll-的工作模式。-区分工作机制"><a href="#epoll-的工作模式。-区分工作机制" class="headerlink" title="epoll 的工作模式。(区分工作机制)"></a>epoll 的工作模式。(区分工作机制)</h3><p>LT（level triggered）<br>LT模式，也叫做水平触发模式。在该模式下，当有事件发生并调用epoll_wait后，若未及时处理，下一次调用epoll_wait仍会继续通知。<br>内部实现方法：将从rdlist上取出的事件重新放回去，再次调用epoll_wait仍会继续通知，直到用户处理完成主动关闭fd。<br>在该模式下有两种工作方式：阻塞和非阻塞。<br>自认为这两种工作方式并没有很明显的区别，因为只要被唤醒就一定有事件可读或者可写，阻塞模式下，一般情况并不会进入阻塞状态。在非阻塞模式下，会使用循环的方式进行读/写，直到完成或出现异常循环退出。</p><p>ET(edge trigger)<br>ET模式，也叫边缘触发模式，其与水平模式的区别就是，调用epoll_wait通知过的事件，不论是否经过处理，再次调用epoll_wait不会再次通知了，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此ET模式效率比LT模式高。<br>内部实现方法：调用epoll_wait从rdlist取出事件后就不会再放回。<br>ET模式下推荐使用非阻塞，我在这件事情上面纠结了很久，为什么阻塞就不行呢？网上给出的答案也都模棱两可，说阻塞模式下可能会造成永久阻塞，但是又不说明情况。思考后我的理解是这样的：</p><p>非阻塞模式：在ET模式下，因为事件只会被通知一次，为了保证数据成功被读取或写入，在非阻塞模式下，采用循环的方式进行读写，直到完成或出现异常时退出。<br>阻塞模式：如果不采用循环的方式进行读写，就会造成数据读/写不完的情况，因为下一次再调用epoll_wait就不会再通知了，如果尝试采用循环的方式进行读写，则会造成永久阻塞。<br>造成阻塞的原因只有没有数据可读/可写，在非阻塞模式下出现没有数据可读/可写可以返回相应的错误信息，但是阻塞模式就会进入阻塞状态，而处理的该fd永远也不可能再有可读数据了，所以就被永久阻塞了。</p><h3 id="c-语言各种变量所在的节"><a href="#c-语言各种变量所在的节" class="headerlink" title="c 语言各种变量所在的节"></a>c 语言各种变量所在的节</h3><h3 id="c-怎么实现一个函数先于main函数运行"><a href="#c-怎么实现一个函数先于main函数运行" class="headerlink" title="c++怎么实现一个函数先于main函数运行"></a>c++怎么实现一个函数先于main函数运行</h3><h3 id="c-的static的变量的初始化顺序怎么样的-如果一个类里面呢？"><a href="#c-的static的变量的初始化顺序怎么样的-如果一个类里面呢？" class="headerlink" title="c++的static的变量的初始化顺序怎么样的,如果一个类里面呢？"></a>c++的static的变量的初始化顺序怎么样的,如果一个类里面呢？</h3><h3 id="两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？"><a href="#两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？" class="headerlink" title="两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？"></a>两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？其他用户不知道头文件的声明顺序怎么确定呢？</h3><h3 id="来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜"><a href="#来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜" class="headerlink" title="来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜"></a>来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜</h3><h3 id="STL说一下"><a href="#STL说一下" class="headerlink" title="STL说一下."></a>STL说一下.</h3><p>在整理:</p><h3 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析:"></a>系统分析:</h3><pre><code>维护在线人数的瓶颈分析。【除了内存,想不到】</code></pre><h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题:"></a>计算题:</h3><pre><code>100G 的文件,分发的 100 个机器上,机器之间互相联通,带宽千兆。最少数据是多少。(这一题答的稀烂,想挂电话)。</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="c++基础实战" scheme="http://example.com/categories/c-%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="c++基础实战" scheme="http://example.com/tags/c-%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>network-of-computer3</title>
    <link href="http://example.com/posts/19628/"/>
    <id>http://example.com/posts/19628/</id>
    <published>2020-11-14T00:55:40.000Z</published>
    <updated>2020-11-14T01:18:00.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="输入-www-baidu-com在浏览器的完整过程，越详细越好"><a href="#输入-www-baidu-com在浏览器的完整过程，越详细越好" class="headerlink" title="输入 www.baidu.com在浏览器的完整过程，越详细越好."></a>输入 <a href="http://www.baidu.com在浏览器的完整过程,越详细越好/">www.baidu.com在浏览器的完整过程，越详细越好</a>.</h3><ol><li>客户端浏览器通过DNS解析到<a href="http://www.baidu.com的ip地址220.181.27.48,通过这个ip地址找到客户端到服务器的路径.客户端浏览器发起一个http会话到220.161.27.48,然后通过tcp进行封装数据包,输入到网络层./">www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</a></li><li>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li><li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。（IP地址转为MAC）</li></ol><p>事件顺序:<br>    (1) 浏览器获取输入的域名<a href="http://www.baidu.com/">www.baidu.com</a><br>    (2) 浏览器向DNS请求解析<a href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a><br>    (3) 域名系统DNS解析出百度服务器的IP地址<br>    (4) 浏览器发出HTTP请求，请求百度首页<br>    (5) 浏览器与该服务器建立TCP连接(默认端口号80)<br>    (6) IP的重要功能是寻址和路由<br>   （7）定义了通过物理网络输出数据所需的协议与硬件要求</p><p>   服务器通过HTTP响应把首页文件发送给浏览器<br>    (7) TCP连接释放<br>    (8) 浏览器将首页文件进行解析，并将Web页显示给用户。</p><p>涉及到的协议:<br>    (1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务)   DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输<br>    (2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)<br>    HTTP会话会被分成报文段，添加源、目的端口；TCP协议进行主要工作 　　(3)网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)<br>    为数据包选择路由，IP协议进行主要工作，相邻结点的可靠传输，ARP协议将IP地址转成MAC地址。<br>    点击网址后，应用层的DNS协议会将网址解析为IP地址；</p><pre><code>DNS查找过程： 1. 浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。 2. 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存（hosts文件）中是否有这个域名对应的DNS解析结果。 3. 若还没有，此时会发送一个数据包给DNS服务器，DNS服务器找到后将解析所得IP地址返回给用户。  在应用层，浏览器会给web服务器发送一个HTTP请求:   请求头为：GET http://www.baidu.com/HTTP/1.1  在传输层，（上层的传输数据流分段）HTTP数据包会嵌入在TCP报文段中:   TCP报文段需要设置端口，接收方（百度）的HTTP端口默认是80，本机的端口是一个1024-65535之间的随机整数，这里假设为1025，这样TCP报文段由TCP首部（包含发送方和接收方的端口信息）+ HTTP数据包组成。  在网络层中，TCP报文段再嵌入IP数据包中:   IP数据包需要知道双方的IP地址，本机IP地址假定为192.168.1.5，接受方IP地址为220.181.111.147（百度），这样IP数据包由IP头部（IP地址信息）+TCP报文段组成。  在网络接口层，IP数据包嵌入到数据帧（以太网数据包）中在网络上传送:    数据帧中包含源MAC地址和目的MAC地址（通过ARP地址解析协议得到的）。这样数据帧由头部（MAC地址）+IP数据包组成。   数据包经过多个网关的转发到达百度服务器，请求对应端口的服务: I    I     服务接收到发送过来的以太网数据包开始解析请求信息，从以太网数据包中提取IP数据包—&gt;TCP报文段—&gt;HTTP数据包，并组装为有效数据交与对应线程池中分配的线程进行处理，在这个过程中，生成相应request、response对象。   请求处理完成之后，服务器发回一个HTTP响应:       请求处理程序会阅读请求及它的参数和cookies。它会读取也可能更新一些数据，并将数据存储在服务器上。处理完毕后，数据通过response对象给客户输出信息，输出信息也需要拼接HTTP协议头部分，关闭后断开连接。断开后，服务器端自动注销request、response对象，并将释放对应线程的使用标识（一般一个请求单独由一个线程处理，部分特殊情况有一个线程处理多个请求的情况）。      响应头为：HTTP/1.1200 OK浏览器以同样的过程读取到HTTP响应的内容（HTTP响应数据包），然后浏览器对接收到的HTML页面进行解析，把网页显示出来呈现给用户。客户端接收到返回数据，去掉对应头信息，形成也可以被浏览器认识的页面HTML字符串信息，交与浏览器翻译为对应页面规则信息展示为页面内容。         1. 由域名→IP 地址         寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。         2. 建立 TCP/IP 连接（三次握手具体过程）         3. 由浏览器发送一个 HTTP 请求         4. 经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器         5. 服务器处理该 HTTP 请求，返回一个 HTML 文件         6. 浏览器解析该 HTML 文件，并且显示在浏览器端         7. 这里需要注意：         o  HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接         o  可以这样理解：HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。         o  两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络实战总结" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux系统</title>
    <link href="http://example.com/posts/63613/"/>
    <id>http://example.com/posts/63613/</id>
    <published>2020-11-12T11:05:40.000Z</published>
    <updated>2020-11-13T13:24:57.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>linux系统的开机过程是比较复杂的一个过程，但整体上可以分成四大步骤或四大块:<br>    1. 按电源按钮后BIOS开始工作,然后进行加电自检<br>    BOIS是英文”Basic input output system”的缩写词，就是进本的输入输出系统，BOIS是电脑启动时加载的第一个软件，其实,他是一组固化到计算机内主板上一个ROM(只读存储器)芯片上的程序.<br>    2. MBR引导(Boot Loader)(0磁盘的0柱面的第一个扇区)<br>     主引导记录(MBR,Main Boot Record)是位于磁盘最前边的一段引导(Loader)代码.它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判断,分区引导信息的定位，它由磁盘操作系统(DOS)对磁盘对象初始化时产生的．<br>    3. 启动内核<br>    4. 启动第一个进程init<br>    进程pid为1的进程,然后进行各个脚本的调用，脚本运行，</p><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><h3 id="BIOS-开机自检"><a href="#BIOS-开机自检" class="headerlink" title="BIOS/开机自检"></a>BIOS/开机自检</h3><h4 id="微控制器"><a href="#微控制器" class="headerlink" title="微控制器"></a>微控制器</h4><p>开机键-&gt;硬件工作(寄存器复位)-&gt;BIOS(执行BIOS里边的程序,作用是找到主引导记录MBR)-&gt;(MBR)-&gt;(MBR程序加载到内存)-&gt;接下来执行MBR的程序.</p><p>系统想要启动必须先加载BOIS,按下电源键时,给微控制器下达一条复位指令,个寄存器复位,最后下达一条跳转指令,跳转到BOIS的ROM,使得硬件去读取主板上的BOIS程序,在这之前都是由硬件来完成，之后硬件就会把控制权交给BOIS.</p><h4 id="BOIS-gt-POST"><a href="#BOIS-gt-POST" class="headerlink" title="BOIS-&gt;POST"></a>BOIS-&gt;POST</h4><p>  随后BOIS程序如果加载CMOS(可读写的RAM芯片(断电数据丢失),保存BIOS设置的硬件参数的数据)的信息,借CMOS取得主机的各项硬件配置:<br>  取得硬件配置的信息之后,BOIS进行加电自检(Power-on self Test, POST)过程检测计算机各种硬件信息,如果发现硬件错误则会报错(发出声音警告);<br>  之后BOIS对硬件进行初始化(检测硬件信息无误)．<br>  BOIS将自己复制到物理内存中继续执行,开始按顺序搜寻可引导存储设备,判断的标准就是判断每个磁盘前512个字节结尾是否存在55AA,有就是可引导，没有就继续检查下一个磁盘.一般第一张磁盘就是可引导磁盘,接下来就会读取磁盘的内容，但是要读取磁盘文件必须要有文件系统，这对BOIS挂载文件系统来说是不可能(BOIS非常小的),因此需要一个不依赖文件系统的方法使得BOIS读取磁盘内容,这种方法就是引入MBR.最后BOIS读取第一个可导的存储设备的MBR(0柱面0磁道第一扇区)中的boot Loader(根引导程序).将MBR加载到物理内存中执行．<br>  MBR载入内存后,BIOS将控制权转交给MBR(准确的说应该是MBR中的boot loader),然后MBR接管任务开始执行．</p><p>  小例子:<br>       如果开机密码忘记了，打开主板扣电池，BIOS断电,然后RAM芯片会全部还原为默认值,BIOS密码会消失.</p><h3 id="MBR引导-Boot-Loader"><a href="#MBR引导-Boot-Loader" class="headerlink" title="MBR引导(Boot Loader)"></a>MBR引导(Boot Loader)</h3><p>  载入了第一个可引导的存储设备的MBR后,MBR中的boot Loader就要读取所在磁盘的操作系统核心文件(即后面所说的内核)了.</p><h4 id="boot-Loader"><a href="#boot-Loader" class="headerlink" title="boot Loader"></a>boot Loader</h4><p>  但是呢还存在一些问题，不同操作系统的文件格式不同?还有我们知道一个磁盘可以安装多个操作系统，boot Loader怎么能够做到引导的就是我们想要的操作系统呢?这么多不同的功能单靠一个446字节的boot Loader是远远不够的．因此必须弄一个相对应的程序来处理各自对应的操作系统核心文件，这个程序就是操作系统的loader(注意不是MBR中的boot Loader,而是没个操作系统本身有一个自己的boot Loader),这样一来boot Loader只需要将控制权限交给对应操作系统的loader,让他负责去启动操作系统就行了．</p><p>第一个扇区512个字节<br>MBR　　　446字节<br>分区表　　64字节　16个字节一个分区<br>55AA标记　2字节</p><p>这里有张图更好的解释boot loader的作用:</p><p>图跳转.<br>扇区的0-2048就是存放这些东西的所以我们用不了</p><p>解读上图内容，我们知道一个硬盘的每个分区的第一个扇区叫做boot sector,这个扇区存放的就是操作系统的loader,所以我们常说一个分区只能安装一个操作系统，如上图，第一个分区的Boot sector存放这windowde的loader,第二个分区放着linux的loader,第三个第四个由于没有安装操作系统所以空着．至于MBR的boot Loader是干嘛呢,Boot Loader有三个功能:<br>    1. 提供选单<br>    2. 读取内存文件<br>    3. 转交给其他loader<br>    提供选单就是给用户提供一张选项单，让用户选择进入那个系统；<br>    读取内核文件，我们知道系统会有一个默认启动的操作系统，这个系统的loader在所有分区的boot sector有一份，除此之外也会将这个迷人启动的操作系统的loader复制一份到MBR的boot Loader中,这样一来MBR就会直接读取Boot Loader总的loader了，然后就是启动默认的操作系统．<br>    转交给其他的Loader,当用户选择其他操作系统启动的时候，Boot Loader会将控制权限转交给对应的loader,让他负责去启动操作系统的启动．<br>    另外，安装window操作系统的时候,window会主动复制一份自己的loader到MBR中的Boot Loader中,这种操作在linux下不会.所以我们安装多重操作系统的时候要求先安装window,然后在安装linux;我们假设先安装linux再安装windows的时候就会把windows的loader复制到MBR中的boot Loader,这样依赖就会默认优先启动windows.然后先安装windows,自动回复Windows的loader到boot Loader,再安装linux的时候,我们可以设置把linux的loader复制到boot Loader中,把原先windows的覆盖掉,这样才能设置linux默认启动.</p><h4 id="Linux的GRUB"><a href="#Linux的GRUB" class="headerlink" title="Linux的GRUB"></a>Linux的GRUB</h4><p>linux操作系统层面的loader使用的是grub.(loader包含在grub)<br>linux的Boot Loader和grub到底是什么关系呢?<br>图片跳转:<br>    我们可以看到很多文件，其实linux的Loader为stage1那个文件，linux所在分区的boot sector(一个扇区是512个字节)就是存放在stage1文件的内容，同时默认linux启动的话,也需要把stage1中的引导代码安装到MBR中的boot Loader中.该文件太小，能完成的功能有限，因此linux的Loader只是简单的引导作用．<br>    stage1完成了主程序的引导后，主引导程序开始加载配置文件了，但是加载这些配置文件之前需要有文件系统的支持，可是现在还没有文件系统呢,gurb在不依赖linux内核的情况下具有读取配置文件与内核映像的能力，gurb的内置文件系统其实是依赖stage1_5这些文件定义的,而且有不同文件系统对应不同的stage1_5文件.<br>    而后开始读取stage2开始真正的读取配置文件grub,conf.解析/boot/grub/grub.conf文件;<br>    (linux操作系统多个系统核心并存,linux内核更新没有覆盖原来的内核，而是增加了一个新的内核)．<br>    文件参数<br>    1. default = 0 第几个操作系统<br>    2. timeout = 5 系统选择页面显示时间．<br>    3. splashimage = (hd0, 0)/grud/splash.xpm.gz: (hd0, 0)磁盘分区的意思，grub表示磁盘是磁盘+坐标形式.<br>    大多数用的是SATA这种接口的硬盘，文件设备名字为sd, 第一块硬盘为Sda,第二块硬盘为 sdb….<br>　　grub中是以hd + 坐标的形式来展现的<br>　　　具体对应关系实现:<br>      　sda -&gt;1.-&gt;(hd0,0)<br>      　　　-&gt;2.-&gt;(hd0,1)<br>      　　　-&gt;3.-&gt;(hd0,2)<br>    4. haddenmenu 隐藏菜单<br>    5. (对应图片)启动系统名字<br> 　　　boot引导分区的根对应的/boot/这个地方．<br>　　　启动linux的内核，初始化一个虚拟的伪文件系统(,img),用来加载linux系统的核心模块，加载完成后，就把这个伪文件系统给删除掉，转而加载真正的linux系统所支持的真正的内核文件系统．</p><h3 id="gurb把内核文件加载到内存"><a href="#gurb把内核文件加载到内存" class="headerlink" title="gurb把内核文件加载到内存"></a>gurb把内核文件加载到内存</h3><h4 id="加载内核文件"><a href="#加载内核文件" class="headerlink" title="加载内核文件."></a>加载内核文件.</h4><p>MBR将内核文件(代码)载入物理内存中执行，内核就是/boot/vmlinuz-2.6.32-696.el6.x86_64.观察该文件，发现是一个压缩镜像文件．<br>看图．<br>控制权转交给内核后，内核重新检测各种硬件信息,(第一次为POST自检)我们前边说了，一个完整的linux包括内核和内核之上的程序需要使用硬件，还需要加载提供这些程序功能的模块（硬件驱动程序），然而这些模块都在根目录的/lib/modules/2.6.32-696.el.x86_64下(和/lib/modules/不能挂载不同的分区)，这时候内核还没有文件系统的概念，没有文件系统就没办法挂载到根目录，想要挂载根目录就需要相应的模块支持，而我们原本的问题就是如何加载模块，先有鸡后有蛋．</p><h4 id="加载initrd初始化ramfs文件系统"><a href="#加载initrd初始化ramfs文件系统" class="headerlink" title="加载initrd初始化ramfs文件系统"></a>加载initrd初始化ramfs文件系统</h4><p>看图<br>我们发现解压之后的内容类似于真正/目录下内容，这是因为这是一个最小化的linux根文件系统，内核就是先把这个文件展开，形成一个虚拟文件系统,内核接虚拟文件系统装在必要的模块，完成后释放该虚拟文件系统并挂载真正的根目录．</p><p>运行起来后真正的根会和fstable挂载在一起，并且会把根目录放在第一个硬盘挂载在一起sda1(?),然后在调用linux系统中的系统程序,第一个就是调用init,进程ID就是1,其他进程都是他的子进程.</p><h3 id="启动第一个进程init"><a href="#启动第一个进程init" class="headerlink" title="启动第一个进程init"></a>启动第一个进程init</h3><h4 id="init进程-主要功能是准备软件执行的环境"><a href="#init进程-主要功能是准备软件执行的环境" class="headerlink" title="init进程:主要功能是准备软件执行的环境"></a>init进程:主要功能是准备软件执行的环境</h4><p>内核完成硬件检测和加载模块后，内核会呼吁第一进程，就是/sbin/init,至此内核把控制权限交给init进程读取初始化配置文件/etc/inittab,决定操作系统的runlevel,/etc/inittab内有这样一句:<br>    id:runlevel:action:process,这里我的实验机器的值:id:3:initdefault:<br>    看图:</p><h4 id="etc-rc-d-rc-sysinit"><a href="#etc-rc-d-rc-sysinit" class="headerlink" title="/etc/rc.d/rc.sysinit"></a>/etc/rc.d/rc.sysinit</h4><p>读取/ect/rc.d/sinit系统初始化脚本，设置主机名，挂载/etc/fstab中的文件系统，修改/etc/systl.conf的内核参数等各项系统环境．<br>查看脚本内容，大致功能如下图:</p><pre><code>k开头的文件杀死，ｓ开头的文件启动．linux默认的号为３,就会扫描rc.d中的rc3.d文件．文件中一部分ｋ开头，一部分ｓ开头．</code></pre><p>根据运行级别(123456)进入相应的etc/rc.d/rcN,d目录，启动和关闭相关的系统服务．里边存放着一堆以k,S开头的软连接文件，分别是代表相应的服务.K开头表示运行级别下需要把该服务杀死，S开头表示该运行级别下需要把服务开启．上述操作都是有/etc/rc.d/rc脚本来完成的.另外我们还注意都S和K后边的数字，他们的数字代表了读取的顺序，因为有一些服务是具有一定的关联性．<br>　　而且每个rcN.d目录内最后都有一个S99local文件，该文件指向../rc.local脚本．</p><h4 id="etc-rc-d-rc-local"><a href="#etc-rc-d-rc-local" class="headerlink" title="/etc/rc,d/rc.local"></a>/etc/rc,d/rc.local</h4><p>　　系统根据runlevel执行完成/etc/rc.d/rcN.d中的脚本后，调用/etc/rc.d/rc.local脚本<br>　　这时候系统已经完成了各种必要系统服务的启动，假如我们想定自定义一些指令要在开机的时候启动，我们就可以把他们放到/etc/rc.d/rc.local内,该文件默认为空.</p><h4 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h4><p>　　接下来会由/sbin/mingetty指令启动终端，会启动6个命令行终端,最终呈现给我们的就是这样画面<br>看图启动过程<br>　<a href="https://blog.csdn.net/abc_ii/article/details/8740008">全面图解</a><br><a href="https://blog.51cto.com/itchentao/1912451">进阶图解强烈推荐</a><br><a href="https://s1.51cto.com/wyfs02/M00/8F/7A/wKiom1jfbn-zLndXAAJfq4gKqGA617.png">直接显示图</a></p><h3 id="Centos7-x的启动过程和相关配置文件"><a href="#Centos7-x的启动过程和相关配置文件" class="headerlink" title="Centos7.x的启动过程和相关配置文件"></a>Centos7.x的启动过程和相关配置文件</h3><p>Cenos7和Centos6启动流程差不多，只不过到init程序时候，改为了systemd,因此详细解释一下systemd后的启动流程，</p><ol><li>uefi或BIOS初始化,开始POST开机自检(uefi是BIOS发展的阶段)</li><li>加载mbr到内存</li><li>GRUB阶段，Centos6加载的是/boot/grub.grub.conf,而Centos7加载的是/boot/grub2/grub.conf</li><li>加载内核和initramfs模块</li><li>内核开始初始化，使用system来代替centos6以前的init程序,systemd使用”target”来处理引导和服务管理过程，这些system里的”target”文件被用于分组不同的引导单元以及自启动同步进程．</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>leedcode_动态规划</title>
    <link href="http://example.com/posts/34955/"/>
    <id>http://example.com/posts/34955/</id>
    <published>2020-11-11T03:23:11.000Z</published>
    <updated>2020-11-15T15:41:45.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h3><p>状态表示: sum表示当前位置的最大子序列和<br>状态划分: 子序列结尾位置<br>转移方程: max(sums ,sum + sums[i+1] )<br>边界:sum = sums[0]<br>目标: sum中最大值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            int length &#x3D; sizeof(nums)&#x2F;sizeof(nums[0]); </span><br><span class="line">            int sum &#x3D; 0; </span><br><span class="line">            if(length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">            int last &#x3D; nums[0];</span><br><span class="line">            sum &#x3D; nums[0];</span><br><span class="line">        for(auto it &#x3D; nums.begin()+1; it !&#x3D; nums.end() ; it++)&#123;</span><br><span class="line">                    sum &#x3D; max(*it, sum + *it);</span><br><span class="line">                    last &#x3D; max(sum, last);                </span><br><span class="line">        &#125;</span><br><span class="line">            return last;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a>面试题 17.16. 按摩师</h3><p>分两种情况的dp.<br>状态表示: dp[i][0]和dp[i][1]表示第i个位置选和不许的两种状态<br>状态划分: dp[i][0/1]表示i位结尾的状态<br>转移方程:<br>    不选: dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);<br>    选: dp[i][1] = dp[i - 1][0] + nums[i]; 这次选上次为不选．<br>边界: (1 &lt;= i &lt;= n),<br>目标: max(dp[n][0], dp[n][1]);</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int massage(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">                int n &#x3D; nums.size();</span><br><span class="line">                if(!n) return 0;</span><br><span class="line">                int dp0 &#x3D; 0, dp1 &#x3D; nums[0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; n; i++)&#123;</span><br><span class="line">                        int tdp0 &#x3D; max(dp0, dp1);</span><br><span class="line">                        int tdp1 &#x3D; dp0 + nums[i];</span><br><span class="line">                        dp0 &#x3D; tdp0;</span><br><span class="line">                        dp1 &#x3D; tdp1;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return max(dp0, dp1);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a>1025. 除数博弈</h3><p>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标:<br>博弈论找规律: 奇数必败偶数必赢.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool divisorGame(int N) &#123;</span><br><span class="line">           return N % 2 &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a>面试题 08.01. 三步问题</h3><p>状态表示: dp[i] 表示i级台阶的状态步数种数.<br>状态划分: dp[i]以i结尾的状态种数和.<br>转移方程: </p><ol><li>转移条件为走1,2,3步到达目标状态.</li><li>dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];<br>就是走到i位置，需要走1,2,3三种情况能到i位置的不同情况.<br>边界:dp[1] = 1, dp[2] = 2, dp[3] = 4;<br>目标: dp[n];<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int waysToStep(int n) &#123;</span><br><span class="line">                int dp[1000005];</span><br><span class="line">                dp[1] &#x3D; 1, dp[2] &#x3D; 2, dp[3] &#x3D; 4;</span><br><span class="line">                if(n &lt; 4) return dp[n];</span><br><span class="line">        for(int i &#x3D; 4; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; (((dp[i - 1] % 1000000007+ dp[i - 2])%1000000007 + dp[i - 3])%1000000007) %1000000007;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return dp[n] % 1000000007;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h3><p>状态表示:<br>    temp记录i节点前dp中的最小值.<br>    sum 记录最大利润.<br>状态划分:<br>    加入一个新节点加入通过比较加入新状态</p><p>转移方程:<br>    sum = max(sum ,prices[i] - temp);<br>    temp = min(temp, prices[i]);<br>边界: sim = -1, temp = prices[0].<br>目标: sum值</p><p>总统思想: 当前节点减去前边最小节点，维护一个最大的利润.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">                if(prices.size()&#x3D;&#x3D; 0) return 0;</span><br><span class="line">                int temp &#x3D; prices[0], sum &#x3D; -1;</span><br><span class="line">        for(auto it &#x3D; prices.begin(); it !&#x3D; prices.end(); it++)&#123;</span><br><span class="line">                        sum &#x3D; max(sum, *it - temp);</span><br><span class="line">                        temp &#x3D; min(temp, *it);</span><br><span class="line">        &#125;</span><br><span class="line">                if(sum &lt;&#x3D; 0) return 0;</span><br><span class="line">                return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h3><p>状态表示: dp[i] 表示当前状态最大的获益<br>状态划分:　抢n, 和不抢n两种状态<br>转移方程: dp[n + 1] = max(dp[n], dp[n - 1] + nums[i - 1]);<br>边界: 左后遍历的时候数组往后移动三位．<br>目标: dp[nums.size() + 1];</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">             &#x2F;&#x2F;   if(nums.size() &#x3D;&#x3D; 0 ) return 0;</span><br><span class="line">             &#x2F;&#x2F;   if(nums.size() &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">                int dp[200] &#x3D; &#123;0&#125;;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; nums.size(); i++)&#123;</span><br><span class="line">                        dp[i + 1] &#x3D; max(dp[i], dp[i - 1] + nums[i - 1]);</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return dp[nums.size() + 1];</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a>剑指 Offer 42. 连续子数组的最大和</h3><p>状态表示: dp[i] 表示到目前的最大值<br>状态划分: dp[i - 1] 加与不加 nums[i - 1]　两种状态<br>转移方程: dp[i] = max(nums[i], dp[i - 1] + nums[i]);<br>边界: dp[0] = nums[0]<br>目标: temp 最大值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">                int dp[100005] &#x3D; &#123;0&#125;;</span><br><span class="line">                if(nums.size() &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">                dp[0] &#x3D; nums[0];</span><br><span class="line">                int temp &#x3D; nums[0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; max(nums[i],dp[i - 1] + nums[i]);</span><br><span class="line">                        temp &#x3D; max(temp, dp[i]);           </span><br><span class="line">        &#125;</span><br><span class="line">                return temp;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>状态表示:  dp[i] 走到当前状态最小步数<br>状态划分:　当前楼梯是上一步还是上两步走到的，<br>转移方程:　dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);<br>边界: dp[0]和dp[1];<br>目标: dp[cost.size()];</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">                int dp[1005] &#x3D; &#123;0&#125;;</span><br><span class="line">                if(cost.size() &#x3D;&#x3D; 0) return 0;</span><br><span class="line">                if(cost.size() &#x3D;&#x3D; 1) return cost[0];</span><br><span class="line">        for(int i &#x3D; 2; i &lt;&#x3D; cost.size(); i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">                return dp[cost.size()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h3><p>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标:<br>思想: 维护前ｎ项和，取差值就是区间和．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class NumArray &#123;</span><br><span class="line">    public:</span><br><span class="line">    NumArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">                res.push_back(0);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;</span><br><span class="line">                        res.push_back(res.back() + nums[i]);</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    int sumRange(int i, int j) &#123;</span><br><span class="line">                return res[j+1] - res[i];</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    private:</span><br><span class="line">         vector&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your NumArray object will be instantiated and called as such:</span><br><span class="line">      * NumArray* obj &#x3D; new NumArray(nums);</span><br><span class="line">       * int param_1 &#x3D; obj-&gt;sumRange(i,j);</span><br><span class="line">        *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>状态表示: dp[i] 当前位置的种数<br>状态划分: 一步和两步到达当前状态.<br>转移方程: dp[i] = dp[i - 1] + dp[i - 2];<br>边界: dp[0],dp[2]<br>目标: dp[n]<br>思想: 依据斐波那契数列</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int climbStairs(int n)&#123;</span><br><span class="line">                int dp[10005] &#x3D; &#123;0&#125;;</span><br><span class="line">                dp[0] &#x3D; 1,dp[1] &#x3D; 1;</span><br><span class="line">        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">                        dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">                    </span><br><span class="line">        &#125; </span><br><span class="line">                return dp[n];</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-16-17-连续数列"><a href="#面试题-16-17-连续数列" class="headerlink" title="面试题 16.17. 连续数列"></a>面试题 16.17. 连续数列</h3><p>dp前边有原题<br>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标:<br>    思路：分治算法就是加判断</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            int max1 &#x3D; nums[0], i &#x3D; 1, sum &#x3D; max1;</span><br><span class="line">        while(i &lt; nums.size())&#123;</span><br><span class="line">            if(sum + nums[i] &lt; nums[i])&#123;</span><br><span class="line">                            sum &#x3D; 0;</span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">                    sum +&#x3D; nums[i];</span><br><span class="line">            if(sum &gt; max1)&#123;</span><br><span class="line">                            max1 &#x3D; sum;</span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            return max1;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h3><p>状态表示:<br>状态划分:<br>转移方程:<br>边界:<br>目标: </p><p>暴力求解</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">            int s1 &#x3D; 0, t1 &#x3D; 0;</span><br><span class="line">        while (s[s1] &amp;&amp; t[t1]) &#123;</span><br><span class="line">            if (s[s1] &#x3D;&#x3D; t[t1]) &#123;</span><br><span class="line">                            s1++;     </span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">                     t1++;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        if (s[s1] &#x3D;&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux_system</title>
    <link href="http://example.com/posts/47607/"/>
    <id>http://example.com/posts/47607/</id>
    <published>2020-11-10T06:09:26.000Z</published>
    <updated>2020-11-13T13:24:57.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linxu" scheme="http://example.com/tags/linxu/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://example.com/posts/1/"/>
    <id>http://example.com/posts/1/</id>
    <published>2020-11-10T00:38:59.000Z</published>
    <updated>2020-11-13T13:29:15.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>heap_sort()<br>o(nlogn)</p><p>堆的一般性操作(底层是一个完全二叉树)．</p><ol><li>插入元素: 插入元素时根据堆自下而上进行调整，层数越高（越接近根节点）调整的次数越多．<br>实例：第零层(根节点位置)插入的时候进行零次调整，第一层元素最多调整1次依次类推.根据推导单个个元素需要调整的次数:<br> 调整次数 = 树高 - 1<br> 推导得到: 调整次数 = (nlogn + 1) - 1;<br> 调整次数 = nlogn;<br>整体的调整次数:（背景为一个满二叉树）<br>　　　　该层节点最多调整次数　节点个数<br>第一层:　　　　　０　　　　　　　2^0<br>第二层:　　　　　１　　　　　　　2^1<br>第三层:　　　　　２　　　　　　　2^2<br>第N层:　　 　　　Ｎ-1　　　　　　2^n<br>（背景满二叉树）<br>度为零的节点比度为二的节点多一个,<br>上边规律可得最后一层节点有2^n个，那么度为2的节点2^n - 1个.<br>这两个的和就是整个要维护的节点个数，之和就是N = 2^(n + 1) - 1个．</li></ol><p>叶子节点处理:<br>最后一层的节点调整之和就是(n - 1) * 2^n<br>转换为(log(2^n) - 1) * (2 ^ n)</p><p>把N代替了n,求全部节点调整次数：<br>(log2N - 2) * (N/2): 注释由于叶子节点和全部节点近似2倍的关系，所以简化为(N/2).</p><p>化简取其最大量级<br>整体的时间复杂度约为 O(NlogN).</p><h4 id="建堆的优化"><a href="#建堆的优化" class="headerlink" title="建堆的优化"></a>建堆的优化</h4><p>为了让建堆的时间复杂度变为O(n).使其层数越高的元素（层数越小），操作的次数越多，就需要自上而下的进行维护一个堆．<br>所以依据传统思路，找到了一个完全优于前者思路，前者思路就会淘汰．<br>得到公式：<br>n<em>2^1 + (n-1)*2^2 + (n-2)*2^3 +……+ 1</em>2^n (n依据上表分析)<br>注意第一项为第二次到顶层调整次数．<br>就比如最后一项: 最后一层节点数2^n个，需要调整的次数为1次.</p><p>这个公式的计算(等差乘等比)</p><p>当前项成公比，然后错位相减（纸上计算）</p><p>过程中需要加上2^0,2^1再整个减去3.可以得到<br>2^1 + 2^2 +…… 2^n -2<em>n - 3<br>等比序列求结果．Sn = a1(1 - q^n)/(1-q) <a href="https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97/1129457?fr=aladdin">公式跳转</a><br>结果为　2^(n+2) - 2</em>n -4 = 2^(n + 1) - 4.</p><p>对于这个结果分析一下:<br>    把n带入求得n+1层节点个数2^n,从下层调整个数2^(n+1).<br>    2^n变化为2^(n + 1)表明了让N = 2^n（表示节点的数量）可以得到等式N = 2N．趋于一种平衡状态．<br>    进一步推导可得O(2N) = O(N)的时间复杂度. </p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>k-归并排序</title>
    <link href="http://example.com/posts/32473/"/>
    <id>http://example.com/posts/32473/</id>
    <published>2020-11-10T00:27:16.000Z</published>
    <updated>2020-11-13T13:24:57.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>system_develop</title>
    <link href="http://example.com/posts/48539/"/>
    <id>http://example.com/posts/48539/</id>
    <published>2020-11-09T15:43:24.000Z</published>
    <updated>2020-11-13T13:24:57.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统开发" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="操作系统开发" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>programming_language</title>
    <link href="http://example.com/posts/21911/"/>
    <id>http://example.com/posts/21911/</id>
    <published>2020-11-09T15:42:36.000Z</published>
    <updated>2020-11-13T13:24:57.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="编程语言开发" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="编程语言开发" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>leedcode</title>
    <link href="http://example.com/posts/62607/"/>
    <id>http://example.com/posts/62607/</id>
    <published>2020-11-09T15:39:53.000Z</published>
    <updated>2020-11-15T02:21:19.565Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单组"><a href="#简单组" class="headerlink" title="简单组"></a>简单组</h2><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>快慢指针:<br>    时间复杂度O(n),空间复杂度O(1);</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      bool hasCycle(ListNode *head) &#123;</span><br><span class="line">                  ListNode *p ,*q;</span><br><span class="line">                  p &#x3D; q &#x3D; head;</span><br><span class="line">          while(q &amp;&amp; q-&gt;next)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                          if(p &#x3D;&#x3D; q) return true;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return false;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="160-相交链表-剑指-Offer-52"><a href="#160-相交链表-剑指-Offer-52" class="headerlink" title="160. 相交链表 剑指 Offer 52"></a>160. 相交链表 剑指 Offer 52</h3><p>变为两个等长链表求第一个交点,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tion for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int getNode(ListNode *head, ListNode **p)&#123;</span><br><span class="line">        *p &#x3D; NULL;</span><br><span class="line">        if(head &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt &#x3D; 1;</span><br><span class="line">        *p &#x3D; head;</span><br><span class="line">        while((*p)-&gt;next !&#x3D; NULL)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            (*p) &#x3D; (*p)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        ListNode *p[2];</span><br><span class="line">        int cnt[2], sub;</span><br><span class="line">        p[0] &#x3D; headA;</span><br><span class="line">        p[1] &#x3D; headB;</span><br><span class="line">        cnt[0] &#x3D; getNode(headA, &amp;p[0]);</span><br><span class="line">        cnt[1] &#x3D; getNode(headB, &amp;p[1]);</span><br><span class="line">        if(p[0] !&#x3D; p[1]) return NULL;</span><br><span class="line">        p[0] &#x3D; cnt[0] &lt;&#x3D; cnt[1] ? headA : headB;</span><br><span class="line">        p[1] &#x3D; cnt[0] &gt; cnt[1] ? headA : headB;</span><br><span class="line">        sub &#x3D; abs(cnt[1] - cnt[0]);</span><br><span class="line">        while(sub--)&#123;</span><br><span class="line">            p[1] &#x3D; p[1]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p[0] !&#x3D; p[1])&#123;</span><br><span class="line">            p[0] &#x3D; p[0]-&gt;next;</span><br><span class="line">            p[1] &#x3D; p[1]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p[0];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h3><p>双指针问题</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">                  ListNode *p, *q;</span><br><span class="line">                  p &#x3D; q &#x3D; head;</span><br><span class="line"></span><br><span class="line">          while(k--)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">          while(p !&#x3D; NULL)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return q;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h3><p>和上一题类似，快慢指针.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthToLast(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode *p, *q;</span><br><span class="line">        p &#x3D; q &#x3D; head;</span><br><span class="line">        while(k--)&#123;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p)&#123;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            q &#x3D; q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return q-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除中间节点"><a href="#删除中间节点" class="headerlink" title="删除中间节点"></a>删除中间节点</h3><p>把删除当前节点转换为删除下一个节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      void deleteNode(ListNode* node) &#123;</span><br><span class="line">                  node-&gt;val &#x3D; node-&gt;next-&gt;val;</span><br><span class="line">                  node-&gt;next &#x3D; node-&gt;next-&gt;next;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h3><p>设置虚拟头结点两个前后指针进行删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* deleteNode(ListNode* head, int val) &#123;</span><br><span class="line">                  ListNode *p &#x3D; new ListNode(NULL), *q &#x3D; head,*r;</span><br><span class="line">                  r &#x3D; p,p-&gt;next &#x3D; q;</span><br><span class="line">          while(q)&#123;</span><br><span class="line">              if(q-&gt;val &#x3D;&#x3D; val)&#123;</span><br><span class="line">                                  p-&gt;next &#x3D; q-&gt;next;</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          q &#x3D; q-&gt;next;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return r-&gt;next;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h3><p>快慢指针,一个指针走一步，一个指针走两不，快指针结束，慢指针输出．<br>注意:快指针两个节点判断.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* middleNode(ListNode* head) &#123;</span><br><span class="line">                  ListNode *p &#x3D; head, *q &#x3D; head;</span><br><span class="line">                  if(head &#x3D;&#x3D; NULL) return head;</span><br><span class="line">          while(( q !&#x3D; NULL ) &amp;&amp; (q-&gt;next !&#x3D; NULL))&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return p;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a>1290. 二进制链表转整数</h3><p>首先看到二进制就想到位运算.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      int getDecimalValue(ListNode* head) &#123;</span><br><span class="line">                  int result &#x3D; 0;</span><br><span class="line">          while(head)&#123;</span><br><span class="line">                          result &lt;&lt;&#x3D; 1;</span><br><span class="line">                          result |&#x3D; head-&gt;val;</span><br><span class="line">                          head &#x3D; head-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return result;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>链表长度等长<br>快慢指针</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      int getNode(ListNode *head, ListNode **p)&#123;</span><br><span class="line">                  *p &#x3D; NULL;</span><br><span class="line">                  if(head &#x3D;&#x3D; NULL) return 0;</span><br><span class="line">                  *p &#x3D; head;</span><br><span class="line">                  int cnt &#x3D; 1;</span><br><span class="line">          while((*p)-&gt;next)&#123;</span><br><span class="line">                          (*p) &#x3D; (*p)-&gt;next;</span><br><span class="line">                          cnt++;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return cnt;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">                  ListNode *p[2];</span><br><span class="line">                  int cnt[2], sub;</span><br><span class="line">                  p[0] &#x3D; headA,p[1] &#x3D; headB;</span><br><span class="line">                  cnt[0] &#x3D; getNode(headA, &amp;p[0]);</span><br><span class="line">                  cnt[1] &#x3D; getNode(headB, &amp;p[1]);</span><br><span class="line">                  p[0] &#x3D; cnt[0] &gt;&#x3D; cnt[1] ? headA : headB;</span><br><span class="line">                  p[1] &#x3D; cnt[0] &lt; cnt[1] ? headA : headB;</span><br><span class="line">                  sub &#x3D; abs(cnt[0] - cnt[1]);</span><br><span class="line">          while(sub--)&#123;</span><br><span class="line">                          p[0] &#x3D; p[0]-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">          while(p[0])&#123;</span><br><span class="line">              if(p[0] &#x3D;&#x3D; p[1])&#123;</span><br><span class="line">                                  return p[0];</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          p[0] &#x3D; p[0]-&gt;next;</span><br><span class="line">                          p[1] &#x3D; p[1]-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return NULL;</span><br><span class="line">                   </span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h3><p>快慢指针找中间位置，链表后半部分翻转，首尾往中间移动比较．</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode* turnlist(ListNode *head)&#123;</span><br><span class="line">                  ListNode *p &#x3D; head, *q &#x3D; head, *temp &#x3D; NULL;</span><br><span class="line">                  if((p &#x3D;&#x3D; NULL) || (p-&gt;next&#x3D;&#x3D;NULL)) return head;</span><br><span class="line">                  q &#x3D; p-&gt;next,  p-&gt;next &#x3D; NULL;</span><br><span class="line">          while(q)&#123;</span><br><span class="line">                          temp &#x3D; q-&gt;next;</span><br><span class="line">                          q-&gt;next &#x3D; p;</span><br><span class="line">                          p &#x3D; q;</span><br><span class="line">                          q &#x3D; temp;</span><br><span class="line">                      </span><br><span class="line">          &#125; </span><br><span class="line">                  return p;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">      bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">                  ListNode *p &#x3D; head, *q &#x3D; head, *temp;</span><br><span class="line">                  if(p &#x3D;&#x3D; NULL  ||p-&gt;next &#x3D;&#x3D; NULL) return true;</span><br><span class="line">          while(q!&#x3D;NULL &amp;&amp; q-&gt;next!&#x3D;NULL)&#123;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          q &#x3D; q-&gt;next-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  temp &#x3D; p;</span><br><span class="line">                  ListNode *k &#x3D; NULL;</span><br><span class="line">                  k &#x3D; turnlist(p);</span><br><span class="line">                  p &#x3D; head;</span><br><span class="line">          while(k)&#123;</span><br><span class="line">              if(p-&gt;val &#x3D;&#x3D; k-&gt;val)&#123;</span><br><span class="line">                                  p &#x3D; p-&gt;next;</span><br><span class="line">                                  k &#x3D; k-&gt;next;</span><br><span class="line">                              continue;</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          else return false;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return true;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h3><p>链表变换虚拟头节点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode *p &#x3D; new ListNode();</span><br><span class="line">        p &#x3D; NULL;</span><br><span class="line">        if(head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;</span><br><span class="line">        ListNode *q &#x3D; head, *k;</span><br><span class="line">        while(q)&#123;</span><br><span class="line">            k &#x3D; q-&gt;next;</span><br><span class="line">            q-&gt;next &#x3D; p;</span><br><span class="line">            p &#x3D; q;</span><br><span class="line">            q &#x3D; k;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h3><p>一般思维就是开一个20001的数组进行hash.<br>无额外内存开销，三个指针完成.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      ListNode * deleteNode(ListNode*head, ListNode *low,ListNode *fast)&#123;</span><br><span class="line">                  if(fast-&gt;next &#x3D;&#x3D; NULL) </span><br><span class="line">                  low-&gt;next &#x3D; NULL;</span><br><span class="line">                  if(fast-&gt;next)</span><br><span class="line">                  low-&gt;next &#x3D; fast-&gt;next;</span><br><span class="line">                  return head;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">      ListNode* removeDuplicateNodes(ListNode* head) &#123;</span><br><span class="line">                  ListNode *p, *q, *k;</span><br><span class="line">                  if(head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) return head;</span><br><span class="line">                  p &#x3D; head, q &#x3D; head-&gt;next, k &#x3D; p;</span><br><span class="line">          while(p)&#123;</span><br><span class="line">              while(q)&#123;</span><br><span class="line">                  if(p-&gt;val &#x3D;&#x3D; q-&gt;val)&#123;</span><br><span class="line">                                          head &#x3D; deleteNode(head, k, q);</span><br><span class="line">                                          q &#x3D; k-&gt;next;</span><br><span class="line">                                          continue;</span><br><span class="line">                                      </span><br><span class="line">                  &#125;</span><br><span class="line">                                  k &#x3D; k-&gt;next, q &#x3D; q-&gt;next;</span><br><span class="line">                              </span><br><span class="line">              &#125;</span><br><span class="line">                          if(p &#x3D;&#x3D; NULL|| p-&gt;next &#x3D;&#x3D; NULL) return head;</span><br><span class="line">                          p &#x3D; p-&gt;next;</span><br><span class="line">                          k &#x3D; p;</span><br><span class="line">                          q &#x3D; p-&gt;next;</span><br><span class="line">                      </span><br><span class="line">          &#125;</span><br><span class="line">                  return  head;</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>###　剑指 Offer 06. 从尾到头打印链表<br>栈列和数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line">      *     int val;</span><br><span class="line">      *     ListNode *next;</span><br><span class="line">      *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">      * </span><br><span class="line"> &#125;;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  class Solution &#123;</span><br><span class="line">      public:</span><br><span class="line">      vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">              vector&lt;int&gt;res;</span><br><span class="line">              stack&lt;ListNode*&gt;node;</span><br><span class="line">              ListNode *p &#x3D; head;</span><br><span class="line">          while(p !&#x3D; NULL)&#123;</span><br><span class="line">                      node.push(p);</span><br><span class="line">                      p &#x3D; p-&gt;next;</span><br><span class="line">                  </span><br><span class="line">          &#125;</span><br><span class="line">          while(!node.empty())&#123;</span><br><span class="line">                      p &#x3D; node.top();</span><br><span class="line">                      node.pop();</span><br><span class="line">                      res.push_back(p-&gt;val);</span><br><span class="line">                  </span><br><span class="line">          &#125;</span><br><span class="line">              return res;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>###<br>###<br>###<br>###<br>###</p><p>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###</p><p>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###<br>###</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leedcode-链表" scheme="http://example.com/categories/leedcode-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="leedcode" scheme="http://example.com/tags/leedcode/"/>
    
  </entry>
  
  <entry>
    <title>socket+tcp</title>
    <link href="http://example.com/posts/14686/"/>
    <id>http://example.com/posts/14686/</id>
    <published>2020-11-09T13:22:27.000Z</published>
    <updated>2020-11-13T13:24:57.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>socket和tcp/udp以及计算机网络传输结合总结．<br>非常详细的博客</p><p><a href="https://blog.csdn.net/m0_37925202/article/details/80286946#commentBox">socket和tcp/udp网络中传输详解</a></p><p><a href="https://www.cnblogs.com/zgq0/p/8780893.html">进程间通信非常详细的博客</a></p><p><a href="https://blog.csdn.net/qq_38182963/article/list/2">tomcat详细解释-socket通信重点看三</a></p><p><a href="https://www.cnblogs.com/runtimeexception/p/10415821.html">nosql中的redis学习笔记</a></p><h3 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h3><ol><li><p>P地址、端口号……</p></li><li><p>socket API</p></li><li><p>实现UDP客户端/服务器</p></li><li><p>套接字<br>套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p></li></ol><h3 id="进程间通信（IPC）有很多种方式"><a href="#进程间通信（IPC）有很多种方式" class="headerlink" title="进程间通信（IPC）有很多种方式"></a>进程间通信（IPC）有很多种方式</h3><ol><li>管道（包括无名管道和命名管道）；</li><li>消息队列；</li><li>信号量；</li><li>共享存储。</li><li>……（ Socket和Streams支持不同主机上的两个进程IPC）。</li></ol><h3 id="认识网络层通信过程："><a href="#认识网络层通信过程：" class="headerlink" title="认识网络层通信过程："></a>认识网络层通信过程：</h3><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>system</title>
    <link href="http://example.com/posts/59942/"/>
    <id>http://example.com/posts/59942/</id>
    <published>2020-11-09T05:47:41.000Z</published>
    <updated>2020-11-13T13:24:57.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="请简述进程，线程及程序三者有什么区别"><a href="#请简述进程，线程及程序三者有什么区别" class="headerlink" title="请简述进程，线程及程序三者有什么区别?"></a>请简述进程，线程及程序三者有什么区别?</h4><p>程序: 是编译好的可执行的二进制文件．<br>程序运行起来后，进入内存中就变成了进程.</p><p>进程: 进程是程序在内存中的镜像，他是一个实例</p><p>包括：加载的二进制程序，虚拟内存，内核资源（打开的文件,关联的用户,<br>关联用户：再分配权限过程，会把程序和用户进行关联，就是哪个用户来把这个程序运行起来的．</p><p>线程: 是进程内的执行单元，<br>如果只有一个线程，就是一个主线程，也就是进程自己.<br>如果有多个线程的话每个线程都是一个执行单元．<br>线程也是操作系统调度器调度的最小单元.</p><p>进程和线程的异同之处?<br>相同: 都是为了增加程序的并发度.为了使功能更为丰富．而实现的.<br>不同:<br>阶段一 进程中有一个虚拟内存，线程中有一个虚拟处理器的东西．得到的结论，进程是独享存，线程是独享CPU.<br>阶段二<br>进程在运行的过程中独占内存，不会感觉到有内存的争抢．<br>线程在运行的时候就会感觉我独占cpu的核心.没有被挣抢．<br>阶段三<br>进程独占内存：所以进程通信是较为复杂的东西．<br>线程没有虚拟内存，所以说线程会共享整个进程空间的内容，或者说整个进程空间．这样产生的后果就是，线程间的通信会变得很方便．<br>阶段四<br>线程调度的代价是相对较小的,因为在进程空间上的内容是共享的，所以在切换线程的时候，内存空间的消耗比较小的．<br>cpu的消耗，比如两个线程都在用cpu的时候,在线程调度和上下文切换消耗也是很小的．</p><p>第五阶段<br>进程和线程的优势:<br>    多进程程序：他运行起来比较稳定，某个进程退出，不会导致其他进程退出．<br>    多进程编程适合并发度比较小的情况，比如就启动程序后就需要两个进程就可以，并且他们做自己独立的无相关活动的情况．<br>    与我们生活息息相关的进程就是守护进程，守护进程就得用多进程去实现，而不能用多线程，<br>    多线程：让编程变得跟简单，就比如把某个模块抽象化出来，就规定一个线程去实现．相互之间的通信比较简单的．</p><p>弊端：<br>多进程：比较复杂，调度的代价比较大．<br>多线程：</p><ol><li>调试及其不容易</li><li>线程安全问题：主要涉及到资源的竞争，（就是三个进程同时访问一个空间上的资源，如果不加上锁，就会产生资源竞争<br>就是即使加了锁，也会产生死锁问题）</li></ol><h4 id="请简述你所知道的fork-函数，以及再多进程编程中需要注意的事项"><a href="#请简述你所知道的fork-函数，以及再多进程编程中需要注意的事项" class="headerlink" title="请简述你所知道的fork()函数，以及再多进程编程中需要注意的事项"></a>请简述你所知道的fork()函数，以及再多进程编程中需要注意的事项</h4><p>函数问题三个考虑方向</p><ol><li><p>用途 : 克隆了一个父进程产生了一个子进程，基本上拷贝了父进程的进程空间，只进行了一个写拷贝（不会进行马上拷贝，而是发生了写操作的时候，才进行拷贝）．</p></li><li><p>函数原型：　无参数</p></li><li><p>函数返回值：是我们遇到的有多个返回值的函数，可能的三个返回值<br>(1): 在子进程中返回的是零<br>(2): 在父进程中返回的是子进程的pid;<br>在子进程中获得父进程的pid 就是getppid(),获得自己的pid就是getpid();<br>在父进程没办法获取子进程的pid只能通过返回值的形式给他．<br>为什么会不能返回呢？<br>因为fork()之后，子进程就是一个独立的内存空间了，父进程失去了对它的控制．<br>(3): 在系统编程或者io操作上，返回-1有明显的含义的，表示出错了，fork()函数不能出现参数出错的情况，只能是</p></li><li><p>存在问题</p></li></ol><p>第一个问题：<br>比如 简单举个例子<br>for(int i = 0; i != 10; i++){<br>    fork();<br>}<br>这样是产生不了10个子进程的．或者说fork第一次就会产生一个子进程，再执行到for循环的时候，就会是父子进程都执行到了下次变成了四个子进程以此类推．所以说产生不了我们想要的十个子进程，只有判断进程的pid</p><p>第二个问题：<br>比如fork()函数前边有一个printf(),函数没有输出回车(\n),fork就可能会把缓冲区的数据进行一下复制，这个子进程这时就会输出两次．</p><p>第三个问题：</p><p>会引起孤儿进程或者是僵尸进程，<br>僵尸进程：　子进程先于父进程死了，父进程不给他收尸，就会产生僵尸进程．<br>孤儿进程：　子进程活着父进程死了，就会产生孤儿进程．孤儿进程会被一号进程收养．<br>僵尸进程不会被一号进程收养是因为他的父进程还存在，所以不会归到一号进程．<br>僵尸进程的危害: 占用pid,进程控制器pcb还在，变相的占用了系统资源</p><p>孤儿进程的好处: 在父进程生成子进程之后，父进程就没有事情做了，然后自己退出，留下子进程被一号进程收养，就是所说的后台进程或者是守护进程的实现方式．</p><h4 id="请回答-进程有哪些状态-他们是如何进行切换的"><a href="#请回答-进程有哪些状态-他们是如何进行切换的" class="headerlink" title="请回答: 进程有哪些状态,他们是如何进行切换的?"></a>请回答: 进程有哪些状态,他们是如何进行切换的?</h4><p>三态模型和无态模型<br>三态：</p><ol><li>ready就绪态</li><li>running运行态</li><li>block阻塞态</li></ol><p>状态执行顺序<br>1-&gt;2-&gt;3<br>2-&gt;1 </p><p>就绪态和运行态是可以两个切换的<br>ready状态可以转换成running状态<br>就比如while(1){}他不会进行io等待也不会涉及到阻塞．<br>那么什么时候结束呢：进程调度器分配的cpu时间片耗尽了，就会回到ready状态.</p><p>running到block状态<br>阻塞主要是io等待，比如输入信息(cin 或者scanf).<br>有io等待的时候就会从运行态转变为block态，等待输入结束后到达ready.下次调度的时候才会被执行．</p><p>###</p><h4 id="请你对用户态-内核态以及系统调用这三个概念做出解释"><a href="#请你对用户态-内核态以及系统调用这三个概念做出解释" class="headerlink" title="请你对用户态,内核态以及系统调用这三个概念做出解释"></a>请你对用户态,内核态以及系统调用这三个概念做出解释</h4><h5 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h5><p>特权级</p><ol><li>对于X86架构的CPU硬件上有0-3四个特权级包括了特权指令和非特权指令</li><li>在Unix/linux系统中,只使用了0和3特权级．<h5 id="两者差别"><a href="#两者差别" class="headerlink" title="两者差别"></a>两者差别</h5></li><li>用户态</li><li>内核态</li><li>特权不同</li><li>处理器是否可被抢占</li></ol><h5 id="相互切换"><a href="#相互切换" class="headerlink" title="相互切换"></a>相互切换</h5><ol><li>有用户态到内核态<br>　以下三种本质上都是中断机制<ol><li>中断 </li><li>异常</li><li>系统调用(陷入)</li></ol></li><li>由内核态到用户态<ol><li>设置程序状态字 </li></ol></li></ol><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><ol><li>为了使上层应用能够访问到硬件资源，内存为上层应用提供了接口</li><li>是用户态主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作完成工作</li><li>包括<ol><li>进程控制</li><li>进程通信</li><li>文件操作</li><li>设备操作等</li></ol></li></ol><h4 id="线程同步是干什么的，线程同步有那些机制"><a href="#线程同步是干什么的，线程同步有那些机制" class="headerlink" title="线程同步是干什么的，线程同步有那些机制?"></a>线程同步是干什么的，线程同步有那些机制?</h4><p>线程同步的主要手段就是互斥.</p><ol><li>相关名词<ol><li>临界区</li><li>原子性</li><li>竞争</li><li>互斥</li></ol></li><li>为什么要有线程同步<br>　　线程安全性．</li><li>线程同步实现机制<ol><li>临界区<br>控制多线程执行某一段代码的顺序．<br>使可能并发的线程，让其一个一个串行化去执行的．</li><li>互斥量 互斥锁就是这种机制，当一个线程拥有这个对象的时候，其他线程就没办法拥有．只有拥有这个对象的人才能够执行这个操作．</li><li>信号量<br>信号量和互斥量不同的地方就是，信号量允许多个线程同时访问某个资源，就比如一个数据可以让五个线程访问，别的不可以．</li><li>事件<br>当内核感知到事件发生的时候，操作系统通知线程去做什么，这个叫事件．</li></ol></li></ol><h4 id="内核线程和用户线程有什么区别"><a href="#内核线程和用户线程有什么区别" class="headerlink" title="内核线程和用户线程有什么区别?"></a>内核线程和用户线程有什么区别?</h4><p>分类原则:<br>根据操作系统是否能感知到线程的存在分为</p><ol><li><p>用户线程:操作系统感知不到的线程</p></li><li><p>内核线程:操作系统能感知到的线程</p></li></ol><p>早期的操作系统没有线程只有进程，因为进程的创建上下文创建销毁的成本代价太高，所以说能不能有一个轻量级的，所以说有了线程的概念，最开始操作系统的内核没办法提供线程的支持的，线程是一些库提供用户层面的支持，所以说在创建一个线程，操作系统感知不到线程的存在的，再发展，操作系统的内核就渐渐的支持线程操作．后来线程由内核提供一下调用的接口，最后可以通过用户调用来创建一些线程，这个时候的线程对内核来说是可见的，内核可以看到这个线程，就是内核线程．</p><p>优缺点对比:</p><ol><li>用户态线程：<br>可以在不支持多线程的机器上实现多线程<br>在自己的线程空间里，自己调度销毁切换，所以相对来说，是比较灵活的，但是他有一个致命的缺点，内核不知道他的存在．只能感知到一个进程的存在，只要发生一个线程阻塞，操作系统就不会继续调度这个进程里边的其他线程，因为他只感知到当前进程处于阻塞状态．直到他重新处于就绪态的时候．他才可以调度其他线程.　</li><li>内核态线程<br>　由内核线程是由内核创建销毁切换的，所以说对于内核线程来说，每一个操作系统内核都知道这个线程的存在，所以说它的调度都是以这些线程为基本单位的，每一个进程里边如果有多个线程的话，操作系统会根据每个线程的状态（就绪，阻塞，运行等状态），来选择是否要调度他．真正意义上实现了并发不是用户写的．并且也不会因为一个线程阻塞导致整个进程的阻塞．<br>　由于线程在内核态，可以使用整个系统内能进行资源的竞争，也相当于对资源的有效利用提高了．<br>　每一个线程都支持一个线程控制块tcp,内核根据该控制块感知线程的存在，并进行控制．在一定程度上相当于进程．跟进程一样创建销毁操作，但是他是一种轻量级的．总的来说，是内核线程提供了一个轻量级的类似于进程的调度．</li></ol><p>linux的线程是什么线程?(加分项)</p><p>多线程模型</p><ol><li>多对一：多个线程对应一个线程．早期内核里一个线程（进程）在用户层面实现了多个线程，这就叫多对一模型．</li><li>一对一：这就是当前linux系统下多线程的主要方式，每一个用户创建的线程都对应着一个内核线程，所以说在内核层面就能感知到线程的存在，然后进行更为精细的调度．</li><li>多对多：对一种和二种方式进行混合，</li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>algorithm</title>
    <link href="http://example.com/posts/54839/"/>
    <id>http://example.com/posts/54839/</id>
    <published>2020-11-08T11:59:08.000Z</published>
    <updated>2020-11-13T13:24:57.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程"><a href="#如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程" class="headerlink" title="如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程"></a>如何判断链表有环，求环的长度以及找到环的起始位置，简述算法过程</h4><p>leedcode 中happy number,不是用链表但是用的是一个思想.</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="如果现在有k个有序数组-如何合并成一个有序数组"><a href="#如果现在有k个有序数组-如何合并成一个有序数组" class="headerlink" title="如果现在有k个有序数组,如何合并成一个有序数组"></a>如果现在有k个有序数组,如何合并成一个有序数组</h4><p>k路归并排序:</p><h4 id="请具体说明，为什么归并排序适合处理大数据排序情况"><a href="#请具体说明，为什么归并排序适合处理大数据排序情况" class="headerlink" title="请具体说明，为什么归并排序适合处理大数据排序情况"></a>请具体说明，为什么归并排序适合处理大数据排序情况</h4><p>如果现在有40g的外部文件，而内存只有2g,如何进行文件的排序操作，这种情况就需要对40g的内存进行划分,划分成20份2g的文件，通过内存排序算法对这20个文件进行排序，然后进行多路归并排序(外存排序算法).</p><p>其中二路归并排序是多路归并排序中的一种.</p><p>特点:　对内存要求很少而且大部分操作是在外存中进行的.</p><h4 id="如何快速的输出无序数组中前k大的值-请说明你的方法-并分析时间复杂度．"><a href="#如何快速的输出无序数组中前k大的值-请说明你的方法-并分析时间复杂度．" class="headerlink" title="如何快速的输出无序数组中前k大的值,请说明你的方法,并分析时间复杂度．"></a>如何快速的输出无序数组中前k大的值,请说明你的方法,并分析时间复杂度．</h4><ol><li>最差的方法: 选择排序(从未排序区选出最大或最小的元素进行插入已排序区尾部)，进而能选出第几大的值．</li><li>维护一个大小为k的大根堆(nlogk)<br>把带插入元素依次性的插入大根堆．</li><li>维护一个小根堆<br>参考堆排序和线性建堆法的过程<br>首先把数组用线性建堆法简历一个小根堆，建堆的时间复杂度O(n)<br>小根堆的时间复杂度是logn,弹出k次,所以总的时间复杂度为n + klogn;</li><li>BFPRT算法<br>基于快速选择算法<br>快速选择算法的影响因素主要是，基准值的选取能否尽可能的平分数组元素．<br>一条性质找到第ｋ位的元素,左边的元素都比ｋ小．</li></ol><p>如果数据量比较大(n或者k比较大)(大数据情况)<br>参考多路归并排序的过程</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h4 id="假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值"><a href="#假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值" class="headerlink" title="假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值"></a>假设有一个不知道多长的数字序列，如何等概率的从里面抽取100个值</h4><ol><li><p>蓄水池抽样<br>假设已经从n个元素中抽取了k个元素，概率为(k/n).<br>假设蓄水池中k个元素a1,a2,a3,….ak.<br>当a(n+1)个元素进来的时候，就会1到(n - 1)中随机一个数值，这个值如果小于等于k的时候，把a(n + 1)替换掉该位置．如果大于k的话,a(n + 1)这个值就不保留．</p></li><li><p>应用场景<br>如果是说大数据场景下的采样问题．大数据场景一般是确定数据大小的情况下．<br>而蓄水池抽样说的是一个为止大小的序列.<br>确切的说应用场景是数据流采样问题,<br>数据流采样问题: 一个请求发送给服务器VPN,然后服务器进行转发达到翻墙的目的.服务器想对所有数据进行等概率采样，</p></li></ol><h4 id="要求设计一个函数-运行100次-非顺序的输出1–100内所有数字，要求，不能使用数组．"><a href="#要求设计一个函数-运行100次-非顺序的输出1–100内所有数字，要求，不能使用数组．" class="headerlink" title="要求设计一个函数,运行100次,非顺序的输出1–100内所有数字，要求，不能使用数组．"></a>要求设计一个函数,运行100次,非顺序的输出1–100内所有数字，要求，不能使用数组．</h4><ol><li><p>使用链表:<br>一百个链表中存取100个数值，然后随机删除节点，来达到随机的目的.</p></li><li><p>线性同余法:<br> 用一个线性同余式进行不断地计算<br> 剩余系:就比如　(4^k) % 7 当ｋ取值1,2,3,4对应值为4,3,1,4出现了循环<br> 就表示该公式的剩余系为4,2,1.<br> 能满足条件的(3xk%101)</p></li><li><p>扩展知识: </p></li></ol><p>要求设计一个函数,运行k次,非顺序的输出1–k内所有数字，要求，不能使用数组</p><ol><li>欧拉定理</li><li>欧拉函数</li></ol><h4 id="简述语言的随机函数原理"><a href="#简述语言的随机函数原理" class="headerlink" title="简述语言的随机函数原理"></a>简述语言的随机函数原理</h4><ol><li><p>c语言中的应用<br>第一步：srand 设置随机种子<br>第二部：rand获取随机种子</p></li><li><p>原理介绍</p></li></ol><p>首先:真随机和伪随机的区别</p><p>其次:线性同余法(计算机中使用的方法)</p><p>最后:为什么设置随机种子<br>就是为了在随机序列上找到一个起始点，如果没有起始点的话，我们的程序就会在一个固定的地方运行，产生的随机数是一样的．<br>如果随机种子一样产生的值也是一样的，只能用时间这个一直在变的量，来进行设定．</p><p>### 　</p><h4 id="一个长度为n的数组-只有一个数字出现了一次，其与数字均出现了2次-请找到出现1次的这个数字"><a href="#一个长度为n的数组-只有一个数字出现了一次，其与数字均出现了2次-请找到出现1次的这个数字" class="headerlink" title="一个长度为n的数组,只有一个数字出现了一次，其与数字均出现了2次,请找到出现1次的这个数字."></a>一个长度为n的数组,只有一个数字出现了一次，其与数字均出现了2次,请找到出现1次的这个数字.</h4><ol><li>异或运算的性质<br>第一: 满足交换率<br>第二: 满足结合率<br>本质是统计相应二进制的奇偶性的</li></ol><ol start="2"><li>解题方法</li></ol><p>一次进行异或操作，相同数字异或为零，最后找到．</p><ol start="3"><li>拓展问题</li></ol><p>有两个数字出现一次．</p><h4 id="一个长度为n的数组，其中的数值范围是1–n-已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度-要求时间复杂度O-n-空间复杂度O-1"><a href="#一个长度为n的数组，其中的数值范围是1–n-已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度-要求时间复杂度O-n-空间复杂度O-1" class="headerlink" title="一个长度为n的数组，其中的数值范围是1–n,已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度.要求时间复杂度O(n),空间复杂度O(1)."></a>一个长度为n的数组，其中的数值范围是1–n,已知只有一个数出现了2次，其与数字都只出现了一次，如何找到这个出现了2次的数字，分析你方法的时间复杂度.要求时间复杂度O(n),空间复杂度O(1).</h4><p>n的数组，和数值范围是1–n，就用数组下标来表示对应位数，如果下标为1值为5,就让第一位和第五位数进行对调，看看第一位是不是五，如果是就找到了，如果不是接着对调．</p><h4 id="一个长度为n的数组-已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．"><a href="#一个长度为n的数组-已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．" class="headerlink" title="一个长度为n的数组,　已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．"></a>一个长度为n的数组,　已知只有一个数字出现了2次，其余数字都只出现了1次，如何找到这个出现了2次的数字，分析你方法的时间复杂度．</h4><p>第一类方法: 排序方法</p><ol><li><p>基数排序(raddix_sort)<br>时间复杂度O(n),常数的空间复杂度但常数较大.</p></li><li><p>其余排序(快排,堆排)</p></li></ol><p>空间复杂度O(nlogn)<br>空间复杂度O(1)</p><p>第二类方法: 哈希表</p><p>时间复杂度:O(n)<br>空间复杂度:O(n)</p><p>方法比较:</p><pre><code>具体场景分析：比如计算资源短缺，选时间复杂度小的，存储空间短缺，选空间复杂度小的.如果其中一个两个都优于另一个，直接舍去第二种．</code></pre><p>###　</p><h4 id="已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-2-请设计算法找到这个数字．"><a href="#已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-2-请设计算法找到这个数字．" class="headerlink" title="已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/2),请设计算法找到这个数字．"></a>已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/2),请设计算法找到这个数字．</h4><p>超过(n/2)的数称为关键元素.</p><p>代码实现:<br>    随机取出一个数值，进行比对，等于加1,不等就减1.</p><h4 id="已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-k-请设计算法找到这个数字．"><a href="#已知在一个有n个整数的数组中，数量最多的一个数字超过了-n-k-请设计算法找到这个数字．" class="headerlink" title="已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/k),请设计算法找到这个数字．"></a>已知在一个有n个整数的数组中，数量最多的一个数字超过了(n/k),请设计算法找到这个数字．</h4><p>摩尔投票法:<br>    记录k-1个数字，及次数.<br>    k个数字来的时候,如果与之前元素不同就说明找到了ｋ个元素，<br>    用一个集合，有相同数加1, </p><p>代码实现:</p><h4 id="在一个数组中，大多数数字都出现3次-只有一个数字出现次数不足3次，请设计算法找到这个数字．"><a href="#在一个数组中，大多数数字都出现3次-只有一个数字出现次数不足3次，请设计算法找到这个数字．" class="headerlink" title="在一个数组中，大多数数字都出现3次,只有一个数字出现次数不足3次，请设计算法找到这个数字．"></a>在一个数组中，大多数数字都出现3次,只有一个数字出现次数不足3次，请设计算法找到这个数字．</h4><ol><li>二进制位统计法:<br> 统计每一个二进制列上的1出现的次数是不是三的倍数,如果是则都是，如果有就说明不是出现了三次.</li></ol><ol start="2"><li>状态转换表:<br> 本质和前边一样的，<br>重新梳理</li></ol><p>###</p><h4 id="如何设计一个支持min操作的栈，min函数返回当前栈中的最小值-要求min-push-pop-操作时间复杂度都是O-1-函数如何设计"><a href="#如何设计一个支持min操作的栈，min函数返回当前栈中的最小值-要求min-push-pop-操作时间复杂度都是O-1-函数如何设计" class="headerlink" title="如何设计一个支持min操作的栈，min函数返回当前栈中的最小值,要求min,push,pop()操作时间复杂度都是O(1),函数如何设计."></a>如何设计一个支持min操作的栈，min函数返回当前栈中的最小值,要求min,push,pop()操作时间复杂度都是O(1),函数如何设计.</h4><h4 id="有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O-n"><a href="#有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O-n" class="headerlink" title="有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O(n);"></a>有一个不包含重复元素的数组，如何快速的找到连续的k个位置，使得这K个位置上面的数字排序以后在数值上也是连续的．要求算法时间复杂度为O(n);</h4><p>维护一个窗口为K的窗口,这K个序列用两个优先队列维护，一个维护最大MAX_N,一个维护最下MIN_N,MAX_N - MIN_N = k - 1 这样的条件.</p><h4 id="给定k值-如果找到链表的倒数第k个元素-一个指针怎么做-两个指针怎么做"><a href="#给定k值-如果找到链表的倒数第k个元素-一个指针怎么做-两个指针怎么做" class="headerlink" title="给定k值,如果找到链表的倒数第ｋ个元素,一个指针怎么做?两个指针怎么做?"></a>给定k值,如果找到链表的倒数第ｋ个元素,一个指针怎么做?两个指针怎么做?</h4><p>第一种做法: 一个指针,跑两次</p><p>一个指针先找到链表的长度，再算出该数在第几位．</p><p>第二种做法: 两个指针,跑一次<br>让两个指针之间的距离控制在ｋ，两个指针一起往后走，当后边指针指向为空时，前指针就是倒数第k位的数.走的步数是一样的.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql2</title>
    <link href="http://example.com/posts/15731/"/>
    <id>http://example.com/posts/15731/</id>
    <published>2020-10-31T07:56:33.000Z</published>
    <updated>2020-11-01T07:02:52.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库高级" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="http://example.com/posts/16097/"/>
    <id>http://example.com/posts/16097/</id>
    <published>2020-10-27T05:25:31.000Z</published>
    <updated>2020-11-01T13:09:31.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/203622688">大佬笔记入口</a><br><a href="https://www.nowcoder.com/discuss/389444">同上</a></p><h3 id="mysql的逻辑架构"><a href="#mysql的逻辑架构" class="headerlink" title="mysql的逻辑架构"></a>mysql的逻辑架构</h3><h3 id="数据库两个操作系统文件"><a href="#数据库两个操作系统文件" class="headerlink" title="数据库两个操作系统文件"></a>数据库两个操作系统文件</h3><p>每个 SQL Server 2005 数据库至少具有两个操作系统文件：<br>一个数据文件和一个日志文件。</p><ol><li>数据文件包含数据和对象，例容如表、索引、存储过程和视图。</li><li>日志文件包含恢复数据库中的所有事务所需的信息。为了便于分配和管理，可以将数据文件集合起来，放到文件组中。<br>主要数据文件包含数据库的启动信息，并指向数据库中的其他文件。用户数据和对象可存储在此文件中，也可以存储在次要数据文件中。每个数据库有一个主要数据文件。主要数据文件的建议文件扩展名是 .mdf。<br>事务日志文件保存用于恢复数据库的日志信息。每个数据库必须至少有一个日志文件。事务日志的建议文件扩展名是 .ldf。</li></ol><h3 id="1-事务四大特性"><a href="#1-事务四大特性" class="headerlink" title="1.事务四大特性"></a>1.事务四大特性</h3><p>事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</p><ol><li><p>原子性:<br>最小的执行单元： 要么全执行，要么全不执行</p></li><li><p>隔离性：<br>所有操作全部执行完以前其它会话不能看到过程</p></li><li><p>一致性：<br>事务前后，数据总额一致</p></li><li><p>持久性:<br> 一旦事务提交，对数据的改变就是永久的</p></li></ol><h3 id="隔离操作"><a href="#隔离操作" class="headerlink" title="隔离操作"></a>隔离操作</h3><h4 id="并行事物的四大问题"><a href="#并行事物的四大问题" class="headerlink" title="并行事物的四大问题"></a>并行事物的四大问题</h4><ol><li>更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）</li><li>脏读：读到别的事务未提交的数据。（万一回滚，数据就是脏的无效的了）</li><li>不可重复读：两次读之间有别的事务修改。</li><li>幻读：两次读之间有别的事务增删。</li></ol><h4 id="对应隔离级别"><a href="#对应隔离级别" class="headerlink" title="对应隔离级别"></a>对应隔离级别</h4><ol><li><p>READ UNCOMMITTED：读未提交，不处理。</p></li><li><p>READ COMMITTED：读已提交，只读提交的数据，无脏读；</p></li><li><p>REPEATABLE READ：可重复读，加行锁，两次读之间不会有修改，无脏读无重复读；</p></li><li><p>SERIALIZABLE: 串行化，加表锁，全部串行，无所有问题。<br>详细解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. READ UNCIMMITTED（未提交读）</span><br><span class="line">　　      事务还没提交，而别的事务可以看到他其中修改的数据的后果，也就是脏读。</span><br><span class="line"></span><br><span class="line">2. READ COMMITTED（提交读）</span><br><span class="line">　　      首先大多数数据库系统的默认隔离级别是READ COMMITTED，这种隔离级别就是一个事务的开始，只能看到已经完成的事务的结果，正在执行的，是无法被其他事务看到的。这种级别会出现读取旧数据的现象</span><br><span class="line"></span><br><span class="line">3. REPEATABLE READ（可重复读）</span><br><span class="line"> 　　     REPEATABLE READ解决了脏读的问题，该级别保证了每行的记录的结果是一致的，也就是上面说的读了旧数据的问题，但是却无法解决另一个问题，幻行，顾名思义就是突然蹦出来的行数据。</span><br><span class="line">          指的就是某个事务在读取某个范围的数据，但是另一个事务又向这个范围的数据去插入数据，导致多次读取的时候，数据的行数不一致。</span><br><span class="line"></span><br><span class="line">4. SERIALIZABLE（可串行化）</span><br><span class="line">          　　      SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行（注意是串行），避免了前面的幻读情况，由于他大量加上锁，导致大量的请求超时，</span><br><span class="line">                   因此性能会比较低下，在需要数据一致性且并发量不需要那么大的时候才可能考虑这个隔离级别。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四中隔离原理"><a href="#四中隔离原理" class="headerlink" title="四中隔离原理"></a>四中隔离原理</h4></li><li><p>READ_UNCOMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据不加锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。</span><br><span class="line">下面分别对应上面1，2产生的表现：</span><br><span class="line"></span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本，即使该修改尚未被提交。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p>READ_COMMITED 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的只能是事务2对其更新前的版本，要不就是事务2提交后的版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>REPEATABLE READ 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1，事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；</span><br><span class="line">2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1读取某行记录时，事务2也能对这行记录进行读取、更新；当事务2对该记录进行更新时，事务1再次读取该记录，读到的仍然是第一次读取的那个版本。</span><br><span class="line">2，事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SERIALIZABLE 的原理:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</span><br><span class="line">2，事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</span><br><span class="line"></span><br><span class="line">表现</span><br><span class="line">1，事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line">2，事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="数据库涉及的锁"><a href="#数据库涉及的锁" class="headerlink" title="数据库涉及的锁"></a>数据库涉及的锁</h4><p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，<br>MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）。<br>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。<br>所有的锁都是绑定在数据库的索引机制上的！！！</p><p>首先锁可以分为： </p><ol><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ol><p>而除了粒度，锁根据模式分为：</p><ol><li><p>共享锁(S)：发生在数据查找之前，多个事务的共享锁之间可以共存</p></li><li><p>排他锁(X)：发生在数据更新之前，排他锁是一个独占锁，与其他锁都不兼容</p></li><li><p>更新锁(U)：发生在更新语句中，更新锁用来查找数据，当查找的数据不是要更新的数据时转化为S锁，当是要更新的数据时转化为X锁</p></li><li><p>意向锁：发生在较低粒度级别的资源获取之前，表示对该资源下低粒度的资源添加对应的锁，意向锁有分为：<br>　　　　意向共享锁(IS) ，意向排他锁(IX)，意向更新锁(IU)，共享意向排他锁(SIX)，共享意向更新锁(SIU)，更新意向排他锁(UIX)</p></li></ol><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><ol><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ol><p>共享锁／排他锁／更新锁一般作用在较低级别上，例如数据行或数据页，意向锁一般作用在较高的级别上，例如数据表或数据。锁是有层级结构的，若在数据行上持有排他锁的时候，则会在所在的数据页上持有意向排他锁. 在一个事务中，可能由于锁持有的时间太长或个数太多，出于节约资源的考虑，会造成锁升级；</p><p>我理解的就以最后一个SERIALIZABLE来说，开始时是设置的表级共享锁，分为表级别的而且是共享锁，表级别就是作用于整个表，不是行级别！而共享锁，则说明了其他事务也是共享锁的情况下可以共享这个表！虽然仅限于读，但这样也可能存在脏读等情况的存在，而如果换成表级排它锁，那么第一个事务在使用了这个锁之后，那其他事务连这个表的读的权限也没有，从根本上避免了各种可能的问题。</p><h5 id="各个索引引擎的情况"><a href="#各个索引引擎的情况" class="headerlink" title="各个索引引擎的情况"></a>各个索引引擎的情况</h5><ol><li><p>InnoDB（MySQL默认存储引擎 从版本5.5.5开始）<br>支持事务，行级锁，以及外键，拥有高并发处理能力。但是在创建索引和加载数据时，比MyISAM慢。默认的隔离级别是Repeatable Read（可重复读）</p></li><li><p>MyISAM<br>不支持事务和行级锁。所以速度很快，性能优秀。可以对整张表加锁，支持并发插入，支持全文索引。</p></li><li><p>MEMORY<br>支持Hash索引，内存表，Memory引擎将数据存储在内存中，表结构不是存储在内存中的，查询时不需要执行磁盘I/O操作，所以要比MyISAM和InnoDB快很多倍，<br>但是数据库断电或是重启后，表中的数据将会丢失，表结构不会丢失。</p></li></ol><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h4><p>在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，乐观锁和悲观锁，可以在一定程度上解决并发访问。</p><h4 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h4><p>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>其他知识点</p><p>悲观锁主要是共享锁或排他锁<br>共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。<br>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><h4 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h4><p>是应用系统层面和数据的业务逻辑层次上的（实际上并没有加锁，只是一种锁思想），利用程序处理并发， 它假定当某一个用户去读取某一个数据的时候，其他的用户不会来访问修改这个数据，但是在最后进行事务的提交的时候会进行数据的检查，以判断在该用户的操作过程中，没有其他用户修改了这个数据。乐观锁的实现大部分都是基于版本控制实现的， 除此之外，还有CAS操作实现</p><p>其他知识点</p><p>实现乐观锁一般来说有以下2种方式：</p><p>使用版本号<br>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><p>使用时间戳<br>乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</p><h4 id="悲观锁与乐观锁区别与联系？"><a href="#悲观锁与乐观锁区别与联系？" class="headerlink" title="悲观锁与乐观锁区别与联系？"></a>悲观锁与乐观锁区别与联系？</h4><h4 id="悲观锁与乐观锁的使用场景？"><a href="#悲观锁与乐观锁的使用场景？" class="headerlink" title="悲观锁与乐观锁的使用场景？"></a>悲观锁与乐观锁的使用场景？</h4><p>悲观锁</p><p>比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p><p>乐观锁</p><p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p><h3 id="innodbe-和-myisim掌握"><a href="#innodbe-和-myisim掌握" class="headerlink" title="innodbe 和 myisim掌握"></a>innodbe 和 myisim掌握</h3><h3 id="三个特性-双次写，插入缓存，自适应"><a href="#三个特性-双次写，插入缓存，自适应" class="headerlink" title="三个特性(双次写，插入缓存，自适应)"></a>三个特性(双次写，插入缓存，自适应)</h3><p>InnoDB存储引擎的关键特性包括插入缓冲、两次写（double write）、自适应哈希索引（adaptive hash index）。这些特性为InnoDB存储引擎带来了更好的性能和更高的可靠性。</p><p><a href="https://blog.csdn.net/ilovemilk/article/details/80024789">详细解释跳转</a></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程并发访问某一资源的机制。</p><h4 id="mvcc-乐观锁，悲观锁"><a href="#mvcc-乐观锁，悲观锁" class="headerlink" title="mvcc(乐观锁，悲观锁)"></a>mvcc(乐观锁，悲观锁)</h4><p>mvcc主要是为了提高并发读写性能，不用枷锁就能让多个事务并发读写．</p><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol><li>从对数据操作的类型（读/写）分<br>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li><li>从对数据操作的粒度分<br>表锁<br>行锁<h4 id="行锁-行锁，零件锁，间隙锁"><a href="#行锁-行锁，零件锁，间隙锁" class="headerlink" title="行锁(行锁，零件锁，间隙锁)"></a>行锁(行锁，零件锁，间隙锁)</h4></li></ol><p>nnodb存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。<br>Innodb与MyISAM的最大不同有两点：</p><ol><li>一是支持事务（TRANSACTION）</li><li>而是采用了行级锁</li></ol><p>由于行锁支持事务，复习老知识</p><p>事务（Transaction）及其ACID属性不可分</p><h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><ol><li><p>更新丢失（Lost Update）:<br> 当两个或多个事物选择同一行，然后基于最初选定的值更新该行时，由于每个事物都不知道其事物的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事物所做的更新．<br> 如果一个程序员完成并提交事物之前，另一个程序员不能访问同一文件，则可避免此问题.</p></li><li><p>脏读<br>一个事物正对一条记录做修改，在这个事物完成并提交前，这条记录的数据就处于不一致状态，这时，另一个事物也来读取同一条记录，如果不加控制，第二个事务读取了这些”脏”数据，并据此作进一步处理，就会产生未提交的数据依赖关系．</p></li><li><p>不可重复读<br>一个事物在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变，或某些记录已经被删除了！这种现象就叫做”不可重复读”．<br>　简而言之:事物ａ读取到了事物b已经提交的修改数据，不符合隔离性．</p></li><li><p>幻读<br>一个事物按相同的查询条件重新读取以前检索过的数据，却发现其他书屋插入了满足其查询条件的新数据，这种成为”幻读”．</p></li></ol><p>简而言之:事物ａ读取到了事物ｂ提交的新增数据，不符合隔离性．</p><p>注意：<br>脏读和幻读有些类似</p><ol><li>脏读是事物b里修改了数据.</li><li>幻读是事物b里边新增了数据.</li></ol><h5 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h5><p>脏读，不可重复读和幻读，其实都是数据库一致性问题，必须由数据库提供一定的事物隔离机制来解决．</p><p>四种解决方案</p><p>读数据一致性及允许的并发副作用隔离级别　　　　　　读数据一致性　　　　　　　　脏读　　不可重复读　　幻读　<br>未提交读　　　　　　　　　　　　最低级别，只能保证不读取物理上损坏的数据　　　　Ｙ　　　Ｙ　　　　　　Ｙ<br>已提交读　　　　　　　　　　　　　　　　　　　　语句级　　　　　　　　　　　　　Ｎ　　　Ｙ　　　　　　Ｙ<br>可重复读　　　　　　　　　　　　　　　　　　　　事物级　　　　　　　　　　　　　Ｎ　　　Ｎ　　　　　　Ｙ<br>可序列化　　　　　　　　　　　　　　　　　　最高级别，事物级　　　　　　　　　　Ｎ　　　Ｎ　　　　　　Ｎ</p><p>所以说数据库的事物隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是时事物在一定程度上”串行化进行”，这显然与”并发是矛盾的”，同时，不同的应用对对一致性和事物隔离程度的要求也是不同的，比如许多应用对”不可重复读”和幻读”并不敏感”，可能更关心数据并发访问的能力．<br>常看当前数据库的事物隔离级别: show variables like ‘tx_isolation’;</p><h5 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h5><p>如果在更新数据的时候出现了强制类型转换导致索引失效，使得行锁变表锁，即在操作不同行的时候，会出现阻塞的现象。</p><h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p>什么是间隙锁：<br>当我们用范围条件而不是相等条件索引数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。<br>危害：<br>因为Query执行过程中通过范围查找的话，会锁定整个范围内所有的索引键值，即使这个键值并不存在。<br>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p><p>结论</p><ol><li>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。</li><li>但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能更差。</li></ol><h5 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h5><p>如何分析行锁定</p><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><p>show status like ‘innodb_row_lock%’;<br>对各个状态量的说明如下：</p><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量；<br>innodb_row_lock_time：从系统启动到现在锁定总时间长度；<br>innodb_row_lock_time_avg：每次等待所花平均时间；<br>innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间；<br>innodb_row_lock_waits：系统启动后到现在总共等待的次数。<br>对于这5个变量，比较重要的是</p><p>innodb_row_lock_time_avg（等待平均时长）<br>innodb_row_lock_waits（等待总次数）<br>innodb_row_lock_time（等待总时长）<br>这三项<br>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><p>优化建议</p><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。<br>合理设计索引，尽量缩小锁的范围。<br>尽可能减少索引条件，避免间隙锁。<br>尽量控制事务大小，减少锁定资源量和时间长度。<br>尽可能低级别事务隔离</p><h4 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h4><ol><li>开销和加锁时间介于表锁和行锁之间。</li><li>会出现死锁。</li><li>锁定粒度介于表锁和行锁之间。</li><li>并发度一般</li></ol><h4 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h4><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><ol><li>手动增加表锁:</li></ol><p>lock table 表名字 read(write), 表名字2 read(write), 其他;<br>2. 查看表上加过的锁<br>show open tables;<br>3. 释放表锁</p><p>unlock tables;<br>4. 加读锁（我们为mylock表加read锁（读阻塞写例子））</p><ol start="5"><li>加写锁（我们为mylock表加write锁（MyISAM存储引擎的写阻塞读例子））</li></ol><p>案例结论</p><p>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是帮助MySQl高效获取数据的排好序的数据结构.</p><h4 id="数据结构（B-树，B树，Hash索引，全文本索引）"><a href="#数据结构（B-树，B树，Hash索引，全文本索引）" class="headerlink" title="数据结构（B+树，B树，Hash索引，全文本索引）"></a>数据结构（B+树，B树，Hash索引，全文本索引）</h4><p>二叉树索引的弊端：如果是序列有序(索引key 值)，就变成线性查找了．比如1,2,3,4,5,6,要查找6则需要搜索六次.</p><p>红黑树索引的弊端: 数据量过大索引次数过多(过多的磁盘io不能被接受)，虽然是一种平衡状态，比二叉树更优越，但是不能够被广泛使用.</p><p>由于树的高度限制了查询的效率</p><p>进而想到的解决办法：纵向不能伸长，就横向扩张．</p><p>进而B-tree就产生了：</p><p>B-tree很难进行范围查找，没有小箭头，而且值的分布不是都在叶子节点，需要每次查找等操作．<br>还有一个就是</p><p>然而数据库的底层用的是我们曾经写过的B+Tree<br>细节讲解：</p><p>为什么每个节点的成员个数有限?<br>因为在查询的到节点，进行磁盘IO,会把该节点的数据写入ARM中,在磁盘中的查找速度非常快，跟磁盘IO时间比较可以忽略不计，但是ARM存储空间毕竟是有限的，MySql中设置的16kb<br>数据库中存储值为bigint为8b后边的指针为6b, 16kb/(8+6)b 大概是1170个索引.<br>叶子节点data是地址，假设比加大给1kb的存储空间.一个叶子节点大概16个元素.<br>那么高度为三的树能容纳 1170 * 1170 * 16 大概2100多万．<br>而且在数据库中根节点是长驻内存的，时间更快了.时间可忽略不计.</p><p>千万级数据表如何用索引快速查找？（上边即为答案）<br>b+Tree的树高可以的得到很好的控制，即使数据量很大，也能把树高维持在一个很小的数值．</p><p>b+tree:<br>    下边的小箭头就是为了支持范围查找的，是一个双向指针．解决了范围查找问题，</p><p>非叶子节点都不存data,只存储索引(冗余).可以放更多的索引，实现了等高的b-tree和<br>b+tree ,b+tree存储量非常可观．<br>就是都是三层b+tree 能存2100多万数据，b+tree就能存16<em>16</em>16 =4096个而已．</p><h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引　"></a>hash索引　</h4><p>select * from t where t.col = 2;</p><ol><li>先通过hash(2) =定位哈西散列值就是对应值的存储地址　MD5或crc16/32就是hash散列算法.</li></ol><p>hash 是不是就是说比B+tree的查找速率高呢？</p><p>单个值的查找是很快的，但是范围查找就崩了，必须遍历查找．<br>2.<br>3. </p><h4 id="逻辑索引-主键，唯一，前缀，覆盖，联合，普通"><a href="#逻辑索引-主键，唯一，前缀，覆盖，联合，普通" class="headerlink" title="逻辑索引(主键，唯一，前缀，覆盖，联合，普通)"></a>逻辑索引(主键，唯一，前缀，覆盖，联合，普通)</h4><h4 id="存储结构-聚集索引-innodbe-排序索引-myisim"><a href="#存储结构-聚集索引-innodbe-排序索引-myisim" class="headerlink" title="存储结构(聚集索引(innodbe),排序索引(myisim))"></a>存储结构(聚集索引(innodbe),排序索引(myisim))</h4><h5 id="MyISAM存储索引实现"><a href="#MyISAM存储索引实现" class="headerlink" title="MyISAM存储索引实现"></a>MyISAM存储索引实现</h5><p>注意: 存储引擎是形容数据库表的不是形容数据库的．</p><p>数据中的表的数据存储位置：根目录的DATA目录.</p><ol><li>.frm文件:表的定义和结构信息.</li><li>.MYD文件:MyISAM-date 存储的数据</li><li>.MYI文件:MyISAM-index 表的索引信息.<br>举例子：<br>select * from T  where coll = 30 ;<br>先判断数据coll有无索引，如果有索引，就去myi文件中检索，快速定位节点，由于MySql中b+Tree的叶子节点的data域存的是数据表中索引所在行的磁盘地址,就是查出地址后根据该地址在MYD文件中查找所对应的数据．</li></ol><h5 id="InnoDB索引实现-聚集"><a href="#InnoDB索引实现-聚集" class="headerlink" title="InnoDB索引实现(聚集)"></a>InnoDB索引实现(聚集)</h5><p>表结构:</p><ol><li><p>frm表: 表的定义和结构信息</p></li><li><p>ibd表: 按照B-tree组织的一个索引结构文件.</p></li><li><p>InnoDB表的主键索引　<br>是聚集的</p></li><li><p>InnoDB表的非主键索引<br>是非聚集的<br>别的位置是一样的，主要是叶子节点，存储的是主键，首先查找到主键信息，然后再从主键索引树里边找到该索引对应的信息．</p></li></ol><p>为什么InnoDB表必须要有主键，并且推荐使用整型的自增主键呢?</p><p>如果自己没有在InnoDB表中规定主键信息，系统会在数据表中找到一列没有重复信息的列，把他确定为主键，并根据该信息维护一个b+tree的主键索引信息表.<br>如果都是有重复的列，系统就会生成一个隐藏的主键列，作为主键维护信息表.<br>所以说在使用的时候定义了主键，系统会减少很多麻烦效率更高.</p><p>整型:</p><p>反义的是UUID不推荐使用既不是整形也不是自增的.</p><p>整型在比较过程中比较快（类比字符串比较）</p><p>bigint 占8个字节如果是字符串字节较多<br>数据库存储环境是高速的SSD(硬盘),价格昂贵.</p><p>主键自增问题:</p><pre><code>涉及到hash索引b+Tree 叶子节点的小箭头</code></pre><p>如果b+Tree插入的顺序不是自增的，就会存在[1,2,4,5,] 这个节点满了，在插入3的情况是就会出现，节点分裂还需要做平衡，中间节点上移的问题，树会说＂我TM裂了＂！<br>正常自增的话就不会频繁出现这样的情况，减少了平衡的操作.<br>先维护索引，再运行insert语句比较快，</p><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引　"></a>聚集索引　</h5><p>叶子节点包含了完整的数据记录<br>说白了索引和数据放在一起的.</p><h5 id="类推非聚集索引-稀疏索引"><a href="#类推非聚集索引-稀疏索引" class="headerlink" title="类推非聚集索引(稀疏索引)"></a>类推非聚集索引(稀疏索引)</h5><p>同样的MyISM 索引文件和数据文件是分离的就是非聚集的.一部分放在了MYZ一部分放在了MYD文件中.</p><p>比较:<br>单纯从聚集和非聚集索引分析，聚集索引更快.直接找到值．</p><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引　"></a>联合索引　</h5><p>就比如(a,b,c)三个联合起来构成一个索引，底层结构什么样子.</p><p>底层采用的b+tree </p><p>如何排序呢：索引最左前缀原理</p><h6 id="索引最左前缀原理"><a href="#索引最左前缀原理" class="headerlink" title="索引最左前缀原理"></a>索引最左前缀原理</h6><p>先比较第一个字段，第一个能比较大小就排序(字典序比较)，若比较不了，比较第二个．<br>注意：不可跨字段，必须按照顺序应用，才能用到联合索引.<br>原因：b+tree 的排序规则，先按照第一个字段，在比较第二个字段．．．．．如果去掉第一个字段，剩下的第二个字段绝大多数可能是无序的，如果不是一个排好序的序列，就不能作为一个索引来用.还得所有值进行一次比较操作．</p><h4 id="索引失效，索引优化，索引下推，索引回表．"><a href="#索引失效，索引优化，索引下推，索引回表．" class="headerlink" title="索引失效，索引优化，索引下推，索引回表．"></a>索引失效，索引优化，索引下推，索引回表．</h4><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h3 id="分区分库分表，主从复制．"><a href="#分区分库分表，主从复制．" class="headerlink" title="分区分库分表，主从复制．"></a>分区分库分表，主从复制．</h3><h4 id="分区分库分表"><a href="#分区分库分表" class="headerlink" title="分区分库分表"></a>分区分库分表</h4><h5 id="分表："><a href="#分表：" class="headerlink" title="分表："></a>分表：</h5><p>分表就是为了减少单个数据库表的压力，当单表数据量达到百万级别时候，无论是插入和查询对将面临瓶颈，访问变慢，引入分表也是为了减轻单表的压力，常见的分表策略</p><p>对于业务表或者用户表，可以根据业务ID或者用户ID 对表数取模、范围a~b等，以取模为例%n,将表分为n个，如tb_uesr0,tb_user1,tb_user2,tb_user3….</p><p>对于用作分析或者统计时候，例如日志表，可以根据日期分表，如tb_log20180101,tb_log20180102….</p><h5 id="分区："><a href="#分区：" class="headerlink" title="分区："></a>分区：</h5><p>分区和分表大致相同，只是将单个数据表的数据分段存放在磁盘的不同区域，对外读写还是现实一张表，由DB去西东组织数据。</p><h5 id="分库："><a href="#分库：" class="headerlink" title="分库："></a>分库：</h5><p>分表减轻的是单个数据表的数据量压力，而分库则是应对并发请求下面数据库服务器的访问压力。分库也可以选择对关键字取模的方式选择访问的数据库</p><p>存放DB= 关键字段%DB数</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>基本原理 slave会从master读取binlog来进行数据同步</p><p>MySql复制过程分为三步:<br>    1. master将改变记录到二进制日志(binary log).这些记录过程叫二进制日志事件，binary log events;<br>    2. slave 将master的binary log events拷贝到他的中继日志(relay log).<br>    3. slave重做中继日志中的时间，将改变应用到自己的数据库中，MySql复制是异步的且串行化的．</p><p>复制的基本原则:<br>    1. 每个slave只有一个master<br>    2. 每个slave只能有一个唯一的服务器ID<br>    3. 每个master可以有多个slave</p><h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制?"></a>什么是主从复制?</h4><p><a href="https://blog.csdn.net/weixin_43879074/article/details/88525006#commentBox">主从复制牛逼博主跳转和图片来源</a><br>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库，主数据库一般是准实时的业务数据库。您看，像在mysql数据库中，支持单项、异步赋值。在赋值过程中，一个服务器充当主服务器，而另外一台服务器充当从服务器。此时主服务器会将更新信息写入到一个特定的二进制文件中。并会维护文件的一个索引用来跟踪日志循环。这个日志可以记录并发送到从服务器的更新中去。当一台从服务器连接到主服务器时，从服务器会通知主服务器从服务器的日志文件中读取最后一次成功更新的位置。然后从服务器会接收从哪个时刻起发生的任何更新，然后锁住并等到主服务器通知新的更新</p><h5 id="主从复制的作用（好处，或者说为什么要做主从）重点？"><a href="#主从复制的作用（好处，或者说为什么要做主从）重点？" class="headerlink" title="主从复制的作用（好处，或者说为什么要做主从）重点？"></a>主从复制的作用（好处，或者说为什么要做主从）重点？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p> 1–在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）<br>  2–在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）<br>   3–当主服务器出现问题时，可以切换到从服务器。（提升性能）</p><h5 id="主从复制的原理？"><a href="#主从复制的原理？" class="headerlink" title="主从复制的原理？"></a>主从复制的原理？</h5><p>一步能让你清晰理解操作的目的</p><p>   1.数据库有个bin-log二进制文件，记录了所有sql语句。</p><p>   2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。</p><p>   3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。</p><p>   4.下面的主从配置就是围绕这个原理配置</p><p>   5.具体需要三个线程来操作：</p><p>   1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：<br>   2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。</p><p>   3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。</p><pre><code>可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。</code></pre><h5 id="主从复制的好处？"><a href="#主从复制的好处？" class="headerlink" title="主从复制的好处？"></a>主从复制的好处？</h5><p>做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。<br>架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p> 好处一:实现服务器负载均衡</p><p> 通过服务器复制功能，可以在主服务器和从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好地客户相应时间。通常情况下，数据库管理员会有两种思路。</p><p> 一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询。将数据更新与查询分别放在不同的服务器 上进行，即可以提高数据的安全性，同时也缩短应用程序的响应时间、提高系统的性能。</p><p> 二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作 业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。当然，像修改数据、插入数 据、删除数据等语句仍然会发送到主服务器中，以便主服务器和从服务器数据的同步。</p><p>  好处二：通过复制实现数据的异地备份</p><p>  可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。</p><p>  而如果使用复制来实现对数据的备份，就可以在从服务器上对数据进行备份。此时不仅不会干扰主服务气的正常运行，而且在备份过程中主服务器可以继 续处理相关的更新作业。同时在数据复制的同时，也实现了对数据的异地备份。除非主服务器和从服务器的两块硬盘同时损坏了，否则的话数据库管理员就可以在最 短时间内恢复数据，减少企业的由此带来的损失。</p><p>   好处三：提高数据库系统的可用性</p><p>   数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。</p><p>   一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道理。</p><p>   二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患。</p><h5 id="从数据库的读的延迟问题了解吗？如何解决？"><a href="#从数据库的读的延迟问题了解吗？如何解决？" class="headerlink" title="从数据库的读的延迟问题了解吗？如何解决？"></a>从数据库的读的延迟问题了解吗？如何解决？</h5><p>主库宕机后，数据可能丢失<br>从库只有一个sql Thread，主库写压力大，复制很可能延时<br>解决方法：</p><ol><li>半同步复制—解决数据丢失的问题</li></ol><p>半同步复制:　<br>就是在master 端放了wait_ack, 在slave端放了ack发送功能，在文件relay_log中写完数据后，发送一个确认ack,等收到ack在进行客户端的反馈．</p><ol start="2"><li><p>并行复制—-解决从库复制延迟的问题<br><a href="https://www.cnblogs.com/caicz/p/11009528.html">参考博客</a></p></li><li><p>那么如何并行化，并行IO线程，还是并行SQL线程？<br>其实两方面都可以并行，但是并行SQL线程的收益更大，因为SQL线程做的事情更多(解析，执行)。并行IO线程，可以将从Master拉取和写Relay lomZ分为两个线程；并行SQL线程则可以根据需要做到库级并行，表级并行，事务级并行。库级并行在mysql官方版本5.6已经实现。并行复制框架实际包含了一个协调线程和若干个工作线程，协调线程负责分发和解决冲突，工作线程只负责执行。</p></li><li><p>并行复制如何处理冲突？</p></li></ol><p>并发的世界是美好的，但不能乱并发，否则数据就乱了。Master上面通过锁机制来保证并发的事务有序进行，那么并行复制呢？Slave必需保证回放的顺序与Master上事务执行顺序一致，因此只要做到顺序读取binlog，将不冲突的事务并发执行即可。对于库级并发而言，协调线程要保证执行同一个库的事务放在一个工作线程串行执行；对于表级并发而言，协调线程要保证同一个表的事务串行执行；对于事务级而言，则是保证操作同一行的事务串行执行。</p><ol start="3"><li>是否粒度越细，性能越好？</li></ol><p>这个并不是一定的。相对于串行复制而言，并行复制多了一个协调线程。协调线程一个重要作用是解决冲突，粒度越细的并发，可能会有更多的冲突，最终可能也是串行执行的，但消耗了大量的冲突检测代价。</p><p>并行复制:<br>    在relay_log库信息读取操作转换为数据的过程中，采用多线程，执行效率增加．</p><h5 id="主从复制和主主复制区别？"><a href="#主从复制和主主复制区别？" class="headerlink" title="主从复制和主主复制区别？"></a>主从复制和主主复制区别？</h5><p>最大区别是<br>主从是对主操作数据，从会实时同步数据。反之对从操作，主不会同步数据，还有可能造成数据紊乱，导致主从失效。 主主则是无论对那一台操作，另一个都会同步数据。一般用作高容灾方案 </p><p><a href="https://blog.csdn.net/qq_22222499/article/details/79060495">以下部分参考网站</a></p><h3 id="2-数据库隔离级别"><a href="#2-数据库隔离级别" class="headerlink" title="2.数据库隔离级别"></a>2.数据库隔离级别</h3><p>多个事务读可能会道理以下问题<br>脏读：事务B读取事务A还没有提交的数据<br>不可重复读：，一行被检索两次，并且该行中的值在不同的读取之间不同时<br>幻读:当在事务处理过程中执行两个相同的查询，并且第二个查询返回的行集合与第一个查询不同时<br>这两个区别在于，不可重复读重点在一行，幻读的重点 ，返回 的集合不一样</p><h3 id="3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"><a href="#3-MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景" class="headerlink" title="3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景"></a>3.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</h3><p>引擎　　　　　　　　　　特性<br>MYISAM<br>　　　　　　　　　　　　不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描<br>INNODB<br>　　　　　　　　　　　　支持外键，行锁，查表总行数时，全表扫描</p><h3 id="4-索引有B-索引和hash索引"><a href="#4-索引有B-索引和hash索引" class="headerlink" title="4.索引有B+索引和hash索引"></a>4.索引有B+索引和hash索引</h3><p>索引　　　　　　　　　　区别<br>Hash<br>　　　　　　　　　　　　hash索引，等值查询效率高，不能排序,不能进行范围查询<br>B+<br>　　　　　　　　　　　　数据有序,范围查询</p><h3 id="5-聚集索引和非聚集索引"><a href="#5-聚集索引和非聚集索引" class="headerlink" title="5.聚集索引和非聚集索引"></a>5.聚集索引和非聚集索引</h3><p>索引　　　　　　　　　　区别<br>聚集索引<br>　　　　　　　　　　　　数据按索引顺序存储，中子结点存储真实的物理数据<br>非聚集索引<br>　　　　　　　　　　　　存储指向真正数据行的指针</p><h3 id="6-索引的优缺点，什么时候使用索引，什么时候不能使用索引"><a href="#6-索引的优缺点，什么时候使用索引，什么时候不能使用索引" class="headerlink" title="6.索引的优缺点，什么时候使用索引，什么时候不能使用索引"></a>6.索引的优缺点，什么时候使用索引，什么时候不能使用索引</h3><ol><li>索引最大的好处是提高查询速度，</li><li>缺点是更新数据时效率低，因为要同时更新索引</li><li>对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。</li></ol><h3 id="7-InnoDB索引和MyISAM索引的区别"><a href="#7-InnoDB索引和MyISAM索引的区别" class="headerlink" title="7.InnoDB索引和MyISAM索引的区别"></a>7.InnoDB索引和MyISAM索引的区别</h3><p>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。<br>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主</p><h3 id="8-索引的底层实现（B-树，为何不采用红黑树，B树）重点"><a href="#8-索引的底层实现（B-树，为何不采用红黑树，B树）重点" class="headerlink" title="8.索引的底层实现（B+树，为何不采用红黑树，B树）重点"></a>8.索引的底层实现（B+树，为何不采用红黑树，B树）重点</h3><p>树                                 区别<br>红黑树<br>                                   增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间</p><p>B树也就是B-树<br>                                   B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。</p><p>B+树<br>                                   B+树相比较于另外两种树,显得更矮更宽，查询层次更浅</p><h3 id="9-B-树的实现"><a href="#9-B-树的实现" class="headerlink" title="9.B+树的实现"></a>9.B+树的实现</h3><p>一个m阶的B+树具有如下几个特征：</p><ol><li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li></ol><h3 id="10-为什么使用B-Tree"><a href="#10-为什么使用B-Tree" class="headerlink" title="10.为什么使用B+Tree"></a>10.为什么使用B+Tree</h3><ol><li>索引查找过程中就要产生磁盘I/O消耗,主要看IO次数，和磁盘存取原理有关。</li><li>根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，</li><li>将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入<br>局部性原理与磁盘预读</li></ol><h3 id="11-Sql的优化"><a href="#11-Sql的优化" class="headerlink" title="11.Sql的优化"></a>11.Sql的优化</h3><p>1.sql尽量使用索引,而且查询要走索引</p><p>2.对sql语句优化</p><ol><li>子查询变成left join</li><li>limit 分布优化，先利用ID定位，再分页</li><li>or条件优化，多个or条件可以用union all对结果进行合并（union all结果可能重复）</li><li>不必要的排序</li><li>where代替having,having 检索完所有记录，才进行过滤</li><li>避免嵌套查询</li><li>对多个字段进行等值查询时，联合索引</li></ol><h3 id="12-索引最左前缀问题"><a href="#12-索引最左前缀问题" class="headerlink" title="12.索引最左前缀问题"></a>12.索引最左前缀问题</h3><p>如果对三个字段建立联合索引，如果第二个字段没有使用索引，第三个字段也使用不到索引了</p><h3 id="13-索引分类，索引失效条件"><a href="#13-索引分类，索引失效条件" class="headerlink" title="13.索引分类，索引失效条件"></a>13.索引分类，索引失效条件</h3><p>索引类型　　　　　　　　　　　　　　　　　　概念<br>普通索引　　　　　　　　　　　　　最基本的索引，没有任何限制<br>唯一索引　　　　mZZ<br>失效条件:</p><p>条件是or,如果还想让or条件生效，给or每个字段加个索引<br>like查询，以%开发<br>内部函数<br>对索引列进行计算<br>is null不会用，is not null 会用</p><h3 id="14-数据库的主从复制"><a href="#14-数据库的主从复制" class="headerlink" title="14.数据库的主从复制"></a>14.数据库的主从复制</h3><p>复制方式：操作.</p><ol><li>异步复制：<br>默认异步复制，容易造成主库数据和从库不一致,一个数据库为Master,一个数据库为slave,通过Binlog日志,slave两个线程，一个线程去读master binlog日志，写到自己的中继日志一个线程解析日志，执行sql,master启动一个线程,给slave传递binlog日志</li><li>半同步复制: 只有把master发送的binlog日志写到slave的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低</li><li>并行操作:slave 多个线程去请求binlog日志</li></ol><h3 id="15-long-query怎么解决"><a href="#15-long-query怎么解决" class="headerlink" title="15.long_query怎么解决"></a>15.long_query怎么解决</h3><p>设置参数，开启慢日志功能，得到耗时超过一定时间的sql</p><h3 id="16-varchar和char的使用场景"><a href="#16-varchar和char的使用场景" class="headerlink" title="16.varchar和char的使用场景"></a>16.varchar和char的使用场景</h3><p>类型           使用场景<br>varchar        字符长度经常变的<br>char           用字符长度固定的</p><h3 id="17-数据库连接池的作用"><a href="#17-数据库连接池的作用" class="headerlink" title="17.数据库连接池的作用"></a>17.数据库连接池的作用</h3><p>维护一定数量的连接，减少创建连接的时间<br>更快的响应时间<br>统一的管理</p><h3 id="19-分库分表，主从复制，读写分离"><a href="#19-分库分表，主从复制，读写分离" class="headerlink" title="19.分库分表，主从复制，读写分离"></a>19.分库分表，主从复制，读写分离</h3><p>读写分离，读从库，写主库<br>spring配置两个数据库，通过AOP（面向切面编程），在写或读方法前面进行判断得到动态切换数据源。</p><h3 id="20-数据库三范式"><a href="#20-数据库三范式" class="headerlink" title="20.数据库三范式"></a>20.数据库三范式</h3><p>级别　　　　　　　　　　　　概念<br>1NF　　　　　　　　　　　　属性不可分<br>2NF　　　　　　　　　　　　非主键属性，完全依赖于主键属性<br>3NF　　　　　　　　　　　　非主键属性无传递依赖</p><h3 id="21-关系型数据库和非关系型数据库区别"><a href="#21-关系型数据库和非关系型数据库区别" class="headerlink" title="21.关系型数据库和非关系型数据库区别"></a>21.关系型数据库和非关系型数据库区别</h3><p>关系型数据库</p><p>优点：</p><p>1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</p><p>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。<br>5.支持事务</p><p>缺点<br>1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、不支持高并发读写需求；<br>4、不支持海量数据的高效率读写</p><p>非关系型数据库</p><p>1、使用键值对存储数据；<br>2、分布式；<br>优点<br>无需经过sql层的解析，读写性能很高<br>基于键值对，数据没有耦合性，容易扩展<br>存储数据的格式：nosql的存储格式是key,value形式<br>缺点<br>不提供sql支持</p><h3 id="22-数据库中join的left-join-inner-join-cross-join"><a href="#22-数据库中join的left-join-inner-join-cross-join" class="headerlink" title="22.数据库中join的left join , inner join, cross join"></a>22.数据库中join的left join , inner join, cross join</h3><ol><li><p>以A，B两张表为例<br>A left join B<br>选出A的所有记录，B表中没有的以null 代替<br>right join 同理</p></li><li><p>inner join<br>A,B有交集的记录</p></li><li><p>cross join (笛卡尔积)<br>A中的每一条记录和B中的每一条记录生成一条记录<br>例如A中有4条，B中有4条，cross join 就有16条记录</p></li></ol><h3 id="23-有哪些锁-select时怎么加排它锁"><a href="#23-有哪些锁-select时怎么加排它锁" class="headerlink" title="23.有哪些锁,select时怎么加排它锁"></a>23.有哪些锁,select时怎么加排它锁</h3><p>锁　　　　　　　　　　　　　　　　　　　概念<br>乐观锁　　　　　　　　　　　　　　　　　自己实现，通过版本号<br>悲观锁　　　　　　　　　　　　　　　　　共享锁，多个事务，只能读不能写，加 lock in share mode<br>排它锁　　　　　　　　　　　　　　　　　一个事务，只能写，for update<br>行锁　　　　　　　　　　　　　　　　　　作用于数据行<br>表锁　　　　　　　　　　　　　　　　　　作于用表</p><h3 id="24-死锁怎么解决"><a href="#24-死锁怎么解决" class="headerlink" title="24.死锁怎么解决"></a>24.死锁怎么解决</h3><p>找到进程号，kill 进程</p><h3 id="25-最左匹配原则"><a href="#25-最左匹配原则" class="headerlink" title="25.最左匹配原则"></a>25.最左匹配原则</h3><p>最左匹配原则是针对索引的<br>举例来说：两个字段（name,age）建立联合索引，如果where age=12这样的话，是没有利用到索引的，<br>这里我们可以简单的理解为先是对name字段的值排序，然后对age的数据排序，如果直接查age的话，这时就没有利用到索引了，<br>查询条件where name=‘xxx’ and age=xx 这时的话，就利用到索引了，再来思考下where age=xx and name=’xxx‘ 这个sql会利用索引吗，<br>按照正常的原则来讲是不会利用到的，但是优化器会进行优化，把位置交换下。这个sql也能利用到索引了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="优化" scheme="http://example.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>balance-tree</title>
    <link href="http://example.com/posts/26821/"/>
    <id>http://example.com/posts/26821/</id>
    <published>2020-10-24T06:06:20.000Z</published>
    <updated>2020-10-27T02:06:58.973Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在绝望的时候才会尽最大的努力!</p><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B_tree"></a>B_tree</h3><p>全名为balance_tree(平衡多路查找树)，平衡的意思是左边和右边分布均匀。多路的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而B_tree有多条路，即父节点有多个子节点。</p><h4 id="B-树用途"><a href="#B-树用途" class="headerlink" title="B-树用途"></a>B-树用途</h4><p>使用B_tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。</p><h4 id="B-tree定义及结构"><a href="#B-tree定义及结构" class="headerlink" title="B_tree定义及结构"></a>B_tree定义及结构</h4><h4 id="B-tree定义"><a href="#B-tree定义" class="headerlink" title="B_tree定义"></a>B_tree定义</h4><ol><li>树中每个节点至多有m棵子树(m表示树的阶数)</li><li>根前节点不是叶子节点,则至少有两棵子树(根节点必须俩儿子).</li><li>除根节点之外的所有非叶子节点至少有p个子节点([m/2] &lt;= p &lt;= m,[m/2]向上取整).或者[(m+1)/2].</li><li>所有的非叶子结点中包含以下数据：（n，A0，K1，A1，K2，…，Kn，An）<br>其中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ki（i&#x3D;1,2,…,n）为关键码，且Ki&lt;Ki+1（注：ki是真实数据，存放在线性表当中，且从左至右升序排列）</span><br><span class="line"></span><br><span class="line">Ai 为指向儿子的指针(i&#x3D;0,1,…,n)，且指针Ai-1 所指子树中所有结点的关键码均小于Ki (i&#x3D;1,2,…,n)，An 所指子树中所有结点的            关键码均大于Kn。（注：每个ki数据两旁各安放了一个指针，即Ai-1和Ai，左边的子树数据统统小于ki，右边子树的数据统             统大于ki）（注：总体来看指针数量比数据数量多1）</span><br><span class="line"></span><br><span class="line"> n 为关键码的个数（[m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m - 1）。</span><br></pre></td></tr></table></figure></li><li> 所有的叶子结点都出现在同一层次上，即所有叶节点具有相同的深度，等于树高度。并且不带信息（可以看作是外部结点或查找失<br>败的结点，实际上这些结点不存在，指向这些结点的指针为空）。</li></ol><h4 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h4><ol><li>B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</li></ol><h4 id="B-tree和二叉树和红黑树的不同点"><a href="#B-tree和二叉树和红黑树的不同点" class="headerlink" title="B_tree和二叉树和红黑树的不同点"></a>B_tree和二叉树和红黑树的不同点</h4><p>与二叉树:</p><ol><li><p>二叉树节点中保存的数据只有一个，而B_树得节点中保存的是线性表，真实数据数据不止一个有很多。由于表中的指针和子节点一一对应，而子节点个数又有限定([m/2] &lt;= p &lt;= m,[m/2]向上取整)，又因为真实数据数量又比指针少一个所以真实数据也就有了限定（\left \lceil m/2 \right \rceil-1\leqslant n\leqslant m-1）。</p></li><li><p>二叉树至多有两个儿子节点，而B-树至多有m个节点（m为树的阶）</p></li></ol><p>与红黑树:<br>    不同在于：B树的节点可以有很多子女，从几个到几万个不等，<br>    相同：一颗含有n个节点的B树高度和红黑树是一样的，都是O（lgn）。</p><h4 id="B-tree和B-tree结构操作"><a href="#B-tree和B-tree结构操作" class="headerlink" title="B_tree和B+tree结构操作"></a>B_tree和B+tree结构操作</h4><p>小编传不了图片,但是我找到了一个特别全很牛逼的网站，作为歉意！<br><a href="https://www.bilibili.com/video/BV1vQ4y1N79m?p=1">简述构造树遵循的规则</a>：<br>以五叉BTree为例，key的数量公式推导<br>ceil(m/2)-1 &lt;= n &lt;= m-1,所以2 &lt;= n &lt;= 4,当n &gt; 4时，中间节点上升进入父节点，两边节点裂开．</p><ol><li><p>插入字母C,N,G,A,H,K.Q.M.F,W,L,T,Z,D,P,R,X,Y,S数据为例．<br>注意每组元素下边都有一组数组.length()+1个下标.<br>插入前四个字母: [A,C,G,H]</p></li><li><p>插入H,n&gt;4,中间元素G字母向上分裂到新的节点(晋升为父节点)<br>　　[G]<br>[A|C]　[H|N]</p></li><li><p>插入E,K,Q不需要分裂　<br>　　　[G]<br>[A|C|E]　[H|K|N|Q]</p></li><li><p>插入M,中间元素M字母向上分裂到父节点G　<br>　　　　[G|M]<br>[A|C|E]　[H|K]　 [NQ]</p></li><li><p>插入F,W,L,T不需要分裂<br>　　　　　[G|M]<br>[A|C|E|F]　[H|K|L]　[N|Q|T|W]</p></li><li><p>插入Z,中间元素T先上分裂到父节点中</p></li></ol><p>　　　　　　　[G|M|T]<br>[A|C|E|F]　[H|K|L]　[N|Q]　[W|Z]</p><p>以此类推最后建成.</p><p><a href="https://www.cnblogs.com/guohai-stronger/p/9225057.html">结构和各种操作</a></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h3 id="M阶B-数特点"><a href="#M阶B-数特点" class="headerlink" title="M阶B+数特点"></a>M阶B+数特点</h3><p>在mysql中增加了叶子节点前后指针(进行了B+tree的优化).提高区间访问的效率)</p><ol><li>有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。</li><li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成一个链表）。</li><li>所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li><li>通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</li><li>同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</li></ol><h4 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h4><ol><li>所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li><li>b+树的中间节点不保存数据，能容纳更多节点元素。</li></ol><h4 id="B-树的时间复杂度"><a href="#B-树的时间复杂度" class="headerlink" title="B+树的时间复杂度"></a>B+树的时间复杂度</h4><h3 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h3><ol><li><p>B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。</p></li><li><p>B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</p></li><li><p>B树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m-1%5D">m/2(向上取整)-1,m-1</a>，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为<a href="%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%BA%5B1,m%5D">m/2(向上取整),m</a>，具有n个关键字的节点包含（n）棵子树。</p></li><li><p>B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。</p></li></ol><h3 id="B树和B-树的共同优点"><a href="#B树和B-树的共同优点" class="headerlink" title="B树和B+树的共同优点"></a>B树和B+树的共同优点</h3><p>考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Data_Sturctures" scheme="http://example.com/tags/Data-Sturctures/"/>
    
  </entry>
  
  <entry>
    <title>bug</title>
    <link href="http://example.com/posts/42182/"/>
    <id>http://example.com/posts/42182/</id>
    <published>2020-10-14T03:38:06.000Z</published>
    <updated>2020-10-14T04:15:50.162Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有的人走错一步就回来,有的人一直错,——–子弹上膛（小庄）<br>由于python2不能导入request包,所以升级为python3.</p><p>Ubuntu下将python从2.7.12升级到3.5.2</p><p>１．我们在Ubuntu中使用Ctrl+Alt+T  快捷键 调出 终端窗口。然后在终端中输入Python,查看当前版本.<br>２．在上面的步骤中，我们看到我们的Python版本是2.7.12 这是Ubuntu中默认安装的Python版本 。接下来我们执行 sudo apt-get install python3 命令 这时候 终端会提示我们需要管理员密码 输入即可。<br>３．稍等片刻 我们的Python3 已经安装完成了 ，但是如果这时候我们输入Python并且回车 我们会发现 我们的Python版本仍然是2.7.12 这个时候我们需要切换Python的版本。</p><p>我们在终端中输入 alias python=python3  回车  </p><p>然后我们再输入Python 这个时候的版本就已经变成Python3了</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python环境问题" scheme="http://example.com/categories/python%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider2</title>
    <link href="http://example.com/posts/40133/"/>
    <id>http://example.com/posts/40133/</id>
    <published>2020-10-13T13:57:29.000Z</published>
    <updated>2020-10-14T08:00:33.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>精神,唯一的财富,其它都是虚的。——袁朗．<br>爬虫实战应用<br><a href="https://blog.csdn.net/qq_21933615/article/details/81171951">Python中BeautifulSoup库的用法</a></p><p><a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/">官方文档</a><br>以上都是爬虫的预备知识，掌握了之后就可以写代码去爬取我们想要爬的网站了。</p><p>Python提供了许多网络请求的库，比如Requests、urllib等，这里只说一下requests库</p><p>Requests库.</p><p>安装：pip(3) install requests</p><p>基本使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 发送 GET 请求获取响应</span><br><span class="line">response &#x3D; requests.get(url)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response常用属性：</span><br><span class="line">&#96;&#96;&#96;c&#x2F;c++</span><br><span class="line">response.text 返回响应内容，响应内容为 str 类型</span><br><span class="line">respones.content 返回响应内容,响应内容为 bytes 类型</span><br><span class="line">response.status_code 返回响应状态码</span><br><span class="line">response.request.headers 返回请求头</span><br><span class="line">response.headers 返回响应头</span><br><span class="line">response.cookies 返回响应的 RequestsCookieJar 对象</span><br><span class="line"># 获取字节数据</span><br><span class="line">content &#x3D; response.content</span><br><span class="line"># 转换成字符串类型</span><br><span class="line">html &#x3D; content.decode(&#39;utf-8&#39;)</span><br></pre></td></tr></table></figure><p>自定义请求头.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 发送自定义请求头</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送Get请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 GET 请求参数</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 GET 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,params&#x3D;params)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>发送POST请求.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义post请求参数</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &quot;kw&quot;:&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.post(url,headers&#x3D;headers,data&#x3D;data)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br></pre></td></tr></table></figure><p>为什么使用代理：1、让服务器以为请求是从多个客户端发出的。2、防止暴露我们的真实地址<br>代理作为中间量简介链接客户端和服务器.</p><p>使用方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 定义 代理服务器</span><br><span class="line">proxies &#x3D; &#123;</span><br><span class="line">    &quot;http&quot;:&quot;http:&#x2F;&#x2F;IP地址:端口号&quot;,</span><br><span class="line">    &quot;https&quot;:&quot;https:&#x2F;&#x2F;IP地址:端口号&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,proxies&#x3D;proxies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求中携带cookie</p><p>作用：有些网站需要登录，这时候cookie就是记录了你的用户信息</p><p>方式：</p><p>直接在自定义请求头中携带</p><p>通过请求参数携带cookie</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入模块</span><br><span class="line">import requests</span><br><span class="line"># 定义请求地址</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line"># 定义自定义请求头</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;</span><br><span class="line">    # 方式一：直接在请求头中携带Cookie内容</span><br><span class="line">    &quot;Cookie&quot;: &quot;Cookie值&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 方式二：定义 cookies 值</span><br><span class="line">cookies &#x3D; &#123;</span><br><span class="line">    &quot;xx&quot;:&quot;yy&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 使用 POST 请求参数发送请求</span><br><span class="line">response &#x3D; requests.get(url,headers&#x3D;headers,cookies&#x3D;cookies)</span><br><span class="line"># 获取响应的 html 内容</span><br><span class="line">html &#x3D; response.text</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据提取</p><p>作用：从爬虫获取的数据中提取出我们想要的数据</p><p>方式：<br>json模块提取<br>xpath提取<br>正则提取<br>beautifulsoup<br>１．json.<br>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式<br>json.loads json字符串 转 Python数据类型<br>json.dumps Python数据类型 转 json字符串<br>json.load json文件 转 Python数据类型<br>json.dump Python数据类型 转 json文件<br>ensure_ascii=False 实现让中文写入的时候保持为中文<br>indent=空格数 通过空格的数量进行缩紧<br>２．xpath.<br>XPath 全称： XML Path Language，是一门在 XML 文档中查找信息的语言。<br>XPath 可用来在 XML 文档中对元素和属性进行遍历。<br>安装：pip(3) install lxml</p><p>常用规则：<br>表达式———–描述——–<br>nodename——–选取此节点的所有子节点<br>/—————-从当前节点选取直接子节点<br>//—————从当前节点选取子孙节点<br>.—————-选取当前节点<br>..—————选取当前节点的父节点<br>@—————-选取属性</p><p>正则；</p><p>Python中通过正则表达对字符串进行匹配是，可以使用re模块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 导入re模块</span><br><span class="line">import re</span><br><span class="line"># 使用match方法进行匹配操作</span><br><span class="line">result &#x3D; re.match(正则表达式,要匹配的字符串)</span><br><span class="line"># 如果上一步匹配到数据的话，可以使用group方法来提取数据</span><br><span class="line">result.group()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/116509288">常用语法：</a></p><p><em>————-匹配前一个字符0次或无限次，例abc</em>,能匹配字符abccccc,<br>+————-匹配前一个字符1次或无限次，例abc+,能匹配字符abccccc,<br>?————-匹配前一个字符0次或一次，例abc?,能匹配字符abc或ab,<br>{m}————-匹配前一个字符m次，例ab{2}c,能匹配字符abbc,<br>\d————-说明:数字[0-9]</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫实战应用" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web-spider1</title>
    <link href="http://example.com/posts/40325/"/>
    <id>http://example.com/posts/40325/</id>
    <published>2020-10-13T12:20:14.000Z</published>
    <updated>2020-10-14T02:55:03.194Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好好活就是做有意义的事,有意义的事就是好好活。 —–送给短暂渺茫的你（许三多）</p><p>爬虫思路</p><p>1：什么是爬虫</p><p>爬虫(spider，又网络爬虫)，是指向网站/网络发起请求，获取资源后分析并提取有用数据的程序。</p><p>从技术层面来说就是 通过程序模拟浏览器请求站点的行为.</p><p>把站点返回的HTML代码/JSON数据/二进制数据（图片、视频） 爬到本地，进而提取自己需要的数据，存放起来使用。</p><p>2：入门爬虫的干货</p><p>2.1： 爬虫的基本思路</p><p>通过URL或者文件获取网页，<br>分析要爬取的目标内容所在的位置<br>用元素选择器快速提取(Raw) 目标内容<br>处理提取出来的目标内容 （ 通常整理合成一个 Json）<br>存储处理好的目标内容 （比如放到 MongoDB 之类的数据库，或者写进文件里。）<br>爬虫流程:<br>发送请求-&gt;获取响应内容-&gt;解析内容-&gt;保存数据</p><p>robots协议：</p><p>网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，但它仅仅是道德层面上的约束</p><p>爬虫的用途：</p><p>1、12306抢票<br>2、短信轰炸<br>3、网络投票<br>4、监控数据<br>5、下载图片、小说、视频、音乐等</p><p>Http和Https：<br>发送请求，获取响应的过程其实就是发送Http或者Https请求和响应的过程。<br>HTTP</p><p>超文本传输协议<br>默认端口号:80<br>HTTPS</p><p>HTTP + SSL(安全套接字层)，即带有安全套接字层的超本文传输协议<br>默认端口号：443</p><p>作用：在传输过程中对数据进行加密，防止被窜改</p><p>区别：http因不需要加密，所以性能更高，但安全性差。</p><p>https安全性高，但是占用服务器资源</p><p>但是Https是未来的主流，比如小程序、ios、android客户端的接口都需要Https接口支持.</p><p>Http请求报文和状态码：参考上一个博客.<br>常见的HTTP状态码：<br>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它 URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p><p>常见请求头：</p><p>Cookie——————–作用—–Cookie<br>User-Agent—————-作用—–浏览器名称<br>Referer——————-作用—–页面跳转处<br>Host———————-作用—–主机和端口号<br>Connection—————-作用—–链接类型<br>Upgrade-Insecure-Requests-作用—–升级为HTTPS<br>Accept——————–作用—–传输文件类型<br>Accept-Encoding———–作用—–文件编解码格式<br>x-Requests-with:XMLHttpRequest作用ajax请求</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Web_spider</title>
    <link href="http://example.com/posts/50097/"/>
    <id>http://example.com/posts/50097/</id>
    <published>2020-10-13T04:18:51.000Z</published>
    <updated>2020-10-13T08:03:26.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>高成：我酒量一斤，陪你二斤吧．<br>袁朗: 我酒量二两，陪你喝舍命!</p><p>爬虫技术基础<br>—–替代繁琐的操作，程序化实现.<br><a href="https://www.cnblogs.com/ranyonsue/p/5984001.html">参考网站</a><br><a href="https://www.cnblogs.com/an-wen/p/11180076.html">参考网站</a></p><h3 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h3><p>(非重点)<br>历史有兴趣可看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</span><br><span class="line"></span><br><span class="line">HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</span><br><span class="line"></span><br><span class="line">2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP&#x2F;2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP&#x2F;2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</span><br></pre></td></tr></table></figure><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><h3 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h3><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B/S及C/S模式。</p><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤：</p><p>１．客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.luffycity.com./">http://www.luffycity.com。</a></p><p>２．发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>３．服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>４．释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p><p>５．客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><p>1.浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2.解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3.浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4.服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5.释放 TCP连接;<br>6.浏览器将该 html 文本并显示内容; 　</p><h4 id="http协议是基于TCP-IP协议之上的应用层协议。"><a href="#http协议是基于TCP-IP协议之上的应用层协议。" class="headerlink" title="http协议是基于TCP/IP协议之上的应用层协议。"></a>http协议是基于TCP/IP协议之上的应用层协议。</h4><h4 id="基于-请求-响应-的模式"><a href="#基于-请求-响应-的模式" class="headerlink" title="基于 请求-响应 的模式"></a>基于 请求-响应 的模式</h4><p>　　HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应</p><h4 id="无状态保存"><a href="#无状态保存" class="headerlink" title="无状态保存"></a>无状态保存</h4><p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。<br>　　　　使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。有关Cookie的详细内容稍后讲解。</p><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><p>GET<br>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p><p>HEAD<br>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p><p>POST<br>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><p>PUT<br>向指定资源位置上传其最新内容。</p><p>DELETE<br>请求服务器删除Request-URI所标识的资源。</p><p>TRACE<br>回显服务器收到的请求，主要用于测试或诊断。</p><p>OPTIONS<br>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p><p>CONNECT<br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。<br>注意事项：<br>1.方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。<br>2.HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源。<br>请求方式: get与post请求（通过form表单我们自己写写看）</p><p>GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中.</p><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>GET与POST请求在服务端获取请求数据方式不同，就是我们自己在服务端取请求数据的时候的方式不同了，这句废话昂</p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><p>1.-1xx消息——请求已被服务器接收，继续处理<br>2.-2xx成功——请求已成功被服务器接收、理解、并接受<br>3.-3xx重定向——需要后续操作才能完成这一请求<br>4.-4xx请求错误——请求含有词法错误或者无法被执行<br>5.-5xx服务器错误——服务器在处理某个正确请求时发生错误<br>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p><h4 id="URL-基本解释"><a href="#URL-基本解释" class="headerlink" title="URL(基本解释)"></a>URL(基本解释)</h4><p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p><p>传送协议。<br>层级URL标记符号(为[//],固定不变)<br>访问资源需要的凭证信息（可省略）<br>服务器。（通常为域名，有时为IP地址）<br>端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）<br>路径。（以“/”字符区别路径中的每一个目录名称）<br>查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）<br>片段。以“#”字符为起点<br>以<a href="http://www.luffycity.com/news/index.html?id=250&amp;page=1">http://www.luffycity.com:80/news/index.html?id=250&amp;page=1</a> 为例, 其中：</p><p>http，是协议；<br><a href="http://www.luffycity.com,是服务器;/">www.luffycity.com，是服务器；</a><br>80，是服务器上的默认网络端口号，默认不显示；<br>/news/index.html，是路径（URI：直接定位到对应的资源）；<br>?id=250&amp;page=1，是查询。<br>大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（<a href="http://www.luffycity.com/news/index.html?id=250&amp;page=1%EF%BC%89%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">www.luffycity.com:80/news/index.html?id=250&amp;page=1）就可以了。</a></p><p>由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务。</p><h4 id="URL划分部分解释"><a href="#URL划分部分解释" class="headerlink" title="URL划分部分解释"></a>URL划分部分解释</h4><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p><p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p><p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a><br>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p><p>2.域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></p><p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p><p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p><p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p><p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p><p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p><p>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p><h4 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h4><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。<br>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p><p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<br>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br><a href="https://www.cnblogs.com/an-wen/p/11180076.html">HTTP请求格式(请求协议)</a></p><h4 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h4><p>GET请求<br>GET /books/?sex=man&amp;name=Professional HTTP/1.1<br>Host: <a href="http://www.wrox.com/">www.wrox.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Connection: Keep-Alive<br>注意最后一行是空行</p><p>POST请求<br>POST / HTTP/1.1<br>Host: <a href="http://www.wrox.com/">www.wrox.com</a><br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br>Gecko/20050225 Firefox/1.0.1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 40<br>Connection: Keep-Alive</p><p>name=Professional%20Ajax&amp;publisher=Wiley<br>1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p><p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p><p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变<br>2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p><p>而在实际开发中存在的限制主要有：</p><p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p><p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p><p>POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p><p>3、安全性</p><p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p><p>4、Http get,post,soap协议都是在http上运行的</p><p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p><p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p><p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>Content-type设置为: text/xml 任何数据都可以xml化。</p><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p><p>我们看看GET和POST的区别</p><p>１．GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p><p>２．GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p>３．GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p><p>４．GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
</feed>
